<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.0">
    <HostPackage>
        <Host autoClearCommandLineAfterSend="no" disableAutoCompletion="no" printCommand="yes" USE_IRE_DRIVER_BUGFIX="yes" mUSE_FORCE_LF_AFTER_PROMPT="no" mUSE_UNIX_EOL="no" mNoAntiAlias="no" mRawStreamDump="no" mAlertOnNewData="yes" mFORCE_NO_COMPRESSION="no" mFORCE_GA_OFF="no" mFORCE_SAVE_ON_EXIT="yes" mEnableGMCP="no" mMapStrongHighlight="no" mLogStatus="no" mEnableSpellCheck="no" mShowInfo="no" mAcceptServerGUI="yes" mMapperUseAntiAlias="no" mFORCE_MXP_NEGOTIATION_OFF="no" mRoomSize="0.5" mLineSize="5" mBubbleMode="no" mShowRoomIDs="no" mShowPanel="no" mHaveMapperScript="no">
            <name>7days Server</name>
            <mInstalledPackages/>
            <url>127.0.0.1</url>
            <serverPackageName>nothing</serverPackageName>
            <serverPackageVersion>-1</serverPackageVersion>
            <port>26900</port>
            <borderTopHeight>0</borderTopHeight>
            <borderBottomHeight>0</borderBottomHeight>
            <borderLeftWidth>0</borderLeftWidth>
            <borderRightWidth>0</borderRightWidth>
            <wrapAt>100</wrapAt>
            <wrapIndentCount>0</wrapIndentCount>
            <commandSeperator>;</commandSeperator>
            <mFgColor>#c0c0c0</mFgColor>
            <mBgColor>#000000</mBgColor>
            <mCommandFgColor>#717100</mCommandFgColor>
            <mCommandBgColor>#000000</mCommandBgColor>
            <mCommandLineFgColor>#808080</mCommandLineFgColor>
            <mCommandLineBgColor>#000000</mCommandLineBgColor>
            <mBlack>#000000</mBlack>
            <mLightBlack>#808080</mLightBlack>
            <mRed>#800000</mRed>
            <mLightRed>#ff0000</mLightRed>
            <mBlue>#000080</mBlue>
            <mLightBlue>#0000ff</mLightBlue>
            <mGreen>#00b300</mGreen>
            <mLightGreen>#00ff00</mLightGreen>
            <mYellow>#808000</mYellow>
            <mLightYellow>#ffff00</mLightYellow>
            <mCyan>#008080</mCyan>
            <mLightCyan>#00ffff</mLightCyan>
            <mMagenta>#800080</mMagenta>
            <mLightMagenta>#ff00ff</mLightMagenta>
            <mWhite>#c0c0c0</mWhite>
            <mLightWhite>#ffffff</mLightWhite>
            <mDisplayFont>DejaVu Sans Mono,10,-1,5,2,0,0,0,1,0</mDisplayFont>
            <mCommandLineFont>Bitstream Vera Sans Mono,10,-1,5,2,0,0,0,0,0</mCommandLineFont>
            <mCommandSeparator>;</mCommandSeparator>
            <commandLineMinimumHeight>30</commandLineMinimumHeight>
            <mFgColor2>#c0c0c0</mFgColor2>
            <mBgColor2>#000000</mBgColor2>
            <mBlack2>#242424</mBlack2>
            <mLightBlack2>#808080</mLightBlack2>
            <mRed2>#800000</mRed2>
            <mLightRed2>#ff0000</mLightRed2>
            <mBlue2>#000080</mBlue2>
            <mLightBlue2>#0000ff</mLightBlue2>
            <mGreen2>#00b300</mGreen2>
            <mLightGreen2>#00ff00</mLightGreen2>
            <mYellow2>#808000</mYellow2>
            <mLightYellow2>#ffff00</mLightYellow2>
            <mCyan2>#008080</mCyan2>
            <mLightCyan2>#00ffff</mLightCyan2>
            <mMagenta2>#800080</mMagenta2>
            <mLightMagenta2>#ff00ff</mLightMagenta2>
            <mWhite2>#c0c0c0</mWhite2>
            <mLightWhite2>#ffffff</mLightWhite2>
            <mSpellDic>en_US</mSpellDic>
            <mLineSize>5</mLineSize>
            <mRoomSize>0.5</mRoomSize>
        </Host>
    </HostPackage>
    <TriggerPackage>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Login</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers 
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see http://www.gnu.org/licenses
--]]

lastAction = &quot;Login&quot;
botOffline = 2
botDisabled = false

-- EDIT ME!
botsDBPassword = &quot;&quot;
serverDBPassword = &quot;&quot;

-- add your telnet password below.  Telnet fails to login on the first try and this will resend the pass.
if string.find(line, &quot;Password incorrect&quot;) then
-- EDIT ME!
	send(&quot;insert telnet password here&quot;)
end

</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>lease enter password:</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>End list players</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end


showPlayers = false
playersOnline = tonumber(string.match(line, &quot;%d+&quot;))
deleteLine()

if (playersOnline == 0) then
	-- we could schedule something to happen when no players are online
end



</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>Total of </string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>2</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>PVP Police</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

function pvpPolice()
	local killerScore = 0
	local victimScore = 0
	local killerid
	local victimid
	local arenaID
	local score
	local eventID

	if (not string.find(line, &quot; GMSG: Player &quot;)) then
		-- prevent players from tricking the bot into banning players
		return
	end 

	r = rand(8)
	score = string.format(&quot;%.1f&quot;, math.random() * 10)

	nameStart = string.find(line, &quot;: Player &quot;) + 9
	nameEnd = string.find(line, &quot; eliminated&quot;) - 1

	killerName = string.sub(line, nameStart, nameEnd)
	killerid = LookupPlayer(killerName)

	nameStart = string.find(line, &quot;eliminated Player &quot;) + 18

	victimName = string.sub(line, nameStart)
	victimid = LookupPlayer(victimName)

	igplayers[victimid].deadX = igplayers[victimid].xPos
	igplayers[victimid].deadY = igplayers[victimid].yPos
	igplayers[victimid].deadZ = igplayers[victimid].zPos

	if (killerName == victimName) then
		if (r == 1) then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; removed themselves from the gene pool.[-]&quot;) end
		if (r == 2) then message(&quot;say [&quot; .. server.chatColour .. &quot;]LOL!  Didn't run far away enough did you &quot; .. killerName .. &quot;?[-]&quot;) end
		if (r == 3) then message(&quot;say [&quot; .. server.chatColour .. &quot;]And the prize for most creative way to end themselves goes to.. &quot; .. killerName .. &quot;[-]&quot;) end
		if (r == 4) then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; really shouldn't handle explosives.[-]&quot;) end
		if (r == 5) then message(&quot;say Oh no! &quot; .. killerName .. &quot; died.  What a shame.[-]&quot;) end
		if (r == 6) then message(&quot;say [&quot; .. server.chatColour .. &quot;]Great effort there &quot; .. killerName .. &quot;. I'm awarding &quot; .. score .. &quot; points.[-]&quot;) end
		if (r == 7) then message(&quot;say [&quot; .. server.chatColour .. &quot;]LOL! REKT[-]&quot;) end
		if (r == 8) then 
			message(&quot;say [&quot; .. server.chatColour .. &quot;]We are gathered here today to remember with sadness the passing of &quot; .. killerName .. &quot;. Rest in pieces. Amen.[-]&quot;)
		end

		return
	else
	--	server.pvpCount = tonumber(server.pvpCount) + 1

		if (pvpZone(igplayers[killerid].xPos, igplayers[killerid].zPos) ~= false) or (server.gameType == &quot;pvp&quot;) then
			if players[killerid].pvpCount == nil then
				players[killerid].pvpCount = 0
				players[killerid].pvpBounty = 0
			end

			if players[killerid].pvpCount == 0 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]Player &quot; .. killerName .. &quot; finally scores their first kill! Woo Hoo!   OH SHIT!   RUN!!![-]&quot;)
				players[killerid].pvpBounty = 200
			else
				r = rand(21)
				if r == 1 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; once again asserts their dominance in the world.[-]&quot;) end
				if r == 2 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; strikes a mighty blow against &quot; .. victimName .. &quot;![-]&quot;) end
				if r == 3 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; fluked that one! &quot; .. victimName .. &quot; will be pissed.[-]&quot;) end
				if r == 4 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; dispatched &quot; .. victimName .. &quot; with a little too much enthusiasm. Medics have been called to consume the body.[-]&quot;) end
				if r == 5 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; ripped &quot; .. victimName .. &quot; a new asshole.[-]&quot;) end
				if r == 6 then message(&quot;say [&quot; .. server.chatColour .. &quot;]Player &quot; .. killerName .. &quot; is on fire metaphorically speaking. &quot; .. victimName .. &quot; is too.. for real.[-]&quot;) end
				if r == 7 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; is really asking for it with another spectacular kill.[-]&quot;) end
				if r == 8 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; sent &quot; .. victimName .. &quot; a heart stopping, high velocity gift.  Right between the eyes.[-]&quot;) end
				if r == 9 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. victimName .. &quot; walked right into that one![-]&quot;) end
				if r == 10 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. victimName .. &quot; forgot their flame proof underwear, or infact any underwear.[-]&quot;) end
				if r == 11 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. victimName .. &quot; spread themselves too thin in that fight.  Anyone got a broom and shovel?[-]&quot;) end
				if r == 12 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. victimName .. &quot; impaled themselves on &quot; .. killerName .. &quot;'s mighty sword! .. I said mighty not erect![-]&quot;) end
				if r == 13 then message(&quot;say [&quot; .. server.chatColour .. &quot;]Sadly &quot; .. victimName .. &quot; lost that fight.  Well I'm sad, I had &quot; .. t .. &quot; zennies riding on him. :([-]&quot;) end
				if r == 14 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. victimName .. &quot; enters the space program with a bang.. and a thud.. and another.  Oh and there's a leg.[-]&quot;) end
				if r == 15 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; cut &quot; .. victimName .. &quot; a new asshole!  I guess that makes &quot; .. victimName .. &quot; their own twin?[-]&quot;) end
				if r == 16 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; cut &quot; .. victimName .. &quot; a new asshole!  &quot; .. victimName .. &quot; is an even bigger asshole now! ^^[-]&quot;) end
				if r == 17 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; is slicing and dicing up the competition![-]&quot;) end
				if r == 18 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; makes mince meat of &quot; .. victimName .. &quot;! Gather round boys!  We're havin a BBQ with a side of WTF covered in OMG sauce![-]&quot;) end
				if r == 19 then message(&quot;say [&quot; .. server.chatColour .. &quot;]Gordon Bennet! &quot; .. killerName .. &quot; is racing towards the lead with another masterfull kill.[-]&quot;) end
				if r == 20 then message(&quot;say [&quot; .. server.chatColour .. &quot;]That was a feeble effort by &quot; .. victimName .. &quot;.[-]&quot;) end
				if r == 21 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. victimName .. &quot; will need to move faster next time.. because they just lost both legs below the knee![-]&quot;) end
				message(&quot;pm &quot; .. killerid .. &quot; [&quot; .. server.chatColour .. &quot;]You won the bounty on &quot; .. victimName .. &quot;![-]&quot;)
			end

			if players[victimid].pvpBounty &gt; 0 then
				players[killerid].cash = players[killerid].cash + players[victimid].pvpBounty
				players[victimid].pvpBounty = 0
				message(&quot;pm &quot; .. killerid .. &quot; [&quot; .. server.chatColour .. &quot;]You got the bounty on &quot; .. victimName .. &quot;![-]&quot;)
			else
				message(&quot;say [&quot; .. server.chatColour .. &quot;]A bounty of &quot; .. players[killerid].pvpBounty .. &quot; is on &quot; .. killerName .. &quot;'s head. Bring it home![-]&quot;)
			end

			players[killerid].pvpCount = players[killerid].pvpCount + 1

			-- record the pvp in the events table
			conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. math.floor(igplayers[killerid].xPos) .. &quot;,&quot; .. math.ceil(igplayers[killerid].yPos) .. &quot;,&quot; .. math.floor(igplayers[killerid].zPos) .. &quot;,'&quot; .. serverTime .. &quot;','pvplegit','Player &quot; .. escape(killerName) .. &quot; killed &quot; .. escape(victimName) .. &quot; in a pvp zone ',&quot; .. killerid .. &quot;)&quot;)
			return
		end

		-- arena pvp zone
		if locations[&quot;arena&quot;] ~= nil then
			if distance (igplayers[killerid].xPos, igplayers[killerid].zPos, locations[&quot;arena&quot;].x, locations[&quot;arena&quot;].z ) &lt; 31 then
				return
			end
		end

		-- don't react if player is inside the prison
		if locations[&quot;prison&quot;] ~= nil then
			if ((math.abs(math.abs(igplayers[killerid].xPos) - math.abs(locations[&quot;prison&quot;].x)) &lt; server.prisonSize) or (math.abs(math.abs(igplayers[killerid].zPos) - math.abs(locations[&quot;prison&quot;].z)) &lt; server.prisonSize)) then
				return
			end
		end

		if (accessLevel(killerid) &lt; 3 and server.ignoreAdmins == true) then 
			cecho(server.windowAlerts, &quot;admin pvp: &quot; .. line .. &quot;\n&quot;)
			message(&quot;say [&quot; .. server.chatColour .. &quot;]PvP is not allowed outside of PVP zones! However &quot; .. killerName .. &quot; is authorised to PVP[-]&quot;)	
			message(&quot;pm &quot; .. killerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are allowed to pvp to defend yourself and others. Don't abuse this privilege.[-]&quot;)
			table.save(homedir .. &quot;/server.lua&quot;, server)
			conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. math.floor(igplayers[victimid].xPos) .. &quot;,&quot; .. math.ceil(igplayers[victimid].yPos) .. &quot;,&quot; .. math.floor(igplayers[victimid].zPos) .. &quot;,'&quot; .. serverTime .. &quot;','pvp','Admin &quot; .. escape(killerName) .. &quot; killed &quot; .. escape(victimName) .. &quot; at &quot; .. igplayers[killerid].xPos .. &quot; &quot; .. igplayers[killerid].yPos .. &quot; &quot; .. igplayers[killerid].zPos .. &quot;',&quot; .. killerid .. &quot;)&quot;)
			return
		end

		cecho(server.windowAlerts, line .. &quot;\n&quot;)
		message(&quot;say [&quot; .. server.chatColour .. &quot;]PvP is not allowed outside of PVP zones!  Read /help pvp[-]&quot;)

		if (players[victimid].newPlayer == true and players[killerid].newplayer == false) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Killing in self-defense is allowed.  No arrest made. Admins will review this killing and may decide to punish for it later.[-]&quot;)	
			irc_QueueMsg(server.ircAlerts, killerName .. &quot; killed new player &quot; .. victimName .. &quot;.  No arrest made. Killer's location was &quot; .. math.floor(igplayers[killerid].xPos) .. &quot; &quot; .. math.floor(igplayers[killerid].yPos) .. &quot; &quot; .. math.floor(igplayers[killerid].zPos))
			conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. math.floor(igplayers[victimid].xPos) .. &quot;,&quot; .. math.ceil(igplayers[victimid].yPos) .. &quot;,&quot; .. math.floor(igplayers[victimid].zPos) .. &quot;,'&quot; .. serverTime .. &quot;','pvp','&quot; .. escape(killerName) .. &quot; killed new player &quot; .. escape(victimName) .. &quot;.  No arrest made. Killer's location was &quot; .. math.floor(igplayers[victimid].xPos) .. &quot; &quot; .. math.floor(igplayers[victimid].yPos) .. &quot; &quot; .. math.floor(igplayers[victimid].zPos) .. &quot;',&quot; .. killerid .. &quot;)&quot;)
			return
		end

		if locations[&quot;prison&quot;] ~= nil then
			igplayers[killerid].xPosOld = math.floor(igplayers[killerid].xPos)
			igplayers[killerid].yPosOld = math.floor(igplayers[killerid].yPos)
			igplayers[killerid].zPosOld = math.floor(igplayers[killerid].zPos)
			
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; has been sent to prison, charged with PVP in a restricted zone.[-]&quot;)
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Admins or the victim can release them by typing /release &quot; .. killerName .. &quot;[-]&quot;)
			message(&quot;pm &quot; .. killerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can not return until released from prison.[-]&quot;)
			irc_QueueMsg(server.ircAlerts, killerName .. &quot; has been sent to prison, charged with PVP at &quot; .. igplayers[killerid].xPosOld .. &quot; &quot; .. igplayers[killerid].yPosOld .. &quot; &quot; .. igplayers[killerid].zPosOld)
			cmd = &quot;tele &quot; .. killerid .. &quot; &quot; .. locations[&quot;prison&quot;].x .. &quot; &quot; .. locations[&quot;prison&quot;].y .. &quot; &quot; .. locations[&quot;prison&quot;].z
			prepareTeleport(killerid, cmd)
			teleport(cmd, true)
				
			players[killerid].prisoner = true
			players[killerid].pvpVictim = victimid
			players[killerid].prisonReason = &quot;PVP against &quot; .. players[victimid].name
			players[killerid].prisonxPosOld = igplayers[killerid].xPosOld
			players[killerid].prisonyPosOld = igplayers[killerid].yPosOld
			players[killerid].prisonzPosOld = igplayers[killerid].zPosOld		

			igplayers[killerid].xPosLastOK = locations[&quot;prison&quot;].x
			igplayers[killerid].yPosLastOK = locations[&quot;prison&quot;].y
			igplayers[killerid].zPosLastOK = locations[&quot;prison&quot;].z
				
			message(&quot;pm &quot; .. victimid  .. &quot; [&quot; .. server.chatColour .. &quot;]You may release &quot; .. killerName .. &quot;. Do so at your own risk by typing[-]&quot;)
			message(&quot;pm &quot; .. victimid  .. &quot; /release &quot; .. players[killerid].id .. &quot; or /release &quot; .. killerName .. &quot;[-]&quot;)
						
			conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. math.floor(igplayers[killerid].xPos) .. &quot;,&quot; .. math.ceil(igplayers[killerid].yPos) .. &quot;,&quot; .. math.floor(igplayers[killerid].zPos) .. &quot;,'&quot; .. serverTime .. &quot;','pvp','Player &quot; .. escape(killerName) .. &quot; sent to prison for killing &quot; .. escape(victimName) .. &quot; at &quot; .. igplayers[killerid].xPos .. &quot; &quot; .. igplayers[killerid].yPos .. &quot; &quot; .. igplayers[killerid].zPos .. &quot;',&quot; .. killerid .. &quot;)&quot;)
		else
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; has been banned for 1 day, charged with PVP.  Contact an admin to get them unbanned any sooner.[-]&quot;)
			irc_QueueMsg(server.ircAlerts, killerName .. &quot; has been banned for 1 day, charged with PVP at &quot; .. igplayers[killerid].xPos .. &quot; &quot; .. igplayers[killerid].yPos .. &quot; &quot; .. igplayers[killerid].zPos)
			kick(killerid, &quot;This is a PVE server.  PVP somewhere else.  An admin may unban you pending the circumstances of the pvp.&quot;)
			send(&quot;ban add &quot; .. killerid .. &quot; 1 day PVP&quot;)
			
			conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. math.floor(igplayers[killerid].xPos) .. &quot;,&quot; .. math.ceil(igplayers[killerid].yPos) .. &quot;,&quot; .. math.floor(igplayers[killerid].zPos) .. &quot;,'&quot; .. serverTime .. &quot;','pvp','Player &quot; .. escape(killerName) .. &quot; banned 1 day for killing &quot; .. escape(victimName) .. &quot; at &quot; .. igplayers[killerid].xPos .. &quot; &quot; .. igplayers[killerid].yPos .. &quot; &quot; .. igplayers[killerid].zPos .. &quot;',&quot; .. killerid .. &quot;)&quot;)
		end
	end
end


if string.find(line, &quot;eliminated Player&quot;) then
	pvpPolice()
end</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>eliminated Player</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>MatchAll</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end


local pname, pid, number, died, coords, words, temp
local dy, mth, yr, hr, min, sec, pm, reason, timestamp, banDate
local fields, values, x, z, id, loc, reset

-- set counter to help detect the bot going offline
botOffline = 2

if string.find(line, &quot;INF Server shutting down!&quot;) then
	saveLuaTables()
end

if string.find(line, &quot;type=EntityZombie&quot;) then
	temp = string.split(line, &quot; &quot;)
	id = string.match(temp[7], &quot;(-?%d+)&quot;)
	x = string.match(temp[9], &quot;(-?%d+)&quot;)
	z = string.match(temp[11], &quot;(-?%d+)&quot;)

	loc = inLocation(x, z)

	if not loc and server.gameType == &quot;con&quot; then
		send(&quot;kill &quot; .. id)
	end

	if loc ~= false then
		if locations[loc].killZombies then
			send(&quot;kill &quot; .. id)
		end
	end
end

if server.coppi then
--Smegz0r friends: 
	if string.find(line, &quot;friends:&quot;) then
		collectFriends = string.sub(line, 1, string.find(line, &quot;friends:&quot;) - 2)
		collectFriends = LookupPlayer(collectFriends)
	end
end

-- look for general stuff
died = false
if (string.find(line, &quot;Player &quot;) and string.find(line, &quot;eliminated&quot;)) then
	nameStart = string.find(line, &quot;eliminated Player &quot;) + 18
	pname = string.trim(string.sub(line, nameStart))
	died = true
end

if (string.find(line, &quot;Player &quot;) and string.find(line, &quot; died&quot;)) then
	pname = string.sub(line, string.find(line, &quot;GMSG: Player&quot;) + 13, string.len(line) - 5)
	pname = string.trim(pname)
	pid = LookupPlayer(pname)
	died = true

	conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. math.floor(igplayers[pid].xPos) .. &quot;,&quot; .. math.ceil(igplayers[pid].yPos) .. &quot;,&quot; .. math.floor(igplayers[pid].zPos) .. &quot;,'&quot; .. serverTime .. &quot;','death','&quot; .. escape(pname) .. &quot; died',&quot; .. pid .. &quot;)&quot;)
end


if died then
	id = LookupPlayer(pname, &quot;all&quot;)
	if (id ~= nil) then
		igplayers[id].tp = 1
		igplayers[id].deadX = math.floor(igplayers[id].xPos)
		igplayers[id].deadY = math.ceil(igplayers[id].yPos)
		igplayers[id].deadZ = math.floor(igplayers[id].zPos)

		players[id].deathX = igplayers[id].xPos
		players[id].deathY = igplayers[id].yPos
		players[id].deathZ = igplayers[id].zPos

		if inLocation(players[id].deathX, players[id].deathZ) == &quot;deadzone&quot; then
			players[id].baseCooldown = 0
			conn:execute(&quot;UPDATE players SET baseCooldown = 0 WHERE steam = &quot; .. id)
		end

		irc_QueueMsg(server.ircMain, &quot;Player &quot; .. id .. &quot; name: &quot; .. pname .. &quot;'s death recorded at &quot; .. igplayers[id].deadX .. &quot; &quot; .. igplayers[id].deadY .. &quot; &quot; .. igplayers[id].deadZ)
	end

	-- nuke their gimme queue of zeds
	for k, v in pairs(gimmeQueuedCommands) do
		if (v.steam == id) and (string.find(v.cmd, &quot;se &quot; .. id)) then
			gimmeQueuedCommands[k] = nil
		end
	end
end

number = tonumber(string.match(line, &quot; (%d+)&quot;))

if (string.find(line, &quot;LootRespawnDays =&quot;)) then
	server.LootRespawnDays = number
end

if (string.find(line, &quot;BlockDurabilityModifier =&quot;)) then
	server.BlockDurabilityModifier = number
end

if (string.find(line, &quot;DayNightLength =&quot;)) then
	server.DayNightLength = number
end

if (string.find(line, &quot;DropOnDeath =&quot;)) then
	server.DropOnDeath = number
end

if (string.find(line, &quot;DropOnQuit =&quot;)) then
	server.DropOnQuit = number
end

if (string.find(line, &quot;EnemyDifficulty =&quot;)) then
	server.EnemyDifficulty = number
end

if (string.find(line, &quot;EnemySenseMemory =&quot;)) then
	server.EnemySenseMemory = number
end

if (string.find(line, &quot;LandClaimSize =&quot;)) then
	server.LandClaimSize = number
end

if (string.find(line, &quot;LootAbundance =&quot;)) then
	server.LootAbundance = number
end

if (string.find(line, &quot;LootRespawnDays =&quot;)) then
	server.LootRespawnDays = number
end

if (string.find(line, &quot;ServerPort =&quot;)) then
	server.ServerPort = number
end

if (string.find(line, &quot;ZombiesRun =&quot;)) then
	server.ZombiesRun = number
end

if (string.find(line, &quot;ServerName =&quot;)) then
	server.ServerName = string.trim(string.sub(line, 22))
end

if (string.find(line, &quot;GameName =&quot;)) then
	server.GameName = string.trim(string.sub(line, 20))
end

if (string.find(line, &quot;ServerMaxPlayerCount =&quot;)) then
	server.ServerMaxPlayerCount = number
end

if (string.find(line, &quot;MaxSpawnedZombies =&quot;)) then
	server.MaxSpawnedZombies = number
end

conn:execute(&quot;UPDATE server SET serverName = '&quot; .. escape(server.ServerName) .. &quot;', ServerPort = &quot; .. server.ServerPort)

-- update owners, admins and mods
if (line == &quot;  Level: SteamID (Player name if online)&quot;) then
	owners = {}
	admins = {}
	mods = {}
	getAdminList = true
end

if (getAdminList ~= nil) and (string.sub(line, 1, 4) == os.date(&quot;%Y&quot;)) then
	getAdminList = nil
else
	if (string.sub(line, 1, 6) == &quot;      &quot;) and (string.sub(line, 8, 8) == &quot;:&quot;) then
		pid = string.sub(line, 10, 26)
		number = string.sub(line, 7, 7)

		if players[pid] then
			if number == &quot;0&quot; then
				owners[pid] = {}
			end

			if number == &quot;1&quot; then
				admins[pid] = {}
			end

			if number == &quot;2&quot; then
				mods[pid] = {}
			end

			players[pid].accessLevel = tonumber(number)
			players[pid].newPlayer = false
			players[pid].silentBob = false
			players[pid].walkies = false
			players[pid].timeout = false
			players[pid].botTimeout = false
			players[pid].prisoner = false
			players[pid].exiled = 2
			players[pid].canTeleport = true
			players[pid].enableTP = true
			players[pid].botHelp = true

			conn:execute(&quot;UPDATE players SET newPlayer = 0, silentBob = 0, walkies = 0, exiled = 2, canTeleport = 1, enableTP = 1, botHelp = 1, accessLevel = &quot; .. number .. &quot; WHERE steam = &quot; .. pid)		
		end
	end
end


if string.sub(line, 1, 4) == &quot;   (&quot; then
	coords = string.split(string.sub(line, 5, string.len(line) - 1), &quot;,&quot;)

	if players[llpid].removedClaims == nil then
		players[llpid].removedClaims = 0
	end

	conn:execute(&quot;UPDATE keystones SET remove = 1 WHERE steam = &quot; .. llpid .. &quot; AND x = &quot; .. coords[1] .. &quot; AND y = &quot; .. coords[2] .. &quot; AND z = &quot; .. coords[3] .. &quot; AND remove &gt; 1&quot;)
	conn:execute(&quot;UPDATE keystones SET removed = 0 WHERE steam = &quot; .. llpid .. &quot; AND x = &quot; .. coords[1] .. &quot; AND y = &quot; .. coords[2] .. &quot; AND z = &quot; .. coords[3])

	if accessLevel(llpid) &gt; 3 then
		region = getRegion(coords[1], coords[3])

		loc, reset = inLocation(coords[1], coords[3])

		if (resetRegions[region]) or reset or players[llpid].removeClaims == true then
			conn:execute(&quot;INSERT INTO keystones (steam, x, y, z, remove) VALUES (&quot; .. llpid .. &quot;,&quot; .. coords[1] .. &quot;,&quot; .. coords[2] .. &quot;,&quot; .. coords[3] .. &quot;,1) ON DUPLICATE KEY UPDATE remove = 1&quot;)
		else
			conn:execute(&quot;INSERT INTO keystones (steam, x, y, z) VALUES (&quot; .. llpid .. &quot;,&quot; .. coords[1] .. &quot;,&quot; .. coords[2] .. &quot;,&quot; .. coords[3] .. &quot;)&quot;)
		end		
	else
		conn:execute(&quot;INSERT INTO keystones (steam, x, y, z) VALUES (&quot; .. llpid .. &quot;,&quot; .. coords[1] .. &quot;,&quot; .. coords[2] .. &quot;,&quot; .. coords[3] .. &quot;)&quot;)
	end
end


if ircListItems ~= nil and string.sub(string.trim(line), 1, 5) == &quot;Slot &quot; then
	ircListItems = nil
end


if ircListItems ~= nil then
	if string.sub(line,1,4) == &quot;    &quot; and string.sub(line,5,5) ~= &quot; &quot; then
		irc_QueueMsg(players[ircListItems].ircAlias, string.trim(line))
	end
end


-- collect the ban list
if collectBans ~= nil then
	if (string.find(line, &quot; AM &quot;)) or (string.find(line, &quot; PM &quot;)) and not string.find(line, &quot;banned until&quot;) then
		temp = string.split(line, &quot;-&quot;)
		conn:execute(&quot;INSERT INTO bans (BannedTo, steam, reason) VALUES ('&quot; .. string.trim(temp[1]) .. &quot;',&quot; .. string.trim(temp[2]) .. &quot;,'&quot; .. string.trim(temp[3]) .. &quot;')&quot;)
	end
end


if (string.find(line, &quot;Banned until&quot;)) then
	collectBans = true
end


if echoConsoleTo ~= nil then
	if string.find(line, &quot;Executing command 'help&quot;) then
		echoConsole = true
		return
	end

	if string.find(line, &quot;Executing command 'se'&quot;) then
		echoConsole = true
		return
	end

	if string.find(line, &quot;Executing command 'si &quot;) and string.find(line, echoConsoleTrigger) then
		echoConsole = true
		return
	end

	if string.find(line, &quot;Executing command 'gg'&quot;) then
		echoConsole = true
		return
	end

	if string.find(line, &quot;Executing command 'llp&quot;) then
		echoConsole = true
		return
	end

	if string.find(line, &quot;Executing command 'ban list'&quot;) then
		echoConsole = true
		return
	end

	if (echoConsole ~= nil) and (string.sub(line, 1, 4) == os.date(&quot;%Y&quot;)) then
		echoConsole = nil
		echoConsoleTo = nil
	end

	if echoConsole == true then
		irc_QueueMsg(echoConsoleTo, line)
	end
end


if (string.sub(line, 1, 4) == os.date(&quot;%Y&quot;)) then
	collectBans = nil
	collectFriends = nil
end


-- collect the friend list
if collectFriends ~= nil then
--	if not string.find(line, &quot;friends:&quot;) then
--		temp = string.split(line, &quot; &quot;)
--		pid = LookupPlayer(temp[4])		

--		if (not string.find(friends[collectFriends].friends, pid)) then
--			friends[collectFriends].friends = friends[collectFriends].friends .. pid .. &quot;,&quot;
--			irc_QueueMsg(server.ircMain, players[collectFriends].name .. &quot; is now friends with &quot; .. players[pid].name)

--			if igplayers[collectFriends] then
--				message(&quot;pm &quot; .. collectFriends .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[pid].name .. &quot; is now recognised as a friend[-]&quot;)	
--			end

--			conn:execute(&quot;INSERT INTO friends (steam, friend) VALUES (&quot; .. collectFriends .. &quot;,&quot; .. pid .. &quot;)&quot;)
--		end

--	end
end


--2015-08-23T15:08:25 87646.450 INF Executing command 'pm IPCHECK' by Telnet from 127.0.0.1:59765
if string.find(line, &quot;IPCHECK&quot;) then
	temp = string.sub(line, string.find(line, &quot;from &quot;) + 5)
	server.botsIP = string.sub(temp, 1, string.find(temp, &quot;:&quot;) - 1)
end


-- detect Coppi's modded Alloc's Mod
if not server.coppi then
	if string.find(line, &quot;Usage: listplayerfriends&quot;) then
		server.coppi = true

		if server.hideCommands then
			send(&quot;tcch /&quot;)
		end
	end
end

</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>^(.*)$</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>1</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>InventorySlot</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

if (string.find(line, &quot;GMSG:&quot;)) then
	-- do not process the line because Slot was mentioned in chat not output from doing si
else
	readInventorySlot()
end


</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>Slot</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Player connected</name>
            <script>--[[ 
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

function playerConnected()
	local entityid
	local player
	local steam
	local IP
	local temp_table
	local temp
	local timestamp = os.time()

	if (string.find(line, &quot;PlayerID=''&quot;)) then
		return
	end

	temp_table = string.split(line, &quot;,&quot;)
	timeConnected = string.sub(line, 1, 19)
	IP = &quot;&quot;

	if string.find(line, &quot;steamid=&quot;) then 
		player = string.trim(string.sub(temp_table[3], string.find(temp_table[3], &quot;name=&quot;) + 5, string.find(temp_table[3], &quot;,&quot;)))
		steam = string.sub(temp_table[4], string.find(temp_table[4], &quot;steamid=&quot;) + 8, string.find(temp_table[4], &quot;,&quot;))
		entityid = string.sub(temp_table[2], string.find(temp_table[2], &quot;entityid=&quot;) + 9, string.find(temp_table[2], &quot;,&quot;))
		IP = string.sub(temp_table[5], string.find(temp_table[5], &quot;ip=&quot;) + 3)
	else
		steam = string.sub(line, string.find(line, &quot;OwnerID=&quot;) + 9, string.find(line, &quot;PlayerName=&quot;) - 4)
		player = string.trim(string.sub(line, string.find(line, &quot;PlayerName=&quot;) + 12, string.len(line) - 1))
		entityid = string.sub(line, string.find(line, &quot;EntityID=&quot;) + 9, string.find(line, &quot;PlayerID=&quot;) - 3)
	end

	-- log the player connection in events table
	conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (0,0,0,'&quot; .. serverTime .. &quot;','player joined','Player joined &quot; .. escape(player) .. &quot; &quot; .. steam .. &quot; &quot; .. entityid .. &quot; &quot; .. IP .. &quot;',&quot; .. steam .. &quot;)&quot;)

	-- restore the correct max player count if we need to
	--if server.ServerMaxPlayerCountOld ~= nil then
	--dbug(&quot;ServerMaxPlayerCountOLD &quot; .. server.ServerMaxPlayerCountOld)

	--	if tonumber(server.ServerMaxPlayerCount) &gt; tonumber(server.ServerMaxPlayerCountOld) and accessLevel(entityid) == 0 then
	--		send(&quot;sg ServerMaxPlayerCount &quot; .. server.ServerMaxPlayerCountOld)
	--		server.ServerMaxPlayerCountOld = nil
	--	end
	--end

	lastPlayerConnected = player
	lastSteamConnected = steam

	-- add to players table
	if (not players[steam]) then
		initNewPlayer(steam, player, entityid)
		fixMissingPlayer(steam)

		irc_QueueMsg(server.ircMain, &quot;###  New player joined &quot; .. player .. &quot; steam: &quot; .. steam.. &quot; id: &quot; .. entityid .. &quot; ###&quot;)
		irc_QueueMsg(server.ircAlerts, &quot;New player joined&quot;)
		irc_QueueMsg(server.ircAlerts, line:gsub(&quot;%,&quot;, &quot;&quot;))

		for k, v in pairs(igplayers) do
			if accessLevel(k) &lt; 3 then
				message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]New player joined &quot; .. entityid .. &quot; &quot; .. player .. &quot;[-]&quot;)
			end
		end

		conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (0,0,0,'&quot; .. serverTime .. &quot;','new player','New player joined &quot; .. escape(player) .. &quot; steam: &quot; .. steam.. &quot; id: &quot; .. entityid .. &quot;',&quot; .. steam .. &quot;)&quot;)
		conn:execute(&quot;INSERT INTO players (steam, id, name, protectSize, protect2Size, firstSeen) VALUES (&quot; .. steam .. &quot;,&quot; .. entityid .. &quot;,'&quot; .. escape(player) .. &quot;',&quot; .. server.baseSize .. &quot;,&quot; .. server.baseSize .. &quot;,&quot; .. os.time() .. &quot;)&quot;)		
	else
		cmd = &quot;llp &quot; .. steam
		tempTimer( 5, [[send(&quot;]] .. cmd .. [[&quot;)]] )
	end

	if IP ~= nil then
		players[steam].IP = IP
	end

	--if (accessLevel(steam) == 0) then
	--	display(&quot;closing reserved slot\n&quot;)
	--	send(&quot;sg ServerMaxPlayerCount &quot; .. server.ServerMaxPlayerCount - 1)
	--	server.ServerMaxPlayerCount = server.ServerMaxPlayerCount - 1
	--end

	-- add to in-game players table
	if (not igplayers[steam]) then
		initNewIGPlayer(steam, player, entityid)
		fixMissingIGPlayer(steam)
	end

	if players[steam].country == &quot;&quot; then
		CheckBlacklist(steam, IP)
	else
		reverseDNS(steam, IP)
	end

	if (not lastHotspots[steam]) then
		lastHotspots[steam] = {}
	end

	if (players[steam].sessionCount ~= nil) then
		players[steam].sessionCount = players[steam].sessionCount + 1
	else
		players[steam].sessionCount = 1
	end

	if (friends[steam] == nil) then
		friends[steam] = {}
		friends[steam].friends = &quot;&quot;
	end

	players[steam].autoKicked = nil

	invTemp[steam] = {}

	if not string.find(players[steam].names, player, nil, true) then -- the last argument disables pattern matching.  We need to do this for player names with () in them.
		players[steam].names = players[steam].names .. &quot;,&quot; .. player
	end

	conn:execute(&quot;UPDATE players SET aliases = '&quot; .. players[steam].names .. &quot;', sessionCount = &quot; .. players[steam].sessionCount .. &quot; WHERE steam = &quot; .. steam)

	-- kick player if currently banned or permabanned
	cursor,errorString = conn:execute(&quot;SELECT * FROM bans WHERE Steam = &quot; .. steam .. &quot; and expiryDate &gt; '&quot; .. os.date(&quot;%Y-%m-%d %H:%M:%S&quot;) .. &quot;'&quot;)
	if cursor:numrows() &gt; 0 then
		send(&quot;kick &quot; .. steam)
		return
	end

	if	not server.allowNumericNames and notserver.allowGarbageNames and not players[steam].whitelisted then
		temp = countAlphaNumeric(player)

		if tonumber(player) ~= nil or tonumber(temp) == 0 then
			kick(steam, &quot;Names without letters are not allowed here. You need to change your name to play on this server.&quot;)
			return
		end
	end

	-- timeout the player if they are relogging too many times in quick succession
	if tonumber(players[steam].relogCount) &gt; 4 and players[steam].newPlayer then
		timeoutPlayer(steam, &quot;relogging many times in a short space of time.&quot;, false)
		players[steam].relogCount = 0
	end

	-- delete read mail that isn't flagged as saved (status = 2).
	conn:execute(&quot;DELETE FROM mail WHERE id = &quot; .. steam .. &quot; and status = 1&quot;)

	if server.coppi then
		send(&quot;pcml &quot; .. steam .. &quot; 255&quot;)
	end

	cecho(server.windowDebug, &quot;Finished Player Connected\n&quot;)
end


if string.find(line, &quot;Player connected&quot;) then
	playerConnected()
end</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>Player connected</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>playerinfo</name>
            <script>--[[ 
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


if botDisabled then
	return
end

function playerInfo()
	faultyPlayerinfo = true
	faultyPlayerinfoID = 0
	faultyPlayerinfoLine = line

	local debugSteam, debug, id, name, posX, posY, posZ, lastX, lastY, lastZ, lastDist, mapCenterDistance
	local deaths, zombies, kills, score, level, steam, steamtest, admin, lastGimme, lastLogin
	local xPosOld, yPosOld, zPosOld, rawPosition, outsideMap, outsideMapDonor, fields, values
	local isAdmin = &quot;No&quot;
	local isPrisoner = &quot;No&quot;
	local timestamp = os.time()
	local region = &quot;&quot;
	local resetZone = false
	local ping, dist, IP, hotspot, currentLocation
	local skipTPtest = false

	debug = 0
	debugSteam = 0
	--debugSteam = &quot;76561198068123756&quot;

	if (debugSteam ~= 0) then 
		dbug(&quot;debug playerinfo&quot;) 
	end	

	if debugSteam ~= 0 then
	--	debugSteam = LookupPlayer(debugSteam)
	end

	r = rand(5)

	name_table = string.split(line, &quot;, &quot;)

	if string.find(name_table[3], &quot;pos&quot;) then 
		name = string.trim(name_table[2])
	else
		temp = name_table[1] .. &quot;, name&quot; .. string.sub(line, string.find(line, &quot;, pos=&quot;), string.len(line))
		name_table = string.split(temp, &quot;, &quot;)
		name = string.trim(string.sub(line, string.find(line, &quot;,&quot;) + 2, string.find(line, &quot;, pos=&quot;) - 1))
	end

	lastLP =  name

	-- stop processing this player if we don't have 17 parts to the line after splitting on comma
	-- it is probably a read error
	if (table.maxn(name_table) &lt; 17) then
		faultyPlayerinfoID = 1
		return
	end

	temp = string.split(name_table[1], &quot;=&quot;)
	id = temp[2]


	num = tonumber(string.sub(name_table[3], 6))
	if (num == nil) then cecho(server.windowDebug, &quot;Bad number found: &quot; .. line .. &quot;\n&quot;) return end
	posX = num

	num = tonumber(name_table[4])
	if (num == nil) then cecho(server.windowDebug, &quot;Bad number found: &quot; .. line .. &quot;\n&quot;) return end
	posY = num

	temp = string.split(name_table[5], &quot;)&quot;)
	num = tonumber(temp[1])
	if (num == nil) then cecho(server.windowDebug, &quot;Bad number found: &quot; .. line .. &quot;\n&quot;) return end
	posZ = num

	temp = string.split(name_table[11], &quot;=&quot;)
	num = tonumber(temp[2])
	if (num == nil) then cecho(server.windowDebug, &quot;Bad number found: &quot; .. line .. &quot;\n&quot;) return end
	deaths = num

	temp = string.split(name_table[12], &quot;=&quot;)
	num = tonumber(temp[2])
	if (num == nil) then cecho(server.windowDebug, &quot;Bad number found: &quot; .. line .. &quot;\n&quot;) return end
	zombies = num

	temp = string.split(name_table[13], &quot;=&quot;)
	num = tonumber(temp[2])
	if (num == nil) then cecho(server.windowDebug, &quot;Bad number found: &quot; .. line .. &quot;\n&quot;) return end
	kills = num

	temp = string.split(name_table[14], &quot;=&quot;)
	num = tonumber(temp[2])
	if (num == nil) then cecho(server.windowDebug, &quot;Bad number found: &quot; .. line .. &quot;\n&quot;) return end
	score = num

	temp = string.split(name_table[15], &quot;=&quot;)
	num = tonumber(temp[2])
	if (num == nil) then cecho(server.windowDebug, &quot;Bad number found: &quot; .. line .. &quot;\n&quot;) return end
	level = num

	temp = string.split(name_table[16], &quot;=&quot;)
	if (num == nil) then cecho(server.windowDebug, &quot;Bad number found: &quot; .. line .. &quot;\n&quot;) return end
	steam = temp[2]

	faultyPlayerinfoID = steam

	temp = string.split(name_table[17], &quot;=&quot;)
	IP = temp[2]

	temp = string.split(name_table[18], &quot;=&quot;)
	ping = temp[2]

	rawPosition = posX .. posY .. posZ


	intX = math.floor(posX)
	intY = math.ceil(posY)
	intZ = math.floor(posZ)

	region = getRegion(intX, intZ)
	if (resetRegions[region]) then 
		resetZone = true 
	else
		resetZone = false
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 1&quot;) 
	end	

	-- check for crazy server crash
	if (string.find(line, &quot;type=EntityZombie&quot;)) then
		if nextRebootTest == nil or (nextRebootTest ~= nil and os.time() &gt; nextRebootTest) then
			if (server.scheduledRestart == true) and scheduledRestartForced == false then
				message(&quot;say /cancel reboot&quot;)
			end

			if scheduledRestartForced == false then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]Zombies have been detected in the player data and an urgent reboot has been initiated to fix it.[-]&quot;)
				message(&quot;say [&quot; .. server.chatColour .. &quot;]You have 2 minutes to stop what you are doing and clear your crafting, forges and campfires.[-]&quot;)
				message(&quot;say /reboot server 2 minutes forced&quot;)
			end
		end

		return
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 2&quot;) 
	end	

	--display (&quot;temp[2] = -&quot; .. temp[2] .. &quot;-\n&quot;)

	-- check for invalid or missing steamid.  kick if not passed
	steamtest = 0
	steamtest = tonumber(steam)
	if (steamtest == nil) and (steam ~= &quot;&quot;) then --  or (string.len(steam) &lt; 17)
		cecho (server.windowAlerts, &quot;Kicking player &quot; .. name .. &quot; for invalid Steam ID &quot; .. steam .. &quot;\n&quot;)
		cecho (server.windowAlerts,  line .. &quot;\n&quot;)
		message(&quot;say [&quot; .. server.chatColour .. &quot;]Kicking player &quot; .. name .. &quot; for bad steam ID: &quot; .. steam .. &quot;[-]&quot;)
		send (&quot;kick &quot; .. id)

		faultyPlayerinfo = false
		return
	end

	-- add to players table
	if (players[steam] == nil) then
		players[steam] = {}
		players[steam].id = id
		players[steam].name = name
		players[steam].steam = steam

		if tonumber(score) == 0 and tonumber(zombies) == 0 and tonumber(deaths) == 0 then
			players[steam].newPlayer = true
		else
			players[steam].newPlayer = false
		end

		players[steam].watchPlayer = true
		players[steam].IP = IP
		players[steam].exiled = 0

		irc_QueueMsg(server.ircMain, &quot;###  New player joined &quot; .. player .. &quot; steam: &quot; .. steam.. &quot; id: &quot; .. id .. &quot; ###&quot;)
		irc_QueueMsg(server.ircAlerts, &quot;New player joined&quot;)
		irc_QueueMsg(server.ircAlerts, line)

		conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. math.floor(posX) .. &quot;,&quot; .. math.floor(posY) .. &quot;,&quot; .. math.floor(posZ) .. &quot;,'&quot; .. serverTime .. &quot;','new player','New player joined &quot; .. name .. &quot; steam: &quot; .. steam.. &quot; id: &quot; .. id .. &quot;',&quot; .. steam .. &quot;)&quot;)
		conn:execute(&quot;INSERT INTO players (steam, name, id, IP, newPlayer, watchPlayer) VALUES (&quot; .. steam .. &quot;,'&quot; .. escape(name) .. &quot;',&quot; .. id .. &quot;,&quot; .. IP .. &quot;,1,1)&quot;)

		fixMissingPlayer(steam)
		CheckBlacklist(steam, IP)
	end

	-- add to in-game players table
	if (igplayers[steam] == nil) then
		igplayers[steam] = {}
		igplayers[steam].id = id
		igplayers[steam].name = name
		igplayers[steam].steam = steam

		fixMissingIGPlayer(steam)
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 4&quot;) 
	end	

	if (players[steam].prisoner == true) then
		isPrisoner = &quot;Yes&quot;
	end

	if accessLevel(steam) &lt; 3 then
		isAdmin = &quot;Yes&quot;
	end

	if IP ~= &quot;&quot; and players[steam].IP == &quot;&quot; then
		players[steam].IP = IP
		CheckBlacklist(steam, IP)
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 9&quot;) 
	end	

	if tonumber(intY) &gt; 0 and tonumber(intY) &lt; 500 then
		igplayers[steam].lastTP = nil

		if igplayers[steam].notifyTP == true then
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]The teleporter has recharged.[-]&quot;)
			igplayers[steam].notifyTP = false
			forgetLastTP(steam)
		end
	else
		igplayers[steam].notifyTP = true
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 10&quot;) 
	end	

	if (players[steam].location ~= &quot;&quot;) then
		-- spawn the player at location
		if (locations[players[steam].location]) then
			cursor,errorString = conn:execute(&quot;select * from locationSpawns where location='&quot; .. players[steam].location .. &quot;'&quot;)
			if cursor:numrows() &gt; 0 then
				randomPVPTP(steam, players[steam].location, true)
			else
				cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. locations[players[steam].location].x .. &quot; &quot; .. locations[players[steam].location].y .. &quot; &quot; .. locations[players[steam].location].z
				igplayers[steam].lastTP = cmd
				teleport(cmd, true)
			end

			players[steam].location = &quot;&quot;
			conn:execute(&quot;UPDATE players SET location = '' WHERE steam = &quot; .. steam)
		end

		if (players[steam].location == &quot;return player&quot;) then		

			if players[steam].xPosTimeout ~= 0 and players[steam].zPosTimeout ~= 0 then
				cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. players[steam].xPosTimeout .. &quot; &quot; .. players[steam].yPosTimeout .. &quot; &quot; .. players[steam].zPosTimeout
				players[steam].xPosTimeout = 0
				players[steam].yPosTimeout = 0
				players[steam].zPosTimeout = 0
			else
				cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. players[steam].xPosOld .. &quot; &quot; .. players[steam].yPosOld .. &quot; &quot; .. players[steam].zPosOld
			end

			igplayers[steam].lastTP = cmd
			teleport(cmd, true)
			players[steam].location = &quot;&quot;
			conn:execute(&quot;UPDATE players SET location = '' WHERE steam = &quot; .. steam)
		end
	end

	currentLocation = inLocation(intX, intZ)

	if currentLocation ~= false then
		resetZone = locations[currentLocation].resetZone
	end

	if igplayers[steam].alertLocation ~= currentLocation and currentLocation ~= false then -- 
		message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Welcome to &quot; .. currentLocation .. &quot;[-]&quot;)
	end

	if currentLocation == false then --  or igplayers[steam].alertLocation ~= currentLocation
		if igplayers[steam].alertLocation ~= &quot;&quot; then
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You have left &quot; .. igplayers[steam].alertLocation .. &quot;[-]&quot;)
		end

		igplayers[steam].alertLocation = &quot;&quot;
		players[steam].inLocation = &quot;&quot;
	else
		igplayers[steam].alertLocation = currentLocation
		players[steam].inLocation = currentLocation
	end

	-- test for hackers teleporting
	if tonumber(igplayers[steam].xPos ~= 0) and tonumber(igplayers[steam].zPos ~= 0) then
		dist = 0

		if igplayers[steam].deadX == nil then
			dist = distancexz(posX, posZ, igplayers[steam].xPos, igplayers[steam].zPos)
		end

		if (dist &gt;= 1000) then
			if igplayers[steam].tp &lt; 1 then
				if players[steam].newPlayer == true then
					new = &quot; [FF8C40]NEW player &quot;
				else
					new = &quot; [FF8C40]Player &quot;
				end

				if accessLevel(steam) &gt; 2 then
	--				irc_QueueMsg(server.ircMain, serverTime .. &quot; Player &quot; .. id .. &quot; name: &quot; .. name .. &quot; detected teleporting to &quot; .. intX .. &quot; &quot; .. intY .. &quot; &quot; .. intZ .. &quot; distance &quot; .. dist)
	--				irc_QueueMsg(server.ircAlerts, serverTime .. &quot; Player &quot; .. id .. &quot; name: &quot; .. name .. &quot; detected teleporting to &quot; .. intX .. &quot; &quot; .. intY .. &quot; &quot; .. intZ .. &quot; distance &quot; .. dist)

					if igplayers[steam].hackerScore == nil then igplayers[steam].hackerScore = 0 end
					igplayers[steam].hackerScore = igplayers[steam].hackerScore + 1

					if (players[steam].newPlayer == true) then
						if igplayers[steam].hackerScore &gt; 1 then
	--						message(&quot;say [&quot; .. server.chatColour .. &quot;]Detaining &quot; .. players[steam].name .. &quot;. Detected anomalous teleporting.  Please wait for an admin to release you.[-]&quot;)
	--						message(&quot;say /timeout &quot; .. players[steam].name)
						end
					else
						if igplayers[steam].hackerScore &gt; 3 then
	--						message(&quot;say [&quot; .. server.chatColour .. &quot;]Detaining &quot; .. players[steam].name .. &quot;. Detected anomalous teleporting.  Please wait for an admin to release you.[-]&quot;)
	--						message(&quot;say /timeout &quot; .. players[steam].name)
						end
					end

					for k, v in pairs(igplayers) do
						if (accessLevel(k) &lt; 3) then
	--						message(&quot;pm &quot; .. k .. new .. id .. &quot; name: &quot; .. name .. &quot; detected teleporting.[-]&quot;)
						end
					end
				end
			end

			igplayers[steam].tp = 0
		end
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 11&quot;) 
	end	

	players[steam].name = name
	igplayers[steam].name = name
	igplayers[steam].steam = steam
	igplayers[steam].xPos = posX
	igplayers[steam].yPos = posY
	igplayers[steam].zPos = posZ
	igplayers[steam].playerKills = kills
	igplayers[steam].deaths = deaths
	igplayers[steam].zombies = zombies
	igplayers[steam].score = score
	igplayers[steam].level = level
	players[steam].level = level
	igplayers[steam].killTimer = 0 -- to help us detect a player that has disconnected unnoticed
	igplayers[steam].raiding = false

	if tonumber(ping) &gt; 0 then
		igplayers[steam].ping = ping
		players[steam].ping = ping
	end

	if igplayers[steam].rawPosition == nil then
		igplayers[steam].rawPosition = rawPosition
	end

	if (igplayers[steam].xPosLast == nil) then
		igplayers[steam].xPosLast = posX
		igplayers[steam].yPosLast = posY
		igplayers[steam].zPosLast = posZ
		igplayers[steam].xPosLastOK = intX
		igplayers[steam].yPosLastOK = intY
		igplayers[steam].zPosLastOK = intZ
	end

	if igplayers[steam].checkNewPlayer == true then
		igplayers[steam].checkNewPlayer = false

		if tonumber(level) &gt; 1 then
			players[steam].newPlayer = false
			conn:execute(&quot;UPDATE players SET newPlayer = 0 WHERE steam = &quot; .. steam)
			irc_QueueMsg(server.ircMain, &quot;Player &quot; .. player .. &quot;'s new player status has been removed because their level is &quot; .. level)
		end
	end

	-- convert zombie kills to cash
	if (tonumber(igplayers[steam].zombies) &gt; tonumber(players[steam].zombies)) and (math.abs(igplayers[steam].zombies - players[steam].zombies) &lt; 20) then
		players[steam].cash = tonumber(players[steam].cash) + math.abs(igplayers[steam].zombies - players[steam].zombies) * 4

		if (players[steam].watchCash == true) then
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]+&quot; .. math.abs(igplayers[steam].zombies - players[steam].zombies) * 4 .. &quot; Zennies. $&quot; .. players[steam].cash .. &quot; in the bank[-]&quot;)
		end

		-- update the lottery prize pool
		server.lottery = server.lottery + (math.abs(igplayers[steam].zombies - players[steam].zombies) * 1)
	end

	-- update player record of zombies
	players[steam].zombies = igplayers[steam].zombies

	if tonumber(players[steam].playerKills) &lt; tonumber(kills) then
		players[steam].playerKills = kills
	end

	if tonumber(players[steam].deaths) &lt; tonumber(deaths) then
		players[steam].deaths = deaths
	end

	if tonumber(players[steam].score) &lt; tonumber(score) then
		players[steam].score = score
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 12&quot;) 
	end	

	--players[steam].level = level
	players[steam].xPos = posX
	players[steam].yPos = posY
	players[steam].zPos = posZ

	mapCenterDistance = distancexz(intX,intZ,0,0)
	outsideMap = squareDistance(intX, intZ, server.mapSize)
	outsideMapDonor = squareDistance(intX, intZ, server.mapSize + 5000)

	if (players[steam].alertReset == nil) then
		players[steam].alertReset = false
	end

	if (igplayers[steam].greet == true) and (igplayers[steam].greetdelay == 0) then
		igplayers[steam].greet = false

		if server.welcome ~= nil then
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. server.welcome .. &quot;[-]&quot;)
		else
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Welcome to &quot; .. server.ServerName .. &quot;!  Type /info, /rules or /help for answers to common questions.[-]&quot;)
		end

		if (tonumber(igplayers[steam].zombies) ~= 0) then
			if (players[steam].donor == true) then
				welcome = &quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Welcome back &quot; .. name .. &quot;! Thanks for supporting us. =D[-]&quot;
			else
				welcome = &quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Welcome back &quot; .. name .. &quot;![-]&quot;
			end

			if (string.find(serverTime, &quot;02-14&quot;, 5, 10)) then welcome = &quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Happy Valentines Day &quot; .. name .. &quot;![-]&quot; end

			message(welcome)
		else
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Welcome &quot; .. name .. &quot;![-]&quot;)
		end

		if (players[steam].timeout == true) then
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You are in timeout, not glitched or lagged.  You will stay here until released by an admin.[-]&quot;)
		end

		if (server.scheduledRestart == true or rebootTimerID ~= nil) then
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]&lt;!&gt; SERVER WILL REBOOT SHORTLY &lt;!&gt;[-]&quot;)
		end

		if server.MOTD ~= &quot;&quot; then
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,&quot; .. steam .. &quot;,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]&quot; .. server.MOTD .. &quot;[-]&quot;) .. &quot;')&quot;)
		end

		if tonumber(players[steam].removedClaims) &gt; 0 then
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,&quot; .. steam .. &quot;,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]I am holding &quot; .. players[steam].removedClaims .. &quot; land claim blocks for you. Type /give claims to receive them.[-]&quot;) .. &quot;')&quot;)
		end

		cursor,errorString = conn:execute(&quot;SELECT * FROM mail WHERE recipient = &quot; .. steam .. &quot; and status = 0&quot;)
		if cursor:numrows() &gt; 0 then
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,&quot; .. steam .. &quot;,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]You have unread mail.  Type /read mail to read it now or /help mail for more options.[-]&quot;) .. &quot;')&quot;)
		end

		if players[steam].newPlayer == true and server.rules ~= &quot;&quot; then
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,&quot; .. steam .. &quot;,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]&quot; .. server.rules ..&quot;[-]&quot;) .. &quot;')&quot;)
		end

		if server.warnBotReset == true and accessLevel(steam) == 0 then
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,&quot; .. steam .. &quot;,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]ALERT!  It appears that the server has been reset.[-]&quot;) .. &quot;')&quot;)
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,&quot; .. steam .. &quot;,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]To reset the bot type /reset bot.[-]&quot;) .. &quot;')&quot;)
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,&quot; .. steam .. &quot;,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]To dismiss this alert type /no reset.[-]&quot;) .. &quot;')&quot;)
		end
	end


	if igplayers[steam].alertLocation == &quot;&quot; and currentLocation ~= false then
		conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,&quot; .. steam .. &quot;,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]Welcome to &quot; .. currentLocation .. &quot;[-]&quot;) .. &quot;')&quot;)
		igplayers[steam].alertLocation = currentLocation
	end


	if (igplayers[steam].greetdelay &gt; 0) then
		igplayers[steam].greetdelay = igplayers[steam].greetdelay - 1
	end


	if (igplayers[steam].teleCooldown &gt; 0) then
		igplayers[steam].teleCooldown = igplayers[steam].teleCooldown - 1
	end

	igplayers[steam].sessionPlaytime = os.time() - igplayers[steam].sessionStart

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 13&quot;) 
	end	

	if (players[steam].newPlayer == true and (igplayers[steam].sessionPlaytime + players[steam].timeOnServer &gt; (server.newPlayerTimer * 60))) then
		players[steam].newPlayer = false
		players[steam].watchPlayer = false
		message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Your new player status has been lifted.  You may now use the base command to teleport home.[-]&quot;)
		conn:execute(&quot;UPDATE players SET newPlayer = 0, watchPlayer = 0 WHERE steam = &quot; .. steam)
	end

	if tonumber(players[steam].donorExpiry) &lt; os.time() and players[steam].donor == true then
		players[steam].donor = false
		players[steam].donorLevel = 0
		conn:execute(&quot;UPDATE players SET donor = 0, donorLevel = 0 WHERE steam = &quot; .. steam)

		message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Your donor status has expired :(  Contact an admin if you need help accessing your second base. Your 2nd base's protection will be disabled one week from when your donor status expired.[-]&quot;)

		if os.time() - tonumber(players[steam].donorExpiry) &gt; (60 * 60 * 24 * 7) then
			players[steam].protect2 = fase
			conn:execute(&quot;UPDATE players SET protect2 = 0 WHERE steam = &quot; .. steam)
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]ALERT! Your second base is no longer bot protected![-]&quot;)
		end
	end

	if (showPlayers == true) then
		if players[steam].prisoner then 
			isPrisoner = &quot;yes&quot;
		else
			isPrisoner = &quot;no&quot;
		end

		if accessLevel(steam) &lt; 3 then 
			isAdmin = &quot;yes&quot;
		else
			isAdmin = &quot;no&quot;
		end

		cecho(server.windowLists, &quot;id:&quot; .. id .. &quot; name:&quot; .. igplayers[steam].name .. &quot; steam:&quot; .. steam .. &quot; admin:&quot; .. isAdmin .. &quot; xyz:&quot; .. math.floor(igplayers[steam].xPos) .. &quot; &quot; .. math.ceil(igplayers[steam].yPos) .. &quot; &quot; .. math.floor(igplayers[steam].zPos) .. &quot; prisoner:&quot; .. isPrisoner .. &quot; score:&quot; .. igplayers[steam].score .. &quot;\n&quot;)
		
		cecho(server.windowPlayers, &quot;id: &quot; .. id .. &quot;\n&quot;)
		cecho(server.windowPlayers, &quot;playerName: &quot; .. igplayers[steam].name .. &quot;\n&quot;)
		cecho(server.windowPlayers, &quot;current X Y Z: &quot; .. math.floor(igplayers[steam].xPos) .. &quot; &quot; .. math.ceil(igplayers[steam].yPos) .. &quot; &quot; .. math.floor(igplayers[steam].zPos) .. &quot;\n&quot;)	
		cecho(server.windowPlayers, &quot;steamID: &quot; .. steam .. &quot;\n&quot;)
		cecho(server.windowPlayers, &quot;playerKills: &quot; .. igplayers[steam].playerKills .. &quot;\n&quot;)
		cecho(server.windowPlayers, &quot;zombies: &quot; .. igplayers[steam].zombies .. &quot;\n&quot;)
		cecho(server.windowPlayers, &quot;score: &quot; .. igplayers[steam].score .. &quot;\n&quot;)
		cecho(server.windowPlayers, &quot;admin: &quot; .. isAdmin .. &quot;\n&quot;)
		cecho(server.windowPlayers, &quot;prisoner: &quot; .. isPrisoner .. &quot;\n&quot;)	
		cecho(server.windowPlayers, &quot;home XYZ: &quot; .. players[steam].homeX .. &quot; &quot; .. players[steam].homeY .. &quot; &quot; .. players[steam].homeZ .. &quot;\n&quot;)	
		cecho(server.windowPlayers, &quot;home2 XYZ: &quot; .. players[steam].homeX .. &quot; &quot; .. players[steam].home2Y .. &quot; &quot; .. players[steam].home2Z .. &quot;\n&quot;)	
		cecho(server.windowPlayers, &quot;session time: &quot; .. os.date(&quot;!%X&quot;,igplayers[steam].sessionPlaytime) .. &quot; seconds\n&quot;)	
		cecho(server.windowPlayers, &quot; \n&quot;)
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 14&quot;) 
	end	

	-- if we are following a player and they move more than 50 meters away, teleport us close to them.
	if igplayers[steam].following ~= nil then
		if igplayers[igplayers[steam].following] and players[igplayers[steam].following].timeout == false and players[igplayers[steam].following].botTimeout == false then
			followDistance = 50
			if igplayers[steam].followDistance ~= nil then followDistance = tonumber(igplayers[steam].followDistance) end

			dist = distancexz(igplayers[steam].xPos, igplayers[steam].zPos, igplayers[igplayers[steam].following].xPos, igplayers[igplayers[steam].following].zPos)	
			if dist &gt; followDistance and igplayers[igplayers[steam].following].yPos &gt; 0 then
				-- teleport close to the player
				send(&quot;tele &quot; .. steam .. &quot; &quot; .. math.floor(igplayers[igplayers[steam].following].xPos) .. &quot; &quot; .. math.ceil(igplayers[igplayers[steam].following].yPos - 15) .. &quot; &quot; .. math.floor(igplayers[igplayers[steam].following].zPos))
			end
		end
	end


	if (igplayers[steam].alertLocationExit ~= nil) then
		dist = distance(igplayers[steam].xPos, igplayers[steam].zPos, locations[igplayers[steam].alertLocationExit].x, locations[igplayers[steam].alertLocationExit].z)
		size = tonumber(locations[igplayers[steam].alertLocationExit].size)

		if (dist &gt; tonumber(locations[igplayers[steam].alertLocationExit].size) + 100) then
			igplayers[steam].alertLocationExit = nil

			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Your have moved too far away from the location. If you still wish to do /protect location, please start again.[-]&quot;)
			faultyPlayerinfo = false
			return
		end

		if (dist &gt; tonumber(locations[igplayers[steam].alertLocationExit].size) + 10) and (dist &lt;  tonumber(locations[igplayers[steam].alertLocationExit].size) + 30) then
			locations[igplayers[steam].alertLocationExit].exitX = intX
			locations[igplayers[steam].alertLocationExit].exitY = intY
			locations[igplayers[steam].alertLocationExit].exitZ = intZ
			locations[igplayers[steam].alertLocationExit].protected = true

			conn:execute(&quot;UPDATE locations SET exitX = &quot; .. intX .. &quot;, exitY = &quot; .. intY .. &quot;, exitZ = &quot; .. intZ .. &quot;, protected = 1 WHERE name = '&quot; .. igplayers[steam].alertLocationExit .. &quot;'&quot;)
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You have enabled protection for &quot; .. igplayers[steam].alertLocationExit .. &quot;.[-]&quot;)

			igplayers[steam].alertLocationExit = nil

			faultyPlayerinfo = false
			return
		end
	end


	if (igplayers[steam].alertVillageExit ~= nil) then
		dist = distance(igplayers[steam].xPos, igplayers[steam].zPos, locations[igplayers[steam].alertVillageExit].x, locations[igplayers[steam].alertVillageExit].z)
		size = tonumber(locations[igplayers[steam].alertVillageExit].size)

		if (dist &gt; tonumber(locations[igplayers[steam].alertVillageExit].size) + 100) then
			igplayers[steam].alertVillageExit = nil

			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Your have moved too far away from &quot; .. igplayers[steam].alertVillageExit .. &quot;. Return to &quot; .. igplayers[steam].alertVillageExit .. &quot; and type /protect village &quot; .. igplayers[steam].alertVillageExit .. &quot; again.[-]&quot;)
			faultyPlayerinfo = false
			return
		end

		if (dist &gt;  tonumber(locations[igplayers[steam].alertVillageExit].size) + 10) and (dist &lt;  tonumber(locations[igplayers[steam].alertVillageExit].size) + 100) then
			locations[igplayers[steam].alertVillageExit].exitX = intX
			locations[igplayers[steam].alertVillageExit].exitY = intY
			locations[igplayers[steam].alertVillageExit].exitZ = intZ
			locations[igplayers[steam].alertVillageExit].protect = true

			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You have enabled protection for &quot; .. igplayers[steam].alertVillageExit .. &quot;[-]&quot;)

			igplayers[steam].alertVillageExit = nil

			faultyPlayerinfo = false
			return
		end
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 15&quot;) 
	end	

	if (igplayers[steam].alertBaseExit == true) then
		if igplayers[steam].alertBase == 1 then
			dist = distance(igplayers[steam].xPos, igplayers[steam].zPos, players[igplayers[steam].alertBaseID].homeX, players[igplayers[steam].alertBaseID].homeZ)
			size = tonumber(players[igplayers[steam].alertBaseID].protectSize)
		else
			dist = distance(igplayers[steam].xPos, igplayers[steam].zPos, players[igplayers[steam].alertBaseID].home2X, players[igplayers[steam].alertBaseID].home2Z)
			size = tonumber(players[igplayers[steam].alertBaseID].protect2Size)
		end

		if (dist &gt; 200) then
			igplayers[steam].alertBaseExit = nil
			igplayers[steam].alertBaseID = nil
			igplayers[steam].alertBase = nil

			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Your have moved too far away from the base. If you still wish to do setexitbase, please start again.[-]&quot;)
			faultyPlayerinfo = false
			return
		end

		if igplayers[steam].alertBase == 1 then
			if (dist &gt;  tonumber(players[igplayers[steam].alertBaseID].protectSize) + 10) and (dist &lt;  tonumber(players[igplayers[steam].alertBaseID].protectSize) + 40) then
				players[igplayers[steam].alertBaseID].exitX = intX
				players[igplayers[steam].alertBaseID].exitY = intY
				players[igplayers[steam].alertBaseID].exitZ = intZ

				if (accessLevel(steam) &lt; 3) then
					message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You have set an exit teleport for &quot; .. players[igplayers[steam].alertBaseID].name .. &quot;'s base.[-]&quot;)
				else
					message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You have set an exit teleport for your base.  You can test it with /test base.[-]&quot;)
				end

				-- check for nearby bases
				failProtect = false
				for k, v in pairs(players) do
					if (v.homeX ~= 0) and k ~= igplayers[steam].alertBaseID then
							if (v.homeX ~= 0 and v.homeZ ~= 0) then
							dist = distance(players[igplayers[steam].alertBaseID].homeX, players[igplayers[steam].alertBaseID].homeZ, v.homeX, v.homeZ)

							if (tonumber(dist) &lt; tonumber(players[igplayers[steam].alertBaseID].protectSize)) then
								if friends[k] == nil or not string.find(friends[k].friends, igplayers[steam].alertBaseID) then
									failProtect = true
								end
							end
						end
					end			

					if (v.home2X ~= 0) and k ~= igplayers[steam].alertBaseID then
						if (v.home2X ~= 0 and v.home2Z ~= 0) then
							dist = distance(players[igplayers[steam].alertBaseID].homeX, players[igplayers[steam].alertBaseID].homeZ, v.home2X, v.home2Z)

							if (dist &lt; players[igplayers[steam].alertBaseID].protectSize + 10) then
								if not string.find(friends[k].friends, igplayers[steam].alertBaseID) then
									failProtect = true
								end
							end
						end
					end						
				end
			
				if failProtect == false then
					players[igplayers[steam].alertBaseID].protect = true
					message(&quot;pm &quot; .. igplayers[steam].alertBaseID .. &quot; [&quot; .. server.chatColour .. &quot;]Base protection for your base is active.[-]&quot;)
				else
					message(&quot;pm &quot; .. igplayers[steam].alertBaseID .. &quot; [&quot; .. server.chatColour .. &quot;]Your base is too close to another player base who is not on your friends list.  Protection cannot be enabled.[-]&quot;)
				end			

				igplayers[steam].alertBaseExit = nil
				igplayers[steam].alertBaseID = nil
				igplayers[steam].alertBase = nil

				faultyPlayerinfo = false
				return
			end
		else
			if (dist &gt;  tonumber(players[igplayers[steam].alertBaseID].protect2Size) + 10) and (dist &lt;  tonumber(players[igplayers[steam].alertBaseID].protect2Size) + 40) then
				players[igplayers[steam].alertBaseID].exit2X = intX
				players[igplayers[steam].alertBaseID].exit2Y = intY
				players[igplayers[steam].alertBaseID].exit2Z = intZ

				if (accessLevel(steam) &lt; 3) then
					message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You have set an exit teleport for &quot; .. players[igplayers[steam].alertBaseID].name .. &quot;'s 2nd base.[-]&quot;)
				else
					message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You have set an exit teleport for your 2nd base.  You can test it with /test base.[-]&quot;)
				end

				-- check for nearby bases
				failProtect = false
				for k, v in pairs(players) do
					if (v.homeX ~= 0) and k ~= igplayers[steam].alertBaseID then
							if (v.homeX ~= 0 and v.homeZ ~= 0) then
							dist = distance(players[igplayers[steam].alertBaseID].home2X, players[igplayers[steam].alertBaseID].home2Z, v.homeX, v.homeZ)

							if (tonumber(dist) &lt; tonumber(players[igplayers[steam].alertBaseID].protect2Size)) then
								if friends[k] == nil or not string.find(friends[k].friends, igplayers[steam].alertBaseID) then
									failProtect = true
								end
							end
						end
					end			

					if (v.home2X ~= 0) and k ~= igplayers[steam].alertBaseID then
						if (v.home2X ~= 0 and v.home2Z ~= 0) then
							dist = distance(players[igplayers[steam].alertBaseID].home2X, players[igplayers[steam].alertBaseID].home2Z, v.home2X, v.home2Z)

							if (dist &lt; players[igplayers[steam].alertBaseID].protect2Size + 10) then
								if not string.find(friends[k].friends, igplayers[steam].alertBaseID) then
									failProtect = true
								end
							end
						end
					end						
				end
			
				if failProtect == false then
					players[igplayers[steam].alertBaseID].protect2 = true
					message(&quot;pm &quot; .. igplayers[steam].alertBaseID .. &quot; [&quot; .. server.chatColour .. &quot;]Base protection for your second base is active.[-]&quot;)
				else
					message(&quot;pm &quot; .. igplayers[steam].alertBaseID .. &quot; [&quot; .. server.chatColour .. &quot;]Your second base is too close to another player base who is not on your friends list.  Protection cannot be enabled.[-]&quot;)
				end			

				igplayers[steam].alertBaseExit = nil
				igplayers[steam].alertBaseID = nil
				igplayers[steam].alertBase = nil

				faultyPlayerinfo = false
				return
			end
		end
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 16&quot;) 
	end	

	x = math.floor(igplayers[steam].xPos / 512)
	z = math.floor(igplayers[steam].zPos / 512)

	if (accessLevel(steam) &lt; 4) then
		if (igplayers[steam].region ~= &quot;r.&quot; .. x .. &quot;.&quot; .. z .. &quot;.7rg&quot;) then
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Region r.&quot; .. x .. &quot;.&quot; .. z .. &quot;.7rg[-]&quot;)
		end	
	end

	igplayers[steam].region = &quot;r.&quot; .. x .. &quot;.&quot; .. z .. &quot;.7rg&quot;
	igplayers[steam].regionX = x
	igplayers[steam].regionZ = z

	-- timeout
	if (players[steam].timeout == true or players[steam].botTimeout == true) then
		if (intY &lt; -50000) or (intY &gt; -5000) then
			send(&quot;tele &quot; .. steam .. &quot; &quot; .. intX .. &quot; &quot; .. -5000 .. &quot; &quot; .. intZ)
		end	

		faultyPlayerinfo = false
		return
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 17&quot;) 
	end	

	-- world fall catcher
	fallCatcher(steam, intX, intY, intZ)

	-- prevent player exceeding the map limit unless an admin and ignoreadmins is false
	if outsideMap and players[steam].donor == false and (accessLevel(steam) &gt; 3) then
		if not inLocation(intX, intZ) then
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]This map is restricted to &quot; .. (server.mapSize / 1000) .. &quot; km from the center.[-]&quot;)
			send (&quot;tele &quot; .. steam .. &quot; &quot; .. igplayers[steam].xPosLastOK .. &quot; &quot; .. igplayers[steam].yPosLastOK .. &quot; &quot; .. igplayers[steam].zPosLastOK)	
			faultyPlayerinfo = false
			return
		end
	end

	if outsideMapDonor and players[steam].donor == true and (accessLevel(steam) &gt; 3 or server.ignoreAdmins == false) then
		if not inLocation(intX, intZ) then
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]This map is restricted to &quot; .. ((server.mapSize + 5000) / 1000) .. &quot; km from the center.[-]&quot;)
			send (&quot;tele &quot; .. steam .. &quot; &quot; .. igplayers[steam].xPosLastOK .. &quot; &quot; .. igplayers[steam].yPosLastOK .. &quot; &quot; .. igplayers[steam].zPosLastOK)	
			faultyPlayerinfo = false
			return
		end
	end


	if tonumber(players[steam].exiled) == 1 and locations[&quot;exile&quot;] and not players[steam].prisoner then
		if (distancexz( intX, intZ, locations[&quot;exile&quot;].x, locations[&quot;exile&quot;].z ) &gt; tonumber(locations[&quot;exile&quot;].size)) then
			randomPVPTP(steam, &quot;exile&quot;, true)
			faultyPlayerinfo = false
			return
		end

		if players[steam].inLocation ~= &quot;exile&quot; then
			cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. igpayers[steam].xPosLastOK .. &quot; &quot; .. igplayers[steam].yPosLastOK .. &quot; &quot; .. igplayers[steam].zPosLastOK
			igplayers[steam].lastTP = cmd
			teleport(cmd, true)	
			faultyPlayerinfo = false
			return
		end
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 18&quot;) 
	end	

	-- left prison zone warning 
	if (locations[&quot;prison&quot;]) then
		if (distance ( intX, intZ, locations[&quot;prison&quot;].x, locations[&quot;prison&quot;].z ) &gt; tonumber(server.prisonSize)) then
			if (players[steam].alertPrison == false) then
				if (not players[steam].prisoner) then
					message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You have left the prison.[-]&quot;)
				end

				players[steam].alertPrison = true
			end
		end

		if (players[steam].prisoner) then
			if (locations[&quot;prison&quot;]) then
				if (squareDistanceXZXZ(locations[&quot;prison&quot;].x, locations[&quot;prison&quot;].z, intX, intZ, server.prisonSize)) then
					players[steam].alertPrison = false

					if (squareDistanceXZXZ(locations[&quot;prison&quot;].x, locations[&quot;prison&quot;].z, igplayers[steam].xPosLastOK, igplayers[steam].zPosLastOK, server.prisonSize)) then
						cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. locations[&quot;prison&quot;].x .. &quot; &quot; .. locations[&quot;prison&quot;].y .. &quot; &quot; .. locations[&quot;prison&quot;].z
					else
						cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. igplayers[steam].xPosLastOK .. &quot; &quot; .. igplayers[steam].yPosLastOK .. &quot; &quot; .. igplayers[steam].zPosLastOK
					end

					prepareTeleport(steam, cmd)
					teleport(cmd, true)
				end
			end

			faultyPlayerinfo = false
			return
		end

		-- entered prison zone warning 
		if (distance ( intX, intZ, locations[&quot;prison&quot;].x, locations[&quot;prison&quot;].z ) &lt; tonumber(server.prisonSize)) then
			if (players[steam].alertPrison == true) then
				if (not players[steam].prisoner) then
					message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You have entered the prison.  Continue at your own risk.[-]&quot;)
				end
				players[steam].alertPrison = false
			end
		end
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 19&quot;) 
	end	

	-- freeze!
	if (players[steam].freeze == true) then
		send(&quot;tele &quot; .. steam .. &quot; &quot; .. igplayers[steam].xPosLastOK .. &quot; &quot; .. igplayers[steam].yPosLastOK .. &quot; &quot; .. igplayers[steam].zPosLastOK)	
		faultyPlayerinfo = false
		return
	end


	-- teleport lookup
	if (igplayers[steam].teleCooldown &lt; 1) and (players[steam].prisoner == false) then
		tp = &quot;&quot;
		tp = LookupTeleport(posX, posY, posZ)

		if (tp ~= nil and teleports[tp].active == true) then

			ownerid = LookupOfflinePlayer(teleports[tp].owner)

			if (players[steam].walkies ~= true) then
				if (accessLevel(steam) &lt; 3) or (teleports[tp].owner == igplayers[steam].steam or teleports[tp].public == true or isFriend(ownerid, steam)) then
					if match == 1 then
						igplayers[steam].teleCooldown = 3
						cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. math.floor(teleports[tp].dx) .. &quot; &quot; .. math.ceil(teleports[tp].dy) + 1 .. &quot; &quot; .. math.floor(teleports[tp].dz)
						igplayers[steam].lastTP = cmd
						teleport(cmd, true)

						faultyPlayerinfo = false
						return
					end

					if match == 2 and teleports[tp].oneway == false then
						igplayers[steam].teleCooldown = 3
						cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. math.floor(teleports[tp].x) .. &quot; &quot; .. math.ceil(teleports[tp].y) + 1 .. &quot; &quot; .. math.floor(teleports[tp].z)
						igplayers[steam].lastTP = cmd
						teleport(cmd, true)

						faultyPlayerinfo = false
						return
					end
				end
			end
		end
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 20&quot;) 
	end	

	-- left reset zone warning
	if (not resetZone) then
		if (players[steam].alertReset == false) then
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You are out of the reset zone[-]&quot;)
			players[steam].alertReset = true
			faultyPlayerinfo = false
		end
	end


	-- entered reset zone warning 
	if (resetZone) then
		if (players[steam].alertReset == true) then
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You are in a reset zone. Don't build here.[-]&quot;)
			players[steam].alertReset = false
			faultyPlayerinfo = false

			-- check for claims in the reset zone not owned by staff and remove them
			checkRegionClaims(x, z)
		end
	end


	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 21&quot;) 
	end	

	if	baseProtection(steam, posX, posY, posZ) and not resetZone then
		faultyPlayerinfo = false
		return
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 21a&quot;) 
	end	

	-- add to tracker table
	dist = distancexyz(intX, intY, intZ, igplayers[steam].xPosLast, igplayers[steam].yPosLast, igplayers[steam].zPosLast)

	if (dist &gt; 2) and tonumber(intY) &gt; 0 and tonumber(intY) &lt; 255 then
		-- record the players position
		conn:execute(&quot;INSERT INTO tracker (steam, x, y, z, session) VALUES (&quot; .. steam .. &quot;,&quot; .. intX .. &quot;,&quot; .. intY .. &quot;,&quot; .. intZ .. &quot;,&quot; .. players[steam].sessionCount .. &quot;)&quot;)

		if igplayers[steam].location ~= nil then
			conn:execute(&quot;INSERT INTO locationSpawns (location, x, y, z) VALUES ('&quot; .. igplayers[steam].location .. &quot;',&quot; .. intX .. &quot;,&quot; .. intY .. &quot;,&quot; .. intZ .. &quot;)&quot;)
		end
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 22&quot;) 
	end	

	if (igplayers[steam].deadX ~= nil) then
		dist = math.abs(distance(igplayers[steam].deadX, igplayers[steam].deadZ, posX, posZ))
		if (dist &gt; 2) then
			igplayers[steam].deadX = nil
			igplayers[steam].deadY = nil
			igplayers[steam].deadZ = nil
			
			if players[steam].bed ~= &quot;&quot; then
				if players[steam].bed == &quot;base1&quot; then
					cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. players[steam].homeX .. &quot; &quot; .. players[steam].homeY .. &quot; &quot; .. players[steam].homeZ
					igplayers[steam].lastTP = cmd
					teleport(cmd, true)	
				end	
				
				if players[steam].bed == &quot;base2&quot; then
					cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. players[steam].home2X .. &quot; &quot; .. players[steam].home2Y .. &quot; &quot; .. players[steam].home2Z
					igplayers[steam].lastTP = cmd
					teleport(cmd, true)	
				end				
			end
		end
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 23&quot;) 
	end	

	-- hotspot lookup
	hotspot = LookupHotspot(posX, posY, posZ)

	if (hotspot ~= nil) then
		if (igplayers[steam].lastHotspot ~= hotspot) then
			for k, v in pairs(lastHotspots[steam]) do
				-- todo finish this off.  look for presence of hotspot
				if v == hotspot then -- don't add or display this hotspot yet.  we've seen it recently
					faultyPlayerinfo = false
					return
				end
			end

			igplayers[steam].lastHotspot = hotspot
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. hotspots[hotspot].hotspot .. &quot;[-]&quot;)

			if (lastHotspots[steam] == nil) then lastHotspots[steam] = {} end
			if (table.maxn(lastHotspots[steam]) &gt; 10) then
				table.remove(lastHotspots[steam], 1)
			end	

			table.insert(lastHotspots[steam],  hotspot)
			faultyPlayerinfo = false
		end
	end


	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 24&quot;) 
	end	

	if igplayers[steam].rawPosition ~= rawPosition then
		igplayers[steam].afk = os.time() + 900
		igplayers[steam].rawPosition = rawPosition
	end

	--if (playersOnline &gt;= server.ServerMaxPlayerCount) and (accessLevel(steam) &gt; 3) then
	--	if (igplayers[steam].afk - os.time() &lt; 0) then
	--		send (&quot;kick &quot; .. steam .. &quot; Server is full.  You were kicked because you were idle too long.  You can rejoin any time.&quot;)
	--	end
	--end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 25&quot;) 
	end	


	if (pvpZone(posX, posZ) ~= false) then
		if players[steam].alertPVP == true then
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You have entered a PVP zone!  Proceed with caution.[-]&quot;)
			players[steam].alertPVP = false
			faultyPlayerinfo = false
		end
	else
		if players[steam].alertPVP == false then
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You have left a PVP zone.  Do not kill other players here![-]&quot;)
			players[steam].alertPVP = true
			faultyPlayerinfo = false
		end
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 26&quot;) 
	end	

	-- stuff to do after everything else
	igplayers[steam].xPosLast = posX
	igplayers[steam].yPosLast = posY
	igplayers[steam].zPosLast = posZ

	igplayers[steam].xPosLastOK = intX
	igplayers[steam].yPosLastOK = intY
	igplayers[steam].zPosLastOK = intZ

	faultyPlayerinfo = false

	if (steam == debugSteam) then 
		dbug(&quot;debug point Z&quot;) 
	end	

	-- ping kick
	if players[steam].whitelisted == false and players[steam].newPlayer then
		if tonumber(ping) &lt; tonumber(server.pingKick) and tonumber(server.pingKick) &gt; 0 then
			igplayers[steam].highPingCount = tonumber(igplayers[steam].highPingCount) - 1
			if tonumber(igplayers[steam].highPingCount) &lt; 0 then igplayers[steam].highPingCount = 0 end
		end 

		if tonumber(ping) &gt; tonumber(server.pingKick) and tonumber(server.pingKick) &gt; 0 then
			igplayers[steam].highPingCount = tonumber(igplayers[steam].highPingCount) + 1

			if tonumber(igplayers[steam].highPingCount) &gt; 5 then
				irc_QueueMsg(server.ircMain, &quot;Kicked &quot; .. name .. &quot; steam: &quot; .. steam.. &quot; for high ping &quot; .. ping)
				kick(steam, &quot;High ping. Contact an admin and ask to be whitelisted.&quot;)
				return
			end
		end
	end
end


if string.find(line, &quot;, health=&quot;) then
	if (faultyPlayerinfo == true) then
		cecho(server.windowDebug, &quot;!! Fault detected in playerinfo trigger\n&quot;)
		cecho(server.windowDebug, faultyPlayerinfoLine .. &quot;\n&quot;)

		cecho(server.windowAlerts, &quot;!! Fault detected in playerinfo trigger\n&quot;)
		cecho(server.windowAlerts, faultyPlayerinfoLine .. &quot;\n&quot;)

		fixMissingPlayer(faultyPlayerinfoID)

		if igplayers[faultyPlayerinfoID] then
			fixMissingIGPlayer(faultyPlayerinfoID)	
		end
	end

	playerInfo()
	deleteLine()
end</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>, health=</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Player disconnected</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

function playerDisconnected()
	local steam
	local pos = string.find(line, &quot;PlayerID='&quot;) + 10
	local serverTime

	serverTime = string.sub(line, 1, 19)
	newDay()

	steam = string.sub(line, pos, pos + 16)

	fixMissingPlayer(steam)

	-- update players table with x y z
	players[steam].protectPaused = nil
	players[steam].protect2Paused = nil
	players[steam].xPos = igplayers[steam].xPos
	players[steam].yPos = igplayers[steam].yPos
	players[steam].zPos = igplayers[steam].zPos
	players[steam].timeOnServer = players[steam].timeOnServer + igplayers[steam].sessionPlaytime
	players[steam].seen = serverTime
	players[steam].playerKills = igplayers[steam].playerKills
	players[steam].deaths = igplayers[steam].deaths
	players[steam].zombies = igplayers[steam].zombies
	players[steam].score = igplayers[steam].score
	players[steam].ping = igplayers[steam].ping

	if (igplayers[steam].sessionPlaytime) &gt; 300 then
		players[steam].relogCount = 0
	end

	if (igplayers[steam].sessionPlaytime) &lt; 60 then
		if not players[steam].timeout and not players[steam].botTimeout and not players[steam].prisoner then
			players[steam].relogCount = tonumber(players[steam].relogCount) + 1
		end
	else
		players[steam].relogCount = tonumber(players[steam].relogCount) - 1
		if tonumber(players[steam].relogCount) &lt; 0 then players[steam].relogCount = 0 dbug(&quot;relog reset 2&quot;) end
	end

	players[steam].lastLogout = os.time()

	if accessLevel(steam) &lt; 3 then
		conn:execute(&quot;DELETE FROM memTracker WHERE admin = &quot; .. steam)
	end

	conn:execute(&quot;DELETE FROM messageQueue WHERE recipient = &quot; .. steam)
	conn:execute(&quot;DELETE FROM gimmeQueue WHERE steam = &quot; .. steam)
	conn:execute(&quot;DELETE FROM commandQueue WHERE steam = &quot; .. steam)
	conn:execute(&quot;DELETE FROM playerQueue WHERE steam = &quot; .. steam)

	dbug(&quot;Removing disconnected player &quot; .. igplayers[steam].name)

	-- delete player from igplayers table
	igplayers[steam] = nil

	lastHotspots[steam] = nil
	invTemp[steam] = nil

	-- update the player record in the database
	updatePlayer(steam)

	-- check how many claims they have placed
	send(&quot;llp &quot; .. steam)
end


if string.find(line, &quot;Player disconnected:&quot;) then
	playerDisconnected()
end</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>Player disconnected:</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Inventory</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

if not string.find(line, server.botsIP) then
	return
end

serverTime = string.sub(line, 1, 19)
invCheckID = string.sub(line, string.find(line, &quot;si &quot;) + 3, string.find(line, &quot;by &quot;) - 2)

deleteLine()</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>Executing command 'si</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>lkp</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

local name, id, steam, playtime, seen, result

data = string.split(line, &quot;,&quot;)

name = string.sub(data[1], string.find(data[1], &quot;. &quot;) + 2)
id = string.sub(data[2], string.find(data[2], &quot;id=&quot;) + 3)
steam = string.sub(data[3], string.find(data[3], &quot;steamid=&quot;) + 8)
playtime = string.sub(data[6], string.find(data[6], &quot;playtime=&quot;) + 9, string.len(data[6]) - 2)
seen = string.sub(data[7], string.find(data[7], &quot;seen=&quot;) + 5)

local pattern = &quot;(%d+)-(%d+)-(%d+) (%d+):(%d+)&quot;
local runyear, runmonth, runday, runhour, runminute, runseconds = seen:match(pattern)
local seenTimestamp = os.time({year = runyear, month = runmonth, day = runday, hour = runhour, min = runminute, sec = runseconds})

if (not players[steam] and (playtime ~= &quot;0&quot;)) then
	cecho(server.windowDebug, &quot;add player &quot; .. name .. &quot;\n&quot;)
	players[steam] = {}
	players[steam].id = id
	players[steam].name = name
	players[steam].steam = steam
	players[steam].playtime = playtime
	players[steam].seen = seen

	conn:execute(&quot;INSERT INTO players (steam, id, name, playtime, seen) VALUES (&quot; .. steam .. &quot;,&quot; .. id .. &quot;,'&quot; .. escape(name) .. &quot;',&quot; .. playtime .. &quot;,'&quot; .. seen .. &quot;') ON DUPLICATE KEY UPDATE playtime = &quot; .. playtime .. &quot;, seen = '&quot; .. seen .. &quot;'&quot;)
else
	if (playtime ~= &quot;0&quot;) then
		cecho(server.windowDebug, &quot;update player &quot; .. name .. &quot;\n&quot;)
		players[steam].id = id
		players[steam].name = name
		players[steam].playtime = playtime
		players[steam].seen = seen

		conn:execute(&quot;INSERT INTO players (steam, id, name, playtime, seen) VALUES (&quot; .. steam .. &quot;,&quot; .. id .. &quot;,'&quot; .. escape(name) .. &quot;',&quot; .. playtime .. &quot;,'&quot; .. seen .. &quot;') ON DUPLICATE KEY UPDATE playtime = &quot; .. playtime .. &quot;, seen = '&quot; .. seen .. &quot;'&quot;)
	end
end

-- add missing fields and give them default values
fixMissingPlayer(steam)</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>online=</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Zombie Scouts</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


-- 014-12-29T18:36:42 13941.838 INF AIDirector: Spawning scouts @ ((-4791.0, 64.0, -5491.0)) heading towards ((-4740.0, 64.0, -5588.0))

if botDisabled then
	return
end

local test, dist, x, z, direction

if string.find(line, &quot;towards&quot;) then
	test = string.sub(line, string.find(line, &quot;towards&quot;) + 7)

	split = string.split(test, &quot;,&quot;)
	x = string.match(split[1], &quot;-?%d+&quot;)
	z = string.match(split[3], &quot;-?%d+&quot;)

	if (string.find(line, &quot;heading towards&quot;)) then
		for k, v in pairs(igplayers) do
			direction = getCompass(v.xPos, v.zPos, x, z)

			dist = distance(v.xPos, v.zPos, x, z)
			if (dist &lt; 50) then
				message(&quot;pm &quot; .. k .. &quot; &quot; ..  &quot; [&quot; .. server.chatColour .. &quot;]Scouts have been detected heading your way from the &quot; .. direction .. &quot;.[-]&quot;)
			end
		end
	end
end</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>AIDirector: Spawning scouts</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>InventoryOwner</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

local pname

pname = string.sub(line, string.find(line, &quot;player &quot;) + 7)
pname = string.sub(pname, 1, string.len(pname) - 1)

invCheckID = LookupPlayer(pname, &quot;all&quot;) 

if (string.find(line, &quot;Belt of player&quot;)) then
	if (igplayers[invCheckID].inventoryLast ~= igplayers[invCheckID].inventory) then
		igplayers[invCheckID].inventoryLast = igplayers[invCheckID].inventory
	end

	igplayers[invCheckID].inventory = &quot;&quot;
	igplayers[invCheckID].oldBelt = igplayers[invCheckID].belt
	igplayers[invCheckID].belt = &quot;&quot;
	igplayers[invCheckID].pack = &quot;&quot;
	igplayers[invCheckID].equipment = &quot;&quot;
	invScan = &quot;belt&quot;
end

if (string.find(line, &quot;Bagpack of player&quot;)) then
	invScan = &quot;bagpack&quot;
end

if (string.find(line, &quot;Equipment of player&quot;)) then
	invScan = &quot;equipment&quot;
end

deleteLine()
</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>Belt of player</string>
                <string>Bagpack of player</string>
                <string>Equipment of player</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
                <integer>0</integer>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>AirDrop alert</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--651 INF AIAirDrop: Spawned supply crate @ ((2114.4, 244.0, -2210.6))&quot;

if botDisabled then
	return
end

local test, dist, direction, coord, k, v

test = string.sub(line, string.find(line, &quot;@&quot;) + 4)
test = string.sub(test, 1, string.len(test) - 2)
coord = string.split(test, &quot;,&quot;)

for k, v in pairs(igplayers) do
	dist = distance(v.xPos, v.zPos, coord[1], coord[3])
	if (tonumber(dist) &lt; 500) then
		direction = getCompass(v.xPos, v.zPos, coord[1], coord[3])
		message(&quot;pm &quot; .. k .. &quot; &quot; ..  &quot; [&quot; .. server.chatColour .. &quot;]Supplies have been dropped &quot; .. math.floor(dist) .. &quot; meters to the &quot; .. direction ..&quot;![-]&quot;)
	end
end</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>AIAirDrop: Spawned supply crate</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Spam</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


deleteLine()
ExceptionCount = 0

-- |Spawned
-- |Player</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>^.*(\'gt|\'mem|\'lp|command \'si|STATS|Time|Token|Started thread|RequestTo|Adding|Removing|Created player|Allowing|Authenticating|Player set to online|OnPlayer|NET: Received package|Infinity|Exited|Couldn\'t send RPC|Disconnected player|Error in|Exception in|INF VOICE|'GameManager| at AllocsFixes.|Freeing).*$</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>1</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Game Time</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

local words = {}

for word in line:gmatch(&quot;%w+&quot;) do table.insert(words, word) end

gameDate = string.trim(line)
gameDay = words[2]
gameHour = tonumber(words[3])
gameMinute = words[4]
gameDate = &quot;Day &quot; .. gameDay .. &quot;, &quot; ..string.format(&quot;%02d&quot;, gameHour) .. &quot;:&quot; .. gameMinute

--if (gameDay % 7 == 0) then
--	if (tonumber(gameHour) == 17) then
--		if (feralWarning == false) then
--			message(&quot;say [&quot; .. server.chatColour .. &quot;]Feral hordes will run tonight![-]&quot;)
--			feralWarning = true
--		end
--	else
--		feralWarning = false
--	end


if (tonumber(gameHour) == 0 and server.allowShop == true) then
	if 	dailyDraw == false then
		drawLottery()
		dailyDraw = true
	end
else
	dailyDraw = false
end

if tonumber(gameDay) &lt; tonumber(server.gameDay) and tonumber(server.gameDay) &gt; 0 and server.warnBotReset ~= true then
	if tonumber(server.gameDay) &lt; 10 then
		-- the server date has rolled back.  try to alert any level 0 admin that the bot may need a reset too.
		server.warnBotReset = true

		for k,v in pairs(igplayers) do
			if accessLevel(k) == 0 then
				message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]ALERT!  It appears that the server has been reset.[-]&quot;)
				message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]To reset the bot type /reset bot.[-]&quot;)
				message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]To dismiss this alert type /no reset.[-]&quot;)
			end
		end
	end
end

server.gameDay = gameDay
conn:execute(&quot;UPDATE server SET gameDay = &quot; .. gameDay)
</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>Day </string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>2</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>GameTickCount</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

local diff, days, hours

-- grab the tick counter
test = string.sub(line, string.find(line, &quot;:&quot;) + 7, string.find(line, &quot; INF&quot;))
gameTick = tonumber(test)

if nextRebootTest ~= nil and os.time() &lt; nextRebootTest then
	return
end

if gameTick &gt; 0 then
	server.uptime = gameTick
else
	server.uptime = os.time() - botStarted
end

if gameTick &lt; 0 and server.scheduledRestart == false and server.allowReboot == true then
	message(&quot;say /reboot server in 5 minutes&quot;)
	message(&quot;say [&quot; .. server.chatColour .. &quot;]A fault has been detected. A reboot should fix it.[-]&quot;)
end

diff = gameTick
days = math.floor(diff / 86400)

if (days &gt; 0) then
	diff = diff - (days * 86400)
end

hours = math.floor(diff / 3600)

if tonumber(hours) &gt;= tonumber(server.maxServerUptime) and server.scheduledRestart == false and server.allowReboot == true then
	message(&quot;say [&quot; .. server.chatColour .. &quot;]The server will reboot soon to keep it running well.[-]&quot;)
	message(&quot;say [&quot; .. server.chatColour .. &quot;]/reboot in 15 minutes&quot;)
end
</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>'gt'</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Logon Successful</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

if string.find(line, &quot;Logon successful.&quot;) then
	botOffline = 2
	irc_QueueMsg(server.ircMain, &quot;Successfully logged in and monitoring server traffic.&quot;)
end</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>Logon successful.</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>2</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Collect Ban</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


if botDisabled then
	return
end

local temp, reason, yr, mth, dy, hr, min, sec, tdate, steam, expiryDate, bannedTo

temp = string.split(line, &quot; &quot;)

tdate = string.split(temp[4], &quot;/&quot;)
yr = tdate[3]
mth = tdate[1]
dy = tdate[2]

tdate = string.split(temp[5], &quot;:&quot;)
hr = tonumber(tdate[1])
min = tdate[2]
sec = tdate[3]

if temp[6] == &quot;PM,&quot; then
	hr = hr + 12
end

bannedTo = temp[4] .. &quot; &quot; .. escape(temp[5]) .. &quot; &quot; .. escape(string.sub(temp[6], 1, 2))
expiryDate = yr .. &quot;-&quot; .. mth .. &quot;-&quot; .. dy .. &quot; &quot; .. hr .. &quot;:&quot; .. min .. &quot;:&quot; .. sec
steam = temp[1]
reason = string.sub(line, string.find(line, &quot;reason:&quot;) + 8)

if reason ~= nil then
	conn:execute(&quot;INSERT INTO bans (BannedTo, steam, reason, expiryDate) VALUES ('&quot; .. bannedTo .. &quot;',&quot; .. steam .. &quot;,'&quot; .. escape(reason) .. &quot;','&quot; .. expiryDate .. &quot;'&quot;)
	connBots:execute(&quot;INSERT INTO bans (bannedTo, steam, reason, expiryDate) VALUES ('&quot; .. bannedTo .. &quot;',&quot; .. steam .. &quot;,'&quot; .. escape(reason) .. &quot;','&quot; .. expiryDate .. &quot;'&quot;)
else
	conn:execute(&quot;INSERT INTO bans (BannedTo, steam, expiryDate) VALUES ('&quot; .. bannedTo .. &quot;',&quot; .. steam .. &quot;,'&quot; .. expiryDate .. &quot;'&quot;)
end
</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>banned until</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Unban player</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

local words

words = {}
for word in line:gmatch(&quot;%S+&quot;) do table.insert(words, word) end

conn:execute(&quot;DELETE FROM bans WHERE steam = &quot; .. words[1])</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>removed from ban list</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Overstack</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--INF Player with ID 2101092 has stack for &quot;weaponRepairKit&quot; greater than allowed (24 &gt; 12)

if botDisabled then
	return
end

local item, limit, id

id = string.sub(line, string.find(line, &quot; ID &quot;) + 4, string.find(line, &quot; has&quot;) - 1)
item = string.sub(line, string.find(line, &quot;stack for &quot;) + 11, string.find(line, &quot;greater&quot;) - 3)
limit = string.sub(line, string.find(line, &quot; &gt; &quot;) + 3, string.len(line) - 1)

stackLimits[item] = {}
stackLimits[item].limit = tonumber(limit)

id = LookupPlayer(id)
if id ~= nil then
	players[id].overstack = true

	if not string.find(item, players[id].overstackItems) then
		players[id].overstackItems = players[id].overstackItems .. item .. &quot;|&quot;
	end
end</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>INF Player with ID</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Open Reserved Slot</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
local steamid
steamid = string.sub(line, string.find(line, &quot;from:&quot;) + 6)
if (steamid == "yourname") then
	display(&quot;opening reserved slot\n&quot;)
	send(&quot;sg ServerMaxPlayerCount &quot; .. tonumber(server.ServerMaxPlayerCount) + 1)
	server.ServerMaxPlayerCount = server.ServerMaxPlayerCount + 1
end
--]]</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>NET: P2PSessionRequest</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>mem</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--Time: 600.95m FPS: 36.19 Heap: 2087.1MB Max: 2749.8MB Chunks: 6444 CGO: 472 Ply: 16 Zom: 55 Ent: 86 (391) Items: 60

if botDisabled then
	return
end

local time, fps, heap, chunks, cgo, ply, zom, ent, items

if (string.find(line, &quot;Heap:&quot;)) then
	time = tonumber(string.sub(line, string.find(line, &quot;Time:&quot;) + 6, string.find(line, &quot;FPS:&quot;) - 3))
	fps = tonumber(string.sub(line, string.find(line, &quot;FPS:&quot;) + 5, string.find(line, &quot;Heap:&quot;) - 2))
	heap = tonumber(string.sub(line, string.find(line, &quot;Heap:&quot;) + 6, string.find(line, &quot;Max:&quot;) - 4))
	chunks = tonumber(string.sub(line, string.find(line, &quot;Chunks:&quot;) + 8, string.find(line, &quot;CGO:&quot;) - 2))
	cgo = tonumber(string.sub(line, string.find(line, &quot;CGO:&quot;) + 5, string.find(line, &quot;Ply:&quot;) - 2))
	ply = tonumber(string.sub(line, string.find(line, &quot;Ply:&quot;) + 5, string.find(line, &quot;Zom:&quot;) - 2))
	zom = tonumber(string.sub(line, string.find(line, &quot;Zom:&quot;) + 5, string.find(line, &quot;Ent:&quot;) - 2))
	ent = string.sub(line, string.find(line, &quot;Ent:&quot;) + 5, string.find(line, &quot;Items:&quot;) - 2)
	items = tonumber(string.sub(line, string.find(line, &quot;Items:&quot;) + 7))

	server.fps = fps
	conn:execute(&quot;INSERT INTO performance (serverdate, gametime, fps, heap, chunks, cgo, players, zombies, entities, items) VALUES ('&quot; .. serverTime .. &quot;',&quot; .. time .. &quot;,&quot; .. fps .. &quot;,&quot; .. heap .. &quot;,&quot; .. chunks .. &quot;,&quot; .. cgo .. &quot;,&quot; .. ply .. &quot;,&quot; .. zom .. &quot;,'&quot; .. ent .. &quot;',&quot; .. items .. &quot;)&quot;)
end</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>Heap:</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>lp</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

if string.find(string.sub(line, 1, 19), os.date(&quot;%Y&quot;)) then
	serverTime = string.sub(line, 1, 19)
end</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>Executing command 'lp</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Tele</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

local player, id, cmd

if string.find(line, &quot;from &quot;) then
	cmd = string.sub(line, string.find(line, &quot;tele &quot;), string.find(line, &quot;from&quot;) - 3)
	cmd = string.split(cmd, &quot; &quot;)

	i = table.maxn(cmd)
	id = LookupPlayer(cmd[2])
	igplayers[id].tp = 1
end


if string.find(line, server.botsIP) then
	cmd = string.sub(line, string.find(line, &quot;tele &quot;), string.find(line, &quot;by Telnet&quot;) - 3)
	cmd = string.split(cmd, &quot; &quot;)

	id = cmd[2]
	igplayers[id].tp = 1
end

</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>Telnet executed 'tele</string>
                <string>Executing command 'tele</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>llp</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]



if botDisabled then
	return
end

if not string.find(line, server.botsIP) then
	return
end

local pos

if string.find(line, &quot;Executing command 'llp&quot;) then
	pos = string.find(line, &quot;llp&quot;) + 4
	llpid = string.sub(line, pos, pos + 16)
	players[llpid].keystones = 0
	return
else
	pos = string.find(line, &quot; owns&quot;) - 3
	llpid = string.sub(line, pos - 16, pos)
	players[llpid].keystones = string.sub(line, string.find(line, &quot;owns &quot;) + 5, string.find(line, &quot; keyst&quot;) - 1)
end

conn:execute(&quot;UPDATE players SET keystones = &quot; .. players[llpid].keystones .. &quot; WHERE steam = &quot; .. llpid)

</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>keystones (protected:</string>
                <string>Executing command 'llp</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>GMSG</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]



if botDisabled then
	return
end

local result, x, z, id, pname, msg, debug

debug = false

if debug then dbug(line) end

gmsgvars = {}

if (faultyGMSG == nil) then faultyGMSG = false end

if (faultyGMSG == true) then
	cecho(server.windowDebug, &quot;!! Fault detected in GMSG\n&quot;)
	cecho(server.windowDebug, faultyLine .. &quot;\n&quot;)
	if (faultyGMSGCommand ~= nil) then cecho(server.windowDebug, &quot;!! Fault occurred in command: &quot; .. faultyGMSGCommand .. &quot;\n&quot;) end
	faultyGMSG = false
end

if debug then dbug(&quot;gmsg 1&quot;) end

faultyLine = line
faultyGMSG = true

gmsgvars.timestamp = os.time()
serverTime = string.sub(line, 1, 19)

if debug then dbug(&quot;gmsg 2&quot;) end

ExceptionCount = 0

gmsgvars.gmsg = line
gmsgvars.oldLine = line
gmsgvars.playerid = 0

--2015-06-04T08:10:32 11084.343 INF Denying command 'pm /library' from client zombiehunter0502&quot;

if string.find(line, &quot; command 'pm&quot;) and not string.find(line, &quot;' from client&quot;) then
	faultyGMSG = false
	return
end

if string.find(line, &quot; command 'pm&quot;) and string.find(line, &quot;' from client&quot;) then
	msg = string.sub(line, string.find(line, &quot;command 'pm&quot;) + 12, string.find(line, &quot;' from client&quot;) - 1)
	id = string.sub(line, string.find(line, &quot;from client &quot;) + 12) 
	id = LookupPlayer(id, &quot;all&quot;)

	cecho(server.windowGMSG, players[id].name .. &quot;: &quot; .. msg .. &quot;\n&quot;)
	irc_QueueMsg(server.ircWatch, gameDate .. &quot; &quot; .. players[id].name .. &quot;: &quot; .. msg)

	gmsgvars.chatline = string.split(gmsgvars.gmsg, &quot;:&quot;)
	gmsgvars.playername = players[id].name
	gmsgvars.command = msg
	gmsgvars.accessLevel = accessLevel(id)
else
	if not string.find(line, &quot;GMSG:&quot;) then -- prevent code executing if we just saved this module and line isn't chat
		faultyGMSG = false
		return
	end

	msg =  string.sub(line, string.find(line, &quot;GMSG:&quot;) + 6)

	cecho(server.windowGMSG, msg .. &quot;\n&quot;)
	lastIRC = gameDate .. &quot; &quot; .. msg
	irc_QueueMsg(server.ircMain, gameDate .. &quot; &quot; .. msg)

	gmsgvars.chatline = string.split(gmsgvars.gmsg, &quot;:&quot;)
	gmsgvars.playername = string.trim(gmsgvars.chatline[4])
	gmsgvars.command = string.trim(string.sub(gmsgvars.gmsg, string.find(gmsgvars.gmsg, gmsgvars.chatline[4], nil, true) + string.len(gmsgvars.chatline[4]) + 2))

	if (string.find(gmsgvars.gmsg, &quot;GMSG: Server:&quot;)) then
		gmsgvars.playername = &quot;Server&quot;
		faultyGMSG = false
	end
end

if debug then dbug(&quot;gmsg 3&quot;) end

-- don't process any chat coming from irc
if (string.find(gmsgvars.gmsg, &quot;-irc:&quot;)) then
	faultyGMSG = false
	return
end

--deleteLine()

faultyGMSGCommand = gmsgvars.command

gmsgvars.playerid = LookupPlayer(gmsgvars.playername, &quot;all&quot;)

if debug then
	cecho(server.windowDebug, &quot;gmsgvars.playername &quot; .. gmsgvars.playername .. &quot;\n&quot;)
	cecho(server.windowDebug, &quot;command &quot; .. gmsgvars.command .. &quot;\n&quot;)
end

-- ignore game messages
if (gmsgvars.playername ~= &quot;Server&quot;) and gmsgvars.playerid == nil then
	faultyGMSG = false
	return
end

if debug then dbug(&quot;gmsg 4&quot;) end

if (gmsgvars.playername ~= &quot;Server&quot;) then
	if not igplayers[gmsgvars.playerid] then
		faultyGMSG = false
		return
	end

	gmsgvars.intX = math.floor(igplayers[gmsgvars.playerid].xPos)
	gmsgvars.intY = math.ceil(igplayers[gmsgvars.playerid].yPos)
	gmsgvars.intZ = math.floor(igplayers[gmsgvars.playerid].zPos)

	x = math.floor(gmsgvars.intX / 512)
	z = math.floor(gmsgvars.intZ / 512)
	gmsgvars.region = &quot;r.&quot; .. x .. &quot;.&quot; .. z .. &quot;.7rg&quot;
	zombies = tonumber(igplayers[gmsgvars.playerid].zombies)
	gmsgvars.zombies = zombies

	if string.len(gmsgvars.command) &gt; 150 and server.coppi then
		if igplayers[gmsgvars.playerid].longLineCount == nil then
			igplayers[gmsgvars.playerid].longLineCount = 0
			igplayers[gmsgvars.playerid].longLineTimer = os.time()
		end

		if igplayers[gmsgvars.playerid].longLineCount &gt; 3 then
			igplayers[gmsgvars.playerid].longLineTimer = os.time() + 10
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have been muted for 1 minute for too many excessively long chat lines.[-]&quot;)
			send(&quot;mpc &quot; .. gmsgvars.playerid .. &quot; true&quot;)
			tempTimer( 60, [[unmutePlayer(&quot;]] .. gmsgvars.playerid .. [[&quot;)]] )
		end
	end
end

--gmsgvars.gmsg = string.lower(gmsgvars.gmsg)

if debug then dbug(&quot;gmsg 5&quot;) end

gmsgvars.words = {}
gmsgvars.wordsOld = {}

for word in gmsgvars.command:gmatch(&quot;%S+&quot;) do 
	table.insert(gmsgvars.words, string.lower(word))
	table.insert(gmsgvars.wordsOld, word) 
end

gmsgvars.wordCount = table.maxn(gmsgvars.words)
gmsgvars.command = string.lower(gmsgvars.command)

if (string.sub(gmsgvars.words[1], 1, 1) == &quot;/&quot;) then
	gmsgvars.words[1] = string.sub(gmsgvars.words[1], 2, string.len(gmsgvars.words[1]))
end

gmsgvars.number = tonumber(string.match(gmsgvars.command, &quot; (-?%d+)&quot;)) -- (-?\%d+)
result = false

if debug then dbug(&quot;gmsg 6&quot;) end

if not result then
	if not result and debug then cecho(server.windowDebug, &quot;debug entering gmsg_custom\n&quot;) end
	result = gmsg_custom()
	if result and debug then cecho(server.windowDebug, &quot;debug ran command in gmsg_custom\n&quot;) end
end

if debug then dbug(&quot;gmsg 7&quot;) end

if not result then
	if not result and debug then cecho(server.windowDebug, &quot;debug entering gmsg_info\n&quot;) end
	result = gmsg_info()
	if result and debug then cecho(server.windowDebug, &quot;debug ran command in gmsg_info\n&quot;) end
end

if debug then dbug(&quot;gmsg 8&quot;) end

if not result then
	if not result and debug then cecho(server.windowDebug, &quot;debug entering gmsg_unslashed\n&quot;) end
	result = gmsg_unslashed()
	if result and debug then cecho(server.windowDebug, &quot;debug ran command in gmsg_unslashed\n&quot;) end
end

if debug then dbug(&quot;gmsg 9&quot;) end

if not result then
	if not result and debug then cecho(server.windowDebug, &quot;debug entering gmsg_fun\n&quot;) end
	result = gmsg_fun()
	if result and debug then cecho(server.windowDebug, &quot;debug ran command in gmsg_fun\n&quot;) end
end

if debug then dbug(&quot;gmsg 10&quot;) end

if (gmsgvars.playername ~= &quot;Server&quot;) then
	if accessLevel(gmsgvars.playerid) &gt; 2 then	
		test =  string.sub(line, string.find(line, &quot;GMSG:&quot;) + 6)
		if test:match(&quot;(%d%d?%d?)%.(%d%d?%d?)%.(%d%d?%d?)%.(%d%d?%d?)%:(%d+)&quot;) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Do not advertise other servers! The offender has been given a temporary ban and this offense has been reported.[-]&quot;)		

			banPlayer(gmsgvars.playerid, &quot;1 hour&quot;, &quot;Advertising another server in public chat.&quot;)
			messageAdmins(&quot;Banned player &quot; .. players[gmsgvars.playerid].name .. &quot; 1 hour for advertising another server in chat.&quot;)

			irc_QueueMsg(server.ircAlerts, gameDate .. &quot; Banned player &quot; .. gmsgvars.playerid .. &quot; &quot; .. players[gmsgvars.playerid].name .. &quot; 1 hour for advertising another server in chat.&quot;)

			faultyGMSG = false
			result = true
		end
	end


	if gmsgvars.words[1] == &quot;hardcore&quot; and gmsgvars.words[2] == &quot;mode&quot; and (gmsgvars.words[3] == &quot;off&quot; or gmsgvars.words[3] == &quot;disable&quot; or string.sub(gmsgvars.words[3], 1, 2) == &quot;de&quot;) then
		players[gmsgvars.playerid].silentBob = false
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The bot will help you.[-]&quot;)		
		faultyGMSG = false
		result = true
	end


	if gmsgvars.words[1] == &quot;hardcore&quot; and gmsgvars.words[2] == &quot;mode&quot; and (gmsgvars.words[3] == &quot;on&quot; or gmsgvars.words[3] == &quot;enable&quot; or gmsgvars.words[3] == &quot;activate&quot;) then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The bot will not help you.[-]&quot;)		
		players[gmsgvars.playerid].silentBob = true
		faultyGMSG = false
		result = true
	end


	if players[gmsgvars.playerid].silentBob == true then
		result = true
		faultyGMSG = false
		return
	end
end

if debug then dbug(&quot;gmsg 11&quot;) end

if not result then
	if not result and debug then cecho(server.windowDebug, &quot;debug entering gmsg_mail\n&quot;) end
	result = gmsg_mail()
	if result and debug then cecho(server.windowDebug, &quot;debug ran command in gmsg_mail\n&quot;) end
end

if not result and (gmsgvars.playername ~= &quot;Server&quot;) then
	if players[gmsgvars.playerid].lastCommand ~= nil then
		-- don't allow /stuck being spammed
		if players[gmsgvars.playerid].lastCommand == gmsgvars.command then
			if (string.sub(gmsgvars.command, 1, 1) == &quot;/&quot;) then
				if math.abs(players[gmsgvars.playerid].lastCommandTimestamp - os.time()) &lt; 3 then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Please don't spam commands.[-]&quot;)
					faultyGMSG = false
					result = true			
					return
				end
			end
		end
	end
end

if debug then dbug(&quot;gmsg 12&quot;) end

if not result then
	if not result and debug then dbug(&quot;debug entering gmsg_admin&quot;) end
	result = gmsg_admin()
	if result and debug then dbug(&quot;debug ran command in gmsg_admin&quot;) end
end

if not result then
	if not result and debug then dbug(&quot;debug entering gmsg_friends&quot;) end
	result = gmsg_friends()
	if result and debug then dbug(&quot;debug ran command in gmsg_friends&quot;) end
end

if not result then
	if not result and debug then dbug(&quot;debug entering gmsg_hotspots&quot;) end
	result = gmsg_hotspots()
	if result and debug then dbug(&quot;debug ran command in gmsg_hotspots&quot;) end
end

if not result then
	if not result and debug then dbug(&quot;debug entering gmsg_trial_code&quot;) end
	result = gmsg_trial_code()
	if result and debug then dbug(&quot;debug ran command in gmsg_trial_code&quot;) end
end

if not result then
	if not result and debug then dbug(&quot;debug entering gmsg_resets&quot;) end
	result = gmsg_resets()
	if result and debug then dbug(&quot;debug ran command in gmsg_resets&quot;) end
end

if not result and server.allowShop then
	if not result and debug then dbug(&quot;debug entering gmsg_shop&quot;) end
	result = gmsg_shop()
	if result and debug then dbug(&quot;debug ran command in gmsg_shop&quot;) end
end

if not result then
	if not result and debug then dbug(&quot;debug entering gmsg_teleports&quot;) end
	result = gmsg_teleports()
	if result and debug then dbug(&quot;debug ran command in gmsg_teleports&quot;) end
end

if not result then
	if not result and debug then dbug(&quot;debug enterinfg gmsg_villages&quot;) end
	result = gmsg_villages()
	if result and debug then dbug(&quot;debug ran command in gmsg_villages&quot;) end
end

if not result and server.allowWaypoints then
	if not result and debug then dbug(&quot;debug entering gmsg_waypoints&quot;) end
	result = gmsg_waypoints()
	if result and debug then dbug(&quot;debug ran command in gmsg_waypoints&quot;) end
end

if not result then
	if not result and debug then dbug(&quot;debug entering gmsg_locations&quot;) end
	result = gmsg_locations()
	if result and debug then dbug(&quot;debug ran command in gmsg_locations&quot;) end
end

if not result then
	if not result and debug then dbug(&quot;debug entering gmsg_server&quot;) end
	result = gmsg_server()
	if result and debug then dbug(&quot;debug ran command in gmsg_server&quot;) end
end

if not result then
	if not result and debug then dbug(&quot;debug entering gmsg_tracker&quot;) end
	result = gmsg_tracker()
	if result and debug then dbug(&quot;debug ran command in gmsg_tracker&quot;) end
end

if not result then
	if not result and debug then dbug(&quot;debug entering gmsg_base&quot;) end
	result = gmsg_base()
	if result and debug then dbug(&quot;debug ran command in gmsg_base&quot;) end
end

if not result then
	if not result and debug then dbug(&quot;debug entering gmsg_bookmarks&quot;) end
	result = gmsg_bookmarks()
	if result and debug then dbug(&quot;debug ran command in gmsg_bookmarks&quot;) end
end

if not result then
	if not result and debug then dbug(&quot;debug entering gmsg_pms&quot;) end
	result = gmsg_pms()
	if result and debug then dbug(&quot;debug ran command in gmsg_pms&quot;) end
end

if not result and server.coppi then
	if not result and debug then dbug(&quot;debug entering gmsg_coppi&quot;) end
	result = gmsg_coppi()
	if result and debug then dbug(&quot;debug ran command in gmsg_coppi&quot;) end
end

if (string.sub(gmsgvars.command, 1, 1) == &quot;/&quot;) then
	players[gmsgvars.playerid].lastCommand = gmsgvars.command
	players[gmsgvars.playerid].lastCommandTimestamp = os.time()
end

-- ###################  do not allow remote commands beyond this point ################
if (gmsgvars.playerid == nil or result == true) then
	faultyGMSG = false
	return
end
-- ####################################################################################

if debug then dbug(&quot;gmsg 13&quot;) end

if (string.sub(gmsgvars.command, 1, 1) == &quot;/&quot;) and not result then  -- THIS COMMAND MUST BE LAST OR IT STOPS SLASH COMMANDS BELOW IT WORKING.
	pname = nil
   	pname = string.sub(gmsgvars.command, 2)
	pname = string.trim(pname)

	id = LookupPlayer(pname)

	if (players[gmsgvars.playerid].prisoner or not players[gmsgvars.playerid].canTeleport) then
		faultyGMSG = false
		result = true
		return
	end

	if (id ~= nil) then 
		-- reject if not an admin or a friend
		if (not isFriend(id,  gmsgvars.playerid)) and (accessLevel(gmsgvars.playerid) &gt; 2) and (id ~= gmsgvars.playerid) then --  and (id ~= gmsgvars.playerid)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Only friends of &quot; .. players[id].name .. &quot; and staff can do this.[-]&quot;)

			faultyGMSG = false
			result = true
			return
		end

		if (players[id].waypointX ~= 0 and players[id].waypointY ~= 0 and players[id].waypointZ ~= 0) and (players[id].shareWaypoint == true or accessLevel(gmsgvars.playerid) &lt; 3) then
			-- first record the current x y z
			players[gmsgvars.playerid].xPosOld = gmsgvars.intX
			players[gmsgvars.playerid].yPosOld = gmsgvars.intY
			players[gmsgvars.playerid].zPosOld = gmsgvars.intZ
			igplayers[gmsgvars.playerid].lastLocation = &quot;&quot;

			-- then teleport to the shared waypoint
			cmd = &quot;tele &quot; .. gmsgvars.playerid .. &quot; &quot; .. players[id].waypointX .. &quot; &quot; .. players[id].waypointY .. &quot; &quot; .. players[id].waypointZ
			prepareTeleport(gmsgvars.playerid, cmd)
			teleport(cmd)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have teleported to &quot; .. players[id].name .. &quot;'s waypoint.[-]&quot;)

			faultyGMSG = false
			result = true
			return
		else
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; does not have an open waypoint set.[-]&quot;)

			faultyGMSG = false
			result = true
			return
		end

		-- teleport to a friend if sufficient zennies
		if (players[gmsgvars.playerid].tokens &gt; 0) or accessLevel(gmsgvars.playerid) &lt; 3 then
			-- first record the current x y z
			players[gmsgvars.playerid].xPosOld = gmsgvars.intX
			players[gmsgvars.playerid].yPosOld = gmsgvars.intY
			players[gmsgvars.playerid].zPosOld = gmsgvars.intZ
			igplayers[gmsgvars.playerid].lastLocation = &quot;&quot;

			-- then teleport to the friend
			cmd = &quot;tele &quot; .. gmsgvars.playerid .. &quot; &quot; .. math.floor(players[id].xPos-1) .. &quot; &quot; .. math.ceil(players[id].yPos) .. &quot; &quot; .. math.floor(players[id].zPos)
			prepareTeleport(gmsgvars.playerid, cmd)
			teleport(cmd)

			if accessLevel(gmsgvars.playerid) &gt; 2 then
				players[gmsgvars.playerid].tokens = players[gmsgvars.playerid].tokens - 1
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have teleported to &quot; .. players[id].name .. &quot;'s location at a cost of 1 P2P token.[-]&quot;)
			else
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have teleported to &quot; .. players[id].name .. &quot;'s location.[-]&quot;)
			end

			faultyGMSG = false
			result = true
			return
		end
	end
end

if not result then
	if (string.sub(gmsgvars.command, 1, 1) == &quot;/&quot;) then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Unknown command: &quot; .. gmsgvars.command .. &quot; Type /help or /commands for commands.[-]&quot;)
	else
		Translate(gmsgvars.playerid, gmsgvars.command, &quot;&quot;)
	end
end


faultyGMSG = false

if debug then dbug(&quot;gmsg end&quot;) end</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>GMSG:</string>
                <string>INF Executing command 'pm </string>
                <string>INF Denying command 'pm</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
                <integer>0</integer>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Player Login</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

local name, id

name = string.sub(line, string.find(line, &quot;Login:&quot;) + 7, string.find(line, &quot;/Alpha&quot;) - 1)

display(&quot;player connecting: &quot; .. name)

id = LookupPlayer(name)

--[[
if server.ServerMaxPlayerCountOld ~= nil then
	if tonumber(playersOnline) &gt;= tonumber(server.ServerMaxPlayerCountOld) and tonumber(server.ServerMaxPlayerCountOld) &gt; 0 and accessLevel(id) &gt; 0 then
		send(&quot;kick &quot; .. id .. &quot; Server is full. The last slot is reserved.&quot;)
		return
	end
end
--]]

--[[
if accessLevel(id) == 0 and tonumber(playersOnline) &gt;= tonumber(server.ServerMaxPlayerCount) then
	server.ServerMaxPlayerCountOld = server.ServerMaxPlayerCount
	send(&quot;sg ServerMaxPlayerCount &quot; .. server.ServerMaxPlayerCount + 1)
	dbug(&quot;sg ServerMaxPlayerCount &quot; .. server.ServerMaxPlayerCount + 1)
else
	server.ServerMaxPlayerCountOld = nil
end
--]]</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>INF PlayerLogin</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>log chat</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

if not (string.find(line, &quot; command 'pm&quot;) and string.find(line, &quot;' from client&quot;)) then
	-- log the chat
-- EDIT ME!
	file = io.open(&quot;/var/www/webdav/chatlogs/7days/&quot; .. os.date(&quot;%Y%m%d&quot;) .. &quot;_chatlog.txt&quot;, &quot;a&quot;)
	file:write(line .. &quot;\n&quot;)
	file:close()
end</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>GMSG:</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
    </TriggerPackage>
    <TimerPackage>
        <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
            <name>EveryHalfMinute</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see http://www.gnu.org/licenses
--]]

if botDisabled then
	return
end

cecho (server.windowDebug, &quot;30 second timer\n&quot;)

if (AnnounceBot == true) then
	message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. server.botName .. &quot; is online. Command me. :3[-]&quot;)
	AnnounceBot = false
end

math.randomseed( os.time() )

if (initError == true) then
	message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. server.botName .. &quot; encountered a problem starting up.  Attempting automatic fix..[-]&quot;)
	gatherServerData()
	initError = false
	AnnounceBot = true
end

send(&quot;gt&quot;)

newDay()

-- scan player inventories
for k, v in pairs(igplayers) do
	if (igplayers[k].killTimer == nil) then igplayers[k].killTimer = 9 end

	if tonumber(igplayers[k].killTimer) &lt; 2 then
		cmd = &quot;si &quot; .. k
		conn:execute(&quot;INSERT into commandQueue (command, steam) VALUES ('&quot; .. cmd .. &quot;',&quot; .. k .. &quot;)&quot;)					
	end

	-- kick player if currently banned or permabanned
--	if players[k].permanentBan == true then
--		send(&quot;kick &quot; .. k)
--	end

--	cursor,errorString = conn:execute(&quot;SELECT * FROM bans WHERE steam = &quot; .. k .. &quot; and expirydate &gt; &quot; .. os.date(&quot;%Y-%m-%d %H:%M:%S&quot;))
--	if cursor:numrows() &gt; 0 then
--		send(&quot;kick &quot; .. k)
--	end
end

cmd = &quot;DoneInventory&quot;
conn:execute(&quot;INSERT into commandQueue (command) VALUES ('&quot; .. cmd .. &quot;')&quot;)					

-- logout anyone on irc who hasn't typed anything and their session has expired
for k,v in pairs(players) do
	if v.ircAuthenticated == true then
		if v.ircSessionExpiry == nil then 
			v.ircAuthenticated = false
		else
			if (v.ircSessionExpiry - os.time()) &lt; 0 then
				v.ircAuthenticated = false
			end	
		end
	end
end


</script>
            <command></command>
            <packageName></packageName>
            <time>00:00:30.000</time>
        </Timer>
        <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
            <name>OneMinuteTimer</name>
            <script>if botDisabled then
	return
end

OneMinuteTimer()

if tablelength(players) == 0 then
	gatherServerData()
	return
end

if server.coppi then
	for k, v in pairs(igplayers) do
		if players[k].autoFriend ~= &quot;NA&quot; then
			send(&quot;lpf &quot; .. k)
		end
	end
end

if not botDisabled then
	writeBotTick()
end</script>
            <command></command>
            <packageName></packageName>
            <time>00:01:00.000</time>
        </Timer>
        <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
            <name>listPlayers</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end


function listPlayers()
	if finalCountdown == nil then
		finalCountdown = false
	end

	send(&quot;lp&quot;)

--[[
	if (faultyPlayerinfo == true) then
		cecho(server.windowDebug, &quot;!! Fault detected in playerinfo trigger\n&quot;)
		cecho(server.windowDebug, faultyPlayerinfoLine .. &quot;\n&quot;)
		cecho(server.windowAlerts, &quot;!! Fault detected in playerinfo trigger\n&quot;)
		cecho(server.windowAlerts, faultyPlayerinfoLine .. &quot;\n&quot;)
		fixMissingPlayer(faultyPlayerinfoID)
		if igplayers[faultyPlayerinfoID] then
			fixMissingIGPlayer(faultyPlayerinfoID)	
		end
		faultyPlayerinfo = false
	end
--]]

	-- delay reboot up to 1.5 days if server busy
	if (tonumber(playersOnline) &gt; 6) and (server.scheduledRestartTimestamp - os.time() &gt; 0) and (math.floor(server.uptime / 3600) &lt; 36) then
		return
	end

	if (server.scheduledRestart == true and scheduledRestartPaused == false) and server.allowReboot == true then
		if (server.scheduledRestartTimestamp - os.time() &lt; 0) then
			server.scheduledRestart = false
			startReboot()
		else
			if (server.scheduledRestartTimestamp - os.time() &gt; 11) and (server.scheduledRestartTimestamp - os.time() &lt; 61) then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]REBOOTING IN &quot; .. server.scheduledRestartTimestamp - os.time() .. &quot; SECONDS[-]&quot;)
				finalCountdown = false
			end

			if (server.scheduledRestartTimestamp - os.time() &lt; 12) and not finalCountdown then
				finalCountdown = true

				tempTimer( 1, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]10[-]&quot;)]] )
				tempTimer( 2, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]9[-]&quot;)]] )
				tempTimer( 3, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]8[-]&quot;)]] )
				tempTimer( 4, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]7[-]&quot;)]] )
				tempTimer( 5, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]6[-]&quot;)]] )
				tempTimer( 6, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]5[-]&quot;)]] )
				tempTimer( 7, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]4[-]&quot;)]] )
				tempTimer( 8, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]3[-]&quot;)]] )
				tempTimer( 9, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]2[-]&quot;)]] )
				tempTimer( 10, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]1[-]&quot;)]] )
				tempTimer( 11, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]Rebooting..[-]&quot;)]] )
			end
		end
	end
end


listPlayers()</script>
            <command></command>
            <packageName></packageName>
            <time>00:00:03.000</time>
        </Timer>
        <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
            <name>OneHourTimer</name>
            <script>if botDisabled then
	return
end

OneHourTimer()
dailyMaintenance()

-- fix any problems with player records
for k,v in pairs(players) do
	fixMissingPlayer(k)
end
</script>
            <command></command>
            <packageName></packageName>
            <time>01:00:00.000</time>
        </Timer>
        <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
            <name>Reconnect</name>
            <script>if botDisabled then
	return
end

botOffline = tonumber(botOffline) - 1

if tonumber(botOffline) &lt; 1 then
	dbug(&quot;Bot is offline - attempting reconnection.&quot;)
	botOffline = 2
	reconnect()
end

</script>
            <command></command>
            <packageName></packageName>
            <time>00:00:20.000</time>
        </Timer>
        <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
            <name>GimmeReset</name>
            <script>if botDisabled then
	return
end

gimmeReset()</script>
            <command></command>
            <packageName></packageName>
            <time>02:00:00.000</time>
        </Timer>
        <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
            <name>TimedCommands</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

cursor,errorString = conn:execute(&quot;select * from commandQueue order by id limit 0,1&quot;)
row = cursor:fetch({}, &quot;a&quot;)

if row then
	cecho(server.windowDebug, &quot;running timed command (&quot; .. row.id .. &quot;) &quot; .. row.command .. &quot;\n&quot;)

	if (row.command ~= &quot;DoneInventory&quot;) then

		if igplayers[row.steam] == nil then
			conn:execute(&quot;delete from commandQueue where steam = &quot; .. row.steam)
			return
		end

		send(row.command)	
		conn:execute(&quot;delete from commandQueue where id = &quot; .. row.id)
	else
		conn:execute(&quot;delete from commandQueue where id = &quot; .. row.id)
		CheckInventory()
		tempTimer( 2, [[CheckClaimsRemoved()]] )
	end
end</script>
            <command></command>
            <packageName></packageName>
            <time>00:00:01.000</time>
        </Timer>
        <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
            <name>ThirtyMinuteTimer</name>
            <script>if botDisabled then
	return
end

ThirtyMinuteTimer()</script>
            <command></command>
            <packageName></packageName>
            <time>00:30:00.000</time>
        </Timer>
        <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
            <name>PlayerQueuedCommands</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

cursor,errorString = conn:execute(&quot;select * from playerQueue order by id limit 0,1&quot;)
row = cursor:fetch({}, &quot;a&quot;)

if row then
	if row.boss == true then
		for k, v in pairs(igplayers) do
			if distancexz(igplayers[k].xPos, igplayers[k].zPos, locations[&quot;arena&quot;].x, locations[&quot;arena&quot;].z) then
				for a, b in pairs(arenaPlayers) do
					message(&quot;pm &quot; .. players[b.id].id .. &quot; [&quot; .. server.chatColour .. &quot;]Here comes the BOSS!&quot;)
				end

				cecho(server.windowDebug, &quot;running player queued command &quot; .. row.command .. &quot;\n&quot;)
				send(row.command)	
				conn:execute(&quot;delete from playerQueue where id = &quot; .. row.id)
				return
			end
		end

		return	
	end

	if tonumber(row.steam) &gt; 0 and (not igplayers[row.steam]) then
		-- destroy the command without sending it
		cecho(server.windowDebug, &quot;destroying player queued command &quot; .. row.command .. &quot;\n&quot;)
		conn:execute(&quot;delete from playerQueue where id = &quot; .. row.id)
		return
	end

	if tonumber(row.steam) == 0 then
		if (string.sub(row.command, 1, 2) ~= &quot;se&quot;) and (string.sub(row.command, 1, 3) ~= &quot;say&quot;) and (string.sub(row.command, 1, 2) ~= &quot;pm&quot;) then
			send(row.command)	
		else
			 message(row.command)	
		end

		conn:execute(&quot;delete from playerQueue where id = &quot; .. row.id)
		return
	end

	if (distance (igplayers[row.steam].xPos, igplayers[row.steam].zPos, locations[&quot;arena&quot;].x, locations[&quot;arena&quot;].z ) &gt; locations[&quot;arena&quot;].size + 1 or igplayers[row.steam].deadX ~= nil) then
		-- destroy the command without sending it
		cecho(server.windowDebug, &quot;destroying player queued command &quot; .. row.command .. &quot;\n&quot;)
		conn:execute(&quot;delete from playerQueue where id = &quot; .. row.id)
		return
	else
		if (tonumber(row.steam) &gt; 0) then
			if (igplayers[row.steam].deadX == nil) then
				cecho(server.windowDebug, &quot;running player queued command &quot; .. row.command .. &quot;\n&quot;)

				if string.sub(row.command, 1, 2) == &quot;se&quot; then
					send(row.command)	
				else
					 message(row.command)	
				end

				conn:execute(&quot;delete from playerQueue where id = &quot; .. row.id)
				return
			end
		else
			cecho(server.windowDebug, &quot;running player queued command &quot; .. row.command .. &quot;\n&quot;)

			if string.sub(row.command, 1, 2) == &quot;se&quot; then
				send(row.command)	
			else
				 message(row.command)	
			end

			conn:execute(&quot;delete from playerQueue where id = &quot; .. row.id)
			return
		end
	end

	conn:execute(&quot;delete from playerQueue where id = &quot; .. row.id)
end</script>
            <command></command>
            <packageName></packageName>
            <time>00:00:03.000</time>
        </Timer>
        <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
            <name>GimmeQueuedCommands</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

local pid, dist1, dist2

cursor1,errorString = conn:execute(&quot;select distinct steam from gimmeQueue&quot;)
row1 = cursor1:fetch({}, &quot;a&quot;)

while row1 do
	cursor2,errorString = conn:execute(&quot;select * from gimmeQueue where steam = &quot; .. row1.steam .. &quot; order by id limit 0,1&quot;)
	row2 = cursor2:fetch({}, &quot;a&quot;)

	if row2 then
		send(row2.command)
		conn:execute(&quot;delete from gimmeQueue where id = &quot; .. row2.id)
	end

	row1 = cursor1:fetch(row1, &quot;a&quot;)
end</script>
            <command></command>
            <packageName></packageName>
            <time>00:00:00.500</time>
        </Timer>
        <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
            <name>ircQueue</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

cursor1,errorString = conn:execute(&quot;select distinct name from ircQueue&quot;)
row1 = cursor1:fetch({}, &quot;a&quot;)

while row1 do
	cursor2,errorString = conn:execute(&quot;select * from ircQueue where name = '&quot; .. escape(row1.name) .. &quot;' order by id limit 0,1&quot;)
	row2 = cursor2:fetch({}, &quot;a&quot;)

	if row2 then
		sendIrc(row2.name, row2.command)
		conn:execute(&quot;delete from ircQueue where id = &quot; .. row2.id)
	end

	row1 = cursor1:fetch(row1, &quot;a&quot;)
end</script>
            <command></command>
            <packageName></packageName>
            <time>00:00:00.300</time>
        </Timer>
        <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
            <name>Every45Seconds</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

local k, v, x, z, row, cursor, errorString

conn:execute(&quot;UPDATE keystones SET removed = 1&quot;)

for k, v in pairs(igplayers) do
	if v.claimPass == nil then v.claimPass = 1 end

	if accessLevel(k) &gt; 2 then
		cursor,errorString = conn:execute(&quot;SELECT count(remove) as deleted FROM keystones WHERE steam = &quot; .. k .. &quot; AND remove = 2&quot;)
		row = cursor:fetch({}, &quot;a&quot;)

		if tonumber(row.deleted) &gt; 0 then
			players[k].removedClaims = players[k].removedClaims + tonumber(row.deleted)
			players[k].alertRemovedClaims = true
			conn:execute(&quot;DELETE FROM keystones WHERE steam = &quot; .. k .. &quot; AND remove = 2&quot;)
		end

		if v.claimPass == 1 then
			x = math.floor(v.xPos / 512)
			z = math.floor(v.zPos / 512)
			checkRegionClaims(x, z)

			v.claimPass = 2
		else
			send(&quot;llp &quot; .. k)
			v.claimPass = 1
		end
	end
end</script>
            <command></command>
            <packageName></packageName>
            <time>00:00:45.000</time>
        </Timer>
        <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
            <name>TrackPlayer</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

local lastSession, rows

for k, v in pairs(igplayers) do	
	lastSession = false

	if v.trackerCount ~= nil then
		if v.trackerStopped == false then
			v.trackerCountdown = tonumber(v.trackerCountdown) - 1

			if (v.trackerCountdown &lt; 1) then
				v.trackerCountdown = v.trackerSpeed

				if v.trackerReversed then
					cursor,errorString = conn:execute(&quot;select * from memTracker where admin = &quot; .. k .. &quot; and trackerID &lt; &quot; .. v.trackerCount .. &quot; order by trackerID desc limit 0,&quot; .. v.trackerSkip + 1)
				else
					cursor,errorString = conn:execute(&quot;select * from memTracker where admin = &quot; .. k .. &quot; and trackerID &gt; &quot; .. v.trackerCount .. &quot; order by trackerID limit 0,&quot; .. v.trackerSkip + 1)
				end

				rows = cursor:numrows()

				if rows &gt; 0 then
					row = cursor:fetch({}, &quot;a&quot;)

					if tonumber(row.session) == tonumber(players[row.steam].sessionCount) then lastSession = true end

					send(&quot;tele &quot; .. k .. &quot; &quot; .. row.x .. &quot; &quot; .. row.y .. &quot; &quot; .. row.z)

					if rows == 1 then
						v.trackerStopped = true

						if lastSession then
							message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]Tracking complete. You have reached the players current position.[-]&quot;)
						else
							message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]Tracking complete. Type /next track or /last track to continue from the next session.[-]&quot;)
						end
					end

					while row do
						row = cursor:fetch(row, &quot;a&quot;)	

						if row.trackerID == nil then
							v.trackerStopped = true

							if lastSession then
								message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]Tracking complete. You have reached the players current position.[-]&quot;)
							else
								message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]Tracking complete. Type /next track or /last track to continue from the next session.[-]&quot;)
							end
						end

						v.trackerCount = row.trackerID
					end

					if v.trackerStop ~= nil then
						v.trackerStopped = true
						v.trackerStop = nil
					end
				else
					v.trackerStopped = true

					if lastSession then
						message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]Tracking complete. You have reached the players current position.[-]&quot;)
					else
						message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]Tracking complete. Type /next track or /last track to continue from the next session.[-]&quot;)
					end
				end
			end
		end
	end
end</script>
            <command></command>
            <packageName></packageName>
            <time>00:00:01.000</time>
        </Timer>
        <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
            <name>messageQueue</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

cursor,errorString = conn:execute(&quot;select * from messageQueue where recipient = 0 order by id limit 0,1&quot;)
row = cursor:fetch({}, &quot;a&quot;)

if row then
	message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. row.message .. &quot;[-]&quot;)
	conn:execute(&quot;delete from messageQueue where id = &quot; .. row.id)
end


for k,v in pairs(igplayers) do
	cursor,errorString = conn:execute(&quot;select * from messageQueue where recipient = &quot; .. k .. &quot; order by id limit 0,1&quot;)
	row = cursor:fetch({}, &quot;a&quot;)

	if row then
		if tonumber(row.recipient) ~= 0 then
			if tonumber(row.sender) ~= 0 then
				message(&quot;pm &quot; .. row.recipient .. &quot; [&quot; .. server.chatColour .. &quot;]Message from &quot; .. players[row.sender].name .. &quot; &quot; .. row.message .. &quot;[-]&quot;)
			else
				message(&quot;pm &quot; .. row.recipient .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. row.message .. &quot;[-]&quot;)
			end
		else
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. row.message .. &quot;[-]&quot;)
		end

		conn:execute(&quot;delete from messageQueue where id = &quot; .. row.id)
	end
end</script>
            <command></command>
            <packageName></packageName>
            <time>00:00:02.000</time>
        </Timer>
        <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
            <name>TwoMinuteTimer</name>
            <script></script>
            <command></command>
            <packageName></packageName>
            <time>00:02:00.000</time>
        </Timer>
    </TimerPackage>
    <AliasPackage/>
    <ActionPackage>
        <ActionGroup isActive="yes" isFolder="yes" isPushButton="no" isFlatButton="yes" useCustomLayout="no">
            <name>menu</name>
            <packageName></packageName>
            <script></script>
            <css></css>
            <commandButtonUp></commandButtonUp>
            <commandButtonDown></commandButtonDown>
            <icon></icon>
            <orientation>1</orientation>
            <location>3</location>
            <posX>0</posX>
            <posY>0</posY>
            <mButtonState>1</mButtonState>
            <sizeX>79508376</sizeX>
            <sizeY>0</sizeY>
            <buttonColumn>1</buttonColumn>
            <buttonRotation>1</buttonRotation>
            <buttonColor>#ffffff</buttonColor>
            <Action isActive="yes" isFolder="no" isPushButton="no" isFlatButton="no" useCustomLayout="no">
                <name>Show Players</name>
                <packageName></packageName>
                <script>clearUserWindow(server.windowPlayers)
showPlayers = true
</script>
                <css></css>
                <commandButtonUp></commandButtonUp>
                <commandButtonDown></commandButtonDown>
                <icon></icon>
                <orientation>1</orientation>
                <location>0</location>
                <posX>0</posX>
                <posY>0</posY>
                <mButtonState>2</mButtonState>
                <sizeX>0</sizeX>
                <sizeY>0</sizeY>
                <buttonColumn>1</buttonColumn>
                <buttonRotation>0</buttonRotation>
                <buttonColor>#ffffff</buttonColor>
            </Action>
            <Action isActive="yes" isFolder="no" isPushButton="no" isFlatButton="yes" useCustomLayout="no">
                <name>CLR Debug</name>
                <packageName></packageName>
                <script>clearUserWindow(server.windowDebug)</script>
                <css></css>
                <commandButtonUp></commandButtonUp>
                <commandButtonDown></commandButtonDown>
                <icon></icon>
                <orientation>1</orientation>
                <location>0</location>
                <posX>0</posX>
                <posY>0</posY>
                <mButtonState>1</mButtonState>
                <sizeX>3145776</sizeX>
                <sizeY>3145776</sizeY>
                <buttonColumn>1</buttonColumn>
                <buttonRotation>-1</buttonRotation>
                <buttonColor>#ffffff</buttonColor>
            </Action>
            <Action isActive="yes" isFolder="no" isPushButton="no" isFlatButton="yes" useCustomLayout="no">
                <name>CLR Lists</name>
                <packageName></packageName>
                <script>clearUserWindow(server.windowLists)</script>
                <css></css>
                <commandButtonUp></commandButtonUp>
                <commandButtonDown></commandButtonDown>
                <icon></icon>
                <orientation>1</orientation>
                <location>0</location>
                <posX>0</posX>
                <posY>0</posY>
                <mButtonState>2</mButtonState>
                <sizeX>75</sizeX>
                <sizeY>41</sizeY>
                <buttonColumn>1</buttonColumn>
                <buttonRotation>0</buttonRotation>
                <buttonColor>#ffffff</buttonColor>
            </Action>
            <Action isActive="yes" isFolder="no" isPushButton="no" isFlatButton="yes" useCustomLayout="no">
                <name>Show Tables</name>
                <packageName></packageName>
                <script>--display(serverFields)
--display(playerFields)

--echo(&quot;Players table\n&quot;)
--display( players )

--echo(&quot;In-game Players table\n&quot;)
--display( igplayers )



--echo(&quot;Admins table\n&quot;)
--display( admins )

--echo(&quot;Friends table\n&quot;)
--display( friends )

--echo(&quot;Teleports table\n&quot;)
--display( teleports )

--echo(&quot;Locations table\n&quot;)
--display( locations )

--echo(&quot;Server table\n&quot;)
--display( server )

--echo(&quot;gmsgvars table\n&quot;)
--display( gmsgvars )

--echo(&quot;Timed Commands table\n&quot;)
--display( timedCommands )

--hotspots={}
--echo(&quot;Hotspots table\n&quot;)
--display( hotspots )

--echo(&quot;badItems table\n&quot;)
--display( badItems )

--echo(&quot;playerQueuedCommands table\n&quot;)
--display( playerQueuedCommands )

--echo(&quot;ArenaPlayers table\n&quot;)
--display( arenaPlayers )

--echo(&quot;Inventory table\n&quot;)
--display( inventory )
--display( invTemp )

--echo(&quot;resetRegions table\n&quot;)
--display( resetRegions )

--echo(&quot;gimmeQueuedCommands table\n&quot;)
--display( gimmeQueuedCommands )

--echo(&quot;lastHotspots table\n&quot;)
--display( lastHotspots )

--echo(&quot;Owners table\n&quot;)
--display( owners )

--echo(&quot;Villagers table\n&quot;)
--display( villagers )

--echo(&quot;restrictedItems table\n&quot;)
--display( restrictedItems )

--stackLimits={}
--display(stackLimits)

--echo(&quot;shop categories table\n&quot;)
--display( shopCategories )

--display(customCommands)</script>
                <css></css>
                <commandButtonUp></commandButtonUp>
                <commandButtonDown></commandButtonDown>
                <icon></icon>
                <orientation>1</orientation>
                <location>0</location>
                <posX>0</posX>
                <posY>0</posY>
                <mButtonState>2</mButtonState>
                <sizeX>1756547332</sizeX>
                <sizeY>59476856</sizeY>
                <buttonColumn>1</buttonColumn>
                <buttonRotation>0</buttonRotation>
                <buttonColor>#ffffff</buttonColor>
            </Action>
            <Action isActive="yes" isFolder="no" isPushButton="no" isFlatButton="yes" useCustomLayout="no">
                <name>Test Code</name>
                <packageName></packageName>
                <script></script>
                <css></css>
                <commandButtonUp></commandButtonUp>
                <commandButtonDown></commandButtonDown>
                <icon></icon>
                <orientation>1</orientation>
                <location>0</location>
                <posX>0</posX>
                <posY>0</posY>
                <mButtonState>1</mButtonState>
                <sizeX>1631854633</sizeX>
                <sizeY>808533369</sizeY>
                <buttonColumn>1</buttonColumn>
                <buttonRotation>-1</buttonRotation>
                <buttonColor>#ffffff</buttonColor>
            </Action>
            <Action isActive="yes" isFolder="no" isPushButton="no" isFlatButton="yes" useCustomLayout="no">
                <name>temp test</name>
                <packageName></packageName>
                <script></script>
                <css></css>
                <commandButtonUp></commandButtonUp>
                <commandButtonDown></commandButtonDown>
                <icon></icon>
                <orientation>1</orientation>
                <location>0</location>
                <posX>0</posX>
                <posY>0</posY>
                <mButtonState>1</mButtonState>
                <sizeX>2097272</sizeX>
                <sizeY>6881382</sizeY>
                <buttonColumn>1</buttonColumn>
                <buttonRotation>-1</buttonRotation>
                <buttonColor>#ffffff</buttonColor>
            </Action>
            <Action isActive="yes" isFolder="no" isPushButton="no" isFlatButton="yes" useCustomLayout="no">
                <name>CLR Alerts</name>
                <packageName></packageName>
                <script>clearUserWindow(server.windowAlerts)</script>
                <css></css>
                <commandButtonUp></commandButtonUp>
                <commandButtonDown></commandButtonDown>
                <icon></icon>
                <orientation>1</orientation>
                <location>0</location>
                <posX>0</posX>
                <posY>0</posY>
                <mButtonState>2</mButtonState>
                <sizeX>7340147</sizeX>
                <sizeY>352329872</sizeY>
                <buttonColumn>1</buttonColumn>
                <buttonRotation>-1</buttonRotation>
                <buttonColor>#ffffff</buttonColor>
            </Action>
            <Action isActive="no" isFolder="no" isPushButton="no" isFlatButton="yes" useCustomLayout="no">
                <name>Load IP Blacklist</name>
                <packageName></packageName>
                <script>--readIPBlacklist()</script>
                <css></css>
                <commandButtonUp></commandButtonUp>
                <commandButtonDown></commandButtonDown>
                <icon></icon>
                <orientation>1</orientation>
                <location>0</location>
                <posX>0</posX>
                <posY>0</posY>
                <mButtonState>1</mButtonState>
                <sizeX>295772544</sizeX>
                <sizeY>0</sizeY>
                <buttonColumn>1</buttonColumn>
                <buttonRotation>0</buttonRotation>
                <buttonColor>#ffffff</buttonColor>
            </Action>
        </ActionGroup>
    </ActionPackage>
    <ScriptPackage>
        <Script isActive="yes" isFolder="no">
            <name>Functions</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see http://www.gnu.org/licenses
--]]

function calcTimestamp(str)
	-- takes input like 1 week, 1 month, 1 year and outputs a timestamp that much in the future
	local number, period

	str = string.lower(str)
	number = math.abs(math.floor(tonumber(string.match(str, &quot;(-?%d+)&quot;))))

	if string.find(str, &quot;day&quot;) then
		period = 60 * 60 * 24
	end

	if string.find(str, &quot;week&quot;) then
		period = 60 * 60 * 24 * 7
	end

	if string.find(str, &quot;month&quot;) then
		period = 60 * 60 * 24 * 30
	end

	if string.find(str, &quot;year&quot;) then
		period = 60 * 60 * 24 * 365
	end

	if number == nil or period == nil then 
		return os.time()
	else
		return os.time() + period * number
	end
end


function dbug(text)
	-- send text to the debug window we created in Mudlet.
	cecho(server.windowLists, text .. &quot;\n&quot;)
end


function countAlphaNumeric(test)
	-- return the number of alphanumeric characters in test

	local _, count = string.gsub(test, &quot;%w&quot;, &quot;&quot;)
	return count
end


function isFile(name)
    if type(name)~=&quot;string&quot; then return false end
    if not isDir(name) then
        return os.rename(name,name) and true or false
        -- note that the short evaluation is to
        -- return false instead of a possible nil
    end
    return false
end


function isFileOrDir(name)
    if type(name)~=&quot;string&quot; then return false end
    return os.rename(name, name) and true or false
end


function isDir(name)
    if type(name)~=&quot;string&quot; then return false end
    local cd = lfs.currentdir()
    local is = lfs.chdir(name) and true or false
    lfs.chdir(cd)
    return is
end


function pmsg(msg, all)
	-- queue msg for output by a timer
	for k,v in pairs(igplayers) do
		if all ~= nil or players[k].noSpam == false then
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,&quot; .. k .. &quot;,'&quot; .. escape(msg) .. &quot;)&quot;)
		end
	end
end


function strDateToTimestamp(strdate)
	-- Unix timestamps end in 2038.  To prevent invalid dates, we will force year to 2030 if it is later.
	local sday, smonth, syear, shour, sminute, sseconds = strdate:match(&quot;(%d+)/(%d+)/(%d+) (%d+):(%d+):(%d+)&quot;)

	-- don't allow dates over 2030.  timestamps stop at 2038
	if tonumber(syear) &gt; 2030 then syear = 2030 end

	return os.time({year = syear, month = smonth, day = sday, hour = shour, min = sminute, sec = sseconds})
end


function inInventory(steam, item, quantity, slot)
	-- search the most recent inventory recording for an item
	local tbl, test, i

	cursor,errorString = conn:execute(&quot;SELECT * FROM inventoryTracker WHERE steam = &quot; .. steam ..&quot;  ORDER BY inventoryTrackerID DESC Limit 0, 1&quot;)
	row = cursor:fetch({}, &quot;a&quot;)

	tbl = string.split(row.belt, &quot;|&quot;)

	for i=1, table.maxn(tbl) - 1, 1 do
		test = string.split(tbl[i], &quot;,&quot;)
		if slot ~= nil then
			if tonumber(test[2]) &gt;= tonumber(quantity) and test[3] == item and tonumber(test[1]) == slot then
				return true
			end
		else
			if tonumber(test[2]) &gt;= tonumber(quantity) and test[3] == item then
				return true
			end
		end
	end

	return false
end


function mapPosition(steam)
	-- express the player's coordinates as a compass bearing
	local ns, ew

	if tonumber(players[steam].xPos) &lt; 0 then
		ew = math.abs(math.floor(players[steam].xPos)).. &quot; W&quot;
	else
		ew = math.floor(players[steam].xPos) .. &quot; E&quot;
	end

	if tonumber(players[steam].zPos) &lt; 0 then
		ns = math.abs(math.floor(players[steam].zPos)) .. &quot; S&quot;
	else
		ns = math.floor(players[steam].zPos) .. &quot; N&quot;
	end

	return ns .. &quot; &quot; .. ew
end


function validPosition(steam, alert)
	-- check that y position is between bedrock and the max build height
	if tonumber(players[steam].yPos) &gt; -1 and tonumber(players[steam].yPos) &lt; 256 then
		return true
	else
		if alert ~= nil then
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You cannot do that here. If you recently teleported, wait a bit then try again.[-]&quot;)
		end

		return false
	end
end


function savePosition(steam)
	-- helper function to save the players position
	if tonumber(players[steam].yPos) &gt; -1 and tonumber(players[steam].yPos) &lt; 256 then
		-- store the player's current x y z
		players[steam].xPosOld = math.floor(players[steam].xPos)
		players[steam].yPosOld = math.ceil(players[steam].yPos)
		players[steam].zPosOld = math.floor(players[steam].zPos)
	end
end


function seen(steam)
	-- when was a player last seen ingame?
	local words, word, diff, ryear, rmonth, rday, rhour, rmin, rsec
	local dateNow, Now, dateSeen, Seen, days, hours, minutes

	if players[steam].seen == &quot;&quot; then
		return &quot;A new player on for the first time now.&quot;
	end

	words = {}
	for word in serverTime:gmatch(&quot;%w+&quot;) do table.insert(words, word) end

	ryear = words[1]
	rmonth = words[2]
	rday = string.sub(words[3], 1, 2)
	rhour = string.sub(words[3], 4, 5)
	rmin = words[4]
	rsec = words[5]

	dateNow = {year=ryear, month=rmonth, day=rday, hour=rhour, min=rmin, sec=rsec}
	Now = os.time(dateNow)

	words = {}
	for word in players[steam].seen:gmatch(&quot;%w+&quot;) do table.insert(words, word) end

	ryear = words[1]
	rmonth = words[2]
	rday = string.sub(words[3], 1, 2)
	rhour = string.sub(words[3], 4, 5)
	rmin = words[4]
	rsec = words[5]

	dateSeen = {year=ryear, month=rmonth, day=rday, hour=rhour, min=rmin, sec=rsec}
	Seen = os.time(dateSeen)

	diff = os.difftime(Now, Seen)
	days = math.floor(diff / 86400)

	if (days &gt; 0) then
		diff = diff - (days * 86400)
	end

	hours = math.floor(diff / 3600)

	if (hours &gt; 0) then
		diff = diff - (hours * 3600)
	end

	minutes = math.floor(diff / 60)

	return players[steam].name .. &quot; was last seen &quot; .. days .. &quot; days &quot; .. hours .. &quot; hours &quot; .. minutes ..&quot; minutes ago&quot;
end


function LookupHotspot(x,y,z)
	-- return the closest hotspot that these coords are inside
	local size, k, v

	for k, v in pairs(hotspots) do
		if (v.radius ~= nil) then 
			size = v.radius 
		else
			size = 3 
		end

		if distancexyz(x, y, z, v.x, v.y, v.z) &lt;= tonumber(size) then
			return k
		end
	end
end


function messageAdmins(message)
	-- helper function to send a message to all staff
	local k,v

	for k, v in pairs(players) do
		if (accessLevel(k) &lt; 3) then
			if igplayers[k] then
				message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. message .. &quot;[-]&quot;)
			else
				conn:execute(&quot;INSERT INTO mail (sender, recipient, message) VALUES (0,&quot; .. k .. &quot;, '&quot; .. escape(message) .. &quot;')&quot;)
			end
		end
	end
end


function kick(steam, reason)
	local tmp

	tmp = steam
	-- if there is no player with steamid steam, try looking it up incase we got their name instead of their steam
	if not players[steam] then
		steam = LookupPlayer(string.trim(steam))
		-- restore the original steam value if nothing matched as we may be banning someone who's never played here.
		if steam == nil then steam = tmp end
	end

	if igplayers[steam] then
		conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. math.floor(players[steam].xPos) .. &quot;,&quot; .. math.ceil(players[steam].yPos) .. &quot;,&quot; .. math.floor(players[steam].zPos) .. &quot;,'&quot; .. serverTime .. &quot;','kick','Player &quot; .. steam .. &quot; &quot; .. escape(players[steam].name) .. &quot; kicked for &quot; .. escape(reason) .. &quot;',&quot; .. steam .. &quot;)&quot;)
		send(&quot;kick &quot; .. steam .. &quot; &quot; .. &quot; \&quot;&quot; .. reason .. &quot;\&quot;&quot;)
	end
end


function banPlayer(steam, duration, reason)
	local tmp

	tmp = steam
	-- if there is no player with steamid steam, try looking it up incase we got their name instead of their steam
	if not players[steam] then
		steam = LookupPlayer(string.trim(steam))
		-- restore the original steam value if nothing matched as we may be banning someone who's never played here.
		if steam == nil then steam = tmp end
	end

	if players[steam] then
		-- also send them to timeout so they can't do anything if they manage to return
		players[steam].timeout = true
		conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. math.floor(players[steam].xPos) .. &quot;,&quot; .. math.ceil(players[steam].yPos) .. &quot;,&quot; .. math.floor(players[steam].zPos) .. &quot;,'&quot; .. serverTime .. &quot;','ban','Player &quot; .. steam .. &quot; &quot; .. escape(players[steam].name) .. &quot; has has been banned for &quot; .. duration .. &quot; for &quot; .. escape(reason) .. &quot;',&quot; .. steam .. &quot;)&quot;)
		irc_QueueMsg(server.ircMain, &quot;[BANNED] Player &quot; .. steam .. &quot; &quot; .. players[steam].name .. &quot; has been banned for &quot; .. duration .. &quot; &quot; .. reason)
		irc_QueueMsg(server.ircAlerts, &quot;[BANNED] Player &quot; .. steam .. &quot; &quot; .. players[steam].name .. &quot; has been banned for &quot; .. duration .. &quot; &quot; .. reason)
	else
		-- handle unknown steam id
		conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (0,0,0,'&quot; .. serverTime .. &quot;','ban','Player &quot; .. steam .. &quot; &quot; .. steam .. &quot; has has been banned for &quot; .. duration .. &quot; for &quot; .. escape(reason) .. &quot;',&quot; .. steam .. &quot;)&quot;)
		irc_QueueMsg(server.ircMain, &quot;[BANNED] Unknown player &quot; .. steam .. &quot; has been banned for &quot; .. duration .. &quot; &quot; .. reason)
		irc_QueueMsg(server.ircAlerts, &quot;[BANNED] Unknown player &quot; .. steam .. &quot; has been banned for &quot; .. duration .. &quot; &quot; .. reason)
	end

	send(&quot;ban add &quot; .. steam .. &quot; &quot; .. duration .. &quot; \&quot;&quot; .. reason .. &quot;\&quot;&quot;)
	send(&quot;llp &quot; .. steam)
end


function timeoutPlayer(steam, reason, bot)
	-- if the player is not already in timeout, send them there.
	if players[steam].timeout == false and players[steam].botTimeout == false then
		players[steam].timeout = true
		if bot then players[steam].botTimeout = true end -- the bot initiated this timeout
		-- record their position for return
		players[steam].xPosTimeout = math.floor(players[steam].xPos)
		players[steam].yPosTimeout = math.ceil(players[steam].yPos) + 1
		players[steam].zPosTimeout = math.floor(players[steam].zPos)

		conn:execute(&quot;UPDATE players SET timeout = 1, botTimeout = &quot; .. dbBool(bot) .. &quot;, xPosTimeout = &quot; .. players[steam].xPosTimeout .. &quot;, yPosTimeout = &quot; .. players[steam].yPosTimeout .. &quot;, zPosTimeout = &quot; .. players[steam].zPosTimeout .. &quot; WHERE steam = &quot; .. steam)		
		conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. math.floor(players[steam].xPos) .. &quot;,&quot; .. math.ceil(players[steam].yPos) .. &quot;,&quot; .. math.floor(players[steam].zPos) .. &quot;,'&quot; .. serverTime .. &quot;','timeout','Player &quot; .. steam .. &quot; &quot; .. escape(players[steam].name) .. &quot; has has been sent to timeout for &quot; .. escape(reason) .. &quot;',&quot; .. steam .. &quot;)&quot;)
		
		-- then teleport the player to timeout
		send(&quot;tele &quot; .. steam .. &quot; &quot; .. players[steam].xPosTimeout .. &quot; -5000 &quot; .. players[steam].zPosTimeout)

		message(&quot;say [&quot; .. server.chatColour .. &quot;]Sending player &quot; .. players[steam].name .. &quot; to timeout for &quot; .. reason .. &quot;[-]&quot;)
		irc_QueueMsg(server.ircMain, &quot;[TIMEOUT] Player &quot; .. steam .. &quot; &quot; .. players[steam].name .. &quot; has been sent to timeout for &quot; .. reason)
		irc_QueueMsg(server.ircAlerts, &quot;[TIMEOUT] Player &quot; .. steam .. &quot; &quot; .. players[steam].name .. &quot; has been sent to timeout for &quot; .. reason)
	end
end


function checkRegionClaims(x, z)
	cursor,errorString = conn:execute(&quot;SELECT * FROM keystones WHERE floor(x / 512) =  &quot; .. x .. &quot; AND floor(z / 512) = &quot; .. z)
	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		if row.remove == &quot;1&quot; then
			send(&quot;rlp &quot; .. row.x .. &quot; &quot; .. row.y .. &quot; &quot; .. row.z)
			conn:execute(&quot;UPDATE keystones SET remove = 2 WHERE steam = &quot; .. row.steam .. &quot; AND x = &quot; .. row.x .. &quot; AND y = &quot; .. row.y .. &quot; AND z = &quot; .. row.z )
		end

		row = cursor:fetch(row, &quot;a&quot;)	
	end
end


function dbWho(ownerid, x, y, z, dist, days, hours, height)
	local cursor, errorString,row, counter

	if days == nil then days = 1 end
	if height == nil then height = 4 end

	conn:execute(&quot;DELETE FROM searchResults WHERE owner = &quot; .. ownerid)

	if hours &gt; 0 then
		cursor,errorString = conn:execute(&quot;select distinct steam, session from tracker where abs(x - &quot; .. x .. &quot;) &lt; &quot; .. dist .. &quot; and abs(z - &quot; .. z .. &quot;) &lt; &quot; .. dist .. &quot; and abs(y - &quot; .. y .. &quot;) &lt; &quot; .. height .. &quot; and timestamp &gt;= '&quot; .. os.date(&quot;%Y-%m-%d %H:%M:%S&quot;, os.time() - (tonumber(hours) * 3600)) .. &quot;'&quot;)
	else
		cursor,errorString = conn:execute(&quot;select distinct steam, session from tracker where abs(x - &quot; .. x .. &quot;) &lt; &quot; .. dist .. &quot; and abs(z - &quot; .. z .. &quot;) &lt; &quot; .. dist .. &quot; and abs(y - &quot; .. y .. &quot;) &lt; &quot; .. height .. &quot; and timestamp &gt;= '&quot; .. os.date(&quot;%Y-%m-%d %H:%M:%S&quot;, os.time() - (tonumber(days) * 86400)) .. &quot;'&quot;)
	end

	row = cursor:fetch({}, &quot;a&quot;)
	counter = 1
	rows = cursor:numrows()

	if igplayers[ownerid] == nil then
		if rows &gt; 50 then
			irc_QueueMsg(ownerid, &quot;****** Report length &quot; .. rows .. &quot; rows.  Cancel it with: nuke irc ******&quot;)
		end
	end

	while row do
		conn:execute(&quot;INSERT INTO searchResults (owner, steam, session, counter) VALUES (&quot; .. ownerid .. &quot;,&quot; .. row.steam .. &quot;,&quot; .. row.session .. &quot;,&quot; .. counter .. &quot;)&quot;)

		if igplayers[ownerid] then
			message(&quot;pm &quot; .. ownerid .. &quot; [&quot; .. server.chatColour .. &quot;] #&quot; .. counter ..&quot; &quot; .. row.steam .. &quot; &quot; .. players[row.steam].id .. &quot; &quot; .. players[row.steam].name .. &quot; sess: &quot; .. row.session .. &quot;[-]&quot;)
		else
			irc_QueueMsg(ownerid, &quot;#&quot; .. counter ..&quot; &quot; .. row.steam .. &quot; &quot; .. players[row.steam].name .. &quot; sess: &quot; .. row.session)
		end

		counter = counter + 1
		row = cursor:fetch(row, &quot;a&quot;)	
	end
end


function dailyMaintenance()
	-- put something here to be run when the server date hits midnight

	return true
end


function startReboot()
	send(&quot;sa&quot;)
--	message(&quot;say [&quot; .. server.chatColour .. &quot;]RESTARTING..[-]&quot;)
	rebootTimerID = tempTimer( 5, [[finishReboot()]] )
end


function clearRebootFlags()
	nextRebootTest = os.time() + 60
	scheduledReboot = false 
	server.scheduledRestart = false
	server.scheduledRestartTimestamp = os.time()
	scheduledRestartPaused = nil
	scheduledRestartForced = false
end


function finishReboot()
	tempTimer( 30, [[clearRebootFlags()]] )

	if (rebootTimerID ~= nil) then 
		killTimer(rebootTimerID)
		rebootTimerID = nil 
	end

	if (rebootTimerDelayID ~= nil) then 
		killTimer(rebootTimerDelayID)
		rebootTimerDelayID = nil 
	end

	send(&quot;shutdown&quot;)
end


function newDay()
	if (string.sub(serverTime, 1, 10) ~= server.date) then
		server.date = string.sub(serverTime, 1, 10)
		resetShop()

		if tonumber(playersOnline) == 0 then
			saveLuaTables()
		end
	end
end


function IPToInt(ip)
	local o1,o2,o3,o4

	o1,o2,o3,o4 = ip:match(&quot;(%d%d?%d?)%.(%d%d?%d?)%.(%d%d?%d?)%.(%d%d?%d?)&quot; )
	return 2^24*o1 + 2^16*o2 + 2^8*o3 + o4
end


function readIPBlacklist()
	-- very slow.  don't run with a full server
	local ln
	local iprange

	local o1,o2,o3,o4
	local num1,num2

	for ln in io.lines(homedir .. &quot;/cn.csv&quot;) do
		iprange = string.split(ln, &quot;,&quot;)

		o1,o2,o3,o4 = iprange[1]:match(&quot;(%d%d?%d?)%.(%d%d?%d?)%.(%d%d?%d?)%.(%d%d?%d?)&quot; )
		num1 = 2^24*o1 + 2^16*o2 + 2^8*o3 + o4

		o1,o2,o3,o4 = iprange[2]:match(&quot;(%d%d?%d?)%.(%d%d?%d?)%.(%d%d?%d?)%.(%d%d?%d?)&quot; )
		num2 = 2^24*o1 + 2^16*o2 + 2^8*o3 + o4

		connBots:execute(&quot;INSERT INTO IPBlacklist (StartIP, EndIP) VALUES (&quot; .. num1 .. &quot;,&quot; .. num2 .. &quot;)&quot;)
	end
end


function Translate(playerid, command, lang, override)
	local words, word, oldCount, matches

	words = {}
	for word in command:gmatch(&quot;%S+&quot;) do table.insert(words, word) end
	oldCount = table.maxn(words)

	if lang == &quot;&quot; then
-- EDIT ME!
		os.execute(&quot;trans -b -no-ansi \&quot;&quot; .. command .. &quot;\&quot; &gt; &quot; .. &quot;~/trans.txt&quot;)
	else
-- EDIT ME!
		os.execute(&quot;trans -b -no-ansi {en=&quot; .. lang ..&quot;}  \&quot;&quot; .. command .. &quot;\&quot; &gt; &quot; .. &quot;~/trans.txt&quot;)
	end                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         

-- EDIT ME!
	for ln in io.lines(&quot;/home/user/trans.txt&quot;) do
		matches = 0
		for word in ln:gmatch(&quot;%S+&quot;) do
			if string.find(command, word) then
				matches = matches + 1
			end
		end

		if matches &lt; 2 then
			if ln ~= command and string.trim(ln) ~= &quot;&quot; then
				if players[playerid].translate == true or override ~= nil then
					message(&quot;say [BDFFFF]&quot; .. players[playerid].name .. &quot; [-]&quot; .. ln)
				end

				if players[playerid].translate == false or override == nil then
					irc_QueueMsg(server.ircMain, players[playerid].name .. &quot; &quot; .. ln)
				end
			end
		end
	end

	io.close()
end


function randomPVPTP(playerid, location, forced)
	local r, rows, row, rowCount

	cursor,errorString = conn:execute(&quot;select * from locationSpawns where location='&quot; .. location .. &quot;'&quot;)
	rows = tonumber(cursor:numrows())

	if rows == 0 then
		cmd = &quot;tele &quot; .. playerid .. &quot; &quot; .. locations[location].x .. &quot; &quot; .. locations[location].y .. &quot; &quot; .. locations[location].z
		prepareTeleport(playerid, cmd)
		teleport(cmd, true)
		return
	end

	rowCount = 1
	r = rand(rows)

	cursor,errorString = conn:execute(&quot;select * from locationSpawns where location='&quot; .. location .. &quot;' limit &quot; .. r - 1 .. &quot;,1&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	cmd = &quot;tele &quot; .. playerid .. &quot; &quot; .. row.x .. &quot; &quot; .. row.y .. &quot; &quot; .. row.z
	prepareTeleport(playerid, cmd)

	if location == &quot;lobby&quot; then
		teleport(cmd, true)
	else
		if forced ~= nil then
			teleport(cmd, true)
		else
			teleport(cmd)
		end
	end

	if (locations[location].pvp ~= nil) then
		if (accessLevel(playerid) &gt; 2) then
			players[playerid].baseCooldown = (os.time() + 1200) -- 2400 = 40 minutes
			conn:execute(&quot;UPDATE players SET baseCooldown = &quot; .. os.time() + 1200 .. &quot; WHERE steam = &quot; .. playerid)
		end
	end
end


function CheckClaimsRemoved()
	for k,v in pairs(igplayers) do
		if players[k].alertRemovedClaims == true then
			message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]You placed claims in a restricted area and they have been automatically removed.  You can get them back by typing /give lcb.[-]&quot;)
			players[k].alertRemovedClaims = false
		end
	end
end


function CheckBlacklist(steam, ip)
-- EDIT ME!
	connBots = env:connect(&quot;bots&quot;, &quot;bots&quot;, botsDBPassword)

	local o1,o2,o3,o4 = ip:match(&quot;(%d%d?%d?)%.(%d%d?%d?)%.(%d%d?%d?)%.(%d%d?%d?)&quot; )
	local ipint = 2^24*o1 + 2^16*o2 + 2^8*o3 + o4

	if players[steam].whitelisted == false then
		-- test for China IP
		ipint = tonumber(ipint)

		cursor,errorString = connBots:execute(&quot;SELECT * FROM IPBlacklist WHERE StartIP &lt;=  &quot; .. ipint .. &quot; AND EndIP &gt;= &quot; .. ipint)
		if cursor:numrows() &gt; 0 then

			irc_QueueMsg(server.ircMain, &quot;Chinese IP detected. &quot; .. players[steam].name)
			irc_QueueMsg(server.ircAlerts, &quot;Chinese IP detected. &quot; .. players[steam].name)
			players[steam].china = true
			players[steam].country = &quot;CN&quot;
			players[steam].ircTranslate = true

			if server.blacklistResponse == 'exile' then
				if tonumber(players[steam].exiled) == 0 then
					players[steam].exiled = 1
					conn:execute(&quot;UPDATE players SET country = 'CN', exiled = 1, ircTranslate = 1 WHERE steam = &quot; .. steam)
				end

				-- alert ingame admins
				for k, v in pairs(igplayers) do
					if (accessLevel(k) &lt; 3) then
						message(&quot;pm &quot; .. k .. &quot; Chinese player detected and exiled id &quot; .. players[steam].id .. &quot; name &quot; .. players[steam].name .. &quot;[-]&quot;)
					end
				end
			end

			if server.blacklistResponse == 'ban' then
				irc_QueueMsg(server.ircMain, &quot;Chinese player &quot; .. players[steam].name .. &quot; banned.&quot;)
				irc_QueueMsg(server.ircAlerts, &quot;Chinese player &quot; .. players[steam].name .. &quot; banned.&quot;)
				send(&quot;ban add &quot; .. steam .. &quot; 10 years blacklisted&quot;)
			end

			connBots:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event,steam) VALUES (&quot; .. math.floor(players[steam].xPos) .. &quot;,&quot; .. math.ceil(players[steam].yPos) .. &quot;,&quot; .. math.floor(players[steam].zPos) .. &quot;,'&quot; .. serverTime .. &quot;','info','Chinese player joined. Name: &quot; .. escape(player) .. &quot; SteamID: &quot; .. steam .. &quot; IP: &quot; .. ip  .. &quot;',&quot; .. steam .. &quot;)&quot;)
		else
			reverseDNS(steam, ip)
		end
	end
end


function reverseDNS(steam, ip)
	os.rename(homedir .. &quot;/dns/&quot; .. steam .. &quot;.txt&quot;, homedir .. &quot;/dns/&quot; .. steam .. &quot;_old.txt&quot;)
	os.execute(&quot;whois &quot; .. ip .. &quot; &gt; \&quot;&quot; .. homedir .. &quot;/dns/&quot; .. steam .. &quot;.txt\&quot;&quot;)
	tempTimer( 30, [[readDNS(&quot;]] .. steam .. [[&quot;)]] )
end


function readDNS(steam)
-- EDIT ME!
	connBots = env:connect(&quot;bots&quot;, &quot;bots&quot;, botsDBPassword)

	local file, ln, split, ip1, ip2, exiled, country, proxy

	file = io.open(homedir .. &quot;/dns/&quot; .. steam .. &quot;.txt&quot;, &quot;r&quot;)	
	exiled = false
	proxy = false
	country = &quot;&quot;
	
	for ln in file:lines() do
		if string.find(ln, &quot;%s(%d+)%.(%d+)%.(%d+)%.(%d+)%s&quot;) then
			a,b = string.find(ln, &quot;%s(%d+)%.(%d+)%.(%d+)%.(%d+)%s&quot;)
			iprange = string.sub(ln, a, a+b)
		end

		if string.find(ln, &quot;ountry:&quot;) then
			a,b = string.find(ln, &quot;%s(%w+)&quot;)
			country = string.upper(string.sub(ln, a + 1))
			if players[steam].country ~= &quot;&quot; and players[steam].country ~= country then
				irc_QueueMsg(server.ircAlerts, &quot;Possible proxy detected! Country changed! &quot; .. steam .. &quot; &quot; .. players[steam].name .. &quot; &quot; .. players[steam].IP .. &quot; old country &quot; .. players[steam].country .. &quot; new &quot; .. country)
				conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event,steam) VALUES (0,0,0'&quot; .. serverTime .. &quot;','proxy','Suspected proxy used by &quot; .. escape(players[steam].name) .. &quot; &quot; .. players[steam].IP .. &quot; old country &quot; .. players[steam].country .. &quot; new &quot; .. country .. &quot;,&quot; .. steam .. &quot;)&quot;)	
				proxy = true
			else
				 players[steam].country = country
			end
		end

		if string.upper(country) == &quot;CN&quot; and players[steam].whitelisted == false then
			-- China detected. Add ip range to IPBlacklist table
			split = string.split(iprange, &quot;-&quot;)

			ip1 = IPToInt(string.trim(split[1]))
			ip2 = IPToInt(string.trim(split[2]))
			
			irc_QueueMsg(server.ircMain, &quot;Chinese IP detected. &quot; .. players[steam].name .. &quot; &quot; .. players[steam].IP)
			irc_QueueMsg(server.ircAlerts, &quot;Chinese IP detected. &quot; .. players[steam].name .. &quot; &quot; .. players[steam].IP)
			players[steam].china = true
			players[steam].ircTranslate = true

			if server.blacklistResponse == 'exile' then
				if players[steam].exiled == 0 then
					players[steam].exiled = 1
					irc_QueueMsg(server.ircMain, &quot;Chinese player &quot; .. players[steam].name .. &quot; exiled.&quot;)
					irc_QueueMsg(server.ircAlerts, &quot;Chinese player &quot; .. players[steam].name .. &quot; exiled.&quot;)
					exiled = true
				end
			end

			if server.blacklistResponse == 'ban' then
				irc_QueueMsg(server.ircMain, &quot;Chinese player &quot; .. players[steam].name .. &quot; banned.&quot;)
				irc_QueueMsg(server.ircAlerts, &quot;Chinese player &quot; .. players[steam].name .. &quot; banned.&quot;)
				send (&quot;ban add &quot; .. steam .. &quot; 10 years blacklisted&quot;)
			end

			irc_QueueMsg(server.ircMain, &quot;Added new Chinese IP range &quot; .. iprange .. &quot; to blacklist&quot;)			
			connBots:execute(&quot;INSERT INTO IPBlacklist (StartIP, EndIP) VALUES (&quot; .. ip1 .. &quot;,&quot; .. ip2 .. &quot;)&quot;)

			-- alert ingame admins
			for k, v in pairs(igplayers) do
				if (accessLevel(k) &lt; 3) then
					if exiled then
						message(&quot;pm &quot; .. k .. &quot; Chinese player detected and exiled id &quot; .. players[steam].id .. &quot; name &quot; .. players[steam].name .. &quot;[-]&quot;)
					else
						message(&quot;pm &quot; .. k .. &quot; Chinese player detected id &quot; .. players[steam].id .. &quot; name &quot; .. players[steam].name .. &quot;[-]&quot;)					
					end
				end
			end		

			conn:execute(&quot;UPDATE players SET country = 'CN', exiled = 1, ircTranslate = 1 WHERE steam = &quot; .. steam)
			conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event,steam) VALUES (&quot; .. math.floor(players[steam].xPos) .. &quot;,&quot; .. math.ceil(players[steam].yPos) .. &quot;,&quot; .. math.floor(players[steam].zPos) .. &quot;,'&quot; .. serverTime .. &quot;','info','Chinese player joined. Name: &quot; .. escape(player) .. &quot; SteamID: &quot; .. steam .. &quot; IP: &quot; .. players[steam].IP  .. &quot;',&quot; .. steam .. &quot;)&quot;)	
			file:close()

			if proxy then
				os.rename(homedir .. &quot;/dns/&quot; .. steam .. &quot;_old.txt&quot;, homedir .. &quot;/proxies/&quot; .. steam .. &quot;.txt&quot;)
				os.rename(homedir .. &quot;/dns/&quot; .. steam .. &quot;.txt&quot;, homedir .. &quot;/proxies/&quot; .. steam .. &quot;_&quot; .. country .. &quot;.txt&quot;)
			else
				os.rename(homedir .. &quot;/dns/&quot; .. steam .. &quot;.txt&quot;, homedir .. &quot;/dns/&quot; .. steam .. &quot;_old.txt&quot;)
			end

			break
		end
	end

	if string.upper(country) == &quot;HK&quot; and players[steam].whitelisted == false then
		conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. math.floor(players[steam].xPos) .. &quot;,&quot; .. math.ceil(players[steam].yPos) .. &quot;,&quot; .. math.floor(players[steam].zPos) .. &quot;,'&quot; .. serverTime .. &quot;','info','Hong Kong player joined. Name: &quot; .. escape(player) .. &quot; SteamID: &quot; .. steam .. &quot; IP: &quot; .. players[steam].IP  .. &quot;',&quot; .. steam .. &quot;)&quot;)	

		if server.blacklistResponse == 'ban' then
			irc_QueueMsg(server.ircMain, &quot;Chinese player &quot; .. players[steam].name .. &quot; banned.&quot;)
			irc_QueueMsg(server.ircAlerts, &quot;Chinese player &quot; .. players[steam].name .. &quot; banned.&quot;)
			send (&quot;ban add &quot; .. steam .. &quot; 10 years blacklisted&quot;)
		else
			players[steam].ircTranslate = true

			if players[steam].exiled == 0 then
				players[steam].exiled = 1
				conn:execute(&quot;UPDATE players SET country = 'HK', exiled = 1, ircTranslate = 1 WHERE steam = &quot; .. steam)

				irc_QueueMsg(server.ircMain, &quot;Chinese player &quot; .. players[steam].name .. &quot; exiled.&quot;)
				irc_QueueMsg(server.ircAlerts, &quot;Chinese player &quot; .. players[steam].name .. &quot; exiled.&quot;)
				exiled = true

				-- alert ingame admins
				for k, v in pairs(igplayers) do
					if (accessLevel(k) &lt; 3) then
						if exiled then
							message(&quot;pm &quot; .. k .. &quot; Hong Kong player detected and exiled id &quot; .. players[steam].id .. &quot; name &quot; .. players[steam].name .. &quot;[-]&quot;)
						end
					end
				end		
			end		
		end
	end

	conn:execute(&quot;UPDATE players SET country = '&quot; .. country .. &quot;' WHERE steam = &quot; .. steam)

	file:close()

	if not proxy then
		os.rename(homedir .. &quot;/dns/&quot; .. steam .. &quot;.txt&quot;, homedir .. &quot;/dns/&quot; .. steam .. &quot;_old.txt&quot;)
	end
end


function initNewPlayer(steam, player, entityid)
	conn:execute(&quot;INSERT INTO players (steam, id, name) VALUES (&quot; .. steam .. &quot;,&quot; .. entityid .. &quot;,'&quot; .. escape(player) .. &quot;')&quot;)

	players[steam] = {}
	players[steam].id = entityid
	players[steam].name = player
	players[steam].names = player .. &quot;,&quot;
	players[steam].steam = steam
	players[steam].xPos = 0
	players[steam].yPos = 0
	players[steam].zPos = 0
	players[steam].homeX = 0
	players[steam].homeY = 0
	players[steam].homeZ = 0
	players[steam].home2X = 0
	players[steam].home2Y = 0
	players[steam].home2Z = 0
	players[steam].gimmeCount = 0
	players[steam].stepCount = 0
	players[steam].baseCooldown = 0
	players[steam].teleCooldown = 0
	players[steam].walkies = true
	players[steam].silentBob = false
	players[steam].donor = false
	players[steam].donorLevel = 0
	players[steam].donorExpiry = os.time()
	players[steam].protect = false
	players[steam].protectSize = server.baseSize
	players[steam].protect2 = false
	players[steam].protect2Size = server.baseSize
	players[steam].firstSeen = os.time()
	players[steam].timeOnServer = 0
	players[steam].alertPrison = true
	players[steam].alertPVP = true
	players[steam].alertReset = true
	players[steam].alertMapLimit = false
	players[steam].timeout = false
	players[steam].newPlayer = true
	players[steam].watchPlayer = true
	players[steam].sessionCount = 1
	players[steam].rescued = false
	players[steam].lastBaseRaid = 0
	players[steam].raiding = false
	players[steam].botTimeout = false
	players[steam].playtime = 0
	players[steam].cash = 0
	players[steam].overstack = false
	players[steam].overstackScore = 0
	players[steam].overstackTimeout = false
	players[steam].overstackItems = &quot;&quot;
	players[steam].removeClaims = false
	players[steam].tokens = 0
	players[steam].prisoner = false
	players[steam].whitelisted = false
	players[steam].permanentBan = false
	players[steam].prisonxPosOld = 0
	players[steam].prisonyPosOld = 0
	players[steam].prisonzPosOld = 0
	players[steam].prisonReason = &quot;&quot;
	players[steam].pvpVictim = 0
	players[steam].country = &quot;&quot;
	players[steam].ping = 0
	players[steam].lastLogout = os.time()
	players[steam].relogCount = 0
	players[steam].atHome = false
	players[steam].location = &quot;lobby&quot;
	players[steam].autoFriend = &quot;&quot;
	return true
end


function initNewIGPlayer(steam, player, entityid)
	igplayers[steam] = {}
	igplayers[steam].id = entityid
	igplayers[steam].name = player
	igplayers[steam].steam = steam
	igplayers[steam].greet = true
	igplayers[steam].connected = true
	igplayers[steam].greetdelay = 4
	igplayers[steam].xPos = 0
	igplayers[steam].yPos = 0
	igplayers[steam].zPos = 0
	igplayers[steam].xPosLast = 0
	igplayers[steam].yPosLast = 0
	igplayers[steam].zPosLast = 0
	igplayers[steam].xPosLastOK = 0
	igplayers[steam].yPosLastOK = 0
	igplayers[steam].zPosLastOK = 0
	igplayers[steam].firstSeen = os.time()
	igplayers[steam].sessionStart = os.time()
	igplayers[steam].sessionPlaytime = 0
	igplayers[steam].timeOnServer = 0
	igplayers[steam].lastHotspot = 0
	igplayers[steam].inventory = &quot;&quot;
	igplayers[steam].inventoryLast = &quot;&quot;
	igplayers[steam].illegalInventory = false
	igplayers[steam].botQuestion = &quot;&quot; -- used for storing the last question the bot asked the player.
	igplayers[steam].killTimer = 0
	igplayers[steam].xPosLastAlert = 0
	igplayers[steam].yPosLastAlert = 0
	igplayers[steam].zPosLastAlert = 0
	igplayers[steam].ping = 0
	igplayers[steam].highPingCount = 0
	igplayers[steam].tp = 0
	igplayers[steam].afk = os.time() + 180
	igplayers[steam].checkNewPlayer = true
	return true
end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>irc code</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function irc_QueueMsg(name, msg)
	-- Don't allow the bot to command itself
	if name == server.botName then
		return
	end

	conn:execute(&quot;INSERT INTO ircQueue (name, command) VALUES ('&quot; .. name .. &quot;','&quot; .. escape(msg) .. &quot;')&quot;)
end


function irc_NewInventory(steam, trackerID)
	local tbl, slot, rows, i

	if trackerID ~= nil then
		cursor,errorString = conn:execute(&quot;SELECT * FROM inventoryTracker WHERE steam = &quot; .. steam ..&quot; AND inventoryTrackerID = &quot; .. trackerID)
	else
		cursor,errorString = conn:execute(&quot;SELECT * FROM inventoryTracker WHERE steam = &quot; .. steam ..&quot; ORDER BY inventoryTrackerid DESC Limit 1&quot;)
	end

	row = cursor:fetch({}, &quot;a&quot;)
	if row then
		irc_QueueMsg(irc_params[1], &quot;&quot;)
		irc_QueueMsg(irc_params[1], &quot;Belt of &quot; .. irc_params[3])
		irc_QueueMsg(irc_params[1], &quot;&quot;)

		tbl = string.split(row.belt, &quot;|&quot;)
		for i=1, table.maxn(tbl) - 1, 1 do
			slot = string.split(tbl[i], &quot;,&quot;)
			if tonumber(slot[4]) &gt; 0 then
				irc_QueueMsg(irc_params[1], &quot;Slot &quot; .. slot[1] .. &quot; qty &quot; .. slot[2] .. &quot; &quot; .. slot[3] .. &quot; &quot; .. slot[4])
			else
				irc_QueueMsg(irc_params[1], &quot;Slot &quot; .. slot[1] .. &quot; qty &quot; .. slot[2] .. &quot; &quot; .. slot[3])
			end
		end

		irc_QueueMsg(irc_params[1], &quot;&quot;)
		irc_QueueMsg(irc_params[1], &quot;Backpack of &quot; .. irc_params[3])
		irc_QueueMsg(irc_params[1], &quot;&quot;)

		tbl = string.split(row.pack, &quot;|&quot;)
		for i=1, table.maxn(tbl) - 1, 1 do
			slot = string.split(tbl[i], &quot;,&quot;)
			if tonumber(slot[4]) &gt; 0 then
				irc_QueueMsg(irc_params[1], &quot;Slot &quot; .. slot[1] .. &quot; qty &quot; .. slot[2] .. &quot; &quot; .. slot[3] .. &quot; &quot; .. slot[4])
			else
				irc_QueueMsg(irc_params[1], &quot;Slot &quot; .. slot[1] .. &quot; qty &quot; .. slot[2] .. &quot; &quot; .. slot[3])
			end
		end

		irc_QueueMsg(irc_params[1], &quot;&quot;)
		irc_QueueMsg(irc_params[1], &quot;Equipment of &quot; .. irc_params[3])
		irc_QueueMsg(irc_params[1], &quot;&quot;)

		tbl = string.split(row.equipment, &quot;|&quot;)
		for i=1, table.maxn(tbl) - 1, 1 do
			slot = string.split(tbl[i], &quot;,&quot;)
			irc_QueueMsg(irc_params[1], &quot;Slot &quot; .. slot[1] .. &quot; qty &quot; .. slot[2] .. &quot; &quot; .. slot[3])
		end
	else
		irc_QueueMsg(irc_params[1], &quot;&quot;)
		irc_QueueMsg(irc_params[1], &quot;I do not have an inventory recorded for &quot; .. players[steam].name)
	end

	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_Request_Inventory()
	irc_NewInventory(irc_params[2])
end


function irc_message()
	irc_QueueMsg(irc_params[1], irc_params[2])
end


function irc_ListTables()
	irc_QueueMsg(irc_params[1], &quot;These are the bot tables that you can view and edit:&quot;)
	irc_QueueMsg(irc_params[1], &quot;server&quot;)
	irc_QueueMsg(irc_params[1], &quot;rollingMessages&quot;)
	irc_QueueMsg(irc_params[1], &quot;whitelist&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_List_Villages()
	local id

	irc_QueueMsg(irc_params[1], &quot;List of villages on the server:&quot;)
	for k, v in pairs(locations) do
		if v.village == true then
			id = LookupOfflinePlayer(v.mayor)
			if id ~= nil then
				irc_QueueMsg(irc_params[1], v.name .. &quot; the Mayor is &quot; .. players[id].name)
			else
				irc_QueueMsg(irc_params[1], v.name)
			end
		end
	end

	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_List_Villagers()
	local text

	irc_QueueMsg(irc_params[1], &quot;The following players are villagers:&quot;)
	for k, v in pairs(villagers) do
		text = v.village .. &quot; &quot; .. players[k].name

		if locations[v.village].mayor == k then
			text = text .. &quot; (the mayor of &quot; .. v.village .. &quot;)&quot;
		end

		irc_QueueMsg(irc_params[1], text)
	end

	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_ListBases(steam)
	local prot1
	local prot2
	local msg

	if steam ~= nil then
		cursor,errorString = conn:execute(&quot;SELECT steam, name, homeX, homeY, homeZ, home2X, home2Y, home2Z, protect, protect2, protectSize, protect2Size from players where steam = &quot; .. steam .. &quot; order by name&quot;)
	else
		cursor,errorString = conn:execute(&quot;SELECT steam, name, homeX, homeY, homeZ, home2X, home2Y, home2Z, protect, protect2, protectSize, protect2Size from players order by name&quot;)
	end

	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		prot1 = &quot;OFF&quot;
		prot2 = &quot;OFF&quot;

		if row.protect == true then prot1 = &quot;ON&quot; end
		if row.protect2 == true then prot2 = &quot;ON&quot; end
		msg = row.steam .. &quot; &quot; .. row.name .. &quot; &quot;

		if tonumber(row.homeX) == 0 and tonumber(row.homeY) == 0 and tonumber(row.homeZ) == 0 and tonumber(row.home2X) == 0 and tonumber(row.home2Y) == 0 and tonumber(row.home2Z) == 0 then
			if steam ~= nil then
				msg = msg .. &quot;has no base set&quot;
			else
				msg = nil
			end
		else
			msg = msg .. row.homeX .. &quot; &quot; .. row.homeY .. &quot; &quot; .. row.homeZ .. &quot; &quot; .. prot1 .. &quot; (&quot; .. row.protectSize .. &quot;) &quot;
			msg = msg .. row.home2X .. &quot; &quot; .. row.home2Y .. &quot; &quot; .. row.home2Z .. &quot; &quot; .. prot2 .. &quot; (&quot; .. row.protect2Size .. &quot;) &quot;
		end

		if irc_params[2] == &quot;protected&quot; and (row.protect == true or row.protect2 == true) then
			if msg ~= nil then
				irc_QueueMsg(irc_params[1], msg)
			end
		end

		if irc_params[2] ~= &quot;protected&quot; then	
			if msg ~= nil then
				irc_QueueMsg(irc_params[1], msg)
			end
		end

		row = cursor:fetch(row, &quot;a&quot;)	
	end

	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_PlayersNearPlayer(offline)
	local alone, dist, number, flag

	alone = true

	if (irc_params[4] == nil) then 
		number = 200
	else
		number = tonumber(irc_params[4])
	end

	if offline == nil then
		irc_QueueMsg(irc_params[1], &quot;Players within &quot; .. number .. &quot; meters of &quot; .. irc_params[3] .. &quot; are:&quot;) 	

		for k, v in pairs(igplayers) do
			if k ~= irc_params[2] then
				dist = distance(players[irc_params[2]].xPos, players[irc_params[2]].zPos, v.xPos, v.zPos)

				if dist &lt; number then
					irc_QueueMsg(irc_params[1], v.name .. &quot; distance: &quot; .. string.format(&quot;%-4.2d&quot;, dist) .. &quot; meters&quot;)
					alone = false
				end
			end
		end
	else
		irc_QueueMsg(irc_params[1], &quot;Players within &quot; .. number .. &quot; meters of &quot; .. irc_params[3] .. &quot; including offline are:&quot;) 	

		for k, v in pairs(players) do
			if k ~= irc_params[2] then
				dist = distance(players[irc_params[2]].xPos, players[irc_params[2]].zPos, v.xPos, v.zPos)

				if dist &lt; number then
					if igplayers[k] then 
						flag = &quot; PLAYING&quot;
					else
						flag = &quot; AWAY&quot;
					end

					irc_QueueMsg(irc_params[1], v.name .. &quot; distance: &quot; .. string.format(&quot;%-4.2d&quot;, dist) .. &quot; meters&quot; .. flag)
					alone = false
				end
			end
		end
	end

	if (alone == true) then
		irc_QueueMsg(irc_params[1], &quot;There is nobody within &quot; .. number .. &quot; meters of &quot; .. irc_params[3])
	end

	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_BasesNearPlayer()
	local alone, dist, number, protected

	alone = true

	if (irc_params[4] == nil) then 
		number = 200
	else
		number = tonumber(irc_params[4])
	end

	irc_QueueMsg(irc_params[1], &quot;Bases within &quot; .. number .. &quot; meters of &quot; .. irc_params[3] .. &quot; are:&quot;) 	

	for k, v in pairs(players) do
		if (v.homeX) and (v.homeX ~= 0 and v.homeZ ~= 0) then
			dist = distance(players[irc_params[2]].xPos, players[irc_params[2]].zPos, v.homeX, v.homeZ)

			if dist &lt; number then
				if players[k].protect == true then
					protected = &quot; bot protected&quot;
				else
					protected = &quot; unprotected&quot;
				end

				irc_QueueMsg(irc_params[1], v.name .. &quot; distance: &quot; .. string.format(&quot;%-.2d&quot;, dist) .. &quot; meters&quot; .. protected)
				alone = false
			end
		end
		
		if (v.home2X) and (v.home2X ~= 0 and v.home2Z ~= 0) then
			dist = distance(players[irc_params[2]].xPos, players[irc_params[2]].zPos, v.home2X, v.home2Z)

			if dist &lt; number then
				if players[k].protect2 == true then
					protected = &quot; bot protected&quot;
				else
					protected = &quot; unprotected&quot;
				end

				irc_QueueMsg(irc_params[1], v.name .. &quot; distance: &quot; .. string.format(&quot;%-.2d&quot;, dist) .. &quot; meters&quot; .. protected)
				alone = false
			end
		end		
	end

	if (alone == true) then
		irc_QueueMsg(irc_params[1], &quot;There are none within &quot; .. number .. &quot; meters of &quot; .. irc_params[3])
	end

	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_PlayerShortInfo()
	local time
	local days
	local hours
	local minutes

	if (igplayers[irc_params[2]]) then
		time = tonumber(players[irc_params[2]].timeOnServer) + tonumber(igplayers[irc_params[2]].sessionPlaytime)
	else
		time = tonumber(players[irc_params[2]].timeOnServer)
	end

	days = math.floor(time / 86400)

	if (days &gt; 0) then
		time = time - (days * 86400)
	end

	hours = math.floor(time / 3600)

	if (hours &gt; 0) then
		time = time - (hours * 3600)
	end

	minutes = math.floor(time / 60)
	time = time - (minutes * 60)

	irc_QueueMsg(irc_params[1], &quot;Info for player &quot; .. irc_params[3])
	if players[irc_params[2]].newPlayer == true then irc_QueueMsg(irc_params[1], &quot;A new player&quot;) end
	irc_QueueMsg(irc_params[1], &quot;SteamID &quot; .. players[irc_params[2]].steam)
	irc_QueueMsg(irc_params[1], &quot;Steam Rep http://steamrep.com/search?q=&quot; .. players[irc_params[2]].steam)
	irc_QueueMsg(irc_params[1], &quot;Player ID &quot; .. players[irc_params[2]].id)
	if players[irc_params[2]].firstSeen ~= nil then irc_QueueMsg(irc_params[1], &quot;First seen: &quot; .. os.date(&quot;%Y-%m-%d %H:%M:%S&quot;, players[irc_params[2]].firstSeen) ) end
	irc_QueueMsg(irc_params[1], seen(irc_params[2]))
	irc_QueueMsg(irc_params[1], &quot;Total time played: &quot; .. days .. &quot; days &quot; .. hours .. &quot; hours &quot; .. minutes .. &quot; minutes &quot; .. time .. &quot; seconds&quot;)
	if players[irc_params[2]].names ~= nil then irc_QueueMsg(irc_params[1], &quot;Has played as &quot; .. players[irc_params[2]].names) end
	if players[irc_params[2]].timeout == true then irc_QueueMsg(irc_params[1], &quot;Is in timeout&quot;) end
	if players[irc_params[2]].prisoner then 
		irc_QueueMsg(irc_params[1], &quot;Is a prisoner&quot;) 
		if players[irc_params[2]].prisonReason ~= nil then irc_QueueMsg(irc_params[1], &quot;Reason Arrested: &quot; .. players[irc_params[2]].prisonReason) end
	end
	irc_QueueMsg(irc_params[1], &quot;Keystones placed &quot; .. players[irc_params[2]].keystones)
	irc_QueueMsg(irc_params[1], &quot;Zombies &quot; .. players[irc_params[2]].zombies)
	irc_QueueMsg(irc_params[1], &quot;Score &quot; .. players[irc_params[2]].score)
	irc_QueueMsg(irc_params[1], &quot;Deaths &quot; .. players[irc_params[2]].deaths)
	irc_QueueMsg(irc_params[1], &quot;Current Session &quot; .. players[irc_params[2]].sessionCount)
	irc_QueueMsg(irc_params[1], &quot;IP http://who.is/whois-ip/ip-address/&quot; .. players[irc_params[2]].IP)
	irc_QueueMsg(irc_params[1], &quot;Ping &quot; .. players[irc_params[2]].ping .. &quot; Country: &quot; .. players[irc_params[2]].country)

	if players[irc_params[2]].china then
		irc_QueueMsg(irc_params[1], &quot;China IP detected&quot;)
	end

	if players[irc_params[2]].exiled == 1 then
		irc_QueueMsg(irc_params[1], &quot;Is exiled&quot;)
	else
		irc_QueueMsg(irc_params[1], &quot;Not exiled&quot;)
	end

	if players[irc_params[2]].inLocation ~= &quot;&quot; and players[irc_params[2]].inLocation ~= nil then
		irc_QueueMsg(irc_params[1], &quot;In location &quot; .. players[irc_params[2]].alertLocation)
	else
		irc_QueueMsg(irc_params[1], &quot;Not in a named location&quot;)
	end

	cursor,errorString = conn:execute(&quot;SELECT * FROM bans WHERE steam =  &quot; .. irc_params[2])
	if cursor:numrows() &gt; 0 then
		row = cursor:fetch({}, &quot;a&quot;)
		irc_QueueMsg(irc_params[1], &quot;BANNED until &quot; .. row.BannedTo .. &quot; &quot; .. row.Reason)
	end

	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_List_Owners()
	irc_QueueMsg(irc_params[1], &quot;The server owners are..&quot;)
	for k, v in pairs(owners) do
		irc_QueueMsg(irc_params[1], players[k].name)
	end

	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_List_Admins()
	irc_QueueMsg(irc_params[1], &quot;The server admins are..&quot;)
	for k, v in pairs(admins) do
		irc_QueueMsg(irc_params[1], players[k].name)
	end

	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_List_Mods()
	irc_QueueMsg(irc_params[1], &quot;The server mods are..&quot;)
	for k, v in pairs(mods) do
		irc_QueueMsg(irc_params[1], players[k].name)
	end

	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_friend()
	-- add to friends table
	if (friends[irc_params[2]] == nil) then
		friends[irc_params[2]] = {}
		friends[irc_params[2]].friends = &quot;&quot;
	end

	if (not string.find(friends[irc_params[2]].friends, irc_params[3])) then
		friends[irc_params[2]].friends = friends[irc_params[2]].friends .. irc_params[3] .. &quot;,&quot;
		irc_QueueMsg(irc_params[1], players[irc_params[2]].name .. &quot; is now friends with &quot; .. players[irc_params[3]].name) 
	else
		irc_QueueMsg(irc_params[1], players[irc_params[2]].name .. &quot; is already friends with &quot; .. players[irc_params[3]].name) 
	end

	conn:execute(&quot;INSERT INTO friends (steam, friend) VALUES (&quot; .. irc_params[3] .. &quot;,&quot; .. irc_params[2] .. &quot;)&quot;)

	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_unfriend()
	local friendlist

	-- add to friends table
	if (friends[irc_params[2]] == nil) then
		friends[irc_params[2]] = {}
		friends[irc_params[2]].friends = &quot;&quot;
	end

	friendlist = string.split(friends[irc_params[2]].friends, &quot;,&quot;)

	-- now simply rebuild friend skipping over the one we are removing
	friends[irc_params[2]].friends = &quot;&quot;
	for i=1,table.maxn(friendlist) - 1,1 do
		if (friendlist[i] ~= irc_params[3]) then
			friends[irc_params[2]].friends = friends[irc_params[2]].friends .. friendlist[i] .. &quot;,&quot;
		end
	end
	
	irc_QueueMsg(irc_params[1], players[irc_params[2]].name .. &quot; is no longer friends with &quot; .. players[irc_params[3]].name) 

	conn:execute(&quot;DELETE FROM friends WHERE steam = &quot; .. irc_params[3] .. &quot; AND friend = &quot; .. irc_params[2])	

	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_friends()
	local friendlist

	friendlist = string.split(friends[irc_params[2]].friends, &quot;,&quot;)

	irc_QueueMsg(irc_params[1], irc_params[3] .. &quot; is friends with..&quot;)
	for i=1,table.maxn(friendlist)-1,1 do
		if (friendlist[i] ~= &quot;&quot;) then
			id = LookupPlayer(friendlist[i])
			irc_QueueMsg(irc_params[1], players[id].name)
		end
	end	

	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_new_players(name)
	local id
	local x
	local z

	id = LookupOfflinePlayer(name, &quot;all&quot;)

	irc_QueueMsg(name, &quot;New players in the last 2 days:&quot;)

	for k, v in pairs(players) do
		if v.firstSeen ~= nil then
			if ((os.time() - tonumber(v.firstSeen)) &lt; 86401) then
				if accessLevel(id) &gt; 3 then
					irc_QueueMsg(name, v.name) 
				else
					irc_QueueMsg(name, &quot;steam: &quot; .. k .. &quot; id: &quot; .. string.format(&quot;%8d&quot;, v.id) .. &quot; name: &quot; .. v.name .. &quot; at &quot; .. math.floor(v.xPos) .. &quot; &quot; .. math.ceil(v.yPos) .. &quot; &quot; .. math.floor(v.zPos))
				end					
			end
		end
	end
	
	irc_QueueMsg(name, &quot;&quot;)
end


function irc_server_status(name, days)
	irc_QueueMsg(name, &quot;The server date is &quot; .. serverTime)

	if days == nil then
		irc_QueueMsg(name, &quot;24 hour stats to now:&quot;)
		days = 1
	else
		irc_QueueMsg(name, &quot;Last &quot; .. days .. &quot; days stats to now:&quot;)
	end

	cursor,errorString = conn:execute(&quot;SELECT COUNT(id) as number FROM events WHERE type LIKE '%pvp%' AND timestamp &gt; DATE_SUB(now(), INTERVAL &quot;.. days .. &quot; DAY)&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	irc_QueueMsg(name, &quot;PVPs: &quot; .. row.number)

	cursor,errorString = conn:execute(&quot;SELECT COUNT(id) as number FROM events WHERE type LIKE '%timeout%' AND timestamp &gt; DATE_SUB(now(), INTERVAL &quot;.. days .. &quot; DAY)&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	irc_QueueMsg(name, &quot;Timeouts: &quot; .. row.number)

	cursor,errorString = conn:execute(&quot;SELECT COUNT(id) as number FROM events WHERE type LIKE '%arrest%' AND timestamp &gt; DATE_SUB(now(), INTERVAL &quot;.. days .. &quot; DAY)&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	irc_QueueMsg(name, &quot;Arrests: &quot; .. row.number)

	cursor,errorString = conn:execute(&quot;SELECT COUNT(id) as number FROM events WHERE type LIKE '%new%' AND timestamp &gt; DATE_SUB(now(), INTERVAL &quot;.. days .. &quot; DAY)&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	irc_QueueMsg(name, &quot;New players: &quot; .. row.number)

	cursor,errorString = conn:execute(&quot;SELECT COUNT(id) as number FROM events WHERE type LIKE '%ban%' AND timestamp &gt; DATE_SUB(now(), INTERVAL &quot;.. days .. &quot; DAY)&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	irc_QueueMsg(name, &quot;Bans: &quot; .. row.number)

	cursor,errorString = conn:execute(&quot;SELECT MAX(players) as number FROM performance WHERE timestamp &gt; DATE_SUB(now(), INTERVAL &quot;.. days .. &quot; DAY)&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	irc_QueueMsg(name, &quot;Most players online: &quot; .. row.number)
	irc_QueueMsg(name, &quot;&quot;)
end


function irc_server_event(name)
	local event, days, steam
	event = irc_params[2]
	days = irc_params[3]
	steam = irc_params[4]

	if days == '' then
		irc_QueueMsg(name, event .. &quot;s in the last 24 hours:&quot;)
		days = 1
	else
		irc_QueueMsg(name, event .. &quot;s in the last &quot; .. days .. &quot; days:&quot;)
	end

	if steam ~= &quot;&quot; then
		cursor,errorString = conn:execute(&quot;SELECT * FROM events WHERE steam = &quot; .. steam .. &quot; AND type LIKE '%&quot; .. event .. &quot;%' AND timestamp &gt; DATE_SUB(now(), INTERVAL &quot;.. days .. &quot; DAY)&quot;)
	else
		cursor,errorString = conn:execute(&quot;SELECT * FROM events WHERE type LIKE '%&quot; .. event .. &quot;%' AND timestamp &gt; DATE_SUB(now(), INTERVAL &quot;.. days .. &quot; DAY)&quot;)
	end

	row = cursor:fetch({}, &quot;a&quot;)

	while row do
		irc_QueueMsg(name, row.serverTime .. &quot; &quot; .. row.event)
		row = cursor:fetch(row, &quot;a&quot;)
	end

	irc_QueueMsg(name, &quot;&quot;)
end


function irc_players(name)
	local id
	local x
	local z
	local flags

	id = LookupPlayer(name, &quot;all&quot;)

	irc_QueueMsg(name, &quot;The following users are in-game right now:&quot;)

	for k, v in pairs(igplayers) do
		x = math.floor(v.xPos / 512)
		z = math.floor(v.zPos / 512)

		flags = &quot; &quot;
		if players[k].newPlayer == true then flags = flags .. &quot;[NEW]&quot; end
		if players[k].timeout == true then flags = flags .. &quot;[TIMEOUT]&quot; end

		if (accessLevel(id) &gt; 3) then
			irc_QueueMsg(name, v.name .. &quot; score: &quot; .. string.format(&quot;%-6d&quot;, v.score) .. &quot; PVP: &quot; .. string.format(&quot;%-2d&quot;, v.playerKills) .. &quot; zeds: &quot; .. string.format(&quot;%-6d&quot;, v.zombies) .. &quot; &quot; .. flags)
		else
			if players[id].ircAuthenticated == true then
				irc_QueueMsg(name, &quot;steam: &quot; .. k .. &quot; id: &quot; .. string.format(&quot;%-7d&quot;, v.id) .. &quot; score: &quot; .. string.format(&quot;%-6d&quot;, v.score) .. &quot; PVP: &quot; .. string.format(&quot;%-2d&quot;, v.playerKills) .. &quot; zeds: &quot; .. string.format(&quot;%-6d&quot;, v.zombies) .. &quot; region r.&quot; .. x .. &quot;.&quot; .. z .. &quot;.7rg   name: &quot; .. v.name  .. flags .. &quot; [ &quot; .. math.floor(v.xPos) .. &quot; &quot; .. math.ceil(v.yPos) .. &quot; &quot; .. math.floor(v.zPos) .. &quot; ] &quot; .. players[k].country .. &quot; &quot; .. v.ping)
			else
				irc_QueueMsg(name, v.name .. &quot; score: &quot; .. string.format(&quot;%-6d&quot;, v.score) .. &quot; PVP: &quot; .. string.format(&quot;%-2d&quot;, v.playerKills) .. &quot; zeds: &quot; .. string.format(&quot;%-6d&quot;, v.zombies) .. &quot; &quot; .. flags)
			end
		end
	end

	irc_QueueMsg(irc_params[1], &quot;There are &quot; .. playersOnline .. &quot; players online.&quot;)
	irc_QueueMsg(name, &quot;&quot;)
end


function irc_listResetZones(name)
   local a = {}
	local n
	local sid
	local pid

	irc_QueueMsg(name, &quot;The following regions are designated reset zones:&quot;)

   for n in pairs(resetRegions) do
		table.insert(a, n)
	end  

	table.sort(a)

   for k, v in ipairs(a) do
		irc_QueueMsg(name, &quot;region: &quot; .. v)
	end

	irc_QueueMsg(name, &quot;&quot;)
end


function irc_gameTime(name)
	irc_QueueMsg(name, &quot;The game date is: &quot; .. gameDate)
end


function irc_uptime(name)
	diff = os.difftime(os.time(), botStarted)
	days = math.floor(diff / 86400)

	if (days &gt; 0) then
		diff = diff - (days * 86400)
	end

	hours = math.floor(diff / 3600)

	if (hours &gt; 0) then
		diff = diff - (hours * 3600)
	end

	minutes = math.floor(diff / 60)

	irc_QueueMsg(name, server.botName .. &quot; has been online &quot; .. days .. &quot; days &quot; .. hours .. &quot; hours &quot; .. minutes ..&quot; minutes&quot;)

	if gameTick &lt; 0 then
		irc_QueueMsg(name, &quot;Server uptime is uncertain&quot;)
	else
		diff = gameTick
		--diff = os.difftime(os.time(), serverStarted)
		days = math.floor(diff / 86400)

		if (days &gt; 0) then
			diff = diff - (days * 86400)
		end

		hours = math.floor(diff / 3600)

		if (hours &gt; 0) then
			diff = diff - (hours * 3600)
		end

		minutes = math.floor(diff / 60)

		irc_QueueMsg(name, &quot;Server uptime is &quot; .. days .. &quot; days &quot; .. hours .. &quot; hours &quot; .. minutes ..&quot; minutes&quot;)
	end
	
	irc_QueueMsg(name, &quot;&quot;)
end


function irc_listAllPlayers(name)
    local a = {}
	local n
	local sid
	local pid

	irc_QueueMsg(name, &quot;These are all the players on record:&quot;)

    for n in pairs(players) do
		table.insert(a, players[n].name)
	end  

	table.sort(a)

    for k, v in ipairs(a) do
		sid = LookupOfflinePlayer(v, &quot;all&quot;)
		pid = players[sid].id

		cmd = &quot;steam: &quot; .. sid .. &quot; id: &quot; .. string.format(&quot;%-8d&quot;, pid) .. &quot; name: &quot; .. v
		irc_QueueMsg(irc_params[1], cmd)
	end

	irc_QueueMsg(name, &quot;&quot;)
end


function irc_IGPlayerInfo()
	if (players[irc_params[2]] ~= nil) then
		irc_QueueMsg(irc_params[1], &quot;In-Game Player record of: &quot; .. players[irc_params[2]].name)
		for k, v in pairs(igplayers[irc_params[2]]) do
			if k ~= &quot;inventory&quot; and k ~= &quot;inventoryLast&quot; then
				cmd = k .. &quot;,&quot; .. tostring(v)
				irc_QueueMsg(irc_params[1], cmd)
			end
		end
	else
		irc_QueueMsg(irc_params[1], &quot;&quot;)
		irc_QueueMsg(irc_params[1], &quot;I do not know a player called &quot; .. irc_params[3])
	end
	
	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_PlayerInfo()
	if (players[irc_params[2]] ~= nil) then
		irc_QueueMsg(irc_params[1], &quot;Player record of: &quot; .. players[irc_params[2]].name)
		for k, v in pairs(players[irc_params[2]]) do
			if k ~= &quot;ircPass&quot; then
				cmd = k .. &quot;,&quot; .. tostring(v)
				irc_QueueMsg(irc_params[1], cmd)
			end
		end
	else
		irc_QueueMsg(irc_params[1], &quot;&quot;)
		irc_QueueMsg(irc_params[1], &quot;I do not know a player called &quot; .. irc_params[3])
	end
	
	irc_QueueMsg(irc_params[1], &quot;&quot;)	
end


function irc_ShowTable()
	irc_QueueMsg(irc_params[1], &quot;The &quot; .. irc_params[2] ..&quot; table: &quot;)

	if string.lower(irc_params[2]) == &quot;server&quot; then
		for k, v in pairs(server) do
			cmd = k .. &quot;,&quot; .. tostring(v)
			irc_QueueMsg(irc_params[1], cmd)
		end
	
		irc_QueueMsg(irc_params[1], &quot;&quot;)	
	end
end


function irc_listDonors(name)
   local a = {}
	local n
	local sid
	local pid

	irc_QueueMsg(name, &quot;These are all the donors on record:&quot;)

   for n in pairs(players) do
		if (players[n].donor == true) then
			table.insert(a, players[n].name)
		end
	end  

	table.sort(a)

   for k, v in ipairs(a) do
		sid = LookupOfflinePlayer(v, &quot;all&quot;)
		pid = players[sid].id

		irc_QueueMsg(name, &quot;steam: &quot; .. sid .. &quot; id: &quot; .. string.format(&quot;%-8d&quot;, pid) .. &quot; name: &quot; .. v)
	end

	irc_QueueMsg(name, &quot;&quot;)
end


function irc_uncraftables(name)
	irc_QueueMsg(name, &quot;The bot scans for these uncraftable items in inventories:&quot;)

	for k, v in pairs(badItems) do
		irc_QueueMsg(name, k)
	end

	irc_QueueMsg(name, &quot;&quot;)
end


function irc_teleports(name)
	irc_QueueMsg(name, &quot;List of teleports:&quot;)

	for k, v in pairs(teleports) do
		if (v.public == true) then
			public = &quot;public&quot;
		else
			public = &quot;private&quot;
		end

		irc_QueueMsg(name, v.name .. &quot; &quot; .. public)
	end

	irc_QueueMsg(name, &quot;&quot;)
end


function irc_locations(name)
	local id

	id = LookupOfflinePlayer(name, &quot;all&quot;)

	irc_QueueMsg(name, &quot;List of locations:&quot;)

	for k, v in pairs(locations) do
		if (v.public == true) then
			public = &quot;public&quot;
		else
			public = &quot;private&quot;
		end

		if (v.active == true) then
			active = &quot;enabled&quot;
		else
			active = &quot;disabled&quot;
		end

		if not admins[id] and public == &quot;private&quot; then
			irc_QueueMsg(name, v.name .. &quot; &quot; .. public .. &quot; &quot; .. active .. &quot; xyz &quot; .. v.x .. &quot;,&quot; .. v.y .. &quot;,&quot; .. v.z)
		else
			irc_QueueMsg(name, v.name .. &quot; &quot; .. public .. &quot; &quot; .. active .. &quot; xyz &quot; .. v.x .. &quot;,&quot; .. v.y .. &quot;,&quot; .. v.z)
		end
	end

	irc_QueueMsg(name, &quot;&quot;)
end


function irc_prisoners(name)
	irc_QueueMsg(name, &quot;List of prisoners:&quot;)

	-- pm a list of all the prisoners
	if (prisoners == {}) then
		irc_QueueMsg(name, v.name .. &quot;Nobody is in prison&quot;)
		return
	end

	for k, v in pairs(prisoners) do
		irc_QueueMsg(name, k .. &quot; &quot; .. players[k].name)
	end

	irc_QueueMsg(name, &quot;&quot;)
end


function irc_playerStatus()
	local protected
	local base

	if (players[irc_params[2]].protect == true) then
		protected = &quot;protected&quot;
	else
		protected = &quot;not protected (unless you have LCB's down)&quot;
	end
	
	if (players[irc_params[2]].homeX == 0 and players[irc_params[2]].homeY == 0 and players[irc_params[2]].homeZ == 0) then
		base = &quot;Has not done /setbase&quot;	
	else
		base = &quot;Has set a base&quot;
	end
	irc_QueueMsg(irc_params[1], irc_params[3] .. &quot; has &quot; .. players[irc_params[2]].cash .. &quot; zennies&quot;)

	irc_QueueMsg(irc_params[1], &quot;Base status for &quot; .. irc_params[3] .. &quot; is..&quot;)
	irc_QueueMsg(irc_params[1], base)
	irc_QueueMsg(irc_params[1], &quot;The base is &quot; .. protected)
	irc_QueueMsg(irc_params[1], &quot;Protection size is &quot; .. players[irc_params[2]].protectSize .. &quot; meters&quot;)

	if (players[irc_params[2]].protectPaused ~= nil) then
		irc_QueueMsg(irc_params[1], &quot;Protection is paused&quot;)
	end


	if (players[irc_params[2]].protect2 == true) then
		protected = &quot;protected&quot;
	else
		protected = &quot;not protected (unless you have LCB's down)&quot;
	end
	
	if (players[irc_params[2]].home2X == 0 and players[irc_params[2]].home2Y == 0 and players[irc_params[2]].home2Z == 0) then
		base = &quot;Has not done /setbase&quot;	
	else
		base = &quot;Has set a base&quot;
	end

	irc_QueueMsg(irc_params[1], &quot;Second Base status for &quot; .. irc_params[3] .. &quot; is..&quot;)
	irc_QueueMsg(irc_params[1], base)
	irc_QueueMsg(irc_params[1], &quot;Base2 is &quot; .. protected)
	irc_QueueMsg(irc_params[1], &quot;Protection size is &quot; .. players[irc_params[2]].protect2Size .. &quot; meters&quot;)

	if (players[irc_params[2]].protect2Paused ~= nil) then
		irc_QueueMsg(irc_params[1], &quot;Protection is paused&quot;)
	end

	irc_QueueMsg(irc_params[1], &quot;&quot;)
end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>Gimme</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function PicknMix(mode)
	local r

	r = rand(25)
	if (r == 12) then r = PicknMix() end
	if (r == 24) then r = PicknMix() end
	return r
end


function setupArenaPlayers(pid)
	local dist
	local pointyStick
	local r
	local t
	local i
	local cmd

	t = os.time()
	arenaPlayers = {}
	arenaCount = 0

	for k, v in pairs(igplayers) do
		if (distancexyz(v.xPos, v.yPos, v.zPos, locations[&quot;arena&quot;].x, locations[&quot;arena&quot;].y, locations[&quot;arena&quot;].z) &lt; tonumber(locations[&quot;arena&quot;].size)) then

			arenaCount = arenaCount + 1
			arenaPlayers[tostring(arenaCount)] = {}
			arenaPlayers[tostring(arenaCount)].id = k

			-- give arena players stuff
			send(&quot;give &quot; .. v.id .. &quot; firstAidBandage 3&quot;)
			send(&quot;give &quot; .. v.id .. &quot; firstAidKit 2&quot;)
			send(&quot;give &quot; .. v.id .. &quot; shotgunShell 50&quot;)
			send(&quot;give &quot; .. v.id .. &quot; antibiotics 1&quot;)
  			send(&quot;give &quot; .. v.id .. &quot; pipeBomb 3&quot;)
  			send(&quot;give &quot; .. v.id .. &quot; superSpeed 2&quot;)
  			send(&quot;give &quot; .. v.id .. &quot; venisonStew 1&quot;)

			r = rand(4)
			if (r == 1) then pointyStick = &quot;boneShiv&quot; end
			if (r == 2) then pointyStick = &quot;pumpShotGun&quot; end
			if (r == 3) then pointyStick = &quot;huntingKnife&quot; end
			if (r == 4) then pointyStick = &quot;clubSpiked&quot;	 end

			send(&quot;give &quot; .. v.id .. &quot; &quot; .. pointyStick .. &quot; 1&quot;)
			message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]Supplies for the battle have been dropped at your feet. You have 10 seconds to prepare! (4 rounds)[-]&quot;)
		end
	end

	if (arenaCount == 0) then
		message(&quot;pm &quot; .. pid .. &quot; [&quot; .. server.chatColour .. &quot;]Nobody is in the arena.  You can't play from the spectator area.  Get in the arena coward.[-]&quot;)
		gimmeHell = 0
	end
end


function announceGimmeHell(wave)
	for k, v in pairs(arenaPlayers) do
		if (wave == &quot;1&quot;) then
			message(&quot;pm &quot; .. v.id .. &quot; [&quot; .. server.chatColour .. &quot;]Here they come![-]&quot;)
		else
			message(&quot;pm &quot; .. v.id .. &quot; [&quot; .. server.chatColour .. &quot;]Here comes round &quot; .. wave .. &quot;![-]&quot;)
		end
	end
end


function queueGimmeHell(wave)
	local multiplier
	local r
	local p
	local cmd
	local zedBoss = 0

	multiplier = rand(12, 7)

	if (wave == &quot;4&quot;) then
		multiplier = 2
	end

	for i = 1, arenaCount * multiplier do
		if (arenaCount &gt; 1) then
			p = rand(arenaCount)
		else
			p = 1
		end

		r = PicknMix()
		while (r == 2 or r == 12) do
			r = PicknMix()
		end

		if (wave == &quot;4&quot;) then
			r = rand(2)
			if (r == 1) then r = 2 end
			if (r == 2) then r = 12 end

			cmd = &quot;se &quot; .. players[arenaPlayers[&quot;1&quot;].id].id .. &quot; &quot; .. r
			conn:execute(&quot;INSERT into playerQueue (command, arena, boss, steam) VALUES ('&quot; .. cmd .. &quot;', true, true, &quot; .. arenaPlayers[&quot;1&quot;].id .. &quot;)&quot;)					
		else	
			cmd = &quot;se &quot; .. players[arenaPlayers[tostring(p)].id].id .. &quot; &quot; .. r
			conn:execute(&quot;INSERT into playerQueue (command, arena, steam) VALUES ('&quot; .. cmd .. &quot;', true, &quot; .. arenaPlayers[tostring(p)].id .. &quot;)&quot;)					
		end
	end	

	if (wave == &quot;4&quot;) then
		for k, v in pairs(arenaPlayers) do
			cmd = &quot;pm &quot; .. v.id .. &quot; [&quot; .. server.chatColour .. &quot;]Congratulations!  You have survived to the end of the fight!  Rest now. Tend to your wounded and mourn the fallen.[-]&quot;
			conn:execute(&quot;INSERT into playerQueue (command, arena, steam) VALUES ('&quot; .. cmd .. &quot;', true, &quot; .. v.id .. &quot;)&quot;)					
		end

--		cmd = &quot;sg MaxSpawnedZombies 50&quot;
--		conn:execute(&quot;INSERT into playerQueue (command) VALUES ('&quot; .. cmd .. &quot;')&quot;)					

		cmd = &quot;say /reset gimmehell&quot;
		conn:execute(&quot;INSERT into playerQueue (command) VALUES ('&quot; .. cmd .. &quot;')&quot;)					
	end
end


function gimmeReset()
	-- reset gimmeCount for everyone
	for k, v in pairs(players) do
		players[k].gimmeCount = 0
	end

	if (playersOnline &gt; 0) and server.allowGimme == true then
		message(&quot;say [&quot; .. server.chatColour .. &quot;]Gimme has been reset!  Type gimme to play (10 gimmies per player, 15 for donors) /help gimme for info.&quot;)
	end
end


function gimme(pid)

--display(pid)

local cmd
local pname = players[pid].name
local specialDay = &quot;&quot;
local maxGimmies
local dist

for k, v in pairs(locations) do
	dist = math.abs(distancexz(igplayers[pid].xPos, igplayers[pid].xPos, locations[k].x, locations[k].z))

	if dist &lt; 50 then
		message(&quot;pm &quot; .. pid .. &quot; [&quot; .. server.chatColour .. &quot;]Gimme cannot be played within 50 meters of a location teleport.[-]&quot;)
		faultyGimme = false
		return
	end
end

--if (string.find(serverTime, &quot;02-14&quot;, 5, 10)) then specialDay = &quot;valentine&quot; end

if (faultyGimme == true) then
	cecho(&quot;Debug&quot;, &quot;!! Fault detected in Gimme\n&quot;)
	cecho(&quot;Debug&quot;, &quot;!! Fault occurred in Gimme #: &quot; .. faultyGimmeNumber .. &quot;\n&quot;)
end

faultyGimme = true

local steamid = pid
local playerid = igplayers[pid].id

-- abort if in the library
--if (distancexyz (igplayers[steamid].xPos, igplayers[steamid].yPos, igplayers[steamid].zPos, locations[&quot;library&quot;].x, locations[&quot;library&quot;].y, locations[&quot;library&quot;].z ) &lt; 50) then
--	message(&quot;pm &quot; .. pid .. &quot; [&quot; .. server.chatColour .. &quot;]Are you nuts!? Do not play gimme in here!&quot;)
--	faultyGimme = false
--	return
--end

local zombies = tonumber(igplayers[pid].zombies)

--		maxGimmies = 11

--display(&quot;gimme here&quot;)

	if players[steamid].donor == true then
		maxGimmies = 16
	else
		maxGimmies = 11
	end
	if (players[steamid].gimmeCount &lt; tonumber(maxGimmies)) then
		players[steamid].gimmeCount = players[steamid].gimmeCount + 1
	else
		message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]You are out of gimmies.  You have to wait until the next gimme reset.[-]&quot;)
		faultyGimme = false
		return
	end


--	if zombies &gt; 3999 then
--		r = math.random(1, 45)
--	else
		r = math.random(1, 44)
--	end

-- debug testing
--if (tonumber(playerid) == 750) then r = 36 end
--display(&quot;playerid = &quot; .. playerid)

	faultyGimmeNumber = r

if r == 36 then r = 37 end


--cecho(&quot;Debug&quot;, &quot;gimme random = &quot; .. r .. &quot; player = &quot; .. pname .. &quot;\n&quot;)

	carChance = rand(20)
	if (carChance == 11) then 
		winACar = true 
	else
		winACar = false 
	end

	crateChance = rand(10)
	if (crateChance == 5) then 
		winACrate = true 
	else
		winACrate = false 
	end

--[[
  1 - zombie04
  2 - zombieferal
  3 - zombie05
  4 - zombie06
  5 - zombie07
  6 - zombie01
  7 - zombiecrawler
  8 - snowzombie01
  9 - snowzombie02
  10 - snowzombie03
  11 - spiderzombie
  12 - burntzombie
  13 - zombiegal01
  14 - zombiegal02
  15 - zombiegal03
  16 - zombiegal04
  17 - zombie02
  18 - fatzombiecop
  19 - fatzombie
  20 - hornet
  21 - zombiedog
  22 - car_Blue
  23 - car_Orange
  24 - car_Red
  25 - car_White
  26 - animalStag
  27 - animalRabbit
  28 - animalPig
  29 - supplyPlane
  30 - sc_MeleeWeapons
  31 - sc_General
  32 - zombieUMAfemale
  33 - zombieUMAmale
--]]


	if (r == 12) then r = 13 end
	if (r == 32) then r = 14 end
	if (r == 33) then r = 15 end

--	if (r == 5) then r = 6 end
--	if (r == 11) then r = 10 end

	-- get name of entity
	if (r == 1) then entity = &quot;zombie04&quot; end
	if (r == 2) then entity = &quot;zombieferal&quot; end
	if (r == 3) then entity = &quot;zombie05&quot; end
	if (r == 4) then entity = &quot;zombie06&quot; end 
	if (r == 5) then entity = &quot;zombie07&quot; end	 
	if (r == 6) then entity = &quot;zombieBoe&quot; end
	if (r == 7) then entity = &quot;zombieJoe&quot; end	 
	if (r == 8) then entity = &quot;zombieMoe&quot; end	 
	if (r == 9) then entity = &quot;zombieYo&quot; end	 
	if (r == 10) then entity = &quot;zombieSteve&quot; end	 
	if (r == 11) then entity = &quot;zombieSteveCrawler&quot; end	 
--	if (r == 12) then entity = &quot;burntzombie&quot; end	 
	if (r == 13) then entity = &quot;zombiegacrawler&quot; end	 
	if (r == 14) then entity = &quot;snowzombie01&quot; end	 
	if (r == 15) then entity = &quot;snowzombie02&quot; end	 
	if (r == 16) then entity = &quot;snowzombie03&quot; end	 
	if (r == 17) then entity = &quot;spiderzombie&quot; end	 
	if (r == 18) then entity = &quot;burntzombie&quot; end	 
	if (r == 19) then entity = &quot;zombiegal01&quot; end	 
	if (r == 20) then entity = &quot;zombiegal02&quot; end	 
	if (r == 21) then entity = &quot;zombiegal03&quot; end	 
	if (r == 22) then entity = &quot;zombiegal04&quot; end	 
	if (r == 23) then entity = &quot;zombie02&quot; end	 
	if (r == 24) then entity = &quot;fatzombiecop&quot; end	 
	if (r == 25) then entity = &quot;fatzombie&quot; end	 
	if (r == 26) then entity = &quot;zombiegal01&quot; end	 
	if (r == 27) then entity = &quot;zombiedog&quot; end	 
	if (r == 28) then entity = &quot;nothing at all!  NaDa!&quot; end	 
	if (r == 29) then entity = &quot;nothing at all!  NaDa!&quot; end	 
	if (r == 30) then entity = &quot;nothing at all!  NaDa!&quot; end	 
	if (r == 31) then entity = &quot;nothing at all!  NaDa!&quot; end	 
	if (r == 32) then entity = &quot;startled stag!&quot; end	 
	if (r == 33) then entity = &quot;grumpy bear&quot; end	 
	if (r == 34) then entity = &quot;terrified bunny!&quot; end	 
	if (r == 35) then entity = &quot;tasty pig!&quot; end	 
	if (r == 36) then entity = &quot;SUPPLIES! par avon&quot; end	 
	if (r == 37) then entity = &quot;General&quot; end	 
	if (r == 38) then entity = &quot;zombieUMAfemale&quot; end	 
	if (r == 39) then entity = &quot;zombieUMAmale&quot; end	 
	if (r == 45) then entity = &quot;BUNNIES!&quot; end	 

	spawnCount = 1

	if (r &lt; 28) then
		-- nasty zombies
		descriptor = rand(6)	
		chanceOfMultiples = rand(50)
		
		if (chanceOfMultiples &gt; 25) then
			if (zombies &gt; 99) and (zombies &lt; 300) then spawnCount = rand(3) end	
			if (zombies &gt; 299) and (zombies &lt; 500) then spawnCount = rand(4) end	
			if (zombies &gt; 499) and (zombies &lt; 800) then spawnCount = rand(5) end
			if (zombies &gt; 799) and (zombies &lt; 1000) then spawnCount = rand(6) end
			if (zombies &gt; 999) and (zombies &lt; 1500) then spawnCount = rand(7) end
			if (zombies &gt; 1499) and (zombies &lt; 2000) then spawnCount = rand(8) end
			if (zombies &gt; 1999) and (zombies &lt; 2500) then spawnCount = rand(9) end
			if (zombies &gt; 2499) and (zombies &lt; 3000) then spawnCount = rand(10) end
			if (zombies &gt; 2999) and (zombies &lt; 3500) then spawnCount = rand(11) end
			if (zombies &gt; 3499) and (zombies &lt; 4000) then spawnCount = rand(12) end
			if (zombies &gt; 3999) and (zombies &lt; 4500) then spawnCount = rand(13) end

			if (zombies &gt; 4499) and (zombies &lt; 5000) then spawnCount = rand(14) end
			if (zombies &gt; 4999) and (zombies &lt; 5500) then spawnCount = rand(15) end
			if (zombies &gt; 5499) and (zombies &lt; 6000) then spawnCount = rand(16) end
			if (zombies &gt; 5999) and (zombies &lt; 6500) then spawnCount = rand(17) end
			if (zombies &gt; 6499) and (zombies &lt; 7000) then spawnCount = rand(18) end
			if (zombies &gt; 6999) and (zombies &lt; 7500) then spawnCount = rand(19) end
			if (zombies &gt; 7499) then spawnCount = rand(50) end
		end

if entity == &quot;zombieferal&quot; then
	spawnCount = rand(3)
end

--cecho(&quot;Debug&quot;, &quot;spawnCount = &quot; .. spawnCount .. &quot;\n&quot;)

		coffee = &quot;&quot;
		if (tonumber(gameHour) &gt; 21 or tonumber(gameHour) &lt; 7) then coffee = &quot;caffeinated &quot; end

		-- set up critter description
		if (spawnCount == 1) then
			if (descriptor == 1) then
				description = &quot;a surprised &quot; .. coffee
			end
			
			if (descriptor == 2) then
				description = &quot;an angry &quot; .. coffee
			end	
			
			if (descriptor == 3) then
				description = &quot;a very dangerous &quot; .. coffee
			end	
			
			if (descriptor == 4) then
				description = &quot;a murderous &quot; .. coffee
			end		
			
			if (descriptor == 5) then
				description = &quot;a pissed off &quot; .. coffee
			end		
			
			if (descriptor == 6) then
				description = &quot;an adorable &quot; .. coffee
			end		
		else
			if (descriptor == 1) then
				description = &quot;surprised &quot; .. coffee
			end
			
			if (descriptor == 2) then
				description = &quot;angry &quot; .. coffee
			end	
			
			if (descriptor == 3) then
				description = &quot;very dangerous &quot; .. coffee
			end	
			
			if (descriptor == 4) then
				description = &quot;murderous &quot; .. coffee
			end		
			
			if (descriptor == 5) then
				description = &quot;pissed off &quot; .. coffee
			end		
			
			if (descriptor == 6) then
				description = &quot;adorable &quot; .. coffee
			end			
		end	

		if (specialDay == &quot;valentine&quot;) then
			if (spawnCount == 1) then
				if (descriptor == 1) then
					description = &quot;a romantic &quot; .. coffee
				end
				
				if (descriptor == 2) then
					description = &quot;an attractive &quot; .. coffee
				end	
				
				if (descriptor == 3) then
					description = &quot;a very special &quot; .. coffee
				end	
				
				if (descriptor == 4) then
					description = &quot;a besotted &quot; .. coffee
				end		
				
				if (descriptor == 5) then
					description = &quot;a single and looking &quot; .. coffee
				end		
				
				if (descriptor == 6) then
					description = &quot;an eligible &quot; .. coffee
				end		
			else
				if (descriptor == 1) then
					description = &quot;eligible &quot; .. coffee
				end
				
				if (descriptor == 2) then
					description = &quot;super sexy &quot; .. coffee
				end	
				
				if (descriptor == 3) then
					description = &quot;lusty &quot; .. coffee
				end	
				
				if (descriptor == 4) then
					description = &quot;infatuated &quot; .. coffee
				end		
				
				if (descriptor == 5) then
					description = &quot;approachable &quot; .. coffee
				end		
				
				if (descriptor == 6) then
					description = &quot;gorgeous &quot; .. coffee
				end			
			end	
		end
	else
		-- spawning a crate or car etc

		if (r == 22) then
--			description =  &quot;a shiny &quot;
		end	
		
		if (r == 23) then
--			description =  &quot;a scratched &quot;
		end		
		
		if (r == 24) then
--			description =  &quot;a &quot;
		end	

		if (r == 25) then
--			description =  &quot;a &quot;
		end		
		
		if (r == 26) then
--			description =  &quot;a &quot;
		end			
		
		if (r == 27) then
--			description =  &quot;a &quot;
		end				
		
		if (r == 28) then
--			description =  &quot;a &quot;
		end				
		
		if (r == 29) then
--			description =  &quot;&quot;
		end			
		
		if (r == 30) then
--			description =  &quot;a crate labelled &quot;
		end		
		
		if (r == 31) then
--			description =  &quot;a crate labelled &quot;
		end			
	end

	if (r == 29) then 
		r = rand(204)

		qty = rand(gimmePrizes[r].limit)
		
		description = &quot;&quot;
		if (qty == 1) then description = &quot;a &quot; end
		
		if (gimmePrizes[r].category == &quot;weapon&quot;) then
			descr = rand(12)
		
			if (descr==1) then description = description .. &quot;shiny new &quot; end
			if (descr==2) then description = description .. &quot;dangerous &quot; end			
			if (descr==3) then description = description .. &quot;sharp &quot; end						
			if (descr==4) then description = description .. &quot;well crafted &quot; end						
			if (descr==5) then description = description .. &quot;knock-off &quot; end									
			if (descr==6) then description = description .. &quot;banged up &quot; end									
			if (descr==7) then description = description .. &quot;basic &quot; end									
			if (descr==8) then description = description .. &quot;barely used &quot; end									
			if (descr==9) then description = description .. &quot;blood stained &quot; end												
			if (descr==10) then description = description .. &quot;common &quot; end												
			if (descr==11) then description = description .. &quot;dull &quot; end															
			if (descr==12) then description = description .. &quot;rusty &quot; end															
		end			
		
		if (gimmePrizes[r].category == &quot;book&quot;) then
			descr = rand(12)
		
			if (descr==1) then description = description .. &quot;rare &quot; end
			if (descr==2) then description = description .. &quot;wordy &quot; end			
			if (descr==3) then description = description .. &quot;well written &quot; end						
			if (descr==4) then description = description .. &quot;useful &quot; end						
			if (descr==5) then description = description .. &quot;tatty old &quot; end									
			if (descr==6) then description = description .. &quot;scruffy &quot; end									
			if (descr==7) then description = description .. &quot;faded &quot; end									
			if (descr==8) then description = description .. &quot;torn &quot; end									
			if (descr==9) then description = description .. &quot;soggy &quot; end												
			if (descr==10) then description = description .. &quot;dirty &quot; end												
			if (descr==11) then description = description .. &quot;chewed &quot; end															
			if (descr==12) then description = description .. &quot;ratty &quot; end															
		end			
		
		if (gimmePrizes[r].category == &quot;misc&quot;) then
			descr = rand(12)
		
			if (descr==1) then description = description .. &quot;common &quot; end
			if (descr==2) then description = description .. &quot;boring &quot; end			
			if (descr==3) then description = description .. &quot;interesting &quot; end						
			if (descr==4) then description = description .. &quot;damaged &quot; end						
			if (descr==5) then description = description .. &quot;rare &quot; end									
			if (descr==6) then description = description .. &quot;stupid &quot; end									
			if (descr==7) then description = description .. &quot;stinky &quot; end									
			if (descr==8) then description = description .. &quot;useless &quot; end									
			if (descr==9) then description = description .. &quot;amazing &quot; end												
			if (descr==10) then description = description .. &quot;collectable &quot; end												
			if (descr==11) then description = description .. &quot;dull &quot; end															
			if (descr==12) then description = description .. &quot;uninteresting &quot; end															
		end				
		
		if (gimmePrizes[r].category == &quot;health&quot;) then
			descr = rand(10)
		
			if (descr==1) then description = description .. &quot;dodgy &quot; end
			if (descr==2) then description = description .. &quot;sterile &quot; end			
			if (descr==3) then description = description .. &quot;generic &quot; end						
			if (descr==4) then description = description .. &quot;expensive &quot; end						
			if (descr==5) then description = description .. &quot;highly saught after &quot; end									
			if (descr==6) then description = description .. &quot;common &quot; end									
			if (descr==7) then description = description .. &quot;knock-off &quot; end									
			if (descr==8) then description = description .. &quot;yucky &quot; end									
			if (descr==9) then description = description .. &quot;gross &quot; end												
			if (descr==10) then description = description .. &quot;spare &quot; end												
		end			
		
		if (gimmePrizes[r].category == &quot;food&quot;) then
			descr = rand(12)
		
			if (descr==1) then description = description .. &quot;delicious &quot; end
			if (descr==2) then description = description .. &quot;yummy &quot; end			
			if (descr==3) then description = description .. &quot;yucky &quot; end						
			if (descr==4) then description = description .. &quot;tasty &quot; end						
			if (descr==5) then description = description .. &quot;bland &quot; end									
			if (descr==6) then description = description .. &quot;boring &quot; end									
			if (descr==7) then description = description .. &quot;expired &quot; end									
			if (descr==8) then description = description .. &quot;chewy &quot; end									
			if (descr==9) then description = description .. &quot;crunchy &quot; end												
			if (descr==10) then description = description .. &quot;tainted &quot; end												
			if (descr==11) then description = description .. &quot;stinky &quot; end															
			if (descr==12) then description = description .. &quot;funky &quot; end															
		end	
		
		if (gimmePrizes[r].category == &quot;tools&quot;) then
			descr = rand(10)
		
			if (descr==1) then description = description .. &quot;handy &quot; end
			if (descr==2) then description = description .. &quot;utilitarian &quot; end			
			if (descr==3) then description = description .. &quot;dirty &quot; end						
			if (descr==4) then description = description .. &quot;rusty &quot; end						
			if (descr==5) then description = description .. &quot;sturdy &quot; end									
			if (descr==6) then description = description .. &quot;ACME &quot; end									
			if (descr==7) then description = description .. &quot;knock-off &quot; end									
			if (descr==8) then description = description .. &quot;genuine &quot; end									
			if (descr==9) then description = description .. &quot;basic &quot; end												
			if (descr==10) then description = description .. &quot;designer &quot; end												
		end		
		
		if (gimmePrizes[r].category == &quot;clothes&quot;) then
			descr = rand(10)
		
			if (descr==1) then description = description .. &quot;shitty &quot; end
			if (descr==2) then description = description .. &quot;sturdy &quot; end			
			if (descr==3) then description = description .. &quot;tatty &quot; end						
			if (descr==4) then description = description .. &quot;used &quot; end						
			if (descr==5) then description = description .. &quot;brand new &quot; end									
			if (descr==6) then description = description .. &quot;soiled &quot; end									
			if (descr==7) then description = description .. &quot;boring &quot; end									
			if (descr==8) then description = description .. &quot;fabulous &quot; end									
			if (descr==9) then description = description .. &quot;natty &quot; end												
			if (descr==10) then description = description .. &quot;stylish &quot; end												

			if (gimmePrizes[r].name == &quot;santaHat&quot;) then description = description .. &quot;very festive &quot; end
		end
		
		description = description .. gimmePrizes[r].name
		
		if (qty &gt; 1) then
			description = qty .. &quot; &quot; .. description .. &quot;s&quot;
		end
				
		if (not server.gimmePeace) then			
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won &quot; .. description .. &quot;[-]&quot;)
		else
			message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won &quot; .. description .. &quot;[-]&quot;)
		end	
		
		send(&quot;give &quot; .. steamid .. &quot; &quot; .. gimmePrizes[r].name .. &quot; &quot; .. qty)

		faultyGimme = false
		return 
	end

	if (r == 32) then
--		if (zombies &lt; 99) then
			if (not server.gimmePeace) then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; almost won a prize![-]&quot;)
			else
				message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; almost won a prize![-]&quot;)
			end
--		else 
--			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; has won a trip to Real Life! You have 20 seconds to pack your stuff!  Bon Voyage!&quot;)
--			cmd = &quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; Here comes your prize!&quot;
--			tempTimer( 15, [[message(&quot;]] .. cmd .. [[&quot;)]] )

--			cmd = &quot;kick &quot; .. pname .. &quot; You won a trip to Real Life!  See you back soon =D&quot;
--			tempTimer( 20, [[send(&quot;]] .. cmd .. [[&quot;)]] )
--		end

		faultyGimme = false
		return 
	end

	if (r == 45) then
		spawnCount = rand(7,2)
		if (not server.gimmePeace) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won &quot; .. spawnCount .. &quot; BUNNIES![-]&quot;)
		else
			message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won &quot; .. spawnCount .. &quot; BUNNIES![-]&quot;)
		end

		for i = 1, spawnCount do
			cmd = &quot;se &quot; .. playerid .. &quot; 27&quot;
			conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('&quot; .. cmd .. &quot;', &quot; .. steamid .. &quot;)&quot;)
		end

		faultyGimme = false
		return
	end

	if (r == 34) then
		r = rand(100)
		if (r &lt; 70) then
			if (not server.gimmePeace) then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; almost won an epic prize![-]&quot;)
			else
				message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; almost won an epic prize![-]&quot;)
			end

			faultyGimme = false
			return
		end

		if (not server.gimmePeace) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won epic litter![-]&quot;)
		else
			message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won epic litter![-]&quot;)
		end

		t = os.time()
		for i = 1, 100 do
			r = rand(7)
		
			if (r == 1) then litter = &quot;canEmpty&quot; end
			if (r == 2) then litter = &quot;candyTin&quot; end
			if (r == 3) then litter = &quot;paper&quot; end
			if (r == 4) then litter = &quot;scrapIron&quot; end
			if (r == 5) then litter = &quot;brownGrassDiagonal&quot; end
			if (r == 6) then litter = &quot;dirt&quot; end
			if (r == 6) then litter = &quot;bulletCasing&quot; end
			if (r == 7) then litter = &quot;emptyJar&quot; end

			cmd = &quot;give &quot; .. playerid .. &quot; &quot; .. litter .. &quot; 1&quot;
			conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('&quot; .. cmd .. &quot;', &quot; .. steamid .. &quot;)&quot;)
		end

		faultyGimme = false
		return
	end

	if (r == 35) then
		item = rand(12)
		if (item == 1) then prize = &quot;canBeef&quot; end
		if (item == 2) then prize = &quot;canChili&quot; end
		if (item == 3) then prize = &quot;canPasta&quot; end
		if (item == 4) then prize = &quot;gasCan&quot; end
		if (item == 5) then prize = &quot;firstAidBandage&quot; end
		if (item == 6) then prize = &quot;beer&quot; end
		if (item == 7) then prize = &quot;shades&quot; end
		if (item == 8) then prize = &quot;bottledWater&quot; end
		if (item == 9) then prize = &quot;baconAndEggs&quot; end
		if (item == 10) then prize = &quot;vegetableStew&quot; end
		if (item == 11) then prize = &quot;goldenRodTea&quot; end
		if (item == 12) then prize = &quot;coffee&quot; end

		for k, v in pairs(igplayers) do
			if (k ~= steamid) then send(&quot;give &quot; .. k .. &quot; &quot; .. prize .. &quot; 1&quot;) end
		end

		message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won a &quot; .. prize .. &quot; for everyone! One for you, one for you, and you and.. oh sorry &quot; .. pname .. &quot; none left.[-]&quot;)
		message(&quot;say [&quot; .. server.chatColour .. &quot;]Everyone else collect your prize![-]&quot;)
		faultyGimme = false
		return
	end


	if (r == 36) then
		message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won a free skydiving trip.  Happy flight &quot; .. pname .. &quot;![-]&quot;)

		-- first record their current x y z
		players[steamid].xPosOld = math.floor(igplayers[steamid].xPos)
		players[steamid].yPosOld = math.ceil(igplayers[steamid].yPos) + 1
		players[steamid].zPosOld = math.floor(igplayers[steamid].zPos)
	
		-- then teleport the player to timeout
		send (&quot;tele &quot; .. steamid .. &quot; &quot; .. locations[&quot;timeout&quot;].x .. &quot; 600 &quot; .. locations[&quot;timeout&quot;].z)

		descr = rand(5)
		if (descr == 1) then cmd = &quot;say [&quot; .. server.chatColour .. &quot;]OH NO! &quot; .. pname .. &quot; forgot the parachute![-]&quot; end
		if (descr == 2) then cmd = &quot;say [&quot; .. server.chatColour .. &quot;]OH NO! This isn't the right drop zone![-]&quot; end
		if (descr == 3) then cmd = &quot;say [&quot; .. server.chatColour .. &quot;]God knows why &quot; .. pname .. &quot; wanted to jump there.  That area's full of zombies![-]&quot; end
		if (descr == 4) then cmd = &quot;say [&quot; .. server.chatColour .. &quot;]Don't forget to pull the cord![-]&quot; end
		if (descr == 5) then cmd = &quot;say [&quot; .. server.chatColour .. &quot;]OMG The pilot's infected! He's gone berzerk.. We're going down!  AAAAAAAAAH![-]&quot; end
		tempTimer( 5, [[message(&quot;]] .. cmd .. [[&quot;)]] )
		cmd = &quot;say /return &quot; .. pname
		tempTimer( 30, [[message(&quot;]] .. cmd .. [[&quot;)]] )

		faultyGimme = false
		return
	end


	if (r == 37) and auto == false then
		descr = rand(8)

		if (descr == 1) then cmd = &quot;Blue smoke!&quot; end
		if (descr == 2) then cmd = &quot;Orange flames!&quot; end
		if (descr == 3) then cmd = &quot;Black smoke!&quot; end

		if (descr == 4) then 
			cmd = &quot;*BZZT*  Oh no!  It's eaten another gimmie![-]&quot; 
			players[steamid].gimmeCount = players[steamid].gimmeCount + 1
		end

		if (descr == 5) then
			i = rand(4)
 
			cmd = i .. &quot; extra gimmies! =D&quot; 
			players[steamid].gimmeCount = players[steamid].gimmeCount - i
		end

		if (descr &gt; 5 and descr &lt; 9) then
			r = rand(20)
			 if (not server.gimmePeace) then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; Ruh Roh! Gimmies short circuited!  You win..[-]&quot;)
				cmd = &quot;say Every panels lit up! OMG! Zombies are coming out of the walls! RUN !![-]&quot; 
			else
				message(&quot;pm [&quot; .. server.chatColour .. &quot;]&quot; .. playerid .. &quot; Ruh Roh! Gimmies short circuited!  You win..[-]&quot;)
				cmd = &quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Every panels lit up! OMG! Zombies are coming out of the walls! RUN !![-]&quot; 
			end

			tempTimer( 1, [[message(&quot;]].. cmd .. [[&quot;)]] )

			for i = 1, r do
				z = rand(17)
				if z == 5 then z = 4 end
				if z == 11 then z = 10 end
				cmd = &quot;se &quot; .. playerid .. &quot; &quot; .. z
				conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('&quot; .. cmd .. &quot;', &quot; .. steamid .. &quot;)&quot;)
			end

			faultyGimme = false
			return
		end

		if (not server.gimmePeace) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; Ruh Roh! Gimmies short circuited!  You win..[-]&quot;)
			cmd = &quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. cmd .. &quot;[-]&quot;
			tempTimer( 2, [[message(&quot;]].. cmd .. [[&quot;)]] )
		else
			cmd = &quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. cmd .. &quot;[-]&quot;
			tempTimer( 2, [[message(&quot;]].. cmd .. [[&quot;)]] )
		end	

		faultyGimme = false
		return	
	end


	if (r == 38) then
		if (not server.gimmePeace) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]HAPPY BIRTHDAY &quot; .. pname .. &quot;!  We got you a puppy![-]&quot;)
		else
			message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]HAPPY BIRTHDAY &quot; .. pname .. &quot;! We got you a puppy![-]&quot;)
		end

		cmd = &quot;se &quot; .. playerid .. &quot; 21&quot;
		conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('&quot; .. cmd .. &quot;', &quot; .. steamid .. &quot;)&quot;)

		faultyGimme = false
		return
	end


	if (r == 39) then
		if (not server.gimmePeace) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]You won a HUGE STEAK!!! &quot; .. pname .. &quot;!  But this guy ate it :(  Deal with him![-]&quot;)
		else
			message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]You won a HUGE STEAK!!! &quot; .. pname .. &quot;!  But this guy ate it :(  Deal with him![-]&quot;)
		end

		cmd = &quot;se &quot; .. playerid .. &quot; 19&quot;
		conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('&quot; .. cmd .. &quot;', &quot; .. steamid .. &quot;)&quot;)

		faultyGimme = false
		return
	end


	if (r == 40) then
		if (not server.gimmePeace) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won invisiblity!  Press Alt-F4 to claim your prize!!![-]&quot;)
		else
			message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]You won invisiblity!  Press Alt-F4 to claim your prize!!![-]&quot;)
		end

		faultyGimme = false
		return
	end


	if (r == 41) then
		spawnCount = rand(15,5)
		if (not server.gimmePeace) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; ate a bad potato and is shitting potatoes everywhere![-]&quot;)
		else
			message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; ate a bad potato and is shitting potatoes everywhere![-]&quot;)
		end

		for i = 1, spawnCount do
			cmd = &quot;give &quot; .. playerid .. &quot; potato 1&quot;
			conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('&quot; .. cmd .. &quot;', &quot; .. steamid .. &quot;)&quot;)
		end

		faultyGimme = false
		return
	end

	if (r == 42) then
		if (not server.gimmePeace) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; voted first place WINNER! Here's your trophy.[-]&quot;)
		else
			message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; voted first place WINNER! Here's your trophy.[-]&quot;)
		end

		cmd = &quot;give &quot; .. playerid .. &quot; trophy3 1&quot;
		conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('&quot; .. cmd .. &quot;', &quot; .. steamid .. &quot;)&quot;)

		faultyGimme = false
		return
	end


	if (r == 43) then
		if (not server.gimmePeace) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won a care package via air drop.  Gee I hope the pilot knows where the drop zone is![-]&quot;)
		else
			message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won a care package via air drop.  Gee I hope the pilot knows where the drop zone is![-]&quot;)
		end

		send(&quot;spawnairdrop&quot;)

		faultyGimme = false
		return
	end


	if (r == 44) then
		players[steamid].baseCooldown = 0
		conn:execute(&quot;UPDATE players SET baseCooldown = 0 WHERE steam = &quot; .. steamid)

		if (not server.gimmePeace) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won a get out of Dodge free card!  Their base cooldown has been reset.[-]&quot;)
		else
			message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won a get out of Dodge free card!  Your base cooldown has been reset.[-]&quot;)
		end

		faultyGimme = false
		return
	end	


	if (r == 45) then
		message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won stealthy Ninja Zombies!  Only they know when they will strike![-]&quot;)
		NinjaZombies(playerid)

		faultyGimme = false
		return
	end	


	if (r &gt; 29) then
		if (not server.gimmePeace) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; did not win a prize.[-]&quot;)
		else
			message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; did not win a prize.[-]&quot;)
		end

		faultyGimme = false
		return
	end


	if (r &gt; 21) and (r &lt; 26) then
		if (not server.gimmePeace) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]You lose!  Try again &quot; .. pname .. &quot;[-]&quot;)
		else
			message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]You lose!  Try again &quot; .. pname .. &quot;[-]&quot;)
		end

		faultyGimme = false
		return
	end


	if (spawnCount == 1) then
		if (not server.gimmePeace) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won &quot; .. description .. entity .. &quot;[-]&quot;)
		else
			message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won &quot; .. description .. entity .. &quot;[-]&quot;)
		end
	else
		if (zombies &gt; 2499) then
			descr = &quot; won &quot; .. spawnCount .. &quot; Pick 'N Mix Zombies!&quot;

			if spawnCount == 6 then
				descr = &quot; won a 6 pack of Ready-To-Die zombies!&quot;
			end

			if spawnCount == 12 then
				descr = &quot; won a 12 pack of zombies!&quot;
			end

			if spawnCount == 13 then
				descr = &quot; won a bakers dozen of zombies!&quot;
			end

			if spawnCount == 24 then
				descr = &quot; won a hearty 24 pack of zombies!&quot;
			end

			if spawnCount == 50 then
				descr = &quot; won ALL THE ZOMBIES!&quot;
			end

			if (not server.gimmePeace) then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. descr .. &quot;[-]&quot;)
			else
				message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. descr .. &quot;[-]&quot;)
			end
		else
			if (not server.gimmePeace) then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won &quot; .. spawnCount .. &quot; &quot; .. description .. entity ..&quot;s![-]&quot;)
			else
				message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won &quot; .. spawnCount .. &quot; &quot; .. description .. entity ..&quot;s![-]&quot;)
			end
		end
	end

	if (spawnCount == 1) then
		cmd = &quot;se &quot; .. playerid .. &quot; &quot; .. r
		conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('&quot; .. cmd .. &quot;', &quot; .. steamid .. &quot;)&quot;)

		if (specialDay == &quot;valentine&quot;) then 
			z = rand(4)
			if z == 1 then send(&quot;give &quot; .. playerid .. &quot; yellowflower 1&quot;) end
			if z == 2 then send(&quot;give &quot; .. playerid .. &quot; plantChrysanthemum 1&quot;) end
			if z == 3 then send(&quot;give &quot; .. playerid .. &quot; goldenrod 1&quot;) end
			if z == 4 then send(&quot;give &quot; .. playerid .. &quot; cotton 1&quot;) end
		end
	else
		if (zombies &gt; 2499) then
			for i = 1, spawnCount do
				cmd = &quot;se &quot; .. playerid .. &quot; &quot; .. PicknMix()
				conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('&quot; .. cmd .. &quot;', &quot; .. steamid .. &quot;)&quot;)
			end
		else
			for i = 1, spawnCount do
				cmd = &quot;se &quot; .. playerid .. &quot; &quot; .. r
				conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('&quot; .. cmd .. &quot;', &quot; .. steamid .. &quot;)&quot;)

				if (specialDay == &quot;valentine&quot;) then 
					z = rand(4)
					if z == 1 then cmd = &quot;give &quot; .. playerid .. &quot; yellowflower 1&quot; end
					if z == 2 then cmd = &quot;give &quot; .. playerid .. &quot; plantChrysanthemum 1&quot; end
					if z == 3 then cmd = &quot;give &quot; .. playerid .. &quot; goldenrod 1&quot; end
					if z == 4 then cmd = &quot;give &quot; .. playerid .. &quot; cotton 1&quot; end

					conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('&quot; .. cmd .. &quot;', &quot; .. steamid .. &quot;)&quot;)
				end
			end
		end
	end

	faultyGimme = false
	return
end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>IRCMessage</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


local ircid, pid, login, name1, name2, words, wordsOld, words2, wordCount, result, msgLower, number, counter, xpos, zpos, debug, tmp

debug = false

function requireLogin(name)
	irc_QueueMsg(name, &quot;Your login has expired. Login and and repeat your command.&quot;)
end

IRCMessage = function (event, name, channel, msg)
	if lastIRC == msg then
		server.ircBotName = name
	end

	if debug then 
		dbug(&quot;debug ircmessage&quot;) 
		dbug(event .. &quot; &quot; .. name .. &quot; &quot; .. channel .. &quot; &quot; .. msg)
	end

	-- block Mudlet from messaging the official Mudlet support channel
	if (channel == &quot;#mudlet&quot;) then return end

	-- block Mudlet from reacting to its own messages
	if (name == server.botName or name == server.ircBotName or string.find(msg, &quot;&lt;&quot; .. server.ircBotName .. &quot;&gt;&quot;)) then return end

	wordsOld = {}
	for word in msg:gmatch(&quot;%S+&quot;) do table.insert(wordsOld, word) end

	words2 = string.split(msg, &quot; &quot;)
	msgLower = string.lower(msg)

	words = {}
	irc_params = {}
	ircid = LookupOfflinePlayer(name, &quot;all&quot;)

if ircid ~= nil and debug then
	dbug(&quot;ircid &quot; .. ircid)
end

	if ircid ~= nil then
		if players[ircid].ircAuthenticated == true then
			-- keep login session alive
			if accessLevel(ircid) &lt; 4 then
				players[ircid].ircSessionExpiry = os.time() + 600
			else
				players[ircid].ircSessionExpiry = os.time() + 10800
			end
		end
	end

	if debug then dbug(&quot;debug ircmessage 2&quot;) end

	table.insert(irc_params, name)
	for word in msgLower:gmatch(&quot;%w+&quot;) do table.insert(words, word) end
	wordCount = table.maxn(words)

	number = tonumber(string.match(msg, &quot; (-?\%d+)&quot;))

		if words[1] == &quot;check&quot; and words[2] == &quot;dns&quot; then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end

			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			pid = &quot;&quot;
			number = &quot;&quot;

			for i=3,wordCount,1 do
				if words2[i] == &quot;dns&quot; then
					name1 = words2[i+1]
					pid = LookupPlayer(name1)
				end					

				if words2[i] == &quot;ip&quot; then
					number = words2[i+1]
				end	
			end


			if pid ~= &quot;&quot; and number ~= &quot;&quot; then
				irc_QueueMsg(irc_params[1], &quot;Checking DNS record for &quot; .. pid .. &quot; IP &quot; .. number)
				CheckBlacklist(pid, number)
			end

			irc_QueueMsg(irc_params[1], &quot;&quot;)											
			return
		end	

	if (words[1] == &quot;hi&quot; or words[1] == &quot;hello&quot;) and (string.lower(words[2]) == string.lower(server.botName) or string.lower(words[2]) == string.lower(server.ircBotName) or words[2] == &quot;bot&quot; or words[2] == &quot;server&quot;) then
		table.insert(irc_params, &quot; Hi there &quot; .. name .. &quot;!  How can I help you today?&quot;)
		irc_QueueMsg(name, irc_params[2])
		return
	end


	if (words[1] == &quot;owners&quot; and words[2] == nil) then
		irc_List_Owners(name)
		return
	end


	if (words[1] == &quot;admins&quot; and words[2] == nil) then
		irc_List_Admins(name)
		return
	end


	if (words[1] == &quot;mods&quot; and words[2] == nil) then
		irc_List_Mods(name)
		return
	end


	if words[1] == string.lower(server.botName) or words[1] == string.lower(server.ircBotName) and words[2] == nil then
		irc_params = {}
		table.insert(irc_params, server.ircMain)
		table.insert(irc_params, &quot; Hi &quot; .. name)
		irc_QueueMsg(irc_params[1], irc_params[2])
		return
	end


	if (words[1] == &quot;say&quot;) then
		if players[ircid].ircAuthenticated == false then
			requireLogin(name)
			return
		end

		msg = string.trim(string.sub(msg, 5))
		message(&quot;say &quot; .. name .. &quot;-irc: [i]&quot; .. msg .. &quot;[/i][-]&quot;)
		return
	end


	if (string.find(words[1], &quot;say&quot;) and (string.len(words[1]) == 5) and words[2] ~= nil) then
		if players[ircid].ircAuthenticated == false then
			requireLogin(name)
			return
		end

		msg = string.sub(msg, string.len(words[1]) + 2)
		msg = string.trim(msg)

		if (msg ~= &quot;&quot;) then
			Translate(ircid, msg, string.sub(words[1], 4), true)
		end

		return
	end


	if (words[1] == &quot;date&quot; or words[1] == &quot;time&quot; or words[1] == &quot;day&quot;) and words[2] == nil then
		irc_gameTime(channel)
		return
	end


	if (words[1] == &quot;uptime&quot;) and words[2] == nil then
		irc_uptime(channel)
		return
	end


	if words[1] == &quot;new&quot; and words[2] == &quot;players&quot; then
		pid = LookupOfflinePlayer(name, &quot;all&quot;)

		if number == nil then 
			number = 86400 
		else
			number = number * 86400
		end

		irc_QueueMsg(name, &quot;New players in the last &quot; .. math.floor(number / 86400) .. &quot; days:&quot;)

		cursor,errorString = conn:execute(&quot;SELECT * FROM events where timestamp &gt;= '&quot; .. os.date('%Y-%m-%d %H:%M:%S', os.time() - number).. &quot;' and type = 'new player' order by timestamp desc&quot;)
		row = cursor:fetch({}, &quot;a&quot;)

		while row do
			if accessLevel(pid) &gt; 3 then
				irc_QueueMsg(name, v.name) 
			else
				msg = &quot;steam: &quot; .. row.steam .. &quot; id: &quot; .. string.format(&quot;%8d&quot;, players[row.steam].id) .. &quot; name: &quot; .. players[row.steam].name .. &quot; at [ &quot; .. players[row.steam].xPos .. &quot; &quot; .. players[row.steam].yPos .. &quot; &quot; .. players[row.steam].zPos .. &quot; ] &quot; .. players[row.steam].country
				msg = msg .. &quot; PVP &quot; .. players[row.steam].playerKills

				if (igplayers[row.steam]) then
					time = tonumber(players[row.steam].timeOnServer) + tonumber(igplayers[row.steam].sessionPlaytime)
				else
					time = tonumber(players[row.steam].timeOnServer)
				end

				hours = math.floor(time / 3600)

				if (hours &gt; 0) then
					time = time - (hours * 3600)
				end

				minutes = math.floor(time / 60)

				msg = msg .. &quot; Playtime &quot; .. hours .. &quot;h &quot; .. minutes .. &quot;m&quot;

				cursor2,errorString = conn:execute(&quot;SELECT * FROM bans WHERE steam =  &quot; .. row.steam)
				if cursor2:numrows() &gt; 0 then
					msg = msg .. &quot; BANNED&quot;
				end

				if players[row.steam].timeout == true then
					msg = msg .. &quot; TIMEOUT&quot;
				end

				if players[row.steam].country == &quot;CN&quot; or players[row.steam].country == &quot;HK&quot; then
					msg = msg .. &quot; Chinese&quot;
				end

				irc_QueueMsg(name, msg)
			end

			row = cursor:fetch(row, &quot;a&quot;)	
		end
	
		irc_QueueMsg(name, &quot;&quot;)
		return
	end

	if words[1] == &quot;server&quot; and (words[2] == &quot;status&quot; or words[2] == &quot;stats&quot;) then
		irc_server_status(name)
		return
	end


	if (words[1] == &quot;who&quot; and words[2] == nil) then
		irc_players(name)
		return
	end


	if (words[1] == &quot;help&quot; and words[2] == &quot;shop&quot;) then
		irc_HelpShop()
		return
	end


	if (words[1] == &quot;help&quot; and words[2] == &quot;topics&quot;) then
		if words[3] ~= nil then
			table.insert(irc_params, words[3])
		end

		irc_HelpTopics()
		return
	end


	if (words[1] == &quot;help&quot; and words[2] == nil) then
		irc_commands()
		return
	end
	
	
	if (words[1] == &quot;help&quot; and words[2] == &quot;server&quot;) then
		irc_HelpServer()
		return
	end


	if (words[1] == &quot;help&quot; and words[2] == &quot;donors&quot;) then
		irc_HelpDonors()
		return
	end
	
	
	if (words[1] == &quot;help&quot; and words[2] == &quot;csi&quot;) then
		irc_HelpCSI()
		return
	end


	if (words[1] == &quot;help&quot; and words[2] == &quot;watchlist&quot;) then
		irc_HelpWatchlist()
		return
	end
	
	
	if (words[1] == &quot;help&quot; and words[2] == &quot;bad&quot; and words[3] == &quot;items&quot;) then
		irc_HelpBadItems()
		return
	end


	if (words[1] == &quot;help&quot; and words[2] == &quot;announcements&quot;) then
		irc_HelpAnnouncements()
		return
	end


	if (words[1] == &quot;help&quot; and words[2] == &quot;commands&quot;) then
		irc_HelpCommands()
		return
	end


	if (words[1] == &quot;help&quot; and words[2] == &quot;custom&quot; and words[3] == &quot;commands&quot;) then
		irc_HelpCustomCommands()
		return
	end


	if (words[1] == &quot;help&quot; and words[2] == &quot;motd&quot;) then
		irc_HelpMOTD()
		return
	end


	if (words[1] == &quot;reset&quot; and words[2] == &quot;zones&quot; and words[3] == nil) then
		irc_listResetZones(name)
		return
	end


	if (words[1] == &quot;locations&quot; and words[2] == nil) then
		irc_locations(name)	
		return
	end


	if (words[1] == &quot;villages&quot; and words[2] == nil) then
		irc_List_Villages(name)
		return
	end


	if words[1] == &quot;fps&quot; and words[2] == nil then
		cursor,errorString = conn:execute(&quot;SELECT * FROM performance  ORDER BY serverdate DESC Limit 0, 1&quot;)
		row = cursor:fetch({}, &quot;a&quot;)

		if row then
			irc_QueueMsg(channel, &quot;Server FPS: &quot; .. server.fps .. &quot; Players: &quot; .. row.players .. &quot; Zombies: &quot; .. row.zombies .. &quot; Entities: &quot; .. row.entities)
		end

		return
	end	


	if words[1] == &quot;shop&quot; and shopCategories[words[2]] then
		LookupShop(words[2], true)	

		cursor,errorString = conn:execute(&quot;SELECT * FROM memShop ORDER BY idx&quot;)
		row = cursor:fetch({}, &quot;a&quot;)

		while row do
			if tonumber(row.stock) == -1 then
				msg = &quot;Code:  &quot; .. row.code .. &quot;    item:  &quot; .. row.item .. &quot;    price:  &quot; .. row.price .. &quot; UNLIMITED&quot;
			else
				msg = &quot;Code:  &quot; .. row.code .. &quot;    item:  &quot; .. row.item .. &quot; price: &quot; .. row.price .. &quot;  (&quot; .. row.stock .. &quot;)  left&quot;
			end

			irc_QueueMsg(irc_params[1], msg)
			row = cursor:fetch(row, &quot;a&quot;)	
		end

		irc_QueueMsg(irc_params[1], &quot;&quot;)											
		return
	end	


	if (words[1] == &quot;shop&quot; and words[2] == &quot;categories&quot;) then		
		irc_QueueMsg(irc_params[1], &quot;The shop categories are:&quot;)

		for k, v in pairs(shopCategories) do
			irc_QueueMsg(irc_params[1], k)
		end

		irc_QueueMsg(irc_params[1], &quot;&quot;)				
		return
	end	


	if (words[1] == &quot;shop&quot; and words[2] ~= nil and words[3] == nil) then
		LookupShop(wordsOld[2], true)		

		cursor,errorString = conn:execute(&quot;SELECT * FROM memShop ORDER BY category, idx&quot;)
		row = cursor:fetch({}, &quot;a&quot;)

		while row do
			if tonumber(row.stock) == -1 then
				msg = &quot;Code:  &quot; .. row.code .. &quot;    item:  &quot; .. row.item .. &quot;    price:  &quot; .. row.price .. &quot; UNLIMITED&quot;
			else
				msg = &quot;Code:  &quot; .. row.code .. &quot;    item:  &quot; .. row.item .. &quot; price: &quot; .. row.price .. &quot;  (&quot; .. row.stock .. &quot;)  left&quot;
			end

			irc_QueueMsg(irc_params[1], msg)

			row = cursor:fetch(row, &quot;a&quot;)	
		end

		irc_QueueMsg(irc_params[1], &quot;&quot;)				
		return
	end	


	if words[1] == &quot;nuke&quot; or words[1] == &quot;clear&quot; and words[2] == &quot;irc&quot; then
		conn:execute(&quot;DELETE FROM ircQueue WHERE name = '&quot; .. name .. &quot;'&quot;)
		irc_QueueMsg(channel, &quot;IRC spam nuked for &quot; .. name)

		if ircListItems == ircid then ircListItems = nil end

		if echoConsoleTo == name then
			echoConsole = nil
			echoConsoleTo = nil
		end
	end
	
	
	if (words[1] == &quot;server&quot;) then
		if words[2] == &quot;ip&quot; or words[2] == &quot;address&quot; and (string.trim(words[3]) ~= &quot;&quot;) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end			
		
			server.IP = string.sub(msg, string.find(msg, words[3]), string.len(msg))
			table.insert(irc_params, &quot;The server address is now &quot; .. server.IP .. &quot;:&quot; .. server.ServerPort)
			irc_message()

			conn:execute(&quot;UPDATE server SET IP = '&quot; .. server.IP .. &quot;'&quot;)

			return
		end

		if words[2] == nil then
			irc_QueueMsg(irc_params[1], &quot;Server name is &quot; .. server.ServerName)
			irc_QueueMsg(irc_params[1], &quot;Address is &quot; .. server.IP .. &quot;:&quot; .. server.ServerPort)
			irc_QueueMsg(irc_params[1], &quot;There are  &quot; .. playersOnline .. &quot; players online.&quot;)
			return
		end
	end


	if (words[1] == &quot;rules&quot;) then
		if words[2] == nil then
			table.insert(irc_params, &quot;The server rules are &quot; .. server.rules)
			irc_message()
			return
		else
			table.insert(irc_params, &quot;To change the rules type set rules &lt;new rules&gt;&quot;)
			irc_message()
			return
		end
	end	
	
	
	if debug then dbug(&quot;debug ircmessage 3&quot;) end

	if (ircid ~= nil) and (accessLevel(ircid) &lt; 3) then
-- ########### Staff only in this section ###########

		if debug then dbug(&quot;debug ircmessage 4&quot;) end
	
		if words[1] == &quot;view&quot; and words[2] == &quot;alerts&quot; then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if number == nil then number = 20 end

			cursor,errorString = conn:execute(&quot;SELECT * FROM alerts order by alertID desc limit &quot; .. number)
			if cursor:numrows() == 0 then
				irc_QueueMsg(irc_params[1], &quot;There are no alerts recorded.&quot;)
			else
				irc_QueueMsg(irc_params[1], &quot;The most recent alerts are:&quot;)
				row = cursor:fetch({}, &quot;a&quot;)
				while row do
					msg = &quot;On &quot; .. row.timestamp .. &quot; player &quot; .. players[row.steam].name .. &quot; at &quot; .. row.x .. &quot; &quot; .. row.y .. &quot; &quot; .. row.z .. &quot; said &quot; .. row.message
					irc_QueueMsg(irc_params[1], msg)
					row = cursor:fetch(row, &quot;a&quot;)	
				end
			end

			irc_QueueMsg(irc_params[1], &quot;&quot;)											
			return
		end	

		if debug then dbug(&quot;debug ircmessage 5&quot;) end

		if words[1] == &quot;show&quot; and words[2] == &quot;inventory&quot; then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			if words[3] == nil then
				irc_QueueMsg(irc_params[1], &quot;Full example.. show inventory player Joe xpos 100 zpos 200 days 2 range 50 item tnt qty 20&quot;)
				irc_QueueMsg(irc_params[1], &quot;You can grab the coords from any player by adding, near joe&quot;)
				irc_QueueMsg(irc_params[1], &quot;Defaults: days = 1, range = 100km, xpos = 0, zpos = 0&quot;)
				irc_QueueMsg(irc_params[1], &quot;Optional: player (or near) joe, days 1, hours 1, range 50, item tin, qty 10, xpos 0, zpos 0, session 1&quot;)
				irc_QueueMsg(irc_params[1], &quot;&quot;)
				return
			end

			name1 = nil
			pid = nil
			days = 1
			hours = 0
			range = 100000
			item = nil
			xpos = 0
			zpos = 0
			qty = nil
			session = 0

			for i=3,wordCount,1 do
				if words2[i] == &quot;player&quot; then
					name1 = words2[i+1]
					pid = LookupPlayer(name1)
				end					
					
				if words2[i] == &quot;days&quot; then
					days = tonumber(words2[i+1])
				end								

				if words2[i] == &quot;hours&quot; then
					hours = tonumber(words2[i+1])
					days = 0
				end								

				if words2[i] == &quot;range&quot; then
					range = tonumber(words2[i+1])
				end	

				if words2[i] == &quot;item&quot; then
					item = words2[i+1]
				end	

				if words2[i] == &quot;qty&quot; then
					qty = words2[i+1]
				end	

				if words2[i] == &quot;xpos&quot; then
					xpos = tonumber(words2[i+1])
				end	

				if words2[i] == &quot;zpos&quot; then
					zpos = tonumber(words2[i+1])
				end	

				if words2[i] == &quot;session&quot; then
					session = words2[i+1]
				end	

				if words2[i] == &quot;near&quot; then
					name2 = words2[i+1]
					pid2 = LookupPlayer(name2)

					if pid2 ~= nil then
						xpos = players[pid2].xPos
						zpos = players[pid2].zPos
					end
				end		
			end

			if days == 0 then
				sql = &quot;SELECT * FROM inventoryChanges WHERE abs(x - &quot; .. xpos .. &quot;) &lt;= &quot; .. range .. &quot; AND abs(z - &quot; .. zpos .. &quot;) &lt;= &quot; .. range .. &quot; AND timestamp &gt;= '&quot; .. os.date(&quot;%Y-%m-%d %H:%M:%S&quot;, os.time() - (tonumber(hours) * 3600)) .. &quot;' &quot;
			else
				sql = &quot;SELECT * FROM inventoryChanges WHERE abs(x - &quot; .. xpos .. &quot;) &lt;= &quot; .. range .. &quot; AND abs(z - &quot; .. zpos .. &quot;) &lt;= &quot; .. range .. &quot; AND timestamp &gt;= '&quot; .. os.date(&quot;%Y-%m-%d %H:%M:%S&quot;, os.time() - (tonumber(days) * 86400)) .. &quot;' &quot;
			end

			if session ~= 0 then
				sql = &quot;SELECT * FROM inventoryChanges WHERE abs(x - &quot; .. xpos .. &quot;) &lt;= &quot; .. range .. &quot; AND abs(z - &quot; .. zpos .. &quot;) &lt;= &quot; .. range .. &quot; AND session = &quot; .. session .. &quot; &quot;
			end

			if pid ~= nil then
				sql = sql .. &quot;AND steam = &quot; .. pid .. &quot; &quot;
			end

			if qty ~= nil then
				if tonumber(qty) &gt; 0 then
					sql = sql .. &quot;AND delta &gt; &quot; .. qty .. &quot; &quot;
				else
					sql = sql .. &quot;AND delta &lt; &quot; .. qty .. &quot; &quot;
				end
			end

			if item ~= nil then
				sql = sql .. &quot;AND item like '%&quot; .. item .. &quot;%'&quot;
			end

			irc_QueueMsg(irc_params[1], &quot;Inventory tracking data for query:&quot;)
			irc_QueueMsg(irc_params[1], sql)

			cursor,errorString = conn:execute(sql)
			if cursor:numrows() == 0 then
				irc_QueueMsg(irc_params[1], &quot;No inventory tracking is recorded for your search parameters.&quot;)
			else
				irc_QueueMsg(irc_params[1], &quot;&quot;)
				irc_QueueMsg(irc_params[1], &quot;   id   |      steam       |      timestamp     |    item     | qty | x y z | session | name&quot;)
				row = cursor:fetch({}, &quot;a&quot;)

				rows = cursor:numrows()

				if rows &gt; 50 then
					irc_QueueMsg(name, &quot;***** Report length &quot; .. rows .. &quot; rows.  Cancel it with: nuke irc *****&quot;)
				end

				while row do
					msg = row.id .. &quot;, &quot; .. row.steam .. &quot;, &quot; .. row.timestamp .. &quot;, &quot; .. row.item .. &quot;, &quot; .. row.delta .. &quot;, &quot; .. row.x .. &quot; &quot; .. row.y .. &quot; &quot; .. row.z .. &quot;, &quot; .. row.session .. &quot;, &quot; .. players[row.steam].name
					irc_QueueMsg(irc_params[1], msg)
					row = cursor:fetch(row, &quot;a&quot;)	
				end
			end

			irc_QueueMsg(irc_params[1], &quot;&quot;)
			return
		end

		if debug then dbug(&quot;debug ircmessage 6&quot;) end

		if words[1] == &quot;announcements&quot; then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			counter = 1
			cursor,errorString = conn:execute(&quot;SELECT * FROM announcements&quot;)
			if cursor:numrows() == 0 then
				irc_QueueMsg(irc_params[1], &quot;There are no announcements recorded.&quot;)
			else
				irc_QueueMsg(irc_params[1], &quot;The server announcements are:&quot;)
				row = cursor:fetch({}, &quot;a&quot;)
				while row do
					msg = &quot;Announcement (&quot; .. counter .. &quot;) &quot; .. row.message
					counter = counter + 1
					irc_QueueMsg(irc_params[1], msg)
					row = cursor:fetch(row, &quot;a&quot;)	
				end
			end

			irc_QueueMsg(irc_params[1], &quot;&quot;)
			return
		end

		if debug then dbug(&quot;debug ircmessage 7&quot;) end

		if words[1] == &quot;add&quot; and words[2] == &quot;announcement&quot; and words[3] ~= nil then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			msg = string.sub(msg, 17, string.len(msg))

			conn:execute(&quot;INSERT INTO announcements (message, startdate, enddate) VALUES ('&quot; .. escape(msg) .. &quot;',&quot; .. os.date(&quot;%Y-%m-%d&quot;, os.time()) .. &quot;,'2020-01-01')&quot;)

			irc_QueueMsg(irc_params[1], &quot;New announcement added.&quot;)
			irc_QueueMsg(irc_params[1], &quot;&quot;)
			return
		end

		if debug then dbug(&quot;debug ircmessage 8&quot;) end

		if words[1] == &quot;delete&quot; and words[2] == &quot;announcement&quot; and words[3] ~= nil then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			counter = 1
			cursor,errorString = conn:execute(&quot;SELECT * FROM announcements&quot;)
			row = cursor:fetch({}, &quot;a&quot;)
			while row do
				if tonumber(number) == counter then
					conn:execute(&quot;DELETE FROM announcements WHERE id = &quot; .. row.id)
				end

				counter = counter + 1
				row = cursor:fetch(row, &quot;a&quot;)	
			end

			irc_QueueMsg(irc_params[1], &quot;Announcement &quot; .. number .. &quot; deleted.&quot;)
			irc_QueueMsg(irc_params[1], &quot;&quot;)
			return
		end

		if debug then dbug(&quot;debug ircmessage 9&quot;) end

		if (words[1] == &quot;who&quot; and words[2] == &quot;visited&quot;) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end
			
			if words[3] == nil then
				irc_QueueMsg(irc_params[1], &quot;See who visited a player location or base.&quot;)
				irc_QueueMsg(irc_params[1], &quot;Example with defaults:  who visited smeg days 1 range 10 height 4&quot;)
				irc_QueueMsg(irc_params[1], &quot;Example with coords:  who visited xpos 0 zpos 0 ypos 100 height 5 days 1 range 20&quot;)
				irc_QueueMsg(irc_params[1], &quot;Setting hours will reset days to zero&quot;)						
				irc_QueueMsg(irc_params[1], &quot;Defaults: days = 1 or hours = 0, range = 10&quot;)
				irc_QueueMsg(irc_params[1], &quot;To see who visited a player's bases add bases at the end.  To report at players position and bases add all.&quot;)
				irc_QueueMsg(irc_params[1], &quot;&quot;)
				return
			end			

			-- irc_params[1] == irc user
			-- irc_params[2] == target steam id
			-- irc_params[3] == distance (optional default=10
			-- irc_params[4] == days (optional default=1

			-- optional params
				-- range &lt;distance in metres&gt; Default 10
				-- days.  Default is 1 day ago from today (local time not server)

			if words[3] ~= &quot;player&quot; then
				name1 = string.trim(words[3])
			else
				name1 = string.trim(words[4])
			end

			pid = LookupPlayer(name1)
			days = 1
			hours = 0
			range = 10
			basesOnly = &quot;player&quot;

			if pid ~= nil then
				xpos = players[pid].xPos
				ypos = players[pid].yPos
				zpos = players[pid].zPos
			end

			for i=3,wordCount,1 do
				if words[i] == &quot;range&quot; then
					range = tonumber(words[i+1])
				end					
					
				if words[i] == &quot;days&quot; then
					days = tonumber(words[i+1])
					hours = 0
				end								

				if words[i] == &quot;hours&quot; then
					hours = tonumber(words[i+1])
					days = 0
				end								

				if words[i] == &quot;base&quot; then
					baseOnly = &quot;base&quot;
				end	

				if words[i] == &quot;all&quot; then
					baseOnly = &quot;all&quot;
				end	

				if words[i] == &quot;xpos&quot; then
					xpos = tonumber(words[i+1])
				end	

				if words[i] == &quot;ypos&quot; then
					ypos = tonumber(words[i+1])
				end	

				if words[i] == &quot;zpos&quot; then
					zpos = tonumber(words[i+1])
				end	

				if words[i] == &quot;height&quot; then
					height = tonumber(words[i+1])
				end	
			end

			if basesOnly == &quot;base&quot; or basesOnly == &quot;all&quot; then
				if players[pid].homeX ~= 0 and players[pid].homeZ ~= 0 then
					irc_QueueMsg(irc_params[1], &quot;Players who visited within &quot; .. range .. &quot; metres of base 1 of &quot; .. players[pid].name)
					dbWho(irc_params[1], players[pid].homeX, players[pid].homeY, players[pid].homeZ, range, days, hours, height)
				else
					irc_QueueMsg(irc_params[1], &quot;Player &quot; .. players[pid].name .. &quot; does not have a base set.&quot;)
				end

				if players[pid].home2X ~= 0 and players[pid].home2Z ~= 0 then
					irc_QueueMsg(irc_params[1], &quot;&quot;)
					irc_QueueMsg(irc_params[1], &quot;Players who visited within &quot; .. range .. &quot; metres of base 2 of &quot; .. players[pid].name)
					dbWho(irc_params[1], players[pid].home2X, players[pid].home2Y, players[pid].home2Z, range, days, hours, height)
				end
			end

			if basesOnly == &quot;player&quot; or basesOnly == &quot;all&quot; then
				irc_QueueMsg(irc_params[1], &quot;Players who visited within &quot; .. range .. &quot; metres (X) &quot; .. players[pid].xPos .. &quot; (Z) &quot; .. players[pid].zPos .. &quot; of player &quot; .. players[pid].name)
				dbWho(irc_params[1], players[pid].xPos, players[pid].yPos, players[pid].zPos, range, days, hours, height)
			end

			irc_QueueMsg(irc_params[1], &quot;&quot;)

			return
		end

		if debug then dbug(&quot;debug ircmessage 10&quot;) end

		if (words[1] == &quot;pay&quot;) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			name1 = string.sub(msg, string.find(msg, &quot; to &quot;) + 4, string.len(msg))
			name1 = string.trim(name1)
			pid = LookupPlayer(name1)

			players[pid].cash = players[pid].cash + number		
			message(&quot;pm &quot; .. pid .. &quot; &quot; .. players[ircid].name .. &quot; just paid you &quot; .. number .. &quot; zennies!  You now have &quot; .. players[pid].cash .. &quot; zennies!  KA-CHING!!&quot;)

			msg = &quot;You just paid &quot; .. number .. &quot; zennies to &quot; .. players[pid].name .. &quot; giving them a total of &quot; .. players[pid].cash .. &quot; zennies.&quot;
			irc_QueueMsg(irc_params[1], msg)
			return
		end

		if debug then dbug(&quot;debug ircmessage 11&quot;) end

		if (words[1] == &quot;claims&quot;) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			pid = nil

			if (words[2] ~= nil) then
				name1 = string.sub(msg, string.find(msgLower, &quot;claims&quot;) + 7)
				name1 = string.trim(name1)
				pid = LookupPlayer(name1)
			end

			if pid ~= nil then
				if players[pid].keystones == 0 then
					msg = players[pid].name .. &quot; has not placed any claims.&quot;
  					irc_QueueMsg(irc_params[1], msg)
					return
				end
			end


			if pid == nil then
				for k, v in pairs(players) do
					if tonumber(v.keystones) &gt; 0 then
						msg = v.keystones .. &quot;   claims belong to &quot; .. k .. &quot; &quot; .. v.name
						irc_QueueMsg(irc_params[1], msg)
					end
				end
			else
				msg = players[pid].name .. &quot; has placed &quot; .. players[pid].keystones .. &quot; at these coordinates..&quot;
				irc_QueueMsg(irc_params[1], msg)

				cursor,errorString = conn:execute(&quot;SELECT * FROM keystones WHERE steam = &quot; .. pid)
				row = cursor:fetch({}, &quot;a&quot;)
				while row do
					msg = row.x .. &quot; &quot; .. row.y .. &quot; &quot; .. row.z
					irc_QueueMsg(irc_params[1], msg)
					row = cursor:fetch(row, &quot;a&quot;)	
				end
			end

			irc_QueueMsg(irc_params[1], &quot;&quot;)
			return
		end

		if debug then dbug(&quot;debug ircmessage 12&quot;) end

		if (words[1] == &quot;cmd&quot;) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			msg = string.trim(string.sub(msg, string.find(msgLower, &quot;cmd&quot;) + 4))
			message(&quot;say &quot; .. msg)
			return
		end

		if debug then dbug(&quot;debug ircmessage 13&quot;) end

		if (words[1] == &quot;pm&quot;) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end

			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			pid = LookupPlayer(words[2])
			msg = string.sub(msg, string.find(msg, words2[2]) + string.len(words2[2]) + 1)
			message(&quot;pm &quot; .. pid .. &quot; &quot; .. name .. &quot;-irc: [i]&quot; .. msg .. &quot;[-]&quot;)
			return
		end

		if debug then dbug(&quot;debug ircmessage 14&quot;) end

-- ************************************************************************************************8
		if (words[1] == &quot;con&quot;) and accessLevel(ircid) == 0 then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			msg = string.lower(string.trim(string.sub(msg, string.find(msgLower, &quot;con&quot;) + 4)))
			send(msg)

			if string.sub(msg, 1, 4) == &quot;help&quot; then
				echoConsoleTo = name
				tempTimer( 2, [[ echoConsoleTo = nil ]] )
				tempTimer( 2, [[ echoConsole = nil ]] )
			end

			if msg == &quot;se&quot; or msg == &quot;ban list&quot; or msg == &quot;gg&quot; or string.sub(msg, 1, 3) == &quot;si &quot; or string.sub(msg, 1, 3) == &quot;llp&quot; then
				echoConsoleTo = name
				echoConsoleTrigger = &quot;&quot;

				if string.sub(msg, 1, 3) == &quot;si &quot; then
					echoConsoleTrigger = string.sub(msg, 4)
				end

				tempTimer( 2, [[ echoConsoleTo = nil ]] )
				tempTimer( 2, [[ echoConsole = nil ]] )
			end

			return
		end
-- ************************************************************************************************8

		if debug then dbug(&quot;debug ircmessage 15&quot;) end

		if (words[1] == &quot;villagers&quot; and words[2] == nil) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_List_Villagers(name)
			return
		end


		if (words[1] == &quot;base&quot;) and (words[2] == &quot;cooldown&quot; or words[2] == &quot;timer&quot;) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			if words[3] == nil then
				table.insert(irc_params, &quot;/base can only be used once every &quot; .. (server.baseCooldown / 60) .. &quot; minutes for players and &quot; .. math.floor((server.baseCooldown / 60) / 2) .. &quot; minutes for donors.&quot;)
				irc_message()
				return
			end

			if words[3] ~= nil then
				server.baseCooldown = tonumber(words[3])
				table.insert(irc_params, &quot; The base cooldown timer is now &quot; .. (server.baseCooldown / 60) .. &quot; minutes for players and &quot; .. math.floor((server.baseCooldown / 60) / 2) .. &quot; minutes for donors.&quot;)
				irc_message()

				conn:execute(&quot;UPDATE server SET baseCooldown = 0&quot;)
				return
			end
		end


		if (words[1] == &quot;set&quot; and words[2] == &quot;rules&quot;) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			if words[3] ~= nil then
				server.rules = string.sub(msg, string.find(msgLower, &quot;set rules&quot;) + 9)
				table.insert(irc_params, &quot;New server rules recorded. &quot; .. server.rules)
				irc_message()

				conn:execute(&quot;UPDATE server SET rules = '&quot; .. server.rules .. &quot;'&quot;)
				return
			end
		end


		if (words[1] == &quot;motd&quot;) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			if words[2] == nil then
				table.insert(irc_params, &quot;MOTD is &quot; .. server.MOTD)
				irc_message()
				return
			end

			if words[2] == &quot;delete&quot; or words[2] == &quot;clear&quot; then
				server.MOTD = nil
				table.insert(irc_params, &quot;Message of the day has been deleted.&quot;)
				irc_message()

				conn:execute(&quot;UPDATE server SET MOTD = ''&quot;)
				return
			end

			table.insert(irc_params, &quot;To change the MOTD type set motd &lt;new message of the day&gt;&quot;)
			irc_message()
			return
		end


		if (words[1] == &quot;set&quot; and words[2] == &quot;motd&quot;) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			if words[3] ~= nil then
				server.MOTD = string.sub(msg, string.find(msgLower, &quot;set motd&quot;) + 9)
				table.insert(irc_params, &quot;New message of the day recorded. &quot; .. server.MOTD)
				irc_message()

				conn:execute(&quot;UPDATE server SET MOTD = '&quot; .. server.MOTD .. &quot;'&quot;)
				return
			end
		end


		if (words[1] == &quot;list&quot;) and (words[2] == &quot;tables&quot;) and (words[3] == nil) and (accessLevel(ircid) == 0) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_ListTables()
			return
		end


		if (words[1] == &quot;show&quot;) and (words[2] == &quot;table&quot;) and (words[3] ~= nil) and (accessLevel(ircid) == 0) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			name1 = string.trim(string.sub(msg, string.find(msgLower, &quot;table&quot;) + 6))
			table.insert(irc_params, name1)
			irc_ShowTable()
			return
		end


		if (words[1] == &quot;reset&quot;) and (words[2] == &quot;bot&quot;) and (accessLevel(ircid) == 0) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end
			
			irc_params = {}
			table.insert(irc_params, server.ircMain)
			
			if resetbotCount == nil then resetbotCount = 0 end
			
			if tonumber(resetbotCount) &lt; 5 then
				resetbotCount = tonumber(resetbotCount) + 1
				table.insert(irc_params, &quot;ALERT! Only do this after a server wipe!  To reset the bot spam the reset bot command 5 more times.&quot;)
			end

			ResetBot()
			
			resetbotCount = nil

			table.insert(irc_params, &quot;The bot has been reset.  All bases, inventories etc are forgotten, but not the players.&quot;)
			irc_message()
			return
		end


		if words[1] == &quot;stop&quot; and words[2] == &quot;translating&quot; and words[3] ~= nil then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			name1 = string.sub(msg, string.find(msgLower, &quot;translating&quot;) + 11)
			name1 = string.trim(name1)
			pid = LookupPlayer(name1)

			if (pid ~= nil) then
				players[pid].ircTranslate = nil
				players[pid].translate = nil
				table.insert(irc_params, &quot;Chat from &quot; .. players[pid].name .. &quot; will not be translated&quot;)
				irc_message()

				conn:execute(&quot;UPDATE players SET translate = 0, ircTranslate = 0 WHERE steam = &quot; .. pid)
			else
				table.insert(irc_params, &quot;No player found matching &quot; .. name1)
				irc_message()
			end

			return
		end


		if words[1] == &quot;translate&quot; and words[2] ~= nil then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			name1 = string.sub(msg, string.find(msgLower, &quot;translate&quot;) + 10)
			name1 = string.trim(name1)
			pid = LookupPlayer(name1)

			if (pid ~= nil) then
				players[pid].translate = true
				table.insert(irc_params, &quot;Chat from &quot; .. players[pid].name .. &quot; will be translated in-game&quot;)
				irc_message()

				conn:execute(&quot;UPDATE players SET translate = 1 WHERE steam = &quot; .. pid)
			else
				table.insert(irc_params, &quot;No player found matching &quot; .. name1)
				irc_message()
			end

			return
		end


		if words[1] == &quot;stealth&quot; and words[2] == &quot;translate&quot; and words[3] ~= nil then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			name1 = string.sub(msg, string.find(msgLower, &quot;translate&quot;) + 10)
			name1 = string.trim(name1)
			pid = LookupPlayer(name1)

			if (pid ~= nil) then
				players[pid].ircTranslate = true
				table.insert(irc_params, &quot;Chat from &quot; .. players[pid].name .. &quot; will be translated to irc only&quot;)
				irc_message()

				conn:execute(&quot;UPDATE players SET ircTranslate = 1 WHERE steam = &quot; .. pid)
			else
				table.insert(irc_params, &quot;No player found matching &quot; .. name1)
				irc_message()
			end

			return
		end
		
		
		if (words[1] == &quot;open&quot; and words[2] == &quot;shop&quot;) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			server.allowShop = true
			
			table.insert(irc_params, &quot;Players can use the shop and play in the lottery.&quot;)
			irc_message()

			conn:execute(&quot;UPDATE server SET allowShop = 1&quot;)
			return
		end			
		
		
		if (words[1] == &quot;close&quot; and words[2] == &quot;shop&quot;) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			server.allowShop = false
			
			table.insert(irc_params, &quot;Only staff can use the shop.&quot;)
			irc_message()

			conn:execute(&quot;UPDATE server SET allowShop = 0&quot;)
			return
		end					


		if (words[1] == &quot;shop&quot; and words[2] == &quot;variation&quot; and words[3] ~= nil) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			LookupShop(words[3])

			table.insert(irc_params, &quot;You have changed the price variation for &quot; .. shopItem .. &quot; to &quot; .. words2[4])
			irc_message()

			conn:execute(&quot;UPDATE shop SET variation = &quot; .. tonumber(words2[4]) .. &quot; WHERE item = '&quot; .. escape(shopItem) .. &quot;'&quot;)
			return
		end	


		if (words[1] == &quot;shop&quot; and words[2] == &quot;special&quot; and words[3] ~= nil) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			LookupShop(words[3], true)
			
			if shopItem == &quot;&quot; then
				irc_QueueMsg(irc_params[1], &quot;The item &quot; .. words[3] .. &quot; does not exist.&quot;)			
				return
			end

			table.insert(irc_params, &quot;You have changed the special for &quot; .. shopItem .. &quot; to &quot; .. words2[4])
			irc_message()

			conn:execute(&quot;UPDATE shop SET special = &quot; .. tonumber(words2[4]) .. &quot; WHERE item = '&quot; .. escape(shopItem) .. &quot;'&quot;)
			return
		end	


		if (words[1] == &quot;shop&quot; and words[2] == &quot;price&quot; and words[3] ~= nil) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			LookupShop(words[3], true)
			
			if shopItem == &quot;&quot; then
				irc_QueueMsg(irc_params[1], &quot;The item &quot; .. words[3] .. &quot; does not exist.&quot;)			
				return
			end			

			table.insert(irc_params, &quot;You have changed the price for &quot; .. shopItem .. &quot; to &quot; .. words2[4])
			irc_message()

			conn:execute(&quot;UPDATE shop SET price = &quot; .. tonumber(words2[4]) .. &quot; WHERE item = '&quot; .. escape(shopItem) .. &quot;'&quot;)
			return
		end	


		if (words[1] == &quot;shop&quot; and words[2] == &quot;max&quot; and words[3] ~= nil) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			LookupShop(words[3], true)
			
			if shopItem == &quot;&quot; then
				irc_QueueMsg(irc_params[1], &quot;The item &quot; .. words[3] .. &quot; does not exist.&quot;)			
				return
			end			

			table.insert(irc_params, &quot;You have changed the max stock level for &quot; .. shopItem .. &quot; to &quot; .. words[4])
			irc_message()

			conn:execute(&quot;UPDATE shop SET maxStock = &quot; .. tonumber(words2[4]) .. &quot; WHERE item = '&quot; .. escape(shopItem) .. &quot;'&quot;)
			return
		end	


		if (words[1] == &quot;shop&quot; and words[2] == &quot;restock&quot; and words[3] ~= nil) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			LookupShop(wordsOld[3], true)
			shopStock = tonumber(words2[4])
			
			if shopItem == &quot;&quot; then
				irc_QueueMsg(irc_params[1], &quot;The item &quot; .. wordsOld[3] .. &quot; does not exist.&quot;)			
				return
			end

			if (shopStock &lt; 0) then
				shopStock = -1
				irc_QueueMsg(irc_params[1], shopItem .. &quot; now has unlimited stock&quot;)
			else
				irc_QueueMsg(irc_params[1], &quot;There are now &quot; .. shopStock .. &quot; of &quot; .. shopItem .. &quot; for sale.&quot;)
			end

			conn:execute(&quot;UPDATE shop SET stock = &quot; .. shopStock .. &quot; WHERE item = '&quot; .. escape(shopItem) .. &quot;'&quot;)
			return
		end
		
		
		if (words[1] == &quot;shop&quot; and words[2] == &quot;add&quot; and words[3] == &quot;category&quot;) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end		

			shopCategories[words[4]] = {}
			
			for i=2,wordCount,1 do 			
				if words[i] == &quot;code&quot; then
					shopCategories[words[4]].code  = words[i+1]
					shopCategories[words[4]].index = 1

					conn:execute(&quot;INSERT INTO shopCategories (category, idx, code) VALUES ('&quot; .. escape(words[4]) .. &quot;',1,'&quot; .. escape(words[i+1]) .. &quot;')&quot;)
				end					
			end

			if (shopCategories[words[4]].code == nil) then
				irc_QueueMsg(irc_params[1], &quot;A code is required. Do not include numbers in the code.&quot;)
				return
			end
			
			irc_QueueMsg(irc_params[1], &quot;You added or updated the category &quot; .. words[4] .. &quot;.&quot;)
			return
		end	
		
		
		if (words[1] == &quot;shop&quot; and words[2] == &quot;remove&quot; and words[3] == &quot;category&quot;) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end
			
			if not shopCategories[words[4]] then
				irc_QueueMsg(irc_params[1], &quot;The category &quot; .. words[4] .. &quot; does not exist.&quot;)
				return
			end

			shopCategories[words[4]] = nil
			conn:execute(&quot;DELETE FROM shopCategories WHERE category = '&quot; .. escape(words[4]) .. &quot;')&quot;)
			conn:execute(&quot;UPDATE shop SET category = '' WHERE category = '&quot; .. escape(words[4]) .. &quot;')&quot;)
			
			irc_QueueMsg(irc_params[1], &quot;You removed the &quot; .. words[4] .. &quot; category from the shop.  Any items using it now have no category.&quot;)
			return
		end			
		
		
		if (words[1] == &quot;shop&quot; and words[2] == &quot;change&quot; and words[3] == &quot;category&quot;) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			if words[5] == &quot;to&quot; then
				oldCategory = words[4]
				newCategory = words[6]
			else
				oldCategory = words[4]			
				newCategory = words[5]				
			end
			
			if not shopCategories[oldCategory] then
				irc_QueueMsg(irc_params[1], &quot;The category &quot; .. words[4] .. &quot; does not exist.&quot;)
				return
			end
		
			shopCategories[oldCategory] = nil
			shopCategories[newCategory] = {}

			conn:execute(&quot;UPDATE shopCategories SET category = '&quot; .. escape(newCategory) .. &quot;' WHERE category = '&quot; .. escape(oldCategory) .. &quot;')&quot;)
			conn:execute(&quot;UPDATE shop SET category = '&quot; .. escape(newCategory) .. &quot;' WHERE category = '&quot; .. escape(oldCategory) .. &quot;')&quot;)
			
			for i=2,wordCount,1 do 			
				if words[i] == &quot;code&quot; then
					shopCategories[newCategory].code  = words[i+1]
				end					
			end
			
			irc_QueueMsg(irc_params[1], &quot;You changed category &quot; .. oldCategory .. &quot; to &quot; .. newCategory .. &quot;. Any items using &quot; .. oldCategory .. &quot; have been updated.&quot;)
			return
		end		


		if (words[1] == &quot;inv&quot;) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			name1 = string.trim(string.sub(msg, string.find(msgLower, &quot;inv&quot;) + 4))
			pid = LookupPlayer(name1)

			if (pid ~= nil) then
				table.insert(irc_params, pid)
				table.insert(irc_params, players[pid].name)
				irc_NewInventory(pid)
			end

			return
		end
		

		if (words[1] == &quot;list&quot; and words[2] == &quot;villagers&quot; and words[3] ~= nil) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			name1 = string.sub(msg, string.find(msgLower, &quot;villagers&quot;) + 10)
			name1 = string.trim(name1)
			pid = LookupVillage(name1)

			if (pid ~= nil) then
				table.insert(irc_params, pid)
				table.insert(irc_params, players[pid].name)
				irc_ListVillagers()
			else	
				table.insert(irc_params, &quot;No village found matching &quot; .. name1)
				irc_message()
			end

			return
		end


		if words[1] == &quot;list&quot; and (words[2] == &quot;bases&quot; or words[3] == &quot;bases&quot;) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			pid = nil
			for i=2,wordCount,1 do
				if words[i] == &quot;bases&quot; then
					pid = words[i+1]
				end	
			end

			if words[2] == &quot;protected&quot; then
				table.insert(irc_params, &quot;protected&quot;)
			else
				table.insert(irc_params, &quot;all&quot;)
			end

			if pid ~= nil then
				pid = LookupPlayer(pid)
			end

			irc_ListBases(pid)

			return
		end


		if (words[1] == &quot;add&quot; and words[2] == &quot;bad&quot; and words[3] == &quot;item&quot; and words[4] ~= nil and accessLevel(ircid) == 0) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			name1 = wordsOld[4]

			-- add the bad item to badItems table
			badItems[name1] = {}

			conn:execute(&quot;INSERT INTO badItems (item) VALUES ('&quot; .. escape(name1) .. &quot;')&quot;)

			table.insert(irc_params, name1 .. &quot; has been added to the bad items list.&quot;)
			irc_message()

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			table.insert(irc_params, name1 .. &quot; has been added to the bad items list.&quot;)
			irc_message()

			return
		end


		if (words[1] == &quot;remove&quot; and words[2] == &quot;bad&quot; and words[3] == &quot;item&quot; and words[4] ~= nil and accessLevel(ircid) == 0) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			name1 = wordsOld[4]

			-- remove the bad item from the badItems table
			badItems[name1] = nil

			conn:execute(&quot;DELETE FROM badItems WHERE item = '&quot; .. escape(name1) .. &quot;'&quot;)

			table.insert(irc_params, name1 .. &quot; has been removed from the bad items list.&quot;)
			irc_message()

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			table.insert(irc_params, name1 .. &quot; has been removed from the bad items list.&quot;)
			irc_message()

			return
		end


		if (words[1] == &quot;near&quot;) and words[2] ~= nil then	
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end	
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end
			
			name1 = words[2]
			number = nil
			
			for i=3,wordCount,1 do
				if words[i] == &quot;range&quot; then
					number = tonumber(words[i+1])
				end						
			end			
	
			name1 = string.trim(name1)
			pid = LookupPlayer(name1)

			if (pid ~= nil) then
				table.insert(irc_params, pid)
				table.insert(irc_params, players[pid].name)
				if number ~= nil then
					table.insert(irc_params, number)
				end

				irc_PlayersNearPlayer()
				irc_BasesNearPlayer()
			else	
				table.insert(irc_params, &quot;No player found matching &quot; .. name1)
				irc_message()
			end

			return
		end


		if (words[1] == &quot;bases&quot; or words[1] == &quot;homes&quot;) and words[2] == &quot;near&quot; and words[3] ~= nil then	
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end	
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			if string.find(msgLower, &quot;range&quot;) then
				name1 = string.sub(msg, string.find(msgLower, &quot;near&quot;) + 5, string.find(msgLower, &quot;range&quot;) - 1)
				number = string.sub(msg, string.find(msgLower, &quot;range&quot;) + 6)
			else
				name1 = string.sub(msg, string.find(msgLower, &quot;near&quot;) + 5)
			end

			name1 = string.trim(name1)
			pid = LookupPlayer(name1)

			if (pid ~= nil) then
				table.insert(irc_params, pid)
				table.insert(irc_params, players[pid].name)
				if string.find(msgLower, &quot;range&quot;) then
					table.insert(irc_params, number)
				end

				irc_BasesNearPlayer()
			else	
				table.insert(irc_params, &quot;No player found matching &quot; .. name1)
				irc_message()
			end

			return
		end


		if (words[1] == &quot;info&quot; and words[2] ~= nil) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			name1 = string.sub(msg, string.find(msgLower, &quot;info&quot;) + 5)
			name1 = string.trim(name1)
			pid = LookupPlayer(name1)

			if (pid ~= nil) then
				table.insert(irc_params, pid)
				table.insert(irc_params, players[pid].name)
				irc_PlayerShortInfo()
				irc_friends()
			else	
				table.insert(irc_params, &quot;No player found matching &quot; .. name1)
				irc_message()
			end

			return
		end


		if (words[1] == &quot;add&quot; and words[2] == &quot;donor&quot; and words[3] ~= nil and owners[ircid]) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			name1 = string.sub(msg, string.find(msgLower, &quot;donor&quot;) + 6)
			name1 = string.trim(name1)
			pid = LookupPlayer(name1)

			if pid ~= nil then
				-- update the player record
				players[pid].donor = true
				table.insert(irc_params, players[pid].name .. &quot; is now a donor.&quot;)
				irc_message()

				conn:execute(&quot;UPDATE players SET donor = 1 WHERE steam = &quot; .. pid)
			end

			return
		end


		if (words[1] == &quot;remove&quot; and words[2] == &quot;donor&quot; and words[3] ~= nil and owners[ircid]) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			name1 = string.sub(msg, string.find(msgLower, &quot;donor&quot;) + 6)
			name1 = string.trim(name1)
			pid = LookupPlayer(name1)

			if pid ~= nil then
				-- update the player record
				players[pid].donor = false
				table.insert(irc_params, players[pid].name .. &quot; is no longer a donor.&quot;)
				irc_message()

				conn:execute(&quot;UPDATE players SET donor = 0 WHERE steam = &quot; .. pid)
			end

			return
		end


		if (words[1] == &quot;add&quot; and words[2] == &quot;owner&quot; and words[3] ~= nil and owners[ircid]) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			name1 = string.sub(msg, string.find(msgLower, &quot;owner&quot;) + 6)
			name1 = string.trim(name1)
			pid = LookupPlayer(name1)

			if pid ~= nil then
				-- add the steamid to the owners table
				owners[pid] = {}
				table.insert(irc_params, players[pid].name .. &quot; has been added as a server owner.&quot;)
				irc_message()

				send(&quot;admin add &quot; .. pid .. &quot; 0&quot;)
			end

			return
		end


		if (words[1] == &quot;remove&quot; and words[2] == &quot;owner&quot; and words[3] ~= nil and owners[ircid]) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			name1 = string.sub(msg, string.find(msgLower, &quot;owner&quot;) + 6)
			name1 = string.trim(name1)
			pid = LookupPlayer(name1)

			if pid ~= nil then
				-- remove the steamid from the owners table
				owners[pid] = nil
				table.insert(irc_params, players[pid].name .. &quot; is no longer a server owner.&quot;)
				irc_message()

				send(&quot;admin remove &quot; .. pid)
			end

			return
		end


		if (words[1] == &quot;add&quot; and words[2] == &quot;admin&quot; and words[3] ~= nil and owners[ircid]) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			name1 = string.sub(msg, string.find(msgLower, &quot;admin&quot;) + 6)
			name1 = string.trim(name1)
			pid = LookupPlayer(name1)

			if pid ~= nil then
				-- add the steamid to the admins table
				admins[pid] = {}
				table.insert(irc_params, players[pid].name .. &quot; has been added as a server admin.&quot;)
				irc_message()

				send(&quot;admin add &quot; .. pid .. &quot; 1&quot;)
			end
		
			return
		end


		if (words[1] == &quot;remove&quot; and words[2] == &quot;admin&quot; and words[3] ~= nil and accessLevel(ircid) == 0) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			name1 = string.sub(msg, string.find(msgLower, &quot;admin&quot;) + 6)
			name1 = string.trim(name1)

			pid = LookupPlayer(name1)

			if pid ~= nil then
				-- remove the steamid from the admins table
				admins[pid] = nil
				table.insert(irc_params, players[pid].name .. &quot; is no longer a server admin.&quot;)
				irc_message()

				send(&quot;admin remove &quot; .. pid)
			end

			return
		end


		if (words[1] == &quot;permaban&quot;) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			name1 = string.trim(string.sub(msg, string.find(msgLower, &quot;permaban&quot;) + 9))
			pid = LookupPlayer(name1)

			if (pid ~= nil) then
				table.insert(irc_params, pid)
				table.insert(irc_params, players[pid].name)
			else
				if (string.len(name1) == 17) then
					banPlayer(pid, &quot;10 years&quot;, &quot;Permanent ban&quot;)

					table.insert(irc_params, name1 .. &quot; banned 10 years.&quot;)
					irc_message()

					conn:execute(&quot;UPDATE players SET permanentBan = 1 WHERE steam = &quot; .. pid)
				else
					table.insert(irc_params, &quot;No player found matching &quot; .. name1)
					irc_message()
				end
			end
			return
		end


		if (words[1] == &quot;remove&quot; and words[2] == &quot;permaban&quot;) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			name1 = string.trim(string.sub(msg, string.find(msgLower, &quot;permaban&quot;) + 9))
			pid = LookupPlayer(name1)

			if (pid ~= nil) then
				table.insert(irc_params, pid)
				table.insert(irc_params, players[pid].name)

				conn:execute(&quot;UPDATE players SET permanentBan = 0 WHERE steam = &quot; .. pid)
				send(&quot;ban remove &quot; .. pid)

				table.insert(irc_params, &quot;Ban lifted for player &quot; .. name1)
				irc_message()
			else	
				table.insert(irc_params, &quot;No player found matching &quot; .. name1)
				irc_message()
			end
			return
		end


		if (words[1] == &quot;add&quot; and words[2] == &quot;player&quot;) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			name1 = words[3]
			login = words[4]
			result = false

			for k, v in pairs(players) do
				if (login == v.ircPass) then
					result = true
					break
				end
			end

			if (result == true) then
				table.insert(irc_params, &quot;That password is already in use.  Please choose another.&quot;)
				tempTimer( 2, [[irc_message()]] )	
				return
			end

			pid = LookupOfflinePlayer(name1, &quot;all&quot;)
			if (pid ~= nil) then
				players[pid].ircPass = login
				players[pid].ircAuthenticated = false

				table.insert(irc_params, name1 .. &quot; is now authorised to talk to ingame players&quot;)
				irc_message()
				conn:execute(&quot;UPDATE players SET ircPass = '&quot; .. escape(login) .. &quot;' WHERE steam = &quot; .. pid)
			end

			return
		end


		if (words[1] == &quot;player&quot; and string.find(msgLower, &quot;unfriend&quot;)) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			name1 = string.trim(string.sub(msg, string.find(msgLower, &quot;player&quot;) + 7, string.find(msgLower, &quot;unfriend&quot;) - 1))
			name2 = string.trim(string.sub(msg, string.find(msgLower, &quot;unfriend&quot;) + 9))

			pid = LookupPlayer(name1)
			if (pid ~= nil) then
				table.insert(irc_params, pid)
				pid = LookupPlayer(name2)
				if (pid ~= nil) then
					table.insert(irc_params, pid)
					irc_unfriend()
				else	
					table.insert(irc_params, &quot;No player found matching &quot; .. name2)
					irc_message()
				end
			else
				table.insert(irc_params, &quot;No player found matching &quot; .. name1)
				irc_message()
			end

			return
		end


		if (words[1] == &quot;player&quot; and string.find(msgLower, &quot;friend&quot;)) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			name1 = string.trim(string.sub(msg, string.find(msgLower, &quot;player&quot;) + 7, string.find(msgLower, &quot;friend&quot;) - 1))
			name2 = string.trim(string.sub(msg, string.find(msgLower, &quot;friend&quot;) + 7))

			pid = LookupPlayer(name1)
			if (pid ~= nil) then
				table.insert(irc_params, pid)
				pid = LookupPlayer(name2)
				if (pid ~= nil) then
					table.insert(irc_params, pid)
					irc_friend()
				else	
					table.insert(irc_params, &quot;No player found matching &quot; .. name2)
					irc_message()
				end
			else
				table.insert(irc_params, &quot;No player found matching &quot; .. name1)
				irc_message()
			end

			return
		end


		if (words[1] == &quot;friends&quot;) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			name1 = string.trim(string.sub(msg, string.find(msgLower, &quot;friends&quot;) + 8))
			pid = LookupPlayer(name1)

			if (pid ~= nil) then
				table.insert(irc_params, pid)
				table.insert(irc_params, players[pid].name)
				irc_friends()
			else	
				table.insert(irc_params, &quot;No player found matching &quot; .. name1)
				irc_message()
			end
			return
		end


		if (words[1] == &quot;players&quot; and words[2] == nil) and accessLevel(ircid) == 0 then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_listAllPlayers(name)
			return
		end


		if (words[1] == &quot;player&quot;) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			name1 = string.trim(string.sub(msg, string.find(msgLower, &quot;player&quot;) + 7))
			pid = LookupOfflinePlayer(name1)

			if (pid ~= nil) then
				table.insert(irc_params, pid)
				table.insert(irc_params, players[pid].name)
				irc_PlayerInfo()
			end
			return
		end


		if (words[1] == &quot;igplayer&quot;) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			name1 = string.trim(string.sub(msg, string.find(msgLower, &quot;igplayer&quot;) + 9))
			pid = LookupPlayer(name1)

			if (pid ~= nil) then
				table.insert(irc_params, pid)
				table.insert(irc_params, players[pid].name)
				irc_IGPlayerInfo()
			end
			return
		end


		if (words[1] == &quot;watch&quot;) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			name1 = string.trim(string.sub(msg, string.find(msgLower, &quot;watch&quot;) + 6))
			pid = LookupPlayer(name1)

			if (pid ~= nil) then
				players[pid].watchPlayer = true

				conn:execute(&quot;UPDATE players SET watchPlayer = 1 WHERE steam = &quot; .. pid)
	
				table.insert(irc_params, &quot;Now watching player &quot; .. players[pid].name)
				irc_message()
			end
			return
		end


		if (words[1] == &quot;stop&quot; and words[2] == &quot;watching&quot;) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			name1 = string.trim(string.sub(msg, string.find(msgLower, &quot;watching&quot;) + 9))
			pid = LookupPlayer(name1)

			if (pid ~= nil) then
				players[pid].watchPlayer = false

				conn:execute(&quot;UPDATE players SET watchPlayer = 0 WHERE steam = &quot; .. pid)
	
				table.insert(irc_params, &quot;No longer watching player &quot; .. players[pid].name)
				irc_message()
			else
				table.insert(irc_params, &quot;No player matched &quot; .. name1)
				irc_message()
			end
			return
		end


		if (words[1] == &quot;donors&quot; and words[2] == nil) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_listDonors(name)
			return
		end


		if (words[1] == &quot;teleports&quot; and words[2] == nil) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_teleports(name)
			return
		end


		if (words[1] == &quot;list&quot; and words[2] == &quot;bad&quot; and words[3] == &quot;items&quot;) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_uncraftables(name)
			return
		end


		if (words[1] == &quot;prisoners&quot; and words[2] == nil) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_prisoners(name)			
			return
		end


		if (words[1] == &quot;li&quot; and words[2] ~= nil) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			ircListItems = ircid
			send(&quot;li &quot; .. words[2])
		end


		if (words[1] == &quot;status&quot;) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			name1 = string.trim(string.sub(msg, string.find(msgLower, &quot;status&quot;) + 7))
			pid = LookupPlayer(name1)

			if (pid ~= nil) then
				table.insert(irc_params, pid)
				table.insert(irc_params, players[pid].name)
				irc_playerStatus()
			else	
				table.insert(irc_params, &quot;No player found matching &quot; .. name1)
				irc_message()
			end
			return
		end

		
		if (words[1] == &quot;shop&quot; and words[2] == &quot;add&quot; and words[3] == &quot;item&quot; and words[4] ~= nil) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			LookupShop(wordsOld[4], &quot;all&quot;)

			if shopCode ~= &quot;&quot; then
				irc_QueueMsg(irc_params[1], &quot;The item &quot; .. shopCode .. &quot; already exists.&quot;)
			else		
				class = &quot;misc&quot;
				price = 10000
				stock = 0

				for i=4,wordCount,1 do 					
					if words[i] == &quot;category&quot; then
						class = words[i+1]
					end					
					
					if words[i] == &quot;price&quot; then
						price = tonumber(words[i+1])
					end					
					
					if words[i] == &quot;stock&quot; then
						stock = tonumber(words[i+1])
					end					
				end

				irc_QueueMsg(irc_params[1], &quot;You added &quot; .. wordsOld[4] .. &quot; to the shop.  You will need to add any missing info such as code, category, price and quantity.&quot;)

				conn:execute(&quot;INSERT INTO shop (item, category, stock, maxStock, price) VALUES ('&quot; .. escape(wordsOld[4]) .. &quot;','&quot; .. escape(class) .. &quot;',&quot; .. stock .. &quot;,&quot; .. stock .. &quot;,&quot; .. price .. &quot;)&quot;)
				
				reindexShop(class)				
			end

			return
		end

		
		if (words[1] == &quot;shop&quot; and words[2] == &quot;remove&quot; and words[3] == &quot;item&quot;) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			LookupShop(wordsOld[4], &quot;all&quot;)

			if shopCode ~= &quot;&quot; then
				conn:execute(&quot;DELETE FROM shop WHERE item = '&quot; .. escape(wordsOld[4]) .. &quot;'&quot;)
				reindexShop(shopCategory)		
				irc_QueueMsg(name, &quot;You removed the item &quot; .. wordsOld[4] .. &quot; from the shop.&quot;)
			else
				irc_QueueMsg(irc_params[1], &quot;The item &quot; .. wordsOld[4] .. &quot; does not exist.&quot;)
			end			

			return
		end	


		if (words[1] == &quot;add&quot; and words[2] == &quot;command&quot; and accessLevel(ircid) &lt; 3) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			cmd = words[3]

			if words[4] == &quot;access&quot; then
				number = tonumber(words[5])
			else
				number = 99
			end

			tmp = string.trim(string.sub(msg, string.find(msgLower, &quot;message&quot;) + 8))

			if tmp == nil then
				irc_QueueMsg(name, &quot;Bad command.  This is used to create commands that send a private message to the player. You can add an optional access level.  99 is the default.&quot;)
				irc_QueueMsg(name, &quot;Valid access levels are 99 (everyone), 90 (regulars), 4 (donors), 2 (mods), 1 (admins) 0 (owners)&quot;)
				irc_QueueMsg(name, &quot;These commands are searched after all other commands. If an identical command exists, it will be used instead. Test the commands you add.&quot;)
				irc_QueueMsg(name, &quot;Correct syntax is: add command &lt;command&gt; access &lt;99 to 0&gt; message &lt;private message&gt;&quot;)
			end

			-- add the custom message to table customMessages
			conn:execute(&quot;INSERT INTO customMessages (command, message, accessLevel) VALUES ('&quot; .. escape(cmd) .. &quot;','&quot; .. escape(tmp) .. &quot;',&quot; .. number .. &quot;) ON DUPLICATE KEY UPDATE accessLevel = &quot; .. number .. &quot;, message = '&quot; .. escape(tmp) .. &quot;'&quot;)

			table.insert(irc_params, cmd .. &quot; has been added to custom commands.&quot;)
			irc_message()
			return
		end


		if (words[1] == &quot;remove&quot; and words[2] == &quot;command&quot; and accessLevel(ircid) &lt; 3) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			cmd = words[3]

			-- remove the custom message from table customMessages
			conn:execute(&quot;DELETE FROM customMessages WHERE command = '&quot; .. escape(cmd) .. &quot;'&quot;)

			table.insert(irc_params, cmd .. &quot; has been removed from custom commands.&quot;)
			irc_message()
			return
		end


		if (words[1] == &quot;blacklist&quot; and words[2] == &quot;add&quot; and accessLevel(ircid) &lt; 3) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			pid = LookupPlayer(words[3])

			if pid ~= nil then
				send(&quot;ban add &quot; .. pid .. &quot; 10 years blacklisted&quot;)
				irc_QueueMsg(name, &quot;Player &quot; .. pid  .. &quot; &quot; .. players[pid].name .. &quot; has been blacklisted 10 years.&quot;)
				return
			end
		end


		if (words[1] == &quot;blacklist&quot; or words[1] == &quot;ban&quot; and words[2] == &quot;remove&quot; and accessLevel(ircid) &lt; 3) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			pid = LookupPlayer(words[3])
			if pid ~= nil then
				send(&quot;ban remove &quot; .. pid)
				irc_QueueMsg(name, &quot;Player &quot; .. pid  .. &quot; &quot; .. players[pid].name .. &quot; has been unbanned.&quot;)
				return
			end
		end

		if words[1] == &quot;list&quot; and (words[2] == &quot;event&quot;) then
			for i=4,wordCount,1 do 					
				if words[i] == &quot;player&quot; then
					pid = words[i+1]
					pid = LookupPlayer(pid)
				end					
			end

			table.insert(irc_params, words[3])

			if number ~= nil then
				table.insert(irc_params, number)
			else
				table.insert(irc_params, &quot;&quot;)
			end

			if pid ~= nil then
				table.insert(irc_params, pid)
			else
				table.insert(irc_params, &quot;&quot;)
			end

			irc_server_event(name)
			return
		end


		if words[1] == &quot;search&quot; and words[2] == &quot;player&quot; then
			irc_QueueMsg(name, &quot;Players matching &quot; .. words[3])

			cursor,errorString = conn:execute(&quot;SELECT id, steam, name FROM players where name like '%&quot; .. words[3] .. &quot;%'&quot;)
			row = cursor:fetch({}, &quot;a&quot;)
			while row do
				irc_QueueMsg(name, row.id  .. &quot; &quot; .. row.steam .. &quot; &quot; .. row.name)
				row = cursor:fetch(row, &quot;a&quot;)
			end

			irc_QueueMsg(name, &quot;&quot;)
		end

	end


	if (words[1] == &quot;login&quot;) then
		ircid = LookupIRCPass(string.sub(msg, string.find(msgLower, &quot;ogin&quot;) + 5))

		if (ircid ~= nil) then
			if string.find(channel, &quot;#&quot;) then
				table.insert(irc_params, &quot;You accidentally revealed your password in a public channel.  You password has been automatically wiped and you won't be able to login until Smeg sets a new password for you.&quot;)
				irc_message()
				players[ircid].ircAuthenticated = false
				players[ircid].ircPass = nil

				conn:execute(&quot;UPDATE players SET ircPass = '' WHERE steam = &quot; .. ircid)
				return
			end

			players[ircid].ircAuthenticated = true
			players[ircid].ircAlias = name

			conn:execute(&quot;UPDATE players SET ircAlias = '&quot; .. escape(name) .. &quot;' WHERE steam = &quot; .. ircid)

			if accessLevel(ircid) &lt; 4 then
				players[ircid].ircSessionExpiry = os.time() + 600
			else
				players[ircid].ircSessionExpiry = os.time() + 10800
			end

			table.insert(irc_params, &quot;You have logged in &quot; .. name)
			irc_message()
			return
		end

		if (players[ircid].ircPass == nil) then
			table.insert(irc_params, &quot;You don't currently have a password.  Ask us to set one for you.&quot;)
			irc_message()
		end

		return
	end

	if debug then dbug(&quot;debug ircmessage 5&quot;) end


	-- replace the words below with your secret phrase or uncomment the return to disable it.
	-- this code allows you to easily regain control of the bot through IRC if you forget your password or the bot disables it.
	-- if you are an admin, this will log you in but you'll still need to set a pass later.
	-- non-admins just get a silly message.
	
	if (words[1] == &quot;all&quot; and words[2] == &quot;your&quot;) and words[3] == &quot;base&quot; then
		if true then
--			return
		end

		ircid = LookupPlayer(name)
		if accessLevel(ircid) &lt; 3 then
			players[ircid].ircSessionExpiry = os.time() + 600
			players[ircid].ircAuthenticated = true
			players[ircid].ircAlias = name
			table.insert(irc_params, &quot;You have logged in &quot; .. name)
			irc_message()

			conn:execute(&quot;UPDATE players SET ircAlias = '&quot; .. escape(name) .. &quot;' WHERE steam = &quot; .. ircid)
		else
			table.insert(irc_params, &quot;Did you drop your contact lense?&quot;)
			irc_message()
		end
	end

	if debug then dbug (&quot;debug ircmessage end&quot;) end
end

</script>
            <eventHandlerList>
                <string>sysIrcMessage</string>
            </eventHandlerList>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg functions</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function baseStatus(command, playerid)
	local pname
	local id
	local protected
	local base

	pname = nil
	if (accessLevel(playerid) &lt; 3 and string.find(command, &quot;status &quot;)) then
		pname = string.sub(command, string.find(command, &quot;status&quot;) + 7)
		if (pname ~= nil) then
			pname = string.trim(pname)
			id = LookupPlayer(pname)
		end
	end

	if (pname == nil) then
		id = playerid	
		pname = players[playerid].name
	else
		pname = players[id].name
	end

	message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have &quot; .. players[id].cash .. &quot; zennies in the bank.[-]&quot;)

	if (players[id].protect == true) then
		protected = &quot;protected&quot;
	else
		protected = &quot;not protected (unless you have LCB's down)&quot;
	end
	
	if (players[id].homeX == 0 and players[id].homeY == 0 and players[id].homeZ == 0) then
		if (id == playerid) then
			base = &quot;You do not have a base set yet&quot;
		else
			base = pname .. &quot; does not have a base set yet&quot;
		end
	else
		if (id == playerid) then
			base = &quot;You have set a base&quot;
		else
			base = pname .. &quot; has set a base&quot;
		end
	end

	message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. base .. &quot;[-]&quot;)	
	message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The base is &quot; .. protected .. &quot;[-]&quot;)
	message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Protection size is &quot; .. players[id].protectSize .. &quot; meters from the /base teleport[-]&quot;)

	if (players[id].protectPaused ~= nil) then
		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Base protection is temporarily paused.[-]&quot;)
	end

	if not (players[id].home2X == 0 and players[id].home2Y == 0 and players[id].home2Z == 0) then
		if (players[id].protect2 == true) then
			protected = &quot;protected&quot;
		else
			protected = &quot;not protected (unless LCB's are placed)&quot;
		end
	
		if (id == playerid) then
			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Your 2nd base status is..[-]&quot;)
		else
			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Base status for &quot; .. pname .. &quot;'s 2nd base is..[-]&quot;)	
		end

		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The base is &quot; .. protected .. &quot;[-]&quot;)
		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Protection size is &quot; .. players[id].protect2Size .. &quot; meters from the /base2 teleport[-]&quot;)

		if (players[id].protect2Paused ~= nil) then
			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Base protection is temporarily paused.[-]&quot;)
		end
	end

	if accessLevel(playerid) &lt; 3 then
		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Current session is &quot; .. players[id].sessionCount .. &quot;[-]&quot;)
		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Claims placed &quot; .. players[id].keystones .. &quot;[-]&quot;)
	end

	return false
end


function gmsg_who(playerid, number)
	local xdir, zdir, k, v, dist, alone, intX, intY, intZ, x, z

	intX = math.floor(igplayers[playerid].xPos)
	intY = math.ceil(igplayers[playerid].yPos)
	intZ = math.floor(igplayers[playerid].zPos)

	x = math.floor(intX / 512)
	z = math.floor(intZ / 512)

	if (pvpZone(igplayers[playerid].xPos, igplayers[playerid].zPos) ~= false) then
		return
	end

	alone = true

	if (number == nil) then number = 501 end

	if (accessLevel(playerid) &gt; 3) then
		number = 401
	end

	if (accessLevel(playerid) &gt; 10) then
		number = 201
	end

	if (tonumber(intX) &lt; 0) then xdir = &quot; west &quot; else xdir = &quot; east &quot; end
	if (tonumber(intZ) &lt; 0) then zdir = &quot; south&quot; else zdir = &quot; north&quot; end
	message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are at &quot; .. intX .. xdir .. intZ .. zdir .. &quot; at a height of &quot; .. intY .. &quot;[-]&quot;)
	message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are in region r.&quot; .. x .. &quot;.&quot; .. z .. &quot;.7rg[-]&quot;)

	for k, v in pairs(igplayers) do
		if (k ~= playerid) then
			dist = distance(intX, intZ, v.xPos, v.zPos)

			if dist &lt; tonumber(number) then
				if (v.steam ~= playerid) then
					if (alone == true) then 
						message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]players within &quot; .. number .. &quot; meters:[-]&quot;) 
						alone = false
					end

					if (accessLevel(playerid) &lt; 11) then
						x = math.floor(v.xPos / 512)
						z = math.floor(v.zPos / 512)

						message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot; distance: &quot; .. string.format(&quot;%d&quot;, dist) .. &quot; region r.&quot; .. x .. &quot;.&quot; .. z .. &quot;.7rg[-]&quot;)
					else
						if (players[playerid].watchPlayer == true) and accessLevel(v.steam) &gt; 3 then
							message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot;[-]&quot;)
						end

						if (players[playerid].watchPlayer == false) then
							message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot;[-]&quot;)
						end
					end
				end
			end
		end
	end
end


</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_help</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function help(command)
	if (command == &quot;me&quot;) then
		r = rand(6)
		if (r==1) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Sorry you're beyond help I'm afraid.[-]&quot;) end
		if (r==2) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Today I did 6 impossible things, but that ain't one.[-]&quot;) end
		if (r==3) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]I can't fix that![-]&quot;) end
		if (r==4) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Ask your cat.[-]&quot;) end
		if (r==5) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You need a wash and a haircut.[-]&quot;) end
		if (r==6) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Get up and go outside.  Maybe you've heard of it?[-]&quot;) end
		return
	end


	if command == &quot;reboot&quot; then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]By default /reboot will reboot 2 minutes later. More detailed help on irc.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/reboot in n minutes/hours (restricted to server owners)[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/cancel reboot[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/pause reboot  /unpause reboot[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/enable (or /disable) reboot (toggle automated rebooting)[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A timed reboot can be delayed if anyone says wait during the countdown. This can be blocked if you add 'forced' to the reboot command.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Several automatic reboots can happen that the bot manages.[-]&quot;)
		return
	end


	if command == &quot;mail&quot; then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Send private messages to your friends. They have to have friended you with /friend &quot; .. players[gmsgvars.playerid].name .. &quot; before you can message them.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can only send mail from your console, which you access from the tild key which is above TAB and left of your 1 key.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]To send a message to your friend Dave type pm @dave Hi Dave!  If he is on, he will get it now.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can message the admins with pm @admin &lt;your message here&gt;.  Every admin will see it.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Ignore the command denied message.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot;&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/list mail (see a numbered list of all your messages)[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/read mail &lt;optional number&gt; (reads all unread by default)[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/save mail &lt;number&gt; (read mail is deleted unless saved)[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/delete mail &lt;number&gt; (delete the numbered message)[-]&quot;)
		return
	end


	if (command == &quot;bookmarks&quot;) then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This feature is just to help admins locate places of interest or so we can screenshot your base before a wipe.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]If you add too many or stupid bookmarks we will not use them.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]These are not teleports like waypoints.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;][-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/bookmark &lt;short description&gt; (add a bookmark where you are standing)[-]&quot;)

		if (accessLevel(gmsgvars.playerid) &lt; 3) then 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/list bookmarks &lt;player&gt; (view a players bookmarks)[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/bk &lt;bookmark number&gt; (tp to the coords of a bookmark)[-]&quot;)
		else
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/list bookmarks (view your own bookmarks)[-]&quot;)
		end

		return
	end


	if (command == &quot;male&quot;) then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]HELLOOOOO Nurse![-]&quot;)
		return
	end


	if (command == &quot;special&quot;) then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]P2Ptokens allow you to teleport to a friend and return (once per token).[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The friend has to have friended you via the bot.  Tokens are not items so there is nothing to pick up or lose.[-]&quot;)
		return
	end


	if command == &quot;shop&quot; then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The game currency is the zenny. Each zombie killed earns you 5 zennies.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/cash (see what you have in the bank)[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]To browse type /shop followed by a category. Categories are..[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]ammo, armour, books, build, decor, food, forge, general, medic, tools, weapons[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]For a general search type /shop &lt;item&gt; eg. /shop shirt[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/buy &lt;item number&gt; &lt;quantity&gt;  Buy all the things![-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/pay &lt;player&gt; &lt;amount&gt;  You can't put a price on love so send money instead.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/gamble (gamble in our daily lottery) 25 zennies per ticket[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Buy multiple tickets at once with /gamble 5 (or any number). The winning number is picked from ticket number 1 to 100.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The shop sells special items. Read /help special for info.[-]&quot;)
		if (accessLevel(gmsgvars.playerid) &lt; 3) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/open shop - allow players access to the shop.[-]&quot;) end
		if (accessLevel(gmsgvars.playerid) &lt; 3) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/close shop - block player access to the shop.[-]&quot;) end
		if (accessLevel(gmsgvars.playerid) &lt; 3) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/set shop open - set a time (0 - 23) when the shop opens.[-]&quot;) end
		if (accessLevel(gmsgvars.playerid) &lt; 3) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/set shop close - set a time (0 - 23) when the shop closes.[-]&quot;) end
		if (accessLevel(gmsgvars.playerid) &lt; 3) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/set shop location &lt;location&gt; - tie the shop to a location.[-]&quot;) end
		if (accessLevel(gmsgvars.playerid) &lt; 3) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/clear shop location - the shop can be used anywhere.[-]&quot;) end
		return
	end


	if command == &quot;waypoints&quot; then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Waypoints are available to donors and admins only.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/set waypoint then /waypoint or /&lt;your name&gt; to tp to it.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/open waypoint - allow your friends to tp with /&lt;your name&gt;[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/close waypoint - make it private again.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/clear waypoint - deletes the waypoint[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]An opened waypoint automatically closes when you clear it.[-]&quot;)
		return
	end


	if command == &quot;irc&quot; then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Our irc server is located at &quot; .. server.ircServer .. &quot;[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Once there type /join #&quot; .. server.ircMain .. &quot;[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Hexchat is a good free irc client which works on Windows.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Or use this link https://kiwiirc.com/client/&quot; .. server.ircServer .. &quot;/&quot; .. server.ircMain .. &quot;[-]&quot;)
		return
	end


	if command == &quot;friends&quot; then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can tell the bot who your friends are. This gives them access to private teleports etc.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/friend &lt;friend's name&gt; - add someone as a friend[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/unfriend &lt;friend's name&gt;[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/friends - see who you have friended[-]&quot;)
		return
	end


	if command == &quot;access&quot; and (accessLevel(gmsgvars.playerid) &lt; 3) then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Access levels control who can do what.  Commands that are above a players level return unknown command.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Level 0 server owners[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Level 1 admins[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Level 2 mods[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Level 3 &lt;reserved&gt;[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Level 4 Donors[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Level 90 Regular players[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Level 99 New players[-]&quot;)
		return
	end


	if command == &quot;custom commands&quot; and (accessLevel(gmsgvars.playerid) &lt; 3) then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can create commands that send a private message.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/custom commands (list them)[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/add command &lt;command&gt; level &lt;access level&gt; message &lt;message&gt;.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/remove command &lt;command&gt;.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Access level is optional and defaults to 99.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]See /help access for the list of access levels.[-]&quot;)
		return
	end


	if command == &quot;pve&quot; then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]PVE means player versus environment.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The objective is to live off the land, gather resources, build shelter and survive.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can always ask others for help and if it gets too tough, you can take refuge in the library.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]On this server there are a few areas where PVP is allowed. Read /help pvp for info.[-]&quot;)
		return
	end


	if command == &quot;pvp&quot; then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]We have a PVP zone called Deadzone where you may PVP other players.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Type deadzone on chat to teleport to there. All other areas are PVE ONLY.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You start off in a large city with plenty of cover.  You will be alerted when you enter or exit the pvp zone.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]If you manage to get arrested for pvp outside of a zone, your victim or an admin can release you.[-]&quot;)
		return
	end


	if (command == &quot;deadzone&quot;) then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]ALERT!  Teleporting to Deadzone is treated the same as using your base teleport. You will not be able to return to base immediately.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You start off in a large city or town in a random location.  You will be alerted when you enter or exit the pvp zone.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]If you manage to get arrested for a PVP in PVE areas, your victim or an admin can release you.[-]&quot;)
		return
	end


	if (command == &quot;gimme&quot; or command == &quot;gimmie&quot;) then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Gimme is a fun game where you can win prizes![-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]To play, place 64 casino coins in the last slot of your belt. Gimmies are played automatically once per minute until you remove the coins or run out fo gimmies to play.[-]&quot;)
		if (accessLevel(gmsgvars.playerid) &lt; 3) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/gimme on - enables gimme[-]&quot;) end
		if (accessLevel(gmsgvars.playerid) &lt; 3) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/gimme off - disables gimme[-]&quot;) end
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/gimme peace - prizes are pm'ed[-]&quot;)
		if (accessLevel(gmsgvars.playerid) &lt; 3) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/gimme gimme - prizes are announced publicly[-]&quot;) end
		if (accessLevel(gmsgvars.playerid) &lt; 3) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/gimme reset - Reset everyone's gimme count to 0 and zero the reset timer (2 hours)[-]&quot;) end
		return
	end


	if (command == &quot;hotspots&quot;) then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Hotspots are pm's that are triggered by proximity to a hotspot. They are 3 dimensional spheres and can be stacked vertically.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/hotspots &lt;optional number&gt; Lists all hotspots within 20 meters of you or type a number for a different distance[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/hotspot delete  Deletes the nearest hotspot to you.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/hotspot &lt;private message&gt;  Adds hotspot where you are with a default radius of 3 meters[-]&quot;)

		if (accessLevel(gmsgvars.playerid) &lt; 3) then 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/hotspot &lt;number&gt;   Change the radius of the nearest hotspot.  If multiple hotspots cover an area, only the first hotspot tested will trigger.[-]&quot;) 
		else
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/hotspot &lt;1 to 5&gt;   Change the radius of the nearest hotspot.  If multiple hotspots cover an area, only the first hotspot tested will trigger.[-]&quot;) 
		end

		return
	end


	if (command == &quot;setup&quot;) and (accessLevel(gmsgvars.playerid) &lt; 3) then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Please set the following for smooth operation of the bot..[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/reset bot (only do this after a wipe and as soon after as possible)[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/name bot &lt;short name for the bot&gt;[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/set map size &lt;number&gt; (how far in meters players can explore away from 0,0)[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/set base cooldown &lt;minutes&gt; (how long to wait between /base teleporting. Donors wait half as long)[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/set chat color &lt;bbcode color without the brackets&gt;[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/location add prison[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/location add exile[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/max animals &lt;number&gt;[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/max players &lt;number&gt;[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/max zombies &lt;number&gt;[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/set website &lt;url or steam group&gt;[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/set irc server &lt;ip:port&gt;[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/set (or clear) max ping &lt;100+&gt;[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/set (or clear) welcome message &lt;your welcome message&gt;[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]For prison and exile also type /set location size &lt;prison/exile&gt; &lt;distance in metres&gt;[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Also for each type /location &lt;prison/exile&gt; pvp[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/set server pvp/pve/creative (tells the bot what type of server this is)[-]&quot;)
		return
	end


	if 	(command == &quot;manual&quot;) and (accessLevel(gmsgvars.playerid) &lt; 3) then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]More detailed help is available to admins on the IRC server.[-]&quot;)
		return
	end


	if (command == &quot;tracker&quot; and accessLevel(gmsgvars.playerid) &lt; 3) then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can walk the path taken by a player at any point in history.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/track &lt;player&gt; session &lt;number&gt; Defaults to the most recent or current.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Once the tracker is running:[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/goto start/end[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/go or /stop[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/go back (change direction)[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/skip &lt;number&gt;.  Skips every (n) steps[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/speed &lt;number&gt;.  Default is 1. Add 1 for each second you want to wait between steps.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/forward (or /advance) &lt;number&gt; Jump forward n steps.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/back &lt;number&gt; Jump backwards n steps.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/next (track the next session)[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/last (track the previous session)[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/stop tracking[-]&quot;)
		return
	end


	if command == &quot;donors&quot; then
		if accessLevel(gmsgvars.playerid) &lt; 3 then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Type player status &lt;player&gt; to check their donor status[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/add donor &lt;player&gt; level &lt;level&gt; expires &lt;number&gt; &lt;week or month or year&gt;[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/remove donor &lt;player&gt;[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Later you will be able to set a time limit like you do with bans.[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Also I will add the ability to give a player a free trial for a settable time limit.[-]&quot;)
		else
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]As a thank you for supporting us donors get extra features but donating is not required and is not pay to win.[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Donors get a 2nd base teleport and base protection,[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The base cooldown timer is half the normal time,[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can set 1 waypoint and share it with friends,[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can explore an extra 5km of map,[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can own a location and even become mayor of your own village,[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You get access to anything we restrict to donors only,[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You may get experimental new features before non-donors.[-]&quot;)
		end

		return
	end


	if (command == &quot;admin&quot;) and accessLevel(gmsgvars.playerid) &lt; 3 then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/arrest &lt;playername / player id&gt;[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/release &lt;playername / player id&gt;[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/release here &lt;playername / player id&gt;[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/prison takes you to the prison[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/closeto &lt;playername / player id&gt; Be in god mode before using this.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/goto &lt;playername / player id&gt;[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/fetch &lt;playername / player id&gt;[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/rescue &lt;playername&gt; - like fetch but just works[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/return &lt;playername / player id&gt;[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/sendhome &lt;playername / player id&gt;[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help donors[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help tracker[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/return - to return to where you came from[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/reboot empty (or idle)[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/who visited &lt;optional player&gt; range &lt;number default is 10&gt;[-]&quot;)
		return
	end


	if command == &quot;locations&quot; then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Locations are POI's (Points of interest) that you may teleport to and from freely.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]To travel to a location, just type the name of the location eg /library  To return type /return[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Locations are for everyone so please try not to trash them and don't claim them for yourself.[-]&quot;)

		if (accessLevel(gmsgvars.playerid) &lt; 3) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/prison takes you to the prison[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/location add &lt;some name&gt;[-]&quot;)	
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/location remove &lt;some name&gt;[-]&quot;)	
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/location private &lt;some name&gt; (this is the default)[-]&quot;)	
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/location public &lt;some name&gt;[-]&quot;)
		end

		return
	end


	if command == &quot;villages&quot; then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Villages are special locations that act like a base but with many players as villagers and one mayor.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A player can belong to many villages and each village can have only 1 mayor.  Villagers can vote for a new mayor once per 7 game days.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The village teleport works exactly like a base teleport including the 30 minute delay.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/villages (list of villages)[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/villagers &lt;optional village&gt; (list of villagers)[-]&quot;)

		if (accessLevel(gmsgvars.playerid) &lt; 3) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/add village &lt;name&gt;[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/remove village &lt;name&gt;[-]&quot;)	
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/village &lt;name&gt; size &lt;size&gt; (of village protection)[-]&quot;)	
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/protect village &lt;name&gt;[-]&quot;)	
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/add member &lt;player&gt; village &lt;village&gt;[-]&quot;)	
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/remove member &lt;player&gt; village &lt;village&gt;[-]&quot;)	
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/elect &lt;player&gt; village &lt;village&gt; (assign the first mayor)[-]&quot;)	
		end
		
		return
	end


	if command == &quot;base&quot; then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]We offer base protection which is a special teleport that ejects uninvited players from your base.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You must tell the bot where your base is. Pick a central spot or right beside your storage.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Type [i]/setbase[/i].  If you have previously typed [i]enabletp[/i] you can teleport to here once every &quot; .. (server.baseCooldown / 60) .. &quot; minutes.[-]&quot;)	
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Type [i]/base[/i] (or [i]home[/i]) to fast travel to your base.[-]&quot;)	
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can activate protection on your base to teleport out unwanted players by typing [i]/protect[/i].[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]If your protection overlaps with an non-friended player, the bot will not allow you to activate your protection.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]By default only you and admins can enter your base. Read /help friends to give your friends access too.[-]&quot;)	
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can temporarily suspend base protection with [i]/pause[/i]. It will auto-resume when you are more than 100 meters from base or quit the game.[-]&quot;)	
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Type [i]/resume[/i] to re-activate it.[-]&quot;)	
		return
	end


	if command == &quot;teleport&quot; then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Telporting is opt-in.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/enabletp to let yourself be teleported[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/disabletp teleports will ignore you[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Read /help base and /help locations for more info.[-]&quot;)

		if (accessLevel(gmsgvars.playerid) &lt; 3) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/opentp tpname[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/closetp tpname (must match opentp name)[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/killtp tpname (deletes a teleport)[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/owntp tpname playername[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/privatetp tpname[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/publictp tpname[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/teleports (list them all)[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/tp tpname (tp to a teleport)[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Teleports are private by default.[-]&quot;)
		end

		return
	end


	if (command == &quot;reset zones&quot;) or (command == &quot;reset&quot;) then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Reset zones areas which may be deleted and reset.  You will recieve a message whenever you enter or leave a reset zone.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Do not build in a reset zone or you risk losing it all.[-]&quot;)

		if (accessLevel(gmsgvars.playerid) &lt; 3) then 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Reset zones can only be managed ingame as they reference your current position.[-]&quot;) 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]To make the region you are in a reset zone type /add reset zone (regions are large)[-]&quot;) 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Remove it with /delete reset zone[-]&quot;) 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/location set reset &lt;location&gt;[-]&quot;) 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/location clear reset &lt;location&gt;[-]&quot;) 
		end

		return
	end


	if (command == &quot;commands&quot;) then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This list is just a summary.[-]&quot;)	
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/alert &lt;your message to admins&gt; Bot adds your coords too.[-]&quot;)
		if (accessLevel(gmsgvars.playerid) &lt; 3) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/enable gimme, /disable gimme, /gimme gimme[-]&quot;) end
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/setbase, /base, /delbase, /pause, /resume, /status[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/enabletp, /disabletp[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/friend, /unfriend, /friends[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/gimme, /gimme peace[-]&quot;)	
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/info[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/locations[-]&quot;)
		if (accessLevel(gmsgvars.playerid) &lt; 3) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/reboot empty (or idle)[-]&quot;) end
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/return[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/rules[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/seen[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/suicide[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/uptime[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/who[-]&quot;)

		cursor,errorString = conn:execute(&quot;select * from customMessages where command = '&quot; .. escape(gmsgvars.words[1]) .. &quot;'&quot;)
		rows = cursor:numrows()

		if rows &gt; 0 then
			row = cursor:fetch({}, &quot;a&quot;)

			if (accessLevel(gmsgvars.playerid) &gt;= tonumber(row.accessLevel)) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/&quot; .. row.command .. &quot;[-]&quot;)
			end
		end

		return
	end

	-- always have the main help last so it catches any unsupported help commands.
	if command == nil then
		if (accessLevel(gmsgvars.playerid) &lt; 3) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help access[-]&quot;) end
		if (accessLevel(gmsgvars.playerid) &lt; 3) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help admin[-]&quot;) end
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help base[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help bookmarks[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help commands or /commands[-]&quot;)
		if (accessLevel(gmsgvars.playerid) &lt; 3) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help custom commands[-]&quot;) end
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help friends[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help gimme[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help hotspots[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help irc[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help locations[-]&quot;)
		if (accessLevel(gmsgvars.playerid) &lt; 3) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help manual[-]&quot;) end
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help pve[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help pvp[-]&quot;)
		if (accessLevel(gmsgvars.playerid) &lt; 3) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help reboot[-]&quot;) end
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help reset[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help shop[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/alert (pass a message to the admins with your current position)[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help teleport[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help villages[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help waypoints[-]&quot;)
		if (accessLevel(gmsgvars.playerid) &lt; 3) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help setup[-]&quot;) end
		return
	end
end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>Inventory</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function CheckInventory()
	local temp, newPlayer, ban, timeout, move, newItems, table1, table2, items, reason, moveTo, moveReason, banReason, timeoutReason
	local d1, delta, inventoryChanged, keystoneChange, changes, flags, debug, badItemsFound, badItemAction, count500

	debug = false

if debug then display (&quot;check inventory 1\n&quot;) end

	-- do a quick sanity check to prevent a rare fault causing this to get stuck
	for k, v in pairs(igplayers) do
		if players[k] == nil then
			igplayers[k] = nil
		end
	end

	for k, v in pairs(igplayers) do

if debug then display (k .. &quot; &quot; .. v.name) end

		players[k].overstack = false
		players[k].overstackItems = &quot;&quot;
		ban = false
		timeout = false
		move = false
		newPlayer = false
		v.illegalInventory = false
		badItemsFound = &quot;&quot;
		count500 = 0

if debug then display (&quot;check inventory 2\n&quot;) end
	
		if igplayers[k] then
			if (tonumber(players[k].timeOnServer) + tonumber(igplayers[k].sessionPlaytime) &lt; (tonumber(server.newPlayerTimer) * 60) ) then
				newPlayer = true
			else
				newPlayer = false	
			end
		end

		temp = {}
		items = {}
		changes = {}
		newItems = &quot;&quot;
		delta = 0
		keystoneChange = 0
		inventoryChanged = false
		flags = &quot;&quot;

		if players[k].newPlayer == true then
			flags = &quot;|NEW|&quot;
		end

		if players[k].watchPlayer == true and players[k].newPlayer == false then
			flags = &quot;|WAT|&quot;
		end

		if v.raiding == true then
			flags = flags .. &quot;RAID &quot; .. v.raidingBase .. &quot;|&quot;
		end

if debug then display (&quot;check inventory 3\n&quot;) end

		if (igplayers[k].inventory ~= &quot;&quot;) then
			table1 = string.split(igplayers[k].inventory, &quot;|&quot;)

			for i = 1, table.maxn(table1) do
				if table1[i] ~= &quot;&quot; then
					table2 = string.split(table1[i], &quot;,&quot;)

					-- count the number of full stacks
					if tonumber(table2[1]) == 500 and (server.gameType ~= &quot;cre&quot;) then
						count500 = count500 + 1
						
						if timeoutReason == nil then
							timeoutReason = &quot;excessive inventory for a new player &quot; .. table2[2] .. &quot;(&quot; .. table2[1] .. &quot;)&quot;
						else
							timeoutReason = timeoutReason .. &quot;, &quot; .. table2[2] .. &quot;(&quot; .. table2[1] .. &quot;)&quot;
						end
					end

					if (badItems[table2[2]]) then
						igplayers[k].illegalInventory = true

						if badItemsFound == &quot;&quot; then
							badItemsFound = table2[2] .. &quot;(&quot; .. table2[1] .. &quot;)&quot;
						else
							badItemsFound = badItemsFound .. &quot;, &quot; .. table2[2] .. &quot;(&quot; .. table2[1] .. &quot;)&quot;
						end
					end

					if items[table2[2]] == nil then
						items[table2[2]] = {}
						items[table2[2]].item = table2[2]
						items[table2[2]].quantity = tonumber(table2[1])
						items[table2[2]].quality = tonumber(table2[3])
					else
						items[table2[2]].quantity = items[table2[2]].quantity + tonumber(table2[1])
					end

					-- stack monitoring
					if (stackLimits[table2[2]] ~= nil) and (accessLevel(k) &gt; 2 or server.ignoreAdmins == false) and (server.gameType ~= &quot;cre&quot;) then
						if tonumber(table2[1]) &gt; tonumber(stackLimits[table2[2]].limit) * 3 then
							if (players[k].overstackScore &lt; 0) then
								players[k].overstackScore = 0
							end

							players[k].overstack = true
							players[k].overstackItems = players[k].overstackItems .. &quot; &quot; .. table2[2] .. &quot; (&quot; .. table2[1] .. &quot;)&quot;

							if newPlayer then
								players[k].overstackScore = players[k].overstackScore + 4
							else
								players[k].overstackScore = players[k].overstackScore + 2
							end
						end

						-- instant ban for overstacking any of these if a new player
						if tonumber(table2[1]) &gt; tonumber(stackLimits[table2[2]].limit) and newPlayer == true then
							if (table2[2] == &quot;tnt&quot; or table2[2] == &quot;keystone&quot; or table2[2] == &quot;mineAirFilter&quot; or table2[2] == &quot;mineHubcap&quot; or table2[2] == &quot;44MagBullet&quot; or table2[2] == &quot;762mmBullet&quot;) then
								ban = true
								banReason = &quot;Banned for overstacking &quot; .. table2[2] .. &quot;(&quot; .. table2[1] .. &quot;).  Take that shit somewhere else.&quot;
							end
						end
					end					
				end
			end 

if debug then display (&quot;check inventory 4\n&quot;) end

			for a, b in pairs(items) do
				if (players[k].newPlayer == true and igplayers[k].skipExcessInventory ~= true) then

					cursor,errorString = conn:execute(&quot;SELECT * FROM memRestrictedItems where item = '&quot; .. escape(b.item) .. &quot;' and accessLevel &lt; &quot; .. players[k].accessLevel)				
					rows = cursor:numrows()

					if tonumber(rows) &gt; 0 then
						row = cursor:fetch({}, &quot;a&quot;)

						if tonumber(b.quantity) &gt; tonumber(row.qty) then
							if row.action == &quot;timeout&quot; then
								timeout = true
								
								if timeoutReason == nil then
									timeoutReason = &quot;excessive inventory for a new player &quot; .. b.item .. &quot;(&quot; .. b.quantity .. &quot;)&quot;
								else
									timeoutReason = timeoutReason .. &quot;, &quot; .. b.item .. &quot;(&quot; .. b.quantity .. &quot;)&quot;
								end
							end
						
							if row.action == &quot;ban&quot; then
								ban = true
							
								if banReason == nil then
									banReason = &quot;excessive inventory for a new player &quot; .. b.item .. &quot;(&quot; .. b.quantity .. &quot;)&quot;
								else
									banReason = banReason .. &quot;, &quot; .. b.item .. &quot;(&quot; .. b.quantity .. &quot;)&quot;
								end
							end
						
							if locations[row.action] then
								move = true
								moveTo = row.action
							
								if moveReason == nil then
									moveReason = &quot;excessive inventory for a new player &quot; .. b.item .. &quot;(&quot; .. b.quantity .. &quot;)&quot;
								else
									moveReason = moveReason .. &quot;, &quot; .. b.item .. &quot;(&quot; .. b.quantity .. &quot;)&quot;
								end
							end

							if row.action == &quot;watch&quot; then
								if players[k].watchPlayer == false then
									players[k].watchPlayer = true
									irc_QueueMsg(server.ircWatch, &quot;Player &quot; .. players[k].name .. &quot; has &quot; .. b.quantity .. &quot; of &quot; .. b.item .. &quot;.  They have been added to the watch list.&quot;)
								end
							end

						end
					end				
				end 
			end

if debug then display (&quot;check inventory 5\n&quot;) end

			if tablelength(invTemp[k]) == 0 then 
				invTemp[k] = items 
			end

if debug then display (&quot;check inventory 6\n&quot;) end

			for a, b in pairs(invTemp[k]) do
				if items[b.item] == nil then
					items[b.item] = {}
					items[b.item].item = b.item
					items[b.item].quantity = 0
				end

				if tonumber(b.quantity) ~= tonumber(items[a].quantity) then
					inventoryChanged = true

					table.insert(changes, { b.item, tonumber(items[a].quantity) - tonumber(b.quantity) } )	

					conn:execute(&quot;INSERT INTO inventoryChanges (steam, item, delta, x, y, z, session) VALUES (&quot; .. k .. &quot;,'&quot; .. escape(b.item) .. &quot;',&quot; .. tonumber(items[a].quantity) - tonumber(b.quantity) .. &quot;,&quot; .. math.floor(v.xPos) .. &quot;,&quot; .. math.ceil(v.yPos) .. &quot;,&quot; .. math.floor(v.zPos) .. &quot;,&quot; .. players[k].sessionCount .. &quot;)&quot;)

					if (items[a] == nil) then
						d1 = 0
					else
						d1 = tonumber(items[a].quantity)
					end

					delta = d1 - tonumber(b.quantity)
					if tonumber(delta) &gt; 0 then
						delta = &quot;+&quot; .. delta
					else
						delta = delta
					end

					if (players[k].watchPlayer == true) then
						cursor,errorString = conn:execute(&quot;SELECT * FROM memRestrictedItems where item = '&quot; .. escape(b.item) .. &quot;' and action = 'watch'&quot;)
						row = cursor:fetch({}, &quot;a&quot;)
						if row then
							if (b.item == row.item) and not string.find(newItems, b.item) then
								newItems = newItems .. row.item .. &quot; (&quot; .. delta .. &quot;), &quot;	
							end
						end

						if tonumber(delta) &gt; 30 and players[k].newPlayer == true and not string.find(newItems, b.item) then
							newItems = newItems .. b.item .. &quot; (&quot; .. delta .. &quot;), &quot;	
						end

						if (b.item == &quot;keystone&quot;) and not string.find(newItems, b.item) then
							newItems = newItems .. &quot;keystone (&quot; .. delta .. &quot;), &quot;	
								
							if tonumber(delta) &lt; 0 then
								players[k].keystones = 0
								send(&quot;llp &quot; .. k)
							end
						end
					end
				end
			end

if debug then display (&quot;check inventory 7\n&quot;) end

			if (players[k].watchPlayer == true) then
				if newItems ~= &quot;&quot; then
					for n, m in pairs(igplayers) do
						if (accessLevel(n) &lt; 3) then
							message(&quot;pm &quot; .. n .. &quot; [&quot; .. server.chatColour .. &quot;]Watched player &quot; .. players[k].id .. &quot; &quot; .. players[k].name .. &quot; &quot; .. newItems .. &quot;[-]&quot;)
						end
					end

					irc_QueueMsg(server.ircMain, &quot;Watched player &quot; .. players[k].id .. &quot; &quot; .. players[k].name .. &quot; inventory &quot; .. newItems .. &quot; near &quot; .. math.floor(igplayers[k].xPos) .. &quot; &quot; .. math.ceil(igplayers[k].yPos) .. &quot; &quot; .. math.floor(igplayers[k].zPos))
				end
			end

if debug then display (&quot;check inventory 8\n&quot;) end

			if inventoryChanged == true or (v.oldBelt ~= v.belt) then --  or (belt ~= v.belt)
				conn:execute(&quot;INSERT INTO inventoryTracker (steam, x, y, z, session, belt, pack, equipment) VALUES (&quot; .. k .. &quot;,&quot; .. math.floor(v.xPos) .. &quot;,&quot; .. math.ceil(v.yPos) .. &quot;,&quot; .. math.floor(v.zPos) .. &quot;,&quot; .. players[k].sessionCount .. &quot;,'&quot; .. escape(v.belt) .. &quot;','&quot; .. escape(v.pack) .. &quot;','&quot; .. escape(v.equipment) .. &quot;')&quot;)
				invTemp[k] = items

				if inventoryChanged == true then
					if players[k].timeOnServer == nil or players[k].watchPlayer == true or v.raiding == true then
						for q, w in pairs(changes) do
							irc_QueueMsg(server.ircWatch, string.trim(flags .. &quot; &quot; .. players[k].name .. &quot;  &quot; .. w[1] .. &quot;  &quot; .. w[2] .. &quot;  [ &quot; .. math.floor(v.xPos) .. &quot; &quot; .. math.ceil(v.yPos) .. &quot; &quot; .. math.floor(v.zPos)) .. &quot; ]&quot;)
						end
					else
						if accessLevel(k) &gt; 2 and tonumber(players[k].timeOnServer) &lt; tonumber(server.newPlayerTimer)  then
							for q, w in pairs(changes) do
								irc_QueueMsg(server.ircWatch, string.trim(flags .. &quot; &quot; .. players[k].name .. &quot;  &quot; .. w[1] .. &quot;   &quot; .. w[2] .. &quot;  [ &quot; .. math.floor(v.xPos) .. &quot; &quot; .. math.ceil(v.yPos) .. &quot; &quot; .. math.floor(v.zPos)) .. &quot; ]&quot;)
							end
						end
					end
				end
			end

if debug then display (&quot;check inventory 9\n&quot;) end

			if (items[&quot;keystone&quot;] and players[k].newPlayer == true and tonumber(items[&quot;keystone&quot;].quantity) &gt; 4 and accessLevel(k) &gt; 2) and (server.gameType ~= &quot;cre&quot;) then
				banPlayer(k, &quot;1 week&quot;, &quot;Too many keystones (&quot; .. items[&quot;keystone&quot;].quantity .. &quot;)&quot;)
				message(&quot;say [&quot; .. server.chatColour .. &quot;]Banning new player &quot; .. igplayers[k].name .. &quot; 1 week for too many keystones (&quot; .. items[&quot;keystone&quot;].quantity .. &quot;) in inventory.  Cheating suspected.[-]&quot;)
				irc_QueueMsg(server.ircMain, &quot;[BANNED] New player &quot; .. k .. &quot; &quot; .. igplayers[k].name .. &quot; has &quot; .. items[&quot;keystone&quot;].quantity .. &quot;(d&quot; .. keystoneChange .. &quot;) keystones and has been banned for 1 week&quot;)
				irc_QueueMsg(server.ircAlerts, &quot;[BANNED] New player &quot; .. k .. &quot; &quot; .. igplayers[k].name .. &quot; has &quot; .. items[&quot;keystone&quot;].quantity .. &quot;(d&quot; .. keystoneChange .. &quot;) keystones and has been banned for 1 week&quot;)
				players[k].watchPlayer = true

				conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. math.floor(v.xPos) .. &quot;,&quot; .. math.ceil(v.yPos) .. &quot;,&quot; .. math.floor(v.zPos) .. &quot;,'&quot; .. serverTime .. &quot;','ban','[BANNED] New player &quot; .. k .. &quot; &quot; .. escape(igplayers[k].name) .. &quot; has &quot; .. items[&quot;keystone&quot;].quantity .. &quot;(d&quot; .. keystoneChange .. &quot;) keystones and has been banned for 1 week',&quot; .. k .. &quot;)&quot;)
			end

		end

		v.oldBelt = v.belt

if debug then display (&quot;check inventory 10\n&quot;) end

		changes = nil
		
		if (players[k].overstack == false) then
			if tonumber(players[k].overstackScore) &gt; 0 then
				players[k].overstackScore = players[k].overstackScore - 1
			end

			if 	players[k].overstackTimeout == true then
				players[k].overstackScore = players[k].overstackScore - 1
			end

			if tonumber(players[k].overstackScore) &lt; -200 then
				players[k].overstackTimeout = false
				players[k].overstackScore = 0
			end
		end

		if (players[k].overstack == true) and (accessLevel(k) &gt; 2 or server.ignoreAdmins == false) then
			message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]You are overstacking items in your inventory - &quot; .. players[k].overstackItems .. &quot;[-]&quot;)
			irc_QueueMsg(server.ircWatch, igplayers[k].name .. &quot; is overstacking &quot; .. players[k].overstackItems)
		end

		if (players[k].overstackScore == 10) and (players[k].botTimeout == false) then
			message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]If you do not break up your overstacked items into their proper stack sizes, you will be automatically sent to timeout in 3 minutes.  Deal with it now to avoid potential loss of inventory.[-]&quot;)
		end

		if (players[k].overstackScore == 10) and (players[k].botTimeout == true) then
			message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]If you do not break up your overstacked items into their proper stack sizes, you will be automatically sent a long way away and your teleport privileges will be removed.[-]&quot;)
		end

		if tonumber(players[k].overstackScore) &gt; 20 and (players[k].botTimeout == false) then
			players[k].botTimeout = true
			players[k].overstackScore = 0

			irc_params = {}
			table.insert(irc_params, server.ircMain)
			table.insert(irc_params, k)
			table.insert(irc_params, players[k].name)
			tempTimer( 2, [[irc_Request_Inventory()]] )	

			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. igplayers[k].name .. &quot; is in timeout for ignoring overstack warnings.[-]&quot;)
			message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]You are still overstacking items. Please review your inventory and break up any excessively overstacked items. Sorry if this means losing stuff but you've had 10 minutes to fix it.[-]&quot;)
			irc_QueueMsg(server.ircWatch, &quot;[TIMEOUT] &quot; .. igplayers[k].name .. &quot; is in timeout for overstacking the following &quot; .. players[k].overstackItems)
			irc_QueueMsg(server.ircAlerts, &quot;[TIMEOUT] &quot; .. igplayers[k].name .. &quot; is in timeout for overstacking the following &quot; .. players[k].overstackItems)

			conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. math.floor(v.xPos) .. &quot;,&quot; .. math.ceil(v.yPos) .. &quot;,&quot; .. math.floor(v.zPos) .. &quot;,'&quot; .. serverTime .. &quot;','timeout','Player &quot; .. escape(igplayers[k].name) .. &quot; is in timeout for overstacking the following &quot; .. escape(players[k].overstackItems) .. &quot;',&quot; .. k .. &quot;)&quot;)
		end

		if (ban == true) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Banning new player &quot; .. igplayers[k].name .. &quot; 1 year for suspected shenannigans.[-]&quot;)
			banPlayer(k, &quot;1 year&quot;, banReason)
			irc_QueueMsg(server.ircMain, &quot;[BANNED] New player &quot; .. k .. &quot; &quot; .. igplayers[k].name .. &quot; has has been banned for &quot; .. banReason .. &quot;.&quot;)
			irc_QueueMsg(server.ircAlerts, &quot;[BANNED] New player &quot; .. k .. &quot; &quot; .. igplayers[k].name .. &quot; has has been banned for 1 year for &quot; .. banReason .. &quot;.&quot;)
			conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. math.floor(v.xPos) .. &quot;,&quot; .. math.ceil(v.yPos) .. &quot;,&quot; .. math.floor(v.zPos) .. &quot;,'&quot; .. serverTime .. &quot;','ban','Player &quot; .. k .. &quot; &quot; .. escape(igplayers[k].name) .. &quot; has has been banned for 1 year for &quot; .. escape(banReason) .. &quot;.',&quot; .. k .. &quot;)&quot;)
		end

		if (timeout == true) then
			v.illegalInventory = true
			timeoutPlayer(k, timeoutReason, true)
		end

		if (move == true and players[k].exiled ~= 1) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Sending player &quot; .. igplayers[k].name .. &quot; to &quot; .. moveTo .. &quot; for &quot; .. moveReason .. &quot;.[-]&quot;)
			teleport(&quot;tele &quot; .. k .. &quot; &quot; .. locations[moveTo].x .. &quot; &quot; .. locations[moveTo].y + 1 .. &quot; &quot; .. locations[moveTo].z)
			players[k].exiled = 1
			players[k].silentBob = true
			players[k].canTeleport = false
			irc_QueueMsg(server.ircMain, &quot;Moving player &quot; .. k .. &quot; &quot; .. igplayers[k].name .. &quot; to &quot; .. moveTo .. &quot; for &quot; .. moveReason .. &quot;.&quot;)
			irc_QueueMsg(server.ircAlerts, &quot;Moving player &quot; .. k .. &quot; &quot; .. igplayers[k].name .. &quot; to &quot; .. moveTo .. &quot; for &quot; .. moveReason .. &quot;.&quot;)
			conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. math.floor(v.xPos) .. &quot;,&quot; .. math.ceil(v.yPos) .. &quot;,&quot; .. math.floor(v.zPos) .. &quot;,'&quot; .. serverTime .. &quot;','exile','Player &quot; .. k .. &quot; &quot; .. escape(igplayers[k].name) .. &quot; has has been exiled to &quot; .. escape(moveTo) .. &quot; for &quot; .. escape(moveReason) .. &quot;.',&quot; .. k .. &quot;)&quot;)
		end

if debug then display (&quot;check inventory 11\n&quot;) end

		if (players[k].allowBadInventory ~= true) then
			if badItemsFound ~= &quot;&quot; then
				igplayers[k].illegalInventory = true

				if (players[k].timeout == false) and (accessLevel(k) &gt; 2 or server.ignoreAdmins == false) then
					players[k].exiled = 1
					players[k].timeout = true
					players[k].botTimeout = true
					message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. igplayers[k].name .. &quot; is in timeout for uncraftable items &quot; .. badItemsFound .. &quot;.[-]&quot;)
					message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]You have items in your inventory that are not permitted.[-]&quot;)
					message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]You must remove all such items if you wish to return to the game.[-]&quot;)
					irc_QueueMsg(server.ircMain, igplayers[k].name .. &quot; detected with uncraftable &quot; .. badItemsFound)
					irc_QueueMsg(server.ircAlerts, igplayers[k].name .. &quot; detected with uncraftable &quot; .. badItemsFound)
					conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event) VALUES (&quot; .. math.floor(igplayers[k].xPos) .. &quot;,&quot; .. math.ceil(igplayers[k].yPos) .. &quot;,&quot; .. math.floor(igplayers[k].zPos) .. &quot;,'&quot; .. serverTime .. &quot;','timeout','Player &quot; .. escape(igplayers[k].name) .. &quot; detected with uncraftable inventory &quot; .. escape(badItemsFound) .. &quot;')&quot;)
					break
				end
			end

			if players[k].newPlayer and count500 &gt; 4  then
				igplayers[k].illegalInventory = true

				if players[k].timeout == false then
					timeoutPlayer(k, timeoutReason, true)
				end
			end
		end


		if players[k].botTimeout == true and v.illegalInventory == false and players[k].overstack == false then
			players[k].botTimeout = false
			players[k].timeout = false
			players[k].overstackScore = 0
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Releasing &quot; .. igplayers[k].name .. &quot; from timeout.[-]&quot;)
			message(&quot;say /return &quot; .. igplayers[k].name)
			message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]You are free to play again.[-]&quot;)

			send(&quot;tele &quot; .. k .. &quot; &quot; .. players[k].xPosOld .. &quot; &quot; .. players[k].yPosOld .. &quot; &quot; .. players[k].zPosOld)

			players[k].xPosOld = 0
			players[k].yPosOld = 0
			players[k].zPosOld = 0
			igplayers[k].lastLocation = &quot;&quot;
		end

	end

if debug then display (&quot;check inventory end\n&quot;) end
end


function readInventorySlot()
	local timestamp, slot, item, quantity, quality, pos, words

	timestamp = os.time()
	item = &quot;&quot;
	slot = &quot;&quot;
	quantity = 0
	quality = 0
	words = {}

	for word in line:gmatch(&quot;%w+&quot;) do table.insert(words, word) end

	--    Slot face: bandanaBlue - quality: 33
	--    Slot armor: leatherJacket - quality: 13
	--    Slot jacket: denimJacket - quality: 25
	--    Slot shirt: plaidShirt - quality: 235
	--    Slot pants: blackDenimPants - quality: 121
	--    Slot boots: wornBoots - quality: 120
	--    Slot gloves: clothGloves - quality: 58
	--    Slot eyes: aviatorGoggles - quality: 24
	--    Slot head: miningHelmet
	--    Slot 31: 003 * emptyJar

	slot = string.sub(line, string.find(line, &quot;Slot&quot;) + 5, string.find(line, &quot;: &quot;) - 1)

	if string.find(line, &quot;*&quot;) then
		slot = tonumber(slot)
		quantity = tonumber(string.sub(line, string.find(line, &quot;:&quot;) + 2, string.find(line, &quot;*&quot;) - 2))
		item = string.trim(string.sub(line, string.find(line, &quot;* &quot;) + 2))
	else
		quantity = 1
	end

	if string.find(line, &quot;quality:&quot;) then
		quality = string.trim(string.sub(line, string.find(line, &quot;quality: &quot;) + 9))

		if string.find(line, &quot;* &quot;) then
			item = string.trim(string.sub(line, string.find(line, &quot;* &quot;) + 2, string.find(line, &quot;quality:&quot;) - 4))
		else
			item = string.trim(string.sub(line, string.find(line, &quot;: &quot;) + 2, string.find(line, &quot;quality:&quot;) - 4))
		end
	else
		if item == &quot;&quot; then
			item = string.trim(string.sub(line, string.find(line, &quot;: &quot;) + 2))
		end
	end

	if (invScan == &quot;belt&quot;) then
		igplayers[invCheckID].inventory = igplayers[invCheckID].inventory .. quantity .. &quot;,&quot; .. item .. &quot;,&quot; .. quality .. &quot;|&quot;
		igplayers[invCheckID].belt = igplayers[invCheckID].belt .. slot .. &quot;,&quot; .. quantity .. &quot;,&quot; .. item .. &quot;,&quot; .. quality .. &quot;|&quot;

		if tonumber(slot) == 7 and tonumber(quantity) &gt; 0 and item == &quot;casinoCoin&quot; then
			-- do a gimme
			if (server.allowGimme) then
				igplayers[invCheckID].playGimme = true
				gimme(invCheckID)
				message(&quot;pm &quot; .. invCheckID .. &quot; [&quot; .. server.chatColour .. &quot;]To stop playing gimme, remove the casino coins from the last slot in your belt.[-]&quot;)
			end
		end
		

		if tonumber(slot) == 7 and tonumber(quantity) &gt; 0 and item == &quot;yuccaFibers&quot; then
			-- run the who command
			gmsg_who(invCheckID)
		end
	end

	if (invScan == &quot;bagpack&quot;) then
		igplayers[invCheckID].inventory = igplayers[invCheckID].inventory .. quantity .. &quot;,&quot; .. item .. &quot;,&quot; .. quality .. &quot;|&quot;
		igplayers[invCheckID].pack = igplayers[invCheckID].pack .. slot .. &quot;,&quot; .. quantity .. &quot;,&quot; .. item .. &quot;,&quot; .. quality .. &quot;|&quot;
	end

	if (invScan == &quot;equipment&quot;) then
		igplayers[invCheckID].equipment = igplayers[invCheckID].equipment .. slot .. &quot;,&quot; .. item .. &quot;,&quot; .. quality .. &quot;|&quot;
	end

	deleteLine()
end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>OneHourTimer</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function OneHourTimer()
	local counter, rows

	cecho (server.windowDebug, &quot;1 hour timer\n&quot;)

	if server.scheduledRestart == false then send(&quot;sa&quot;) end

	if (announceRoller == nil) then announceRoller = 1 end

	if (tonumber(playersOnline) == 0) then 
		return 
	end

	counter = 1
	cursor,errorString = conn:execute(&quot;SELECT * FROM announcements&quot;)
	rows = cursor:numrows()

	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		if tonumber(announceRoller) == counter then
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,0,'&quot; .. escape(row.message) .. &quot;')&quot;)
		end

		counter = counter + 1
		row = cursor:fetch(row, &quot;a&quot;)	
	end

	announceRoller = announceRoller + 1
	if (tonumber(announceRoller) &gt; rows) then announceRoller = 1 end
	return true
end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>OneMinuteTimer</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function OneMinuteTimer()
	local words, word, rday, rhour, rmin
	local diff, days, hours, restartTime, zombiePlayers

	zombiePlayers = {}
	diff = gameTick
	days = math.floor(diff / 86400)

	if (days &gt; 0) then
		diff = diff - (days * 86400)
	end

	hours = math.floor(diff / 3600)

	require &quot;lfs&quot;

	cecho (server.windowDebug, &quot;60 second timer\n&quot;)

	-- save some server fields
	conn:execute(&quot;UPDATE server SET lottery = &quot; .. server.lottery .. &quot;, date = '&quot; .. server.date .. &quot;'&quot;)

	if (scheduledReboot == true or server.scheduledRestart == true) and scheduledRestartPaused == false and tonumber(playersOnline) &gt; 0 and server.allowReboot == true then
		restartTime = server.scheduledRestartTimestamp - os.time()

		if (restartTime &gt; 60 and restartTime &lt; 601) or (restartTime &gt; 1139 and restartTime &lt; 1201) or (restartTime &gt; 1799 and restartTime &lt; 1861) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Rebooting in &quot; .. os.date(&quot;%M minutes %S seconds&quot;,server.scheduledRestartTimestamp - os.time()) .. &quot;.[-]&quot;)
		end
	end

--	if (server.ServerMaxPlayerCount &gt; 24) or (server.ServerMaxPlayerCount == 23) then
--		server.ServerMaxPlayerCount = 24
--		send(&quot;sg ServerMaxPlayerCount 24&quot;)
--		tempTimer( 1, [[send(&quot;gg&quot;)]] )
--	end

	if (idleKickTimer == nil) then 	idleKickTimer = 0 end

--	if (raidsFile == nil) then raidsFile = os.date(&quot;%Y%m%d&quot;) .. &quot;_raids.lua&quot; end

	for k, v in pairs(igplayers) do
--		if (v.afk - os.time() &lt; 421) and (playersOnline &gt;= server.ServerMaxPlayerCount) and (accessLevel(steam) &gt; 2) then
--			message(&quot;pm &quot; .. v.steam .. &quot; [&quot; .. server.chatColour .. &quot;]You appear to be away from your keyboard.  You will be kicked in &quot; .. os.date(&quot;%M minutes %S seconds&quot;,v.afk - os.time()) .. &quot; for being afk.  If you simply move you will not be kicked.[-]&quot;)
--		end

		if (v.killTimer == nil) then
			v.killTimer = 0
		end

		v.killTimer = v.killTimer + 1

		if (v.killTimer &gt; 1) then
			-- save the igplayer to players and destroy the igplayer record

			fixMissingPlayer(k)
			fixMissingIGPlayer(k)

			invTemp[k] = nil

			-- update players table with x y z
			players[k].protectPaused = nil
			players[k].name = v.name
			players[k].xPos = v.xPos
			players[k].yPos = v.yPos
			players[k].zPos = v.zPos
			players[k].seen = serverTime
			players[k].playerKills = v.playerKills
			players[k].deaths = v.deaths
			players[k].zombies = v.zombies
			players[k].score = v.score
			players[k].ping = v.ping

			if (os.time() - players[k].lastLogout) &gt; 300 then
				players[k].relogCount = 0
			end

			if (os.time() - players[k].lastLogout) &lt; 60 then
				players[k].relogCount = tonumber(players[k].relogCount) + 1
			else
				players[k].relogCount = tonumber(players[k].relogCount) - 1
				if tonumber(players[k].relogCount) &lt; 0 then players[k].relogCount = 0 dbug(&quot;relog reset 4&quot;) end
			end

			if accessLevel(k) &lt; 3 then
				conn:execute(&quot;DELETE FROM memTracker WHERE steam = &quot; .. k)
			end

			conn:execute(&quot;DELETE FROM messageQueue WHERE recipient = &quot; .. k)
			conn:execute(&quot;DELETE FROM gimmeQueue WHERE steam = &quot; .. k)
			conn:execute(&quot;DELETE FROM commandQueue WHERE steam = &quot; .. k)
			conn:execute(&quot;DELETE FROM playerQueue WHERE steam = &quot; .. k)

			if (v.timeOnServer) then players[k].timeOnServer = players[k].timeOnServer + v.sessionPlaytime end

			lastHotspots[k] = nil
			players[k].lastLogout = os.time()

			-- update the player record in the database
			updatePlayer(k)

			-- check how many claims they have placed
			send(&quot;llp &quot; .. k)

			-- flag this ingame player record for deletion
			zombiePlayers[k] = {}
		end
	end

	for k, v in pairs(zombiePlayers) do
		dbug(&quot;Removing zombie player &quot; .. players[k].name .. &quot;\n&quot;)
		igplayers[k] = nil		
	end

	-- check players table for problems and remove
	for k, v in pairs(players) do
		if (k ~= v.steam) or v.id == &quot;-1&quot; then
			players[k] = nil
		end
	end

	if (playersOnline == 0 and gameTick &lt; 0) and (scheduledReboot ~= true) and server.allowReboot == true then
		rebootTimerID = tempTimer( 60, [[startReboot()]] )
		scheduledReboot = true
	end
end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>shop</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


local id, page, count, shopState

function LookupShop(search,all)
	-- build a sorted list of the search result and store in stock table
	local cursor, errorString, row, temp

	shopCode = &quot;&quot;
	shopCategory = &quot;&quot;
	shopItem = &quot;&quot;
	shopStock = 0
	shopPrice = 0
	shopIndex = 0

	conn:execute(&quot;DELETE FROM memShop&quot;)

	if all ~= nil then
		cursor,errorString = conn:execute(&quot;SELECT * FROM shop WHERE item = '&quot; .. escape(search) .. &quot;' or category = '&quot; .. escape(search) .. &quot;' ORDER BY idx&quot;)
	else
		cursor,errorString = conn:execute(&quot;SELECT * FROM shop WHERE item like '%&quot; .. escape(search) .. &quot;%' or category like '%&quot; .. escape(search) .. &quot;%' ORDER BY idx&quot;)
	end

	shopRows = cursor:numrows()
	row = cursor:fetch({}, &quot;a&quot;)

	while row do
		shopCode = shopCategories[row.category].code .. string.format(&quot;%02d&quot;, row.idx)
		shopItem = row.item
		shopIndex = row.idx
		shopCategory = row.category
		shopStock = row.stock
		shopPrice = (row.price + row.variation) * ((100 - row.special) / 100)
		conn:execute(&quot;INSERT INTO memShop (item, idx, category, price, stock, code) VALUES ('&quot; .. escape(row.item) .. &quot;',&quot; .. row.idx .. &quot;,'&quot; .. escape(row.category) .. &quot;',&quot; .. (row.price + row.variation) * ((100 - row.special) / 100) .. &quot;,&quot; .. row.stock .. &quot;,'&quot; .. escape(shopCode) .. &quot;')&quot;)

		row = cursor:fetch(row, &quot;a&quot;)	
	end

	-- search for the shop code
	if shopCode == &quot;&quot; then
		cursor,errorString = conn:execute(&quot;SELECT * FROM shop&quot;)
		row = cursor:fetch({}, &quot;a&quot;)

		while row do
			temp = shopCategories[row.category].code .. string.format(&quot;%02d&quot;, row.idx)
		
			if temp == search then
				shopRows = 1
				shopCode = temp
				shopItem = row.item
				shopIndex = row.idx
				shopCategory = row.category
				shopStock = row.stock
				shopPrice = (row.price + row.variation) * ((100 - row.special) / 100)
				conn:execute(&quot;INSERT INTO memShop (item, idx, category, price, stock, code) VALUES ('&quot; .. escape(row.item) .. &quot;',&quot; .. row.idx .. &quot;,'&quot; .. escape(row.category) .. &quot;',&quot; .. (row.price + row.variation) * ((100 - row.special) / 100) .. &quot;,&quot; .. row.stock .. &quot;,'&quot; .. escape(shopCode) .. &quot;')&quot;)
				return
			end

			row = cursor:fetch(row, &quot;a&quot;)	
		end
	end

	return shopItem
end


function reindexShop(category)
	local nextidx, cursor, errorString, row

	cursor,errorString = conn:execute(&quot;UPDATE shop SET idx = 0 WHERE category = '&quot; .. escape(category) .. &quot;'&quot;)
	cursor,errorString = conn:execute(&quot;SELECT * FROM shop WHERE category = '&quot; .. escape(category) .. &quot;' ORDER BY item&quot;)
	row = cursor:fetch({}, &quot;a&quot;)

	nextidx = 1
	while row do
		conn:execute(&quot;UPDATE shop SET idx = &quot; .. nextidx .. &quot; WHERE item = '&quot; .. escape(row.item) .. &quot;'&quot;)		
		nextidx = nextidx + 1

		row = cursor:fetch(row, &quot;a&quot;)	
	end
end


function drawLottery()
	local winners, winnersCount, prizeDraw, x, rows

	if server.lottery == 0 then
		return
	end

	winners = {}
	winnersCount = 0

	for x=1,100,1 do
		prizeDraw = rand(100)

		cursor,errorString = conn:execute(&quot;SELECT * FROM memLottery WHERE ticket = &quot; .. prizeDraw)
		rows = cursor:numrows()

		if rows &gt; 0 then
			winnersCount = rows
			break
		end
	end

	message(&quot;say [&quot; .. server.chatColour .. &quot;]It's time for the daily lottery draw for &quot; .. server.lottery .. &quot; zennies![-]&quot;)

	if winnersCount &gt; 0 then
		prizeDraw = math.floor(server.lottery / winnersCount)

		row = cursor:fetch({}, &quot;a&quot;)
		while row do
			players[row.steam].cash = players[row.steam].cash + prizeDraw
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[row.steam].name .. &quot; won &quot; .. prizeDraw .. &quot; zennies![-]&quot;)

			if not igplayers[row.steam] then
				if winnersCount &gt; 1 then
					conn:execute(&quot;INSERT INTO mail (sender, recipient, message) VALUES (0,&quot; .. row.steam .. &quot;, 'Congratulations!  You won &quot; .. prizeDraw .. &quot; zennies in the daily lottery along with &quot; .. winnersCount - 1 .. &quot; others. :)')&quot;)
				else
					conn:execute(&quot;INSERT INTO mail (sender, recipient, message) VALUES (0,&quot; .. row.steam .. &quot;, 'Congratulations!  You won &quot; .. prizeDraw .. &quot; zennies in the daily lottery! =D')&quot;)
				end
			end

			row = cursor:fetch(row, &quot;a&quot;)	
		end

		message(&quot;say [&quot; .. server.chatColour .. &quot;]$$$ Congratulation$ $$$   xD[-]&quot;)

		conn:execute(&quot;DELETE FROM memLottery&quot;)
		conn:execute(&quot;DELETE FROM lottery&quot;)
		server.lottery = 0

		conn:execute(&quot;UPDATE server SET lottery = 0&quot;)
	else
		r = rand(6)
		if (r == 1) then message(&quot;say [&quot; .. server.chatColour .. &quot;]Nobody wins again![-]&quot;) end
		if (r == 2) then message(&quot;say [&quot; .. server.chatColour .. &quot;]Everyone lucked out that time! xD[-]&quot;) end

		if (r == 3) then 
			message(&quot;say [&quot; .. server.chatColour .. &quot;]OH NO! A zombie ate the winning number![-]&quot;) 
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,0,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]BAD ZOMBIE!  No biscuit![-]&quot;) .. &quot;')&quot;)
		end

		if (r == 4) then 
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,0,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]Tonight's winner is..[-]&quot;) .. &quot;')&quot;)
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,0,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]Nobody again!  That guy has all the luck.[-]&quot;) .. &quot;')&quot;)
		end

		if (r == 5) then 
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,0,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]Tonight's winner is..[-]&quot;) .. &quot;')&quot;)
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,0,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]*CRASH*    BLUUUUEERGH!      AAAAH!  ZOMBIES!   *SCREAM!*[-]&quot;) .. &quot;')&quot;)
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,0,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]CUT!  Go to commercials![-]&quot;) .. &quot;')&quot;)
		end

		if (r == 6) then
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,0,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]Tonight's winner is..[-]&quot;) .. &quot;')&quot;)
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,0,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]Nobody!  But he's won enough so we're doing a redraw![-]&quot;) .. &quot;')&quot;)
			tempTimer( 15, [[drawLottery()]] )
		end
	end
end


function resetShop(forced)
	local specialCount, r, i, discCount

	server.shopCountdown = server.shopCountdown - 1

	if (server.shopCountdown &lt; 0) or forced ~= nil then
		conn:execute(&quot;UPDATE shop SET stock = maxStock&quot;)
		server.shopCountdown = 1
	end
end


function doShop(command, playerid, words)
	local k, v, i, number, cmd, list

	list = &quot;&quot;
	for k, v in pairs(shopCategories) do
		if k ~= &quot;misc&quot; then
			list = list .. k .. &quot;,  &quot;
		end
	end
	list = string.sub(list, 1, string.len(list) - 3)

	shopState = &quot;[OPEN]&quot;

	if server.shopOpenHour ~= server.shopCloseHour then
		if (tonumber(gameHour) &lt; tonumber(server.shopOpenHour) or tonumber(gameHour) &gt; tonumber(server.shopCloseHour)) then
			shopState = &quot;[CLOSED]&quot;
		end
	end

	number = tonumber(string.match(command, &quot; (-?\%d+)&quot;))

	if words[1] == &quot;shop&quot; and words[2] == nil then
		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have &quot; .. players[playerid].cash .. &quot; zennies in the bank. Shop is &quot; .. shopState .. &quot;[-]&quot;)
		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Shop categories are &quot; .. list .. &quot;.[-]&quot;)
		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Type shop food (to browse our fine collection of food).[-]&quot;)
		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Stock arrives every 3 days from other zones.[-]&quot;)
		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Type help shop for more info.[-]&quot;)
		if (accessLevel(playerid) &lt; 3) then message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]shop admin (for admin commands)[-]&quot;) end
		return false
	end


	if (words[1] == &quot;shop&quot; and words[2] == &quot;admin&quot;) and (accessLevel(playerid) &lt; 3) then
		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]shop price &lt;code or item name&gt; &lt;whole number without $&gt;[-]&quot;)
		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]shop restock &lt;code or item name&gt; &lt;quantity&gt; or -1 (add quantity to stock)[-]&quot;)
		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]shop special &lt;code or item name&gt; &lt;number from 0 to 100&gt;[-]&quot;)
		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]shop variation &lt;code or item name&gt; &lt;number&gt; (can be negative)[-]&quot;)
		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can manage categories and items for sale via IRC.[-]&quot;)
		return false
	end
	
	
	if (shopCategories[words[2]]) then
		LookupShop(words[2],all)

		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]To buy type buy &lt;code&gt; &lt;quantity&gt;[-]&quot;)

		cursor,errorString = conn:execute(&quot;SELECT * FROM memShop ORDER BY category, item&quot;)
		row = cursor:fetch({}, &quot;a&quot;)

		while row do
			if tonumber(row.stock) == -1 then
				message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]code:  &quot; .. row.code .. &quot;    item:  &quot; .. row..item .. &quot; price:  &quot; .. row.price .. &quot; UNLIMITED STOCK![-]&quot;)
			else
				if row.stock == 0 then
					message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]code:  &quot; .. row.code .. &quot;    item:  &quot; .. row..item .. &quot; price: &quot; .. row.price .. &quot;[-]  [FF0000]SOLD OUT[-]&quot;)
				else
					message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]code:  &quot; .. row.code .. &quot;    item:  &quot; .. row.item .. &quot; price: &quot; .. row.price.. &quot;  (&quot; .. row.stock .. &quot; left)[-]&quot;)
				end
			end

			row = cursor:fetch(row, &quot;a&quot;)	
		end

		return false
	end	


	if (words[2] == &quot;list&quot;) then
		list = &quot;&quot;

		for k, v in pairs(shopCategories) do
			list = list .. k .. &quot;,  &quot; 
		end
		list = string.sub(list, 1, string.len(list) - 3)

		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]To browse my wares type shop &lt;category&gt;.  The categories are &quot; .. list .. &quot;.[-]&quot;)

		return false
	end

	if (words[2] == &quot;variation&quot; and words[3] ~= nil) then
		if (accessLevel(playerid) &gt; 2) then
			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			return false
		end

		LookupShop(words[3])

		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have changed the price variation for &quot; .. shopItem .. &quot; to &quot; .. number .. &quot;[-]&quot;)
		conn:execute(&quot;UPDATE shop SET variation = &quot; .. number .. &quot; WHERE item = '&quot; .. escape(shopItem) .. &quot;'&quot;)		

		return false
	end


	if (words[2] == &quot;special&quot; and words[3] ~= nil) then
		if (accessLevel(playerid) &gt; 2) then
			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			return false
		end

		LookupShop(words[3])
		number = tonumber(words[4])

		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have changed the shop special for &quot; .. shopItem .. &quot; to &quot; .. number .. &quot;[-]&quot;)

		conn:execute(&quot;UPDATE shop SET special = &quot; .. number .. &quot; WHERE item = '&quot; .. escape(shopItem) .. &quot;'&quot;)
		return false
	end


	if (words[2] == &quot;price&quot; and words[3] ~= nil) then
		if (accessLevel(playerid) &gt; 2) then
			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			return false
		end

		LookupShop(words[3])
		number = tonumber(words[4])

		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have changed the shop price for &quot; .. shopItem .. &quot; to &quot; .. number .. &quot;[-]&quot;)

		conn:execute(&quot;UPDATE shop SET price = &quot; .. number .. &quot; WHERE item = '&quot; .. escape(shopItem) .. &quot;'&quot;)
		return false
	end


	if (words[2] == &quot;restock&quot; and words[3] ~= nil) then
		if (accessLevel(playerid) &gt; 2) then
			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			return false
		end

		LookupShop(words[3])

		if (tonumber(shopStock) &gt; -1) then
			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have added &quot; .. number .. &quot; &quot; .. shopItem .. &quot; to the shop[-]&quot;)

			conn:execute(&quot;UPDATE shop SET stock = stock + &quot; .. number .. &quot; WHERE item = '&quot; .. escape(shopItem) .. &quot;'&quot;)
			conn:execute(&quot;UPDATE shop SET stock = -1 WHERE stock &lt; 0&quot;)
		end

		return false
	end


	if (words[1] == &quot;buy&quot; and words[2] == &quot;ticket&quot;) or words[1] == &quot;gamble&quot; then
		if number == nil then number = 1 end

		if accessLevel(playerid) &lt; 1 then
			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Sorry &quot; .. players[playerid].name .. &quot; server owners may not enter the lottery.[-]&quot;)
			return false
		end

		if players[playerid].cash &lt; (25 * number) then
			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Sorry &quot; .. players[playerid].name .. &quot; but you don't have enough zennies.[-]&quot;)
			return false
		end


		for i=1,number,1 do		
			found = false
			tries = 0
			gotTicket = false

			while not gotTicket do
				r = rand(100)

				cursor,errorString = conn:execute(&quot;SELECT * FROM memLottery WHERE steam = &quot; .. playerid .. &quot; AND ticket = &quot; .. r)
				rows = cursor:numrows()

				if rows &gt; 0 then
					found = true
					break
				end

				if not found then
					conn:execute(&quot;INSERT INTO memLottery (steam, ticket) VALUES (&quot; .. playerid .. &quot;,&quot; .. r .. &quot;)&quot;)
					conn:execute(&quot;INSERT INTO lottery (steam, ticket) VALUES (&quot; .. playerid .. &quot;,&quot; .. r .. &quot;)&quot;)

					players[playerid].cash = players[playerid].cash - 25
					break
				end

				tries = tries + 1
				if (tries &gt; 100) then
					break
				end
			end
		end

		conn:execute(&quot;UPDATE players SET cash = &quot; .. players[playerid].cash .. &quot; WHERE steam = &quot; .. playerid)
		cursor,errorString = conn:execute(&quot;SELECT count(ticket) as tickets FROM lottery WHERE steam = &quot; .. playerid)
		row = cursor:fetch(row, &quot;a&quot;)	

		if tonumber(row.tickets) &gt; 0 then
			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Good Luck!  You have &quot; .. row.tickets .. &quot; tickets in the next draw![-]&quot;)
		end

		return false
	end


	if (words[1] == &quot;buy&quot; and words[2] ~= nil) then
		if server.shopOpenHour ~= server.shopCloseHour then
			if (tonumber(gameHour) &lt; tonumber(server.shopOpenHour) or tonumber(gameHour) &gt; tonumber(server.shopCloseHour)) and (accessLevel(playerid) &gt; 2) then
				message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The shop is closed! Go play with zombies or something![-]&quot;)
				return false
			end
		end

		if server.shopLocation ~= nil then
			dist = distancexz(igplayers[playerid].xPos, igplayers[playerid].zPos, locations[server.shopLocation].x, locations[server.shopLocation].z)

			if (dist &gt; 20) and (accessLevel(playerid) &gt; 2) then
				message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The shop is only available in the &quot; .. server.shopLocation .. &quot; location.[-]&quot;)
				message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Type /&quot; .. server.shopLocation .. &quot; to go there now and /return when finished.[-]&quot;)
				return false
			end
		end

		LookupShop(words[2], true) 

		if words[3] ~= nil then
			number = tonumber(words[3])
		else
			number = 1
		end

		if shopRows &gt; 1 then
			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]I sell several items called &quot; .. words[2] .. &quot;.  Try again using with one of the following fine wares.&quot;)

			cursor,errorString = conn:execute(&quot;SELECT * FROM memShop ORDER BY category, item&quot;)
			row = cursor:fetch({}, &quot;a&quot;)

			while row do
				if tonumber(row.stock) == -1 then
					message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]code:  &quot; .. row.code .. &quot;    item:  &quot; .. row.item .. &quot; price:  &quot; .. row.price .. &quot; UNLIMITED STOCK![-]&quot;)
				else
					if v.remaining == 0 then
						message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]code:  &quot; .. row.code .. &quot;    item:  &quot; .. row.item .. &quot; price: &quot; .. row.price .. &quot;[-]  [FF0000]SOLD OUT[-]&quot;)
					else
						message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]code:  &quot; .. row.code .. &quot;    item:  &quot; .. row.item .. &quot; price: &quot; .. row.price.. &quot;  (&quot; .. row.stock .. &quot; left)[-]&quot;)
					end
				end

				row = cursor:fetch(row, &quot;a&quot;)	
			end

			return false
		end

		if shopItem == &quot;voodooForDummies&quot; then
			number = 1
		end

		if (tonumber(players[playerid].cash) &gt; (tonumber(shopPrice) * number)) and ((number &lt;= tonumber(shopStock) or (tonumber(shopStock) == -1))) then
			players[playerid].cash = tonumber(players[playerid].cash) - (tonumber(shopPrice) * number)

			if shopItem == &quot;P2Ptoken&quot; then
				message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have purchased &quot; .. number .. &quot; &quot; .. shopItem .. &quot;. You have &quot; .. players[playerid].cash .. &quot; zennies remaining.[-]&quot;)
				message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Use a token to teleport to a friend by typing their name with a slash eg. /bob.[-]&quot;)

				if players[playerid].tokens == nil then
					players[playerid].tokens = 0
				end

				players[playerid].tokens = players[playerid].tokens + 1
				conn:execute(&quot;UPDATE players SET tokens = &quot; .. players[playerid].tokens .. &quot; WHERE steam = &quot; .. playerid)
				return false
			end

			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have purchased &quot; .. number .. &quot; &quot; .. shopItem .. &quot;. You have &quot; .. players[playerid].cash .. &quot; zennies remaining.[-]&quot;)
			send(&quot;give &quot; .. playerid .. &quot; &quot; .. shopItem .. &quot; &quot; .. number)
			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Press e now to pick up your purchase.[-]&quot;)

			conn:execute(&quot;UPDATE players SET cash = &quot; .. players[playerid].cash .. &quot; WHERE steam = &quot; .. playerid)
			conn:execute(&quot;UPDATE shop SET stock = &quot; .. shopStock - tonumber(number) .. &quot; WHERE item = '&quot; .. escape(shopItem) .. &quot;'&quot;)

			return false
		else
			if (number &gt; tonumber(shopStock)) and (tonumber(shopStock) &gt; 0)  then
				message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]I do not have that many &quot; .. shopItem .. &quot; in stock.[-]&quot;)
			else
				message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]I am sorry but you have insufficient zennies.[-]&quot;)
			end
		end

		return false
	end


	if (words[1] == &quot;cash&quot; or words[1] == &quot;zennies&quot; or words[1] == &quot;bank&quot; or words[1] == &quot;wallet&quot;) then
		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have &quot; .. players[playerid].cash .. &quot; zennies in the bank. The shop is &quot; .. shopState .. &quot;[-]&quot;)
		return false
	end


	if (words[1] == &quot;pay&quot; and words[2] ~= nil) then
		id = LookupPlayer(words[2])
		if (id ~= nil) then
			igplayers[playerid].botQuestion = &quot;pay player&quot;
			igplayers[playerid].botQuestionID = id
			igplayers[playerid].botQuestionValue = math.abs(number)
			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You want to pay &quot; .. math.abs(number) .. &quot; zennies to &quot; .. players[id].name .. &quot;? Answer yes to complete the transaction or start over.[-]&quot;)
		end

		return false
	end


	if (words[1] == &quot;shop&quot; and words[2] ~= nil and words[3] == nil) then
		cursor,errorString = conn:execute(&quot;SELECT * FROM shop&quot;)
		shopRows = cursor:numrows()

		if shopRows == 0 then
			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]CALL THE POLICE!  The shop is empty![-]&quot;)
			return false
		end
	end


	if (words[1] == &quot;shop&quot; and words[2] ~= nil and words[3] == nil) then
		LookupShop(words[2], true)

		cursor,errorString = conn:execute(&quot;SELECT * FROM memShop ORDER BY category, item&quot;)
		row = cursor:fetch({}, &quot;a&quot;)

		while row do
			if tonumber(row.stock) == -1 then
				message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]code:  &quot; .. row.code .. &quot;    item:  &quot; .. row.item .. &quot; price:  &quot; .. row.price .. &quot; UNLIMITED STOCK![-]&quot;)
			else
				if v.remaining == 0 then
					message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]code:  &quot; .. row.code .. &quot;    item:  &quot; .. row.item .. &quot; price: &quot; .. row.price .. &quot;[-]  [FF0000]SOLD OUT[-]&quot;)
				else
					message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]code:  &quot; .. row.code .. &quot;    item:  &quot; .. row.item .. &quot; price: &quot; .. row.price.. &quot;  (&quot; .. row.stock .. &quot; left)[-]&quot;)
				end
			end

			row = cursor:fetch(row, &quot;a&quot;)	
		end
	
		return false
	end
end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>Core Functions</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function isFriend(testid, steamid)
	-- is steamid a friend of testid?

	if testid == nil then
		return false
	end

	if friends[testid] == nil then -- testid is missing from friends data
		return false
	end

	if friends[testid].friends == nil then -- testid has no friends
		return false
	end

	if string.find(friends[testid].friends, steamid) then
		-- found steamid in testid's friends list.
		return true
	end

	-- steamid is not a friend of testid
	return false
end


function message(msg, irc)
	-- parse msg and enclose the actual message in double quotes
	words = {}
	for word in msg:gmatch(&quot;%S+&quot;) do table.insert(words, word) end

	if words[1] == &quot;say&quot; then
		-- say the message in public chat
		send(&quot;say \&quot;&quot; .. string.sub(msg, 5) .. &quot;\&quot;&quot;)
	else
		-- if the recipient of the message hasn't disabled bot messages, private message them
		if players[words[2]].silentBob == false then
			send(&quot;pm  &quot; .. words[2] .. &quot; \&quot;&quot; .. string.sub(msg, 21) .. &quot;\&quot;&quot;)
		end

		if irc ~= nil then
			-- send a copy of the pm to irc
			irc_QueueMsg(irc, &quot;pm to &quot; .. words[2] .. &quot; &quot; .. string.sub(msg, 21))
		end
	end
end


function pvpZone(x, z)
	-- is the coord x,z a pvp zone?
	for k, v in pairs(locations) do
		if (v.pvp) then
			-- if the coord is inside this pvp location, return the location name
			if math.abs(v.x-x) &lt;= (tonumber(v.size)) and math.abs(v.z-z) &lt;= (tonumber(v.size)) then
				return v.name
			end
		end
	end

	return false
end


function inLocation(x, z)
	-- is the coord inside a location?
	local closestLocation, closestDistance, dist, reset

	-- since locations can exist inside other locations, work out which location centre is closest
	closestDistance = 100000
	reset = false

	for k, v in pairs(locations) do
		if v.size ~= nil then
			if math.abs(v.x-x) &lt;= tonumber(v.size) and math.abs(v.z-z) &lt;= tonumber(v.size) then
				dist = distancexz(x, z, v.x, v.z)

				if tonumber(dist) &lt; tonumber(closestDistance) then
					closestLocation = v.name
					closestDistance = dist
					reset = v.resetZone
				end	
			end
		else
			if math.abs(v.x-x) &lt; 15 and math.abs(v.z-z) &lt; 15 then
				dist = distancexz(x, z, v.x, v.z)

				if dist &lt; closestDistance then
					closestLocation = v.name
					closestDistance = dist
					reset = v.resetZone
				end	
			end
		end
	end

	if closestLocation ~= nil then
		return closestLocation, reset
	else
		return false, false
	end
end


function LookupArenaPlayer(id)
	-- is id in the arenaPlayers table?
	for k, v in pairs(arenaPlayers) do
		if (id == v.id) then
			return k
		end
	end
end


function LookupPlayer(search, match)
	-- try to find the player amoung those who are playing right now
	local id

	search = string.lower(search)

	if string.starts(search, &quot;\&quot;&quot;) and string.ends(search,&quot;\&quot;&quot;) then
		search = search:match(&quot;%w+&quot;)
		match = &quot;all&quot;
	end

	for k, v in pairs(igplayers) do
		if search == v.id then
			-- matched the player id
			return k
		end

		if k == search then
			-- matched the steam id
			return k
		end

		if (v.name ~= nil) then
			if match == &quot;all&quot; then
				-- look for an exact match
				if (search == string.lower(v.name)) then
					return k
				end

				if (v.ircAlias ~= nil) and (search == string.lower(v.ircAlias)) then
					return k
				end
			else
				-- if it contains the search it is a match
				if (search == string.lower(v.name)) or (string.find(string.lower(v.name), search)) then
					return k
				end

				if (string.find(v.id, search)) then
					return k
				end
			end
		end
	end

	-- no matches so try again but including all players
	id = LookupOfflinePlayer(search, match)

	-- if id isn't nil we found a match
	if id ~= nil then return id end
end


function LookupOfflinePlayer(search, match)
	search = string.lower(search)

	if string.starts(search, &quot;\&quot;&quot;) and string.ends(search,&quot;\&quot;&quot;) then
		search = search:match(&quot;%w+&quot;)
		match = &quot;all&quot;
	end

	for k, v in pairs(players) do
		if (v.name ~= nil) then
			if match == &quot;all&quot; then
				if (search == string.lower(v.name)) then
					return k
				end

				if (v.ircAlias ~= nil) and (search == string.lower(v.ircAlias)) then
					return k
				end
			else
				if (search == string.lower(v.name)) or (string.find(string.lower(v.name), search)) then
					return k
				end
			end
		end

		if search == v.id then
			return k
		end

		if k == search then
			return k
		end
	end

	return nil
end


function LookupIRCPass(pass)
	-- is this pass in use?
	pass = string.lower(pass)

	for k, v in pairs(players) do
		if (v.ircPass ~= nil) then
			if (pass == string.lower(v.ircPass)) then
				return k
			end
		end
	end
end


function LookupLocation(command)
	-- is command the name of a location?
	command = string.lower(command)

	if (string.find(command, &quot;/&quot;) == 1) then 
		command = string.sub(command, 2) -- strip off the leading /
	end

	for k, v in pairs(locations) do
		if (command == string.lower(v.name)) then
			return k
		end
	end
end


function LookupTeleportByName(tpname)
	-- find a teleport by its name
	tpname = string.lower(tpname)

	for k, v in pairs(teleports) do
		if (tpname == string.lower(v.name)) then
			return k
		end
	end
end


function LookupTeleport(x,y,z)
	-- is this 3D coord inside a teleport?
	match = 0

	for k, v in pairs(teleports) do
       if ((math.abs(math.abs(x) - math.abs(v.x)) &lt; 1) and (math.abs(math.abs(y) - math.abs(v.y)) &lt; 1) and (math.abs(math.abs(z) - math.abs(v.z)) &lt; 1)) then
			match = 1
			return k
		end

		if(v.dx) then
	       if ((math.abs(math.abs(x) - math.abs(v.dx)) &lt; 1) and (math.abs(math.abs(y) - math.abs(v.dy)) &lt; 1) and (math.abs(math.abs(z) - math.abs(v.dz)) &lt; 1)) then
				match = 2
				return k
			end
		end
	end
end


function ClosestHotspot(x, y, z)
	-- what is the closest hotspot to this 3D coord?
	local closest = 1000
	local dist = 2000
	local spot = 0

	for k, v in pairs(hotspots) do
		dist = distancexyz(x, y, z, v.x, v.y, v.z)
			
		if (dist &lt; closest) and (dist &lt; 21) then
			closest = dist
			spot = k
		end
	end

	if (spot ~= 0) then
		return spot
	end
end


function LookupVillager(steam, village)
	-- is steam a member of village?
	if villagers[steam .. village] ~= nil then
		return true
	else
		return false
	end
end


function tablelength(T)
	-- helper function to count the members of a Lua table
  local count = 0
  for _ in pairs(T) do count = count + 1 end
  return count
end


function getRegion(xpos,zpos)
	-- build the region name from the coords.  Each region is a physical file in the saves folder
	local x
	local z

	x = math.floor(xpos / 512)
	z = math.floor(zpos / 512)
	return &quot;r.&quot; .. x .. &quot;.&quot; .. z .. &quot;.7rg&quot;, x, z
end


function squareDistanceXZXZ(x1, z1, x2, z2, distance)
	-- calculate the square distance between 2 coords
	if math.abs(x2-x1) &gt; tonumber(distance) or math.abs(z2-z1) &gt; tonumber(distance) then
		return true
	else
		return false
	end
end


function squareDistance(x, z, distance)
	-- another square distance calculation
	if math.abs(x) &gt; tonumber(distance) or math.abs(z) &gt; tonumber(distance) then
		return true
	else
		return false
	end
end


function compare(a,b)
	-- simple sort
  return a[1] &lt; b[1]
end


function distancexyz( x1, y1, z1, x2, y2, z2 )
	-- calc the distance between 2 points in 3D
   local dx = x2 - x1
	local dy = y2 - y1
	local dz = z2 - z1	
   return math.sqrt((dx * dx) + (dy * dy) + (dz * dz))
end


function distancexz(x1, z1, x2, z2)
	-- calc the distance between 2 points in 2D (xz)
	local dx = x1 - x2
   local dz = z1 - z2
   return math.sqrt(dx * dx + dz * dz)
end


function distance( x1, y1, x2, y2 )
	-- calc the distance between 2 xy coords
   local dx = x1 - x2
   local dy = y1 - y2
   return math.sqrt( dx * dx + dy * dy )
end


function say(message)
	-- just a catcher for old code
	send(message)
	return
end


function ToInt(number)
   return math.floor(tonumber(number) or nil)
end


function getAngle(x1, z1, x2, z2)
	-- Returns the angle between two points.
	return math.atan2(z2-z1, x2-x1) 
end


function getCompass(x1, z1, x2, z2)
	-- given 2 pairs of coordinates (the player and something else), determine where it is on a compass in relation to the player.
	local direction
	local angle
	local testangle
	local increment
	local index

	direction = { &quot;south west&quot;,&quot;south&quot;,&quot;south east&quot;,&quot;east&quot;, &quot;north east&quot;,&quot;north&quot;,&quot;north west&quot;,&quot;west&quot; }

	angle = getAngle(x1, z1, x2, z2)

	increment = (2 * math.pi) / 8
	testangle = -math.pi + increment
	index = 1

	while angle &gt; tonumber(testangle) do
	    index = index + 1
	    if(index &gt; 8) then
        return direction[1] --roll over
		end

		testangle = testangle + increment
	end

	return direction[index]
end


function accessLevel(pid)
	-- determine the access level of the player

	if owners[pid] then
		players[pid].accessLevel = 0
		return 0
	end

	if admins[pid] then
		players[pid].accessLevel = 1
		return 1
	end

	if mods[pid] then
		players[pid].accessLevel = 2
		return 2
	end

	-- 3 is reserved for visiting admins

	if players[pid].donor == true then
--TODO: Add donor levels
		players[pid].accessLevel = 10
		return 10
	end

	-- anyone stripped of certain rights
	if players[pid].denyRights == true then
		players[pid].accessLevel = 99
		return 99
	end

	-- regulars
	if igplayers[pid] then
		if tonumber(players[pid].timeOnServer) + tonumber(igplayers[pid].sessionPlaytime) &gt; (server.newPlayerTimer * 60) then
			players[pid].accessLevel = 90
			return 90
		end
	else
		if tonumber(players[pid].timeOnServer) &gt; (server.newPlayerTimer * 60) then
			players[pid].accessLevel = 90
			return 90
		end
	end
	
	-- new players
	players[pid].accessLevel = 99
	return 99
end


function fixMissingPlayer(steam)
	-- if any fields are missing from the players player record, add them with default values
	if (players[steam].canTeleport == nil) then
		players[steam].canTeleport = true
	end

	if (players[steam].country == nil) then
		players[steam].country = &quot;&quot;
	end

	if (players[steam].prisoner == nil) then
		players[steam].prisoner = false
	end

	if (players[steam].whitelisted == nil) then
		players[steam].whitelisted = false
	end

	if (players[steam].permanentBan == nil) then
		players[steam].permanentBan = false
	end

	if (players[steam].tokens == nil) then
		players[steam].tokens = 0
	end

	if (players[steam].removeClaims == nil) then
		players[steam].removeClaims = false
	end

	if (players[steam].exiled == nil) then
		players[steam].exiled = 0
	end

	if (players[steam].removedClaims == nil) then
		players[steam].removedClaims = 0
	end

	if (players[steam].bed == nil) then
		players[steam].bed = &quot;&quot;
	end

	if (players[steam].seen == nil) then
		players[steam].seen = &quot;&quot;
	end

	if (players[steam].IP == nil) then
		players[steam].IP = &quot;&quot;
	end

	if (players[steam].raiding == nil) then
		players[steam].raiding = false
	end

	if (players[steam].watchCash == nil) then
		players[steam].watchCash = false
	end

	if (players[steam].alertPVP == nil) then
		players[steam].alertPVP = true
	end

	if (players[steam].shareWaypoint == nil) then
		players[steam].shareWaypoint = false
	end

	if (players[steam].teleCooldown == nil) then
		players[steam].teleCooldown = 0
	end

	if (players[steam].keystones == nil) then
		players[steam].keystones = 0
	end

	if (players[steam].firstSeen == nil) then
		players[steam].firstSeen = 0
	end

	if (players[steam].level == nil) then
		players[steam].level = 1
	end

	if (players[steam].exitX == nil) then
		players[steam].exitX = 0
		players[steam].exitY = 0
		players[steam].exitZ = 0
	end

	if players[steam].exitX == 0 and players[steam].exitZ == 0 then
		players[steam].exitY = 0
	end

	if (players[steam].exit2X == nil) then
		players[steam].exit2X = 0
		players[steam].exit2Y = 0
		players[steam].exit2Z = 0
	end

	if players[steam].exit2X == 0 and players[steam].exit2Z == 0 then
		players[steam].exit2Y = 0
	end

	if (players[steam].xPos == nil) then
		players[steam].xPos = 0
		players[steam].yPos = 0
		players[steam].zPos = 0
	end

	if (players[steam].xPosOld == nil) then
		players[steam].xPosOld = 0
		players[steam].yPosOld = 0
		players[steam].zPosOld = 0
	end

	if (players[steam].ircAlias == nil) then
		players[steam].ircAlias = &quot;&quot;
		players[steam].ircAuthenticated = false
	end

	if (players[steam].baseCooldown == nil) then
		players[steam].baseCooldown = 0
	end

	if (players[steam].silentBob == nil) then
		players[steam].silentBob = false
	end

	if (players[steam].donor == nil) then
		players[steam].donor = false
	end

	if (players[steam].donorExpiry == nil) then
		players[steam].donorLevel = 0
		players[steam].donorExpiry = os.time()
	end

	if (players[steam].timeOnServer == nil) then
		players[steam].timeOnServer = 0
	end

	if (players[steam].protect == nil) then
		players[steam].protect = false
	end

	if (players[steam].protectSize == nil) then
		players[steam].protectSize = server.baseSize
	end

	if (players[steam].protect2 == nil) then
		players[steam].protect2 = false
	end

	if (players[steam].protect2Size == nil) then
		players[steam].protect2Size = server.baseSize
	end

	if (players[steam].homeX == nil) then
		players[steam].homeX = 0
		players[steam].homeY = 0
		players[steam].homeZ = 0
	end

	if players[steam].homeX == 0 and players[steam].homeZ == 0 then
		players[steam].homeY = 0
	end

	if (players[steam].home2X == nil) then
		players[steam].home2X = 0
		players[steam].home2Y = 0
		players[steam].home2Z = 0
	end

	if players[steam].home2X == 0 and players[steam].home2Z == 0 then
		players[steam].home2Y = 0
	end

	if (players[steam].waypointX == nil) then
		players[steam].waypointX = 0
		players[steam].waypointY = 0
		players[steam].waypointZ = 0
	end

	if (players[steam].timeout == nil) then
		players[steam].timeout = false
	end

	if (players[steam].alertPrison == nil) then
		players[steam].alertPrison = true
	end

	if (players[steam].alertReset == nil) then
		players[steam].alertReset = true
	end

	if (players[steam].alertMapLimit == nil) then
		players[steam].alertMapLimit = false
	end

	if (players[steam].alertRemovedClaims == nil) then
		players[steam].alertRemovedClaims = false
	end

	if (players[steam].walkies == nil) then
		players[steam].walkies = false
	end

	if (players[steam].newPlayer == nil) then
		players[steam].newPlayer = true
	end

	if (players[steam].sessionCount == nil) then
		players[steam].sessionCount = 1
	end

	if (players[steam].rescued == nil) then
		players[steam].rescued = false
	end

	if (players[steam].watchPlayer == nil) then
		players[steam].watchPlayer = true
	end

	if (players[steam].lastBaseRaid == nil) then
		players[steam].lastBaseRaid = 0
	end

	if players[steam].names == nil then
		players[steam].names = players[steam].name
	end

	if players[steam].playtime == nil then
		players[steam].playtime = 0
	end

	if players[steam].playerKills == nil then
		players[steam].playerKills = 0
	end

	if players[steam].deaths == nil then
		players[steam].deaths = 0
	end

	if players[steam].score == nil then
		players[steam].score = 0
	end

	if players[steam].zombies == nil then
		players[steam].zombies = 0
	end

	if players[steam].cash == nil then
		players[steam].cash = 0
	end

	if players[steam].overstackScore == nil then
		players[steam].overstack = false
		players[steam].overstackScore = 0
		players[steam].overstackItems = &quot;&quot;
		players[steam].overstackTimeout = false
	end

	if (players[steam].botTimeout == nil) then
		players[steam].botTimeout = false
	end

	if players[steam].pvpCount == nil then
		players[steam].pvpCount = 0
		players[steam].pvpBounty = 0
	end

	if (invTemp[steam] == nil) then
		invTemp[steam] = {}
	end

	if (friends[steam] == nil) then
		friends[steam] = {}
		friends[steam].friends = &quot;&quot;
	end

	if (lastHotspots[steam] == nil) then
		lastHotspots[steam] = {}
	end

	if players[steam].denyRights == nil then -- if true, a player is not allowed special roles like admin.
		players[steam].denyRights = false
	end

	if players[steam].lastCommand == nil then
		players[steam].lastCommand = &quot;&quot;
		players[steam].lastCommandTimestamp = os.time()
	end

	if players[steam].lastLogout == nil then
		players[steam].lastLogout = os.time()
		players[steam].relogCount = 0
	end

	if players[steam].atHome == nil then
		players[steam].atHome = false
	end

	if players[steam].autoFriend == nil then
		players[steam].autoFriend = &quot;&quot;
	end
end


function fixMissingIGPlayer(steam)
	-- if any fields are missing from the players in-game player record, add them with default values
	if igplayers[steam].playGimme == nil then
		igplayers[steam].playGimme = false
	end

	if (igplayers[steam].tp == nil) then
		igplayers[steam].tp = 0
	end

	if igplayers[steam].alertRemovedClaims == nil then
		igplayers[steam].alertRemovedClaims = false
	end

	if (igplayers[steam].lastLogin == nil) then
		igplayers[steam].lastLogin = &quot;&quot;
	end

	if (igplayers[steam].greet == nil) then
		igplayers[steam].greet = false
	end

	if (igplayers[steam].greetdelay == nil) then
		igplayers[steam].greetdelay = 0
	end

	if (igplayers[steam].teleCooldown == nil) then
		igplayers[steam].teleCooldown = 0
	end

	if (igplayers[steam].firstSeen == nil) then
		igplayers[steam].firstSeen = os.time()
	end

	if (igplayers[steam].sessionStart == nil) then
		igplayers[steam].sessionStart = os.time()
	end

	if (igplayers[steam].sessionPlaytime == nil) then
		igplayers[steam].sessionPlaytime = 0
	end

	if (igplayers[steam].fetch == nil) then
		igplayers[steam].fetch = false
	end

	if (igplayers[steam].lastHotspot == nil) then
		igplayers[steam].lastHotspot = 0
	end

	if (igplayers[steam].inventory == nil) then
		igplayers[steam].inventory = &quot;&quot;
	end

	if (igplayers[steam].belt == nil) then
		igplayers[steam].belt = &quot;&quot;
	end

	if (igplayers[steam].pack == nil) then
		igplayers[steam].pack = &quot;&quot;
	end

	if (igplayers[steam].equipment == nil) then
		igplayers[steam].equipment = &quot;&quot;
	end

	if (igplayers[steam].illegalInventory == nil) then
		igplayers[steam].illegalInventory = false
	end

	if (igplayers[steam].inventoryLast == nil) then
		igplayers[steam].inventoryLast = &quot;&quot;
	end

	if (igplayers[steam].botQuestion == nil) then
		igplayers[steam].botQuestion = &quot;&quot;
	end

	if (igplayers[steam].region == nil) then
		igplayers[steam].region = &quot;&quot;
	end

	if (igplayers[steam].killTimer == nil) then
		igplayers[steam].killTimer = 0
	end

	if (igplayers[steam].connected == nil) then
		igplayers[steam].connected = true
	end

	if (igplayers[steam].timeOnServer == nil) then
		igplayers[steam].timeOnServer = players[steam].timeOnServer
	end

	if (igplayers[steam].region == nil) then
		igplayers[steam].region = &quot;&quot;
	end

	if (igplayers[steam].ping == nil) then
		igplayers[steam].ping = ping
	end

	if (igplayers[steam].xPos == nil) then
		igplayers[steam].xPos = 0
		igplayers[steam].yPos = 0
		igplayers[steam].zPos = 0

		igplayers[steam].xPosLast = 0
		igplayers[steam].yPosLast = 0
		igplayers[steam].zPosLast = 0

		igplayers[steam].xPosLastOK = 0
		igplayers[steam].yPosLastOK = 0
		igplayers[steam].zPosLastOK = 0
	end

	if (igplayers[steam].afk == nil) then
		igplayers[steam].afk = os.time() + 900
	end

	if igplayers[steam].lastCatchTimestamp == nil then
		igplayers[steam].lastCatchTimestamp = os.time()
	end

	if igplayers[steam].alertLocation == nil then
		igplayers[steam].alertLocation = &quot;&quot;
	end

	if igplayers[steam].notifyTP == nil then
		igplayers[steam].notifyTP = false
	end
end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>mysql</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


-- useful reference: luapower.com/mysql

mysql = require &quot;luasql.mysql&quot;


function rand(high, low, real)
	-- generate a random number using MySQL
	if low == nil then low = 1 end

	if real == nil then
		cursor,errorString = conn:execute(&quot;select floor(RAND()*(&quot; .. high .. &quot;-&quot; .. low .. &quot;)+&quot; .. low .. &quot;) as rnum&quot;)
	else
		cursor,errorString = conn:execute(&quot;select RAND()*(&quot; .. high .. &quot;-&quot; .. low .. &quot;)+&quot; .. low .. &quot; as rnum&quot;)
	end

	row = cursor:fetch({}, &quot;a&quot;)
	return tonumber(row.rnum)
end


function nextID(table, idfield)
	local cursor, row, errorString

	cursor,errorString = conn:execute(&quot;SELECT MAX(&quot; .. idfield .. &quot;) as lastid FROM &quot; .. table)
	row = cursor:fetch({}, &quot;a&quot;)

	if row.id ~= nil then
		nextid = tonumber(row.lastid) + 1
	else
		nextid = 1
	end

	cursor:close()
	return nextid
end


function dbBaseDefend(steam, base)
-- experimental
	local cursor, errorString,row, dist

	dist = distancexz(igplayers[steam].xPos, igplayers[steam].zPos, players[base].homeX, players[base].homeZ)

	if dist &lt; server.baseSize then
		cursor,errorString = conn:execute(&quot;SELECT x, y, z FROM tracker WHERE steam = &quot; .. steam ..&quot; AND (abs(x - &quot; .. players[base].homeX .. &quot;) &gt; &quot; .. server.baseSize .. &quot; AND abs(z - &quot; .. players[base].homeZ .. &quot;) &gt; &quot; .. server.baseSize .. &quot;)  AND (abs(x - &quot; .. players[base].homeX .. &quot;) &lt; &quot; .. server.baseSize + 40 .. &quot; AND abs(z - &quot; .. players[base].homeZ .. &quot;) &lt; &quot; .. server.baseSize + 40 .. &quot;) ORDER BY trackerid DESC Limit 0, 50&quot;)
		row = cursor:fetch({}, &quot;a&quot;)
		while row do
			cmd = (&quot;tele &quot; .. steam .. &quot; &quot; .. row.x .. &quot; &quot; .. row.y .. &quot; &quot; .. row.z)
			teleport(cmd)

			if true then
				return
			end

			row = cursor:fetch(row, &quot;a&quot;)	
		end
	end
end


function escape(string)
	-- always escape your strings!

	if string == nil then
		return &quot;&quot;
	else
		return conn:escape(string)
	end
end


function dbTrue(value)
	-- translate db true false to Lua true false
	if value == &quot;0&quot; then
		return false
	else
		return true
	end
end


function dbYN(value)
	-- translate db true false to Lua true false
	if value == &quot;0&quot; then
		return &quot;No&quot;
	else
		return &quot;Yes&quot;
	end
end


function dbBool(value)
	-- translate Lua true false to db 1 or 0
	if value == false then
		return 0
	else
		return 1
	end
end


function initDB()
	conn:execute(&quot;DELETE FROM ircQueue&quot;)
	conn:execute(&quot;DELETE FROM memTracker&quot;)
	conn:execute(&quot;DELETE FROM messageQueue&quot;)
	conn:execute(&quot;DELETE FROM commandQueue&quot;)
	conn:execute(&quot;DELETE FROM gimmeQueue&quot;)
	conn:execute(&quot;DELETE FROM searchResults&quot;)
end


function closeDB()
	conn:close()
	connBots:close()
	env:close()
end


function openDB()
	lastAction = &quot;Open Database&quot;
	env = mysql.mysql()
-- EDIT ME!
	conn = env:connect(&quot;testbot&quot;, &quot;testbot&quot;, serverDBPassword)
-- EDIT ME!
	connBots = env:connect(&quot;bots&quot;, &quot;bots&quot;, botsDBPassword)

	alterTables()
	initDB()
end


function importBlacklist()
	local cursor, cursor2, errorString, row

	cursor,errorString = connBots:execute(&quot;SELECT * FROM IPBlacklist&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		cursor2,errorString = conn:execute(&quot;INSERT INTO IPBlacklist (StartIP, EndIP) values (&quot; .. row.StartIP .. &quot;,&quot; .. row.EndIP .. &quot;)&quot;)
		row = cursor:fetch(row, &quot;a&quot;)	
	end

	cursor:close()
	cursor2:close()
end


function importBadItems()
	local cursor, cursor2, errorString, row

	conn:execute(&quot;DELETE FROM badItems&quot;)

	cursor,errorString = connBots:execute(&quot;SELECT * FROM badItems&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		cursor2,errorString = conn:execute(&quot;INSERT INTO badItems (item, action) values ('&quot; .. escape(row.item) .. &quot;','&quot; .. row.action .. &quot;')&quot;)
		row = cursor:fetch(row, &quot;a&quot;)	
	end

	cursor:close()
	cursor2:close()
end

function alterTables()
	conn:execute(&quot;ALTER TABLE `hotspots` CHANGE `size` `size` INT(11) NOT NULL DEFAULT '2'&quot;)
	conn:execute(&quot;ALTER TABLE `hotspots` ADD `idx` INT NOT NULL DEFAULT '0'&quot;)
	conn:execute(&quot;ALTER TABLE `keystones` ADD `removed` int(11) NOT NULL DEFAULT '1'&quot;)
	conn:execute(&quot;DROP TABLE `languages`&quot;)
	conn:execute(&quot;ALTER TABLE `locations` ADD `resetZone` tinyint(1) NOT NULL DEFAULT '0'&quot;)
	conn:execute(&quot;ALTER TABLE `players` DROP `teleCooldown`&quot;)
	conn:execute(&quot;ALTER TABLE `server` ADD `gameType` VARCHAR(3) NOT NULL DEFAULT 'pve'&quot;)
	conn:execute(&quot;ALTER TABLE `players` ADD `donorLevel` INT NOT NULL DEFAULT '0' , ADD `donorExpiry` TIMESTAMP NOT NULL&quot;)
	conn:execute(&quot;ALTER TABLE `locations` ADD `other` VARCHAR(10) NULL DEFAULT NULL&quot;)
	conn:execute(&quot;ALTER TABLE `server` ADD `hideCommands` BOOLEAN NOT NULL DEFAULT TRUE&quot;)
	conn:execute(&quot;ALTER TABLE `locations` ADD `killZombies` BOOLEAN NOT NULL DEFAULT FALSE&quot;)
	conn:execute(&quot;ALTER TABLE `players` ADD `autoFriend` VARCHAR(2) NOT NULL COMMENT 'NA/AF/AD'&quot;)
	conn:execute(&quot;ALTER TABLE `server` ADD `botTick` INT NOT NULL DEFAULT '0'&quot;)
end


function readBotTick()
	local cursor, errorString, row

	cursor,errorString = conn:execute(&quot;select botTick from server&quot;)
	row = cursor:fetch({}, &quot;a&quot;)

	if row then
		return tonumber(row.botTick)
	end

	cursor:close()	
end


function writeBotTick()
	if botTick == nil then
		botTick = 0
	end

	botTick = tonumber(botTick) + 1
	conn:execute(&quot;update server set botTick = &quot; .. botTick)
end


function checkBotTick()
	local tick

	tick = readBotTick()

	if tick ~= botTick then
		botDisabled = true
		dbug(&quot;Another bot has been detected.  This bot has been disabled.&quot;)
		irc_QueueMsg(server.ircMain, &quot;Another bot has been detected.  This bot has been disabled.  Do not run multiples of the same bot!&quot;)
		disconnect()
	end
end                                                                                                      </script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_base</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
base commands
=============
set base size
setbed
setbase
protect
base
delbase
protectbase
unprotectbase
setbase &lt;player&gt;
pause
resume
test base
--]]


function gmsg_base()
	calledFunction = &quot;gmsg_base&quot;

	local id, pname, psize,  words, word, dist, debug, dist1, dist2, wait, loc, reset

	debug = false

if debug then dbug(&quot;debug base 0&quot;) end

	-- don't proceed if there is no leading slash
	if (string.sub(gmsgvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyGMSG = false
		return false
	end
  
--working
	if (gmsgvars.words[1] == &quot;set&quot; and (gmsgvars.words[2] == &quot;base&quot; or gmsgvars.words[2] == &quot;base2&quot;) and gmsgvars.words[3] == &quot;size&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				gmsgvars.faultyGMSG = false
				return true
			end
		end

		pname = &quot;&quot;
		words = {}
		for word in gmsgvars.command:gmatch(&quot;%w+&quot;) do table.insert(words, word) end

		id = LookupPlayer(gmsgvars.words[5])
		if (players[id]) then
			pname = players[id].name
		end

		psize = string.match(gmsgvars.command, &quot; (%d+)&quot;)
		psize = tonumber(psize)

		if (pname == &quot;&quot;) then
			faultyGMSG = false
			return
		end

		if (gmsgvars.words[2] == &quot;base&quot;) then
			if (players[id]) then players[id].protectSize = psize end
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name ..&quot;'s base is protected to &quot; .. psize .. &quot; metres from their base teleport[-]&quot;)

			conn:execute(&quot;UPDATE players SET protectSize = &quot; .. psize .. &quot; WHERE steam = &quot; .. id)
		else
			if (accessLevel(id) &lt; 11) then
				if (players[id]) then players[id].protect2Size = psize end
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name ..&quot;'s 2nd base is protected to &quot; .. psize .. &quot; metres from their base teleport[-]&quot;)

				conn:execute(&quot;UPDATE players SET protect2Size = &quot; .. psize .. &quot; WHERE steam = &quot; .. id)
			end
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug base 1&quot;) end

	if (gmsgvars.words[1] == &quot;man&quot; and gmsgvars.words[2] == &quot;setbed&quot;) then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/setbed makes your nearest base your spawn point after you die.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Unlike a real bed, this can't be broken or stolen. Also it doesn't show up on the map or compass.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Use it within 50 metres of your base.[-]&quot;)

		faultyGMSG = false
		return true
	end
--working
	if (gmsgvars.words[1] == &quot;setbed&quot;) then
		dist = distancexz(gmsgvars.intX, gmsgvars.intZ, players[gmsgvars.playerid].homeX, players[gmsgvars.playerid].homeZ)
		if dist &lt; 50 then
			players[gmsgvars.playerid].bed = &quot;base1&quot;
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You will respawn at your first base after death.[-]&quot;)

			conn:execute(&quot;UPDATE players SET bed = 'base1' WHERE steam = &quot; .. id)
		end

		if (players[gmsgvars.playerid].homeX ~= 0 and players[gmsgvars.playerid].homeZ ~= 0) then
			dist = distancexz(gmsgvars.intX, gmsgvars.intZ, players[gmsgvars.playerid].home2X, players[gmsgvars.playerid].home2Z)
			if dist &lt; 50 then
				players[gmsgvars.playerid].bed = &quot;base2&quot;
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You will respawn at your second base after death.[-]&quot;)

				conn:execute(&quot;UPDATE players SET bed = 'base2' WHERE steam = &quot; .. id)
			end
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug base 2&quot;) end

	if (gmsgvars.words[1] == &quot;man&quot; and gmsgvars.words[2] == &quot;sethome&quot; or gmsgvars.words[2] == &quot;setbase&quot; or gmsgvars.words[2] == &quot;sethome2&quot; or gmsgvars.words[2] == &quot;setbase2&quot;) then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/setbase (/setbase2) tells the bot where your base(s) are so the bot can defend them and alert you and admins to raids.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]It is also used by /base to teleport you back to the spot where /setbase is done.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can and should set base protection next.  Type /man protect for info.[-]&quot;)

		faultyGMSG = false
		return true
	end

	if (gmsgvars.words[1] == &quot;sethome&quot; or gmsgvars.words[1] == &quot;setbase&quot; or gmsgvars.words[1] == &quot;sethome2&quot; or gmsgvars.words[1] == &quot;setbase2&quot;) and gmsgvars.words[2] == nil then
		if (players[gmsgvars.playerid].timeout == true) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are in timeout. Trust me, you don't want your base here.[-]&quot;)
			faultyGMSG = false
			return true
		end

		loc, reset = inLocation(igplayers[gmsgvars.playerid].xPos, igplayers[gmsgvars.playerid].zPos)

		if resetRegions[gmsgvars.region] or reset then --  and (accessLevel(gmsgvars.playerid) &gt; 2 or server.ignoreAdmins == false)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are in a reset zone. Do not set your base here. It will be deleted when this zone is reset.[-]&quot;)
			faultyGMSG = false
			return true
		end

		if not validPosition(gmsgvars.playerid, true) then
			faultyGMSG = false
			return true
		end

		for k, v in pairs(locations) do
			if v.village == nil then
				dist = distance(igplayers[gmsgvars.playerid].xPos, igplayers[gmsgvars.playerid].zPos, locations[k].x, locations[k].z)

				if locations[k].size ~= nil then
					psize = locations[k].size
				else
					psize = server.baseSize
				end

				if v.allowBase == true then
					psize = 0
				end

				if dist &lt;= tonumber(psize) then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are too close to a location.  You are not allowed to set your base here.[-]&quot;)
					faultyGMSG = false
					return true
				end
			end
		end

		if (players[gmsgvars.playerid].protect == true and accessLevel(gmsgvars.playerid) &gt; 2) then
			for k, v in pairs(igplayers) do
				if (accessLevel(k) &lt; 3) then
					if (gmsgvars.words[1] == &quot;sethome&quot; or gmsgvars.words[1] == &quot;setbase&quot;) then
						message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. igplayers[gmsgvars.playerid].name .. &quot;'s base is no longer protected.[-]&quot;)
						message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]Type playerbase &quot; .. igplayers[gmsgvars.playerid].name .. &quot; to tp there and re-activate base protection if appropriate.[-]&quot;)
					else
						message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. igplayers[gmsgvars.playerid].name .. &quot;'s 2nd base is no longer protected.[-]&quot;)
						message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]Type playerbase2 &quot; .. igplayers[gmsgvars.playerid].name .. &quot; to tp there and re-activate base protection if appropriate.[-]&quot;)
					end
				end
			end
		end

		-- set the players home coords
		if (gmsgvars.words[1] == &quot;sethome&quot; or gmsgvars.words[1] == &quot;setbase&quot;) then
			players[gmsgvars.playerid].homeX = gmsgvars.intX
			players[gmsgvars.playerid].homeY = gmsgvars.intY
			players[gmsgvars.playerid].homeZ = gmsgvars.intZ
			players[gmsgvars.playerid].exitX = gmsgvars.intX
			players[gmsgvars.playerid].exitY = gmsgvars.intY
			players[gmsgvars.playerid].exitZ = gmsgvars.intZ
			players[gmsgvars.playerid].protect = false
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is your new home location.[-]&quot;)

			conn:execute(&quot;UPDATE players SET homeX = &quot; .. gmsgvars.intX .. &quot;, homeY = &quot; .. gmsgvars.intY .. &quot;, homeZ = &quot; .. gmsgvars.intZ .. &quot;, exitX = &quot; .. gmsgvars.intX .. &quot;, exitY = &quot; .. gmsgvars.intY .. &quot;, exitZ = &quot; .. gmsgvars.intZ .. &quot;, protect = 0 WHERE steam = &quot; .. gmsgvars.playerid)
			conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. gmsgvars.intX .. &quot;,&quot; .. gmsgvars.intY .. &quot;,&quot; .. gmsgvars.intZ .. &quot;,'&quot; .. serverTime .. &quot;','setbase','Player &quot; .. escape(players[gmsgvars.playerid].name) .. &quot; set a base',&quot; .. gmsgvars.playerid .. &quot;)&quot;)
			removeInvalidHotspots(gmsgvars.playerid)
		else
			if accessLevel(gmsgvars.playerid) &lt; 11 then
				players[gmsgvars.playerid].home2X = gmsgvars.intX
				players[gmsgvars.playerid].home2Y = gmsgvars.intY
				players[gmsgvars.playerid].home2Z = gmsgvars.intZ
				players[gmsgvars.playerid].exit2X = gmsgvars.intX
				players[gmsgvars.playerid].exit2Y = gmsgvars.intY
				players[gmsgvars.playerid].exit2Z = gmsgvars.intZ
				players[gmsgvars.playerid].protect2 = false
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is the location of your 2nd base.[-]&quot;)

				conn:execute(&quot;UPDATE players SET home2X = &quot; .. gmsgvars.intX .. &quot;, home2Y = &quot; .. gmsgvars.intY .. &quot;, home2Z = &quot; .. gmsgvars.intZ .. &quot;, exit2X = &quot; .. gmsgvars.intX .. &quot;, exit2Y = &quot; .. gmsgvars.intY .. &quot;, exit2Z = &quot; .. gmsgvars.intZ .. &quot;, protect2 = 0 WHERE steam = &quot; .. gmsgvars.playerid)
				removeInvalidHotspots(gmsgvars.playerid)
			else
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Only donors and admins can have 2 bases. Consider donating. =D[-]&quot;)
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Please let us know if you are still seeing this message after donating.[-]&quot;)
			end
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug base 3&quot;) end

	if (gmsgvars.words[1] == &quot;man&quot; and gmsgvars.words[2] == &quot;protect&quot;) then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/protect defends your base from raiders by teleporting them out.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]From you base tp type /protect then just walk away from your base. The bot will do the rest.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can /pause and /resume protection or permanently allow friends in by friending them with /friend[-]&quot;)

		faultyGMSG = false
		return true
	end

	if (gmsgvars.words[1] == &quot;protect&quot; or gmsgvars.words[1] == &quot;protect2&quot; and not players[gmsgvars.playerid].prisoner and gmsgvars.words[2] ~= &quot;village&quot;) then
		-- allow base protection after player has played 30 minutes
		if (players[gmsgvars.playerid].newPlayer == true) and (players[gmsgvars.playerid].timeOnServer + igplayers[gmsgvars.playerid].sessionPlaytime &lt; 1800) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is not available to you yet.  It will be automatically unlocked soon.[-]&quot;)
			faultyGMSG = false
			return true
		end

		id = gmsgvars.playerid

		if (gmsgvars.words[2] ~= nil and accessLevel(gmsgvars.playerid) &lt; 4) then
			pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;protect&quot;) + 8)
			pname = string.trim(pname)
			id = LookupPlayer(pname)
		end

		if not validPosition(gmsgvars.playerid, true) then
			faultyGMSG = false
			return true
		end

		if gmsgvars.words[1] == &quot;protect&quot; then
			dist = distance(igplayers[gmsgvars.playerid].xPos, igplayers[gmsgvars.playerid].zPos, players[id].homeX, players[id].homeZ)
		else
			dist = distance(igplayers[gmsgvars.playerid].xPos, igplayers[gmsgvars.playerid].zPos, players[id].home2X, players[id].home2Z)
		end


		if (gmsgvars.words[1] == &quot;protect&quot;) then
			if (tonumber(dist) &lt;  tonumber(players[id].protectSize) + 1) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are too close to the base, but just walk away and I will set it when you are far enough away.[-]&quot;)
				igplayers[gmsgvars.playerid].alertBaseExit = true
				igplayers[gmsgvars.playerid].alertBaseID = id
				igplayers[gmsgvars.playerid].alertBase = 1
				faultyGMSG = false
				return true
			end

			if (tonumber(dist) &gt;  tonumber(players[id].protectSize) + 20) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are too far from the base, but just walk towards the base and I will set it when you are close enough.[-]&quot;)
				igplayers[gmsgvars.playerid].alertBaseExit = true
				igplayers[gmsgvars.playerid].alertBaseID = id
				igplayers[gmsgvars.playerid].alertBase = 1
				faultyGMSG = false
				return true
			end

			players[id].exitX = gmsgvars.intX
			players[id].exitY = gmsgvars.intY
			players[id].exitZ = gmsgvars.intZ

			conn:execute(&quot;UPDATE players SET exitX = &quot; .. gmsgvars.intX .. &quot;, exitY = &quot; .. gmsgvars.intY .. &quot;, exitZ = &quot; .. gmsgvars.intZ .. &quot; WHERE steam = &quot; .. id)

			igplayers[gmsgvars.playerid].alertBaseExit = nil
			igplayers[gmsgvars.playerid].alertBaseID = nil
			igplayers[gmsgvars.playerid].alertBase = nil

			if (accessLevel(gmsgvars.playerid) &lt; 3) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have set an exit teleport for &quot; .. players[id].name .. &quot;'s base.[-]&quot;)
			else
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have set an exit teleport for your base.[-]&quot;)
			end

			-- check for nearby bases
			failProtect = false
			for k, v in pairs(players) do
				if (v.homeX ~= nil) and k ~= id then
						if (v.homeX ~= 0 and v.homeZ ~= 0) then
						dist = distancexz(players[id].homeX, players[id].homeZ, v.homeX, v.homeZ)

						if (tonumber(dist) &lt; tonumber(players[id].protectSize)) then
							if not isFriend(k, id) then
								failProtect = true
							end
						end
					end
				end

				if (v.home2X ~= nil) then
						if (v.home2X ~= 0 and v.home2Z ~= 0) then
						dist = distancexz(players[id].homeX, players[id].homeZ, v.home2X, v.home2Z)

						if (dist &lt; players[id].protectSize + 10) then
							if not isFriend(k, id) then
								failProtect = true
							end
						end
					end
				end
			end

			if failProtect == false then
				players[id].protect = true
				message(&quot;pm &quot; .. id .. &quot; [&quot; .. server.chatColour .. &quot;]Base protection for your base is active.[-]&quot;)
			else
				message(&quot;pm &quot; .. id .. &quot; [&quot; .. server.chatColour .. &quot;]Your base is too close to another player base who is not on your friends list.  Protection cannot be enabled.[-]&quot;)
			end
		else
			if (tonumber(dist) &lt;  tonumber(players[id].protect2Size) + 1) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are too close to the base, but just walk away and I will set it when you are far enough away.[-]&quot;)
				igplayers[gmsgvars.playerid].alertBaseExit = true
				igplayers[gmsgvars.playerid].alertBaseID = id
				igplayers[gmsgvars.playerid].alertBase = 2
				faultyGMSG = false
				return true
			end

			if (tonumber(dist) &gt;  tonumber(players[id].protect2Size) + 20) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are too far from the base, but just walk towards the base and I will set it when you are close enough.[-]&quot;)
				igplayers[gmsgvars.playerid].alertBaseExit = true
				igplayers[gmsgvars.playerid].alertBaseID = id
				igplayers[gmsgvars.playerid].alertBase = 2
				faultyGMSG = false
				return true
			end

			players[id].exit2X = gmsgvars.intX
			players[id].exit2Y = gmsgvars.intY
			players[id].exit2Z = gmsgvars.intZ

			conn:execute(&quot;UPDATE players SET exit2X = &quot; .. gmsgvars.intX .. &quot;, exit2Y = &quot; .. gmsgvars.intY .. &quot;, exit2Z = &quot; .. gmsgvars.intZ .. &quot; WHERE steam = &quot; .. id)

			igplayers[gmsgvars.playerid].alertBaseExit = nil
			igplayers[gmsgvars.playerid].alertBaseID = nil
			igplayers[gmsgvars.playerid].alertBase = nil

			if (accessLevel(gmsgvars.playerid) &lt; 3) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have set an exit teleport for &quot; .. players[id].name .. &quot;'s 2nd base.[-]&quot;)
			else
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have set an exit teleport for your 2nd base.[-]&quot;)
			end

			-- check for nearby bases
			failProtect = false
			for k, v in pairs(players) do
				if (v.homeX) and (v.homeX ~= 0 and v.homeZ ~= 0) then
					dist = distancexz(players[id].home2X, players[id].home2Z, v.homeX, v.homeZ)

					if (dist &lt; players[id].protectSize2 + 10) then
						if not isFriend(k, id) then
							failProtect = true
						end
					end
				end

				if (v.home2X) and (v.home2X ~= 0 and v.home2Z ~= 0) then
					dist = distancexz(players[id].home2X, players[id].home2Z, v.home2X, v.home2Z)

					if (dist &lt; players[id].protectSize2 + 10) then
						if not isFriend(k, id) then
							failProtect = true
						end
					end
				end
			end

			if failProtect == false then
				players[id].protect2 = true
				message(&quot;pm &quot; .. id .. &quot; [&quot; .. server.chatColour .. &quot;]Base protection for your second base is active.[-]&quot;)
			else
				message(&quot;pm &quot; .. id .. &quot; [&quot; .. server.chatColour .. &quot;]Your base is too close to another player base who is not on your friends list.  Protection cannot be enabled.[-]&quot;)
			end
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug base 4&quot;) end

	if gmsgvars.words[1] == &quot;man&quot; and (gmsgvars.words[2] == &quot;base&quot; or gmsgvars.words[2] == &quot;home&quot;) then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Teleport back to your base with /base or /home.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]After using /base there is a delay set by the server owner before you can use it again.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Also the base teleport disables /return so you have to walk to return to where you were.[-]&quot;)

		faultyGMSG = false
		return true
	end

	if gmsgvars.words[1] == &quot;homer&quot; and gmsgvars.words[2] == nil then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Doh![-]&quot;)
		faultyGMSG = false
		return true
	end

	if (gmsgvars.words[1] == &quot;base&quot; or gmsgvars.words[1] == &quot;home&quot; or gmsgvars.words[1] == &quot;base2&quot; or gmsgvars.words[1] == &quot;home2&quot;) and gmsgvars.words[2] == nil then
		if (accessLevel(gmsgvars.playerid) &gt; 10) and (gmsgvars.words[1] == &quot;base2&quot; or gmsgvars.words[1] == &quot;home2&quot;) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Only donors can have 2 base teleports and base protections.  Consider donating =D[-]&quot;)
			faultyGMSG = false
			return true
		end

if debug then dbug(&quot;debug base 4a&quot;) end

		if (players[gmsgvars.playerid].timeout == true) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are in timeout. Wait for an admin to /return you.[-]&quot;)
			faultyGMSG = false
			return true
		end

if debug then dbug(&quot;debug base 4b&quot;) end

		if (players[gmsgvars.playerid].prisoner or not players[gmsgvars.playerid].canTeleport) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are not allowed to use teleports.[-]&quot;)
			faultyGMSG = false
			return true
		end

		if (gmsgvars.words[1] == &quot;base&quot; or gmsgvars.words[1] == &quot;home&quot;) and (players[gmsgvars.playerid].homeY == 0) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have not set a base yet. Type /setbase in your base first then /base will work.[-]&quot;)
			faultyGMSG = false
			return true
		end

		if (accessLevel(gmsgvars.playerid) &lt; 11) then
			if (gmsgvars.words[1] == &quot;base2&quot; or gmsgvars.words[1] == &quot;home2&quot;) and (players[gmsgvars.playerid].home2Y == 0) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have not set a 2nd base yet. Type /setbase2 in your base first then /base2 will work.[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

if debug then dbug(&quot;debug base 4c&quot;) end

		wait = true

		if gmsgvars.intY &gt; 0 then
			if (players[gmsgvars.playerid].walkies == true) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have not opted in to using teleports. Type /enabletp to opt-in.[-]&quot;)
				faultyGMSG = false
				return true
			end

if debug then dbug(&quot;debug base 4d&quot;) end

			if (players[gmsgvars.playerid].newPlayer == true) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is not available to new players.  It will be automatically unlocked after a couple of hours of play.[-]&quot;)
				faultyGMSG = false
				return true
			end

			dist1 = distancexz(players[gmsgvars.playerid].xPos, players[gmsgvars.playerid].zPos, players[gmsgvars.playerid].homeX, players[gmsgvars.playerid].homeZ)
			dist2 = distancexz(players[gmsgvars.playerid].xPos, players[gmsgvars.playerid].zPos, players[gmsgvars.playerid].home2X, players[gmsgvars.playerid].home2Z)

			if (gmsgvars.words[1] == &quot;base&quot; or gmsgvars.words[1] == &quot;home&quot;) and (tonumber(dist1) &lt; 201) then
				wait = false
			end

			if (gmsgvars.words[1] == &quot;base2&quot; or gmsgvars.words[1] == &quot;home2&quot;) and (tonumber(dist2) &lt; 201) then
				wait = false
			end

			if (accessLevel(gmsgvars.playerid) &gt; 3) then
				if (players[gmsgvars.playerid].baseCooldown - os.time() &gt; 0) then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have to wait &quot; .. os.date(&quot;%M minutes %S seconds&quot;,players[gmsgvars.playerid].baseCooldown - os.time()) .. &quot; before you can use /base again.[-]&quot;)
					faultyGMSG = false
					return true
				end
			end
		end

if debug then dbug(&quot;debug base 4h&quot;) end

		-- first record the current x y z
		if accessLevel(gmsgvars.playerid) &lt; 3 then
			igplayers[gmsgvars.playerid].lastLocation = &quot;&quot;
			savePosition(gmsgvars.playerid)
		else
			igplayers[gmsgvars.playerid].lastLocation = &quot;&quot;
			players[gmsgvars.playerid].xPosOld = 0
			players[gmsgvars.playerid].yPosOld = 0
			players[gmsgvars.playerid].zPosOld = 0
		end

if debug then dbug(&quot;debug base 4i&quot;) end

		if wait then
			if players[gmsgvars.playerid].donor == true then
				players[gmsgvars.playerid].baseCooldown = (os.time() + math.floor(server.baseCooldown / 2))
			else
				players[gmsgvars.playerid].baseCooldown = (os.time() + server.baseCooldown)
			end
		end

if debug then dbug(&quot;debug base 4j&quot;) end

		conn:execute(&quot;UPDATE players SET xPosOld = &quot; .. players[gmsgvars.playerid].xPosOld .. &quot;, yPosOld = &quot; .. players[gmsgvars.playerid].yPosOld .. &quot;, zPosOld = &quot; .. players[gmsgvars.playerid].zPosOld .. &quot;, baseCooldown = &quot; .. players[gmsgvars.playerid].baseCooldown .. &quot; WHERE steam = &quot; .. gmsgvars.playerid)

if debug then dbug(&quot;debug base 4k&quot;) end

		if (gmsgvars.words[1] == &quot;base&quot; or gmsgvars.words[1] == &quot;home&quot;) then
			cmd = &quot;tele &quot; .. gmsgvars.playerid .. &quot; &quot; .. players[gmsgvars.playerid].homeX .. &quot; &quot; .. players[gmsgvars.playerid].homeY + 1 .. &quot; &quot; .. players[gmsgvars.playerid].homeZ
		else
			cmd = &quot;tele &quot; .. gmsgvars.playerid .. &quot; &quot; .. players[gmsgvars.playerid].home2X .. &quot; &quot; .. players[gmsgvars.playerid].home2Y + 1 .. &quot; &quot; .. players[gmsgvars.playerid].home2Z
		end

		if wait then
			prepareTeleport(gmsgvars.playerid, cmd)
			teleport(cmd)
		else
			send(cmd)
		end

if debug then dbug(&quot;debug base 4l&quot;) end

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug base 6\n&quot;) end

	if (gmsgvars.words[1] == &quot;man&quot; and gmsgvars.words[2] == &quot;delbase&quot;) then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/delbase will make the bot forget your base which also removes base protection.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]If you are moving your base you can just type /setbase at the new location.[-]&quot;)

		faultyGMSG = false
		return true
	end

	if (gmsgvars.words[1] == &quot;delbase&quot;) then
		id = gmsgvars.playerid

		if (gmsgvars.playername == &quot;Server&quot;) or (accessLevel(gmsgvars.playerid) &lt; 3) then
			if (gmsgvars.words[2] ~= nil) then
				pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;delbase&quot;) + 8)
				pname = string.trim(pname)
				id = LookupPlayer(pname)
				if id == nil then
					if (gmsgvars.playername ~= &quot;Server&quot;) then 
						message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No player found called &quot; .. pname .. &quot;[-]&quot;)
					else
						irc_QueueMsg(server.ircMain, &quot;No player found called &quot; .. pname)
					end

					faultyGMSG = false
					return true
				end
			end
		end

		players[id].homeX = 0
		players[id].homeY = 0
		players[id].homeZ = 0
		players[id].protect = false

		conn:execute(&quot;UPDATE players SET homeX = 0, homeY = 0, homeZ = 0, protect = 0  WHERE steam = &quot; .. id)

		if id == gmsgvars.playerid then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Your base and base protection has been removed.[-]&quot;)
		else
			if (gmsgvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot;'s base and base protection has been removed.[-]&quot;)
			else
				irc_QueueMsg(server.ircMain, players[id].name .. &quot;'s base and base protection has been removed.&quot;)
			end
		end

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug base 7\n&quot;) end

	if gmsgvars.words[1] == &quot;delbase2&quot; and (accessLevel(gmsgvars.playerid) &lt; 4) then
		id = gmsgvars.playerid

		if (gmsgvars.playername == &quot;Server&quot;) or (accessLevel(gmsgvars.playerid) &lt; 3) then
			if (gmsgvars.words[2] ~= nil) then
				pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;delbase2&quot;) + 9)
				pname = string.trim(pname)
				id = LookupPlayer(pname)
				if id == nil then
					if (gmsgvars.playername ~= &quot;Server&quot;) then 
						message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No player found called &quot; .. pname .. &quot;[-]&quot;)
					else
						irc_QueueMsg(server.ircMain, &quot;No player found called &quot; .. pname)
					end

					faultyGMSG = false
					return true
				end
			end
		end

		players[id].home2X = 0
		players[id].home2Y = 0
		players[id].home2Z = 0
		players[id].protect2 = false

		conn:execute(&quot;UPDATE players SET home2X = 0, home2Y = 0, home2Z = 0, protect2 = 0  WHERE steam = &quot; .. id)

		if id == gmsgvars.playerid then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Your 2nd base and base protection has been removed.[-]&quot;)
		else
			if (gmsgvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot;'s 2nd base and base protection has been removed.[-]&quot;)
			else
				irc_QueueMsg(server.ircMain, players[id].name .. &quot;'s 2nd base and base protection has been removed.&quot;)
			end
		end

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug base 8\n&quot;) end

	if (gmsgvars.words[1] == &quot;unprotectbase&quot; or gmsgvars.words[1] == &quot;unprotectbase2&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;unprotectbase&quot;) + 14)
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if (pname == nil or pname == &quot;&quot;) then
			faultyGMSG = false
			return true
		end

		if (gmsgvars.words[1] == &quot;unprotectbase&quot;) then
			if (players[id]) then players[id].protect = false end
			conn:execute(&quot;UPDATE players SET protect = 0 WHERE steam = &quot; .. id)

			if (gmsgvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name ..&quot;'s base is no longer protected[-]&quot;)
			else
				irc_QueueMsg(server.ircMain, players[id].name ..&quot;'s base is no longer protected.&quot;)
			end
		else
			if (players[id].donor == true or (accessLevel(id) &lt; 4)) then
				if (players[id]) then players[id].protect2 = false end
				conn:execute(&quot;UPDATE players SET protect2 = 0 WHERE steam = &quot; .. id)

				if (gmsgvars.playername ~= &quot;Server&quot;) then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name ..&quot;'s 2nd base is no longer protected[-]&quot;)
				else
					irc_QueueMsg(server.ircMain, players[id].name ..&quot;'s 2nd base is no longer protected.&quot;)
				end
			else
				if (gmsgvars.playername ~= &quot;Server&quot;) then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Only donors and admins are allowed 2 base protections[-]&quot;)
				else
					irc_QueueMsg(server.ircMain, &quot;Only donors and admins are allowed 2 base protections.&quot;)
				end
			end
		end

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug base 11\n&quot;) end

	-- ###################  do not allow remote commands beyond this point ################
	if (gmsgvars.playerid == nil) then
		faultyGMSG = false
		return false
	end
	-- ####################################################################################

if debug then display (&quot;debug base 12\n&quot;) end

	if (gmsgvars.words[1] == &quot;setbase&quot; and gmsgvars.words[2] ~= nil) and not players[gmsgvars.playerid].prisoner then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Type setbase without anything after it.[-]&quot;)
			faultyGMSG = false
			return true
		end

		pname = gmsgvars.words[gmsgvars.wordCount]
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if not validPosition(gmsgvars.playerid, true) then
			faultyGMSG = false
			return true
		end

		if (id ~= nil) then
			players[id].homeX = gmsgvars.intX
			players[id].homeY = gmsgvars.intY
			players[id].homeZ = gmsgvars.intZ
			players[id].protectSize = server.baseSize
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot;'s base has been set at where you are standing.[-]&quot;)

			conn:execute(&quot;UPDATE players SET protectSize = &quot; .. server.baseSize .. &quot;, homeX = &quot; .. gmsgvars.intX .. &quot;, homeY = &quot; .. gmsgvars.intY .. &quot;, homeZ = &quot; .. gmsgvars.intZ .. &quot; WHERE steam = &quot; .. id)
		end

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug base 13\n&quot;) end

	if (gmsgvars.words[1] == &quot;man&quot; and gmsgvars.words[2] == &quot;test&quot; and gmsgvars.words[3] == &quot;base&quot;) then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Test your base protection for 30 seconds.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can also check your base with /status[-]&quot;)

		faultyGMSG = false
		return true
	end

	if (gmsgvars.words[1] == &quot;test&quot; and gmsgvars.words[2] == &quot;base&quot;) then
		if players[gmsgvars.playerid].protect == false and players[gmsgvars.playerid].protect2 == false then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You don't have base protection established now.  Type /protect at your base or /protect2 at your 2nd base to set it up first.[-]&quot;)
			faultyGMSG = false
			return true
		end

		igplayers[gmsgvars.playerid].protectTest = true
		igplayers[gmsgvars.playerid].protectTestEnd = os.time() + 30

		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Your base protection is active and will keep you out for 30 seconds.[-]&quot;)

		faultyGMSG = false
		return true
	end


	if (gmsgvars.words[1] == &quot;man&quot; and gmsgvars.words[2] == &quot;pause&quot;) then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can temporarily give access to your base with /pause.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Protection will automatically resume if you move more than 100 metres away or log off.[-]&quot;)

		faultyGMSG = false
		return true
	end

	if (gmsgvars.words[1] == &quot;pause&quot; or gmsgvars.words[1] == &quot;paws&quot;) and gmsgvars.words[2] == nil then
		pname = igplayers[gmsgvars.playerid].name

		if (players[gmsgvars.playerid].protect == false) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You don't have base protection established now.  An admin is required to set it up or re-establish it.[-]&quot;)
			faultyGMSG = false
			return true
		end

		dist = distancexz(igplayers[gmsgvars.playerid].xPos, igplayers[gmsgvars.playerid].zPos, players[gmsgvars.playerid].homeX, players[gmsgvars.playerid].homeZ)
		if (dist &lt; tonumber(players[gmsgvars.playerid].protectSize) + 100) then
			players[gmsgvars.playerid].protectPaused = true
		else
			players[gmsgvars.playerid].protect2Paused = true
		end

		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Your base protection is disabled while you are within 100 meters of your /base teleport.[-]&quot;)

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug base 14\n&quot;) end

	if (gmsgvars.words[1] == &quot;man&quot; and gmsgvars.words[2] == &quot;resume&quot;) then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Visitors won't leave? Resume your base protection and watch them leave.[-]&quot;)

		faultyGMSG = false
		return true
	end

	if (gmsgvars.words[1] == &quot;resume&quot;) then
		pname = igplayers[gmsgvars.playerid].name

		dist = distancexz(igplayers[gmsgvars.playerid].xPos, igplayers[gmsgvars.playerid].zPos, players[gmsgvars.playerid].home2X, players[gmsgvars.playerid].home2Z)
		if (dist &lt; tonumber(players[gmsgvars.playerid].protectSize) + 100) then
			players[gmsgvars.playerid].protectPaused = nil

			if (players[gmsgvars.playerid].protect == true) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Your base protection is now active.[-]&quot;)
			else
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You don't have base protection. An admin can set up or re-establish it for you.[-]&quot;)
			end
		else
			players[gmsgvars.playerid].protect2Paused = nil

			if (players[gmsgvars.playerid].protect2 == true) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Your second base's protection is now active.[-]&quot;)
			else
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You don't have base protection on your second base. An admin can set up or re-establish it for you.[-]&quot;)
			end
		end

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug base end\n&quot;) end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_admin</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
add /claims &lt;distance&gt; it will count all claims (using llp) within range.
add /claim owners &lt;distance&gt; will list all the players with claims down in range
update /tp so it accepts coords
admin commands
=============
reload bot
timeout
return &lt;player&gt;
release
give claim
hordeme
leave claims
remove claims
exile
free
player &lt;player&gt; is not new
add donor
remove donor
give
disallow teleport
allow teleport
enable waypoints
disable waypoints
close shop
open shop
set shop open
set shop close
set shop location
clear shop location
ignore player
include player
prisoner
arrest
resettimers
exclude admins
include admins
freeze
unfreeze
move
sendhome
watch &lt;player&gt;
stop watching
send &lt;player1&gt; to &lt;player2&gt;
who visited
bases
admin add
admin remove
goto &lt;player&gt;
offline players nearby
crimescene &lt;player&gt;
near &lt;player&gt;
add bad item
remove bad item
bad items
add restricted item
remove restricted item
restricted items
prisoners
equip admin
release here
playerbase
--]]

function gmsg_admin()
	calledFunction = &quot;gmsg_admin&quot;
	
	local debug, tmp, str

	debug = false
	tmp = {}

if debug then dbug(&quot;debug admin&quot;) end

	-- don't proceed if there is no leading slash
	if (string.sub(gmsgvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyGMSG = false
		return false
	end


	if (gmsgvars.words[1] == &quot;reload&quot; or gmsgvars.words[1] == &quot;refresh&quot; or gmsgvars.words[1] == &quot;update&quot;) and gmsgvars.words[2] == &quot;bot&quot; then
		-- run admin list, gg, ban list and lkp

		message(&quot;say [&quot; .. server.chatColour .. &quot;]Collecting known players[-]&quot;)
		send(&quot;lkp&quot;)

		tempTimer( 4, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]Reading admin list[-]&quot;)]] )
		tempTimer( 4, [[send(&quot;admin list&quot;)]] )

		tempTimer( 6, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]Reading bans[-]&quot;)]] )
		tempTimer( 6, [[send(&quot;ban list&quot;)]] )

		tempTimer( 8, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]Reading server config[-]&quot;)]] )
		tempTimer( 8, [[send(&quot;gg&quot;)]] )

		tempTimer( 10, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]Reading claims[-]&quot;)]])
		tempTimer( 10, [[send(&quot;llp)]] )

		tempTimer( 13, [[send(&quot;pm IPCHECK&quot;)]] )
		tempTimer( 13, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]Reload complete.[-]&quot;)]] )

		faultyGMSG = false
		return true

	end


	if gmsgvars.words[1] == &quot;gimme&quot; and gmsgvars.words[2] == &quot;admin&quot; and server.botName == &quot;Tester&quot; then
		-- add the steamid to the admins table
		admins[players[gmsgvars.playerid].steam] = {}
		players[gmsgvars.playerid].newPlayer = false
		players[gmsgvars.playerid].silentBob = false
		players[gmsgvars.playerid].walkies = false
		players[gmsgvars.playerid].exiled = 2
		players[gmsgvars.playerid].canTeleport = true
		players[gmsgvars.playerid].botHelp = true

		message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[gmsgvars.playerid].name .. &quot; has been given admin powers[-]&quot;)
		send(&quot;admin add &quot; .. gmsgvars.playerid .. &quot; 0&quot;)

		tempTimer( 2, [[send(&quot;admin list&quot;)]] )

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 1&quot;) end

	if (gmsgvars.words[1] == &quot;timeout&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 90) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		if (gmsgvars.words[2] == nil) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Send a player to timeout where they can only talk.[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can also send yourself to timeout but not other staff.[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/timeout &lt;player&gt;[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]See also: /return &lt;player&gt;[-]&quot;)
			faultyGMSG = false
			return true
		end

		tmp = {}
		tmp.pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;timeout &quot;) + 8)
		tmp.pname = string.trim(tmp.pname)
		tmp.id = LookupPlayer(tmp.pname)

		if (gmsgvars.playername ~= &quot;Server&quot;) then 	
			if (players[tmp.id].newPlayer == false and accessLevel(gmsgvars.playerid) &gt; 3) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are limited to sending new players to timeout. &quot; .. players[tmp.id].name .. &quot; is not new.[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		if (players[tmp.id].timeout == true) then
			if (gmsgvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This player is already in timeout.  Did you mean /return ?[-]&quot;)
			else
				irc_QueueMsg(server.ircMain, &quot;Player &quot; .. tmp.id .. &quot; &quot; .. players[tmp.id].name .. &quot; is already in timeout.&quot;)
			end

			faultyGMSG = false
			return true
		end

		if (accessLevel(tmp.id) &lt; 3 and server.ignoreAdmins == true) and tmp.id ~= gmsgvars.playerid then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Staff can not be sent to timeout.[-]&quot;)
			faultyGMSG = false
			return true
		end

		-- first record their current x y z
		players[tmp.id].timeout = true
		players[tmp.id].xPosTimeout = math.floor(players[tmp.id].xPos)
		players[tmp.id].yPosTimeout = math.ceil(players[tmp.id].yPos)
		players[tmp.id].zPosTimeout = math.floor(players[tmp.id].zPos)

		conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. players[tmp.id].xPosTimeout .. &quot;,&quot; .. players[tmp.id].yPosTimeout .. &quot;,&quot; .. players[tmp.id].zPosTimeout .. &quot;,'&quot; .. serverTime .. &quot;','timeout','Player &quot; .. escape(players[tmp.id].name) .. &quot; SteamID: &quot; .. tmp.id .. &quot; sent to timeout by &quot; .. escape(players[gmsgvars.playerid].name) .. &quot;',&quot; .. tmp.id .. &quot;)&quot;)
		
		-- then teleport the player to timeout
		send(&quot;tele &quot; .. tmp.id .. &quot; &quot; .. players[tmp.id].xPosTimeout .. &quot; -5000 &quot; .. players[tmp.id].zPosTimeout)

		message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. igplayers[tmp.id].name .. &quot; has been sent to timeout.[-]&quot;)

		conn:execute(&quot;UPDATE players SET timeout = 1, xPosTimeout = &quot; .. players[tmp.id].xPosTimeout .. &quot;, yPosTimeout = &quot; .. players[tmp.id].yPosTimeout .. &quot;, zPosTimeout = &quot; .. players[tmp.id].zPosTimeout .. &quot; WHERE steam = &quot; .. tmp.id)		

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 2&quot;) end

	if (gmsgvars.words[1] == &quot;return&quot; and gmsgvars.words[2] ~= nil) then 
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 90) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted. Just type /return.[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		tmp = {}

		if string.find(gmsgvars.command, &quot; to &quot;) then 
			tmp.loc = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot; to &quot;) + 4)
			tmp.loc = string.trim(tmp.loc)
			tmp.loc = LookupLocation(tmp.loc)

			tmp.pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;return &quot;) + 7, string.find(gmsgvars.command, &quot; to &quot;) - 1)
			tmp.pname = string.trim(tmp.pname)
			tmp.id = LookupPlayer(tmp.pname)
		else
			tmp.pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;return &quot;) + 7)
			tmp.pname = string.trim(tmp.pname)
			tmp.id = LookupPlayer(tmp.pname)
		end

		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			-- don't allow players to return anyone to a different location.
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				tmp.loc = nil
			end
		end

		if (players[tmp.id].timeout == true and tmp.id == gmsgvars.playerid and accessLevel(gmsgvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are in timeout. You cannot release yourself.[-]&quot;)
			faultyGMSG = false
			return true
		end
		
		if players[tmp.id].timeout == false and players[tmp.id].prisoner and ((tmp.id ~= gmsgvars.playerid and accessLevel(gmsgvars.playerid) &gt; 2) or gmsgvars.playerid == players[id].pvpVictim) then
			message(&quot;say release &quot; .. players[tmp.id].name)
			faultyGMSG = false
			return true	
		end	

		if (gmsgvars.playername ~= &quot;Server&quot;) then	
			if (players[tmp.id].timeout == true and players[tmp.id].newPlayer == false and accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can only use this command on new players.[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		-- return player to previously recorded x y z
		if (igplayers[tmp.id]) then
			if (players[tmp.id].yPosTimeout) then
				players[tmp.id].timeout = false
				players[tmp.id].botTimeout = false
				players[tmp.id].freeze = false 

				igplayers[tmp.id].skipExcessInventory = true

				if tmp.loc ~= nil then
					tmp.cmd = &quot;tele &quot; .. tmp.id .. &quot; &quot; .. locations[tmp.loc].x .. &quot; &quot; .. locations[tmp.loc].y .. &quot; &quot; .. locations[tmp.loc].z
				else
					send(&quot;tele &quot; .. tmp.id .. &quot; &quot; .. players[tmp.id].xPosTimeout .. &quot; &quot; .. players[tmp.id].yPosTimeout .. &quot; &quot; .. players[tmp.id].zPosTimeout)

					players[tmp.id].xPosTimeout = 0
					players[tmp.id].yPosTimeout = 0
					players[tmp.id].zPosTimeout = 0

					conn:execute(&quot;UPDATE players SET timeout = 0, botTimeout = 0, xPosTimeout = 0, yPosTimeout = 0, zPosTimeout = 0 WHERE steam = &quot; .. tmp.id)

					message(&quot;say [&quot; .. server.chatColour .. &quot;]Returning &quot; .. players[tmp.id].name .. &quot;[-]&quot;)

					faultyGMSG = false
					return true
				end

				prepareTeleport(tmp.id, tmp.cmd)
				teleport(tmp.cmd, true)

				players[tmp.id].xPosTimeout = 0
				players[tmp.id].yPosTimeout = 0
				players[tmp.id].zPosTimeout = 0

				if tmp.loc ~= nil then
					message(&quot;say [&quot; .. server.chatColour .. &quot;]Returning &quot; .. players[tmp.id].name .. &quot; to &quot; .. tmp.loc .. &quot;[-]&quot;)
				else
					message(&quot;say [&quot; .. server.chatColour .. &quot;]Returning &quot; .. players[tmp.id].name .. &quot;[-]&quot;)
				end

				conn:execute(&quot;UPDATE players SET timeout = 0, botTimeout = 0, xPosTimeout = 0, yPosTimeout = 0, zPosTimeout = 0 WHERE steam = &quot; .. tmp.id)

				faultyGMSG = false
				return true
			end

			if (players[tmp.id].yPosOld &gt; 0) then
				players[tmp.id].timeout = false
				players[tmp.id].botTimeout = false

				if tmp.loc ~= nil then
					tmp.cmd = &quot;tele &quot; .. tmp.id .. &quot; &quot; .. locations[tmp.loc].x .. &quot; &quot; .. locations[tmp.loc].y .. &quot; &quot; .. locations[tmp.loc].z
				else
					cmd = &quot;tele &quot; .. tmp.id .. &quot; &quot; .. players[tmp.id].xPosOld .. &quot; &quot; .. players[tmp.id].yPosOld .. &quot; &quot; .. players[tmp.id].zPosOld
				end

				prepareTeleport(tmp.id, tmp.cmd)
				teleport(tmp.cmd, true)

				players[tmp.id].xPosOld = 0
				players[tmp.id].yPosOld = 0
				players[tmp.id].zPosOld = 0

				conn:execute(&quot;UPDATE players SET timeout = 0, botTimeout = 0, xPosOld = 0, yPosOld = 0, zPosOld = 0 WHERE steam = &quot; .. tmp.id)

				if tmp.loc ~= nil then
					if (gmsgvars.playername ~= &quot;Server&quot;) then 
						message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Returning &quot; .. players[tmp.id].name .. &quot; to &quot; .. tmp.loc .. &quot;[-]&quot;)
					else
						message(&quot;say [&quot; .. server.chatColour .. &quot;]Returning &quot; .. players[tmp.id].name .. &quot; to &quot; .. tmp.loc .. &quot;[-]&quot;)
					end
				else
					if (gmsgvars.playername ~= &quot;Server&quot;) then 
						message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Returning &quot; .. players[tmp.id].name .. &quot;[-]&quot;)
					else
						message(&quot;say [&quot; .. server.chatColour .. &quot;]Returning &quot; .. players[tmp.id].name .. &quot;[-]&quot;)
					end
				end
			end
		else
			if (players[tmp.id].yPosTimeout) then
				players[tmp.id].timeout = false
				players[tmp.id].botTimeout = false
				players[tmp.id].location = &quot;return player&quot;

				message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[tmp.id].name .. &quot; will be returned when they next join the server.[-]&quot;)

				conn:execute(&quot;UPDATE players SET timeout = 0, botTimeout = 0 WHERE steam = &quot; .. tmp.id)

				faultyGMSG = false
				return true
			end
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 3&quot;) end

	if (gmsgvars.words[1] == &quot;release&quot; or (gmsgvars.words[1] == &quot;just&quot; and gmsgvars.words[2] == &quot;release&quot;)) then 	
		prisoner = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;release &quot;) + 8)
		prisoner = string.trim(prisoner)
		prisonerid = LookupPlayer(prisoner)
		prisoner = players[prisonerid].name

		if prisonerid == nil then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]We don't have a prisoner called &quot; .. prisoner .. &quot;.[-]&quot;)
			faultyGMSG = false
			return true
		end

		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) and players[gmsgvars.playerid].pvpVictim == 0 then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is for admins and the PVP victim only[-]&quot;)
				faultyGMSG = false
				return true
			end
			
			if (accessLevel(gmsgvars.playerid) &gt; 2) and (tonumber(players[gmsgvars.playerid].pvpVictim) &gt; 0) and (prisonerid ~= players[gmsgvars.playerid].pvpVictim) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. prisoner .. &quot; is not in prison for your death and cannot be released by you.[-]&quot;)	
				faultyGMSG = false	
				return true
			end		
		end

		if (players[prisonerid].timeout == true or players[prisonerid].botTimeout == true) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Citizen &quot; .. prisoner .. &quot; is released from timeout.[-]&quot;)
			players[prisonerid].timeout = false
			players[prisonerid].botTimeout = false
			players[prisonerid].freeze = false

			conn:execute(&quot;UPDATE players SET timeout = 0, botTimeout = 0 WHERE steam = &quot; .. prisonerid)

			faultyGMSG = false
			return true
		end

		if (not players[prisonerid].prisoner and players[prisonerid].timeout == false) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Citizen &quot; .. prisoner .. &quot; is not a prisoner[-]&quot;)
			faultyGMSG = false
			return true
		end
		
		players[prisonerid].xPosOld = 0
		players[prisonerid].yPosOld = 0
		players[prisonerid].zPosOld = 0
		
		if (igplayers[prisonerid]) then
			message(&quot;say Releasing prisoner &quot; .. prisoner)
			message(&quot;pm &quot; .. prisonerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are released from prison.  Be a good citizen if you wish to remain free.[-]&quot;)

			if (gmsgvars.words[1] ~= &quot;just&quot;) then
				if (players[prisonerid].prisonxPosOld) then
					cmd = &quot;tele &quot; .. prisonerid .. &quot; &quot; .. players[prisonerid].prisonxPosOld .. &quot; &quot; .. players[prisonerid].prisonyPosOld .. &quot; &quot; .. players[prisonerid].prisonzPosOld
					igplayers[prisonerid].lastTP = cmd
					prepareTeleport(prisonerid, cmd)
					teleport(cmd, true)
				end
			else
				message(&quot;pm &quot; .. prisonerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are a free citizen, but you must find your own way back.[-]&quot;)
			end
		else
			if (players[prisonerid]) then
				players[prisonerid].location = &quot;return player&quot;
				message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[prisonerid].name .. &quot; will be released when they next join the server.[-]&quot;)

				players[prisonerid].xPosOld = players[prisonerid].prisonxPosOld
				players[prisonerid].yPosOld = players[prisonerid].prisonyPosOld
				players[prisonerid].zPosOld = players[prisonerid].prisonzPosOld

				conn:execute(&quot;UPDATE players SET prisoner = 0, location = 'return player', xPosOld = &quot; .. players[prisonerid].prisonxPosOld .. &quot;, yPosOld = &quot; .. players[prisonerid].prisonyPosOld .. &quot;, zPosOld = &quot; .. players[prisonerid].prisonzPosOld .. &quot; WHERE steam = &quot; .. prisonerid)
			end
		end

		players[prisonerid].prisoner = false
		
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 4&quot;) end

	if gmsgvars.words[1] == &quot;give&quot; and (string.find(gmsgvars.words[2], &quot;claim&quot;) or string.find(gmsgvars.words[2], &quot;key&quot;) or string.find(gmsgvars.words[2], &quot;lcb&quot;)) then
		if players[gmsgvars.playerid].removedClaims &gt; 5 then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]I am holding a lot of claims. Due to bugs with the count I can't release them to you.  Please talk to an admin to get them back so we can verify the count.[-]&quot;)

			faultyGMSG = false
			return true
		end

		if players[gmsgvars.playerid].removedClaims &gt; 0 then
			send(&quot;give &quot; .. gmsgvars.playerid .. &quot; keystone &quot; .. players[gmsgvars.playerid].removedClaims)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]I was holding &quot; .. players[gmsgvars.playerid].removedClaims .. &quot; keystones for you and have dropped them at your feet.  Press e to collect them now.[-]&quot;)
			players[gmsgvars.playerid].removedClaims = 0
		else
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]I have no keystones to give you at this time.[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 5&quot;) end

	-- ###################  Staff only beyond this point ################
	-- Don't proceed if this is a player.  Server and staff only here.
	if (gmsgvars.playername ~= &quot;Server&quot;) then 
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			faultyGMSG = false
			return false
		end
	end
	-- ##################################################################

if debug then dbug(&quot;admin 6&quot;) end


	if (gmsgvars.words[1] == &quot;hordeme&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyGMSG = false
				return true
			end
		end

		message(&quot;say [&quot; .. server.chatColour .. &quot;]HORDE!!![-]&quot;)

		for i=1,50,1 do
			cmd = &quot;se &quot; .. players[gmsgvars.playerid].id .. &quot; &quot; .. PicknMix()
			conn:execute(&quot;INSERT INTO gimmeQueue (steam, command) VALUES (&quot; .. gmsgvars.playerid .. &quot;,'&quot; .. cmd .. &quot;')&quot;)
		end

		faultyGMSG = false
		return true
	end


	if (gmsgvars.words[1] == &quot;leave&quot; and gmsgvars.words[2] == &quot;claims&quot; and gmsgvars.words[3] ~= nil) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyGMSG = false
				return true
			end
		end

		pname = gmsgvars.words[3]
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if id ~= nil then
			-- this players claims wil not be removed unless in a reset zone and not staff
			players[id].removeClaims = false
			conn:execute(&quot;UPDATE keystones SET remove = 0 WHERE steam = &quot; .. id)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Player &quot; .. players[id].name .. &quot;'s claims will not be removed unless found in reset zones (if not staff).[-]&quot;)		

			conn:execute(&quot;UPDATE players SET removeClaims = 0 WHERE steam = &quot; .. id)
		end

		faultyGMSG = false
		return true
	end


	if (gmsgvars.words[1] == &quot;remove&quot; and gmsgvars.words[2] == &quot;claims&quot; and gmsgvars.words[3] ~= nil) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyGMSG = false
				return true
			end
		end

		pname = gmsgvars.words[3]
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if id ~= nil then
			-- flag the player's claims for removal
			players[id].removeClaims = true
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]I will remove all of player &quot; .. players[id].name .. &quot;'s claims when their chunks are loaded.[-]&quot;)		
			send(&quot;llp &quot; .. id)

			conn:execute(&quot;UPDATE players SET removeClaims = 1 WHERE steam = &quot; .. id)
		end

		faultyGMSG = false
		return true
	end


	if (gmsgvars.words[1] == &quot;exile&quot; and gmsgvars.words[2] ~= nil) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyGMSG = false
				return true
			end
		end

		pname = gmsgvars.words[2]
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if id ~= nil then
			-- flag the player as exiled
			players[id].exiled = 1
			players[id].silentBob = true
			players[id].canTeleport = false
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; has been exiled! D:[-]&quot;)

			conn:execute(&quot;UPDATE players SET exiled = 1, silentBob = 1, canTeleport = 0 WHERE steam = &quot; .. id)
		end

		faultyGMSG = false
		return true
	end


	if (gmsgvars.words[1] == &quot;free&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyGMSG = false
				return true
			end
		end

		pname = gmsgvars.words[2]
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if id ~= nil then
			-- flag the player as no longer exiled
			players[id].exiled = 2
			players[id].silentBob = false
			players[id].canTeleport = true
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; has been released from exile! :D[-]&quot;)

			conn:execute(&quot;UPDATE players SET exiled = 2, silentBob = 0, canTeleport = 1 WHERE steam = &quot; .. id)
		end

		faultyGMSG = false
		return true
	end


	if (gmsgvars.words[1] == &quot;player&quot; and string.find(gmsgvars.command, &quot;is not new&quot;)) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyGMSG = false
				return true
			end
		end

		pname = gmsgvars.words[2]
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if id ~= nil then
			-- set the newPlayer flag to false
			players[id].newPlayer = false
			players[id].watchPlayer = false
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; is no longer new here. Welcome back &quot; .. players[id].name .. &quot;! =D[-]&quot;)

			conn:execute(&quot;UPDATE players SET newPlayer = 0, watchPlayer = 0 WHERE steam = &quot; .. id)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 7&quot;) end

	if (gmsgvars.words[1] == &quot;add&quot; and gmsgvars.words[2] == &quot;donor&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyGMSG = false
				return true
			end
		end

		if (gmsgvars.words[3] == nil) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Add donors with optional level and expiry. Defaults level 1 and 10 years.[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]eg. /add donor bob level 5 expires 1 week (or month or year)[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Expires automatically. 2nd protected base becomes unprotected 1 week later.[-]&quot;)
			faultyGMSG = false
			return true
		end

		tmp = {}
		tmp.sql = &quot;UPDATE players SET donor = 1&quot;
		tmp.level = 1
		tmp.expiry = calcTimestamp(&quot;10 years&quot;)

		for i=4,gmsgvars.wordCount,1 do
			if gmsgvars.words[i] == &quot;expires&quot; then
				tmp.expiry = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;expires&quot;) + 8)
				tmp.expiry = calcTimestamp(tmp.expiry)

				if tonumber(tmp.expiry) &lt;= os.time() then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Invalid expiry entered. Expected &lt;number&gt; &lt;week or month or year&gt; eg. 1 month.[-]&quot;)		
					faultyGMSG = false
					return true
				end
			end					

			if gmsgvars.words[i] == &quot;level&quot; then
				tmp.level = math.abs(ToInt(gmsgvars.words[i+1]))

				if tmp.level &gt; 7 then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Level must be a number from 0 to 7.[-]&quot;)		
					faultyGMSG = false
					return true
				end
				
				if tmp.level == nil then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Level must be a number from 0 to 7.[-]&quot;)		
					faultyGMSG = false
					return true
				end
			end
		end

		tmp.sql = tmp.sql .. &quot;, donorExpiry = '&quot; .. os.date(&quot;%Y-%m-%d %H:%M:%S&quot;, tmp.expiry) .. &quot;', donorLevel = &quot; .. tmp.level
		tmp.pname = gmsgvars.words[3]
		tmp.id = LookupPlayer(tmp.pname)

		if tmp.id ~= nil then
			-- set the donor flag to true
			players[tmp.id].donor = true
			players[tmp.id].donorLevel = tmp.level
			players[tmp.id].donorExpiry = tmp.expiry
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[tmp.id].name .. &quot; has donated! Thanks =D[-]&quot;)
			conn:execute(tmp.sql .. &quot; WHERE steam = &quot; .. tmp.id)
		end

		faultyGMSG = false
		return true
	end


if debug then dbug(&quot;admin 8&quot;) end

	if (gmsgvars.words[1] == &quot;remove&quot; and gmsgvars.words[2] == &quot;donor&quot; and gmsgvars.words[3] ~= nil) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyGMSG = false
				return true
			end
		end

		pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;donor &quot;) + 6)
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if id ~= nil then
			-- set the donor flag to false
			players[id].donor = false
			players[id].donorLevel = 0
			players[id].donorExpiry = os.time() - 1
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; no longer has donor status :([-]&quot;)

			conn:execute(&quot;UPDATE players SET donor = 0, donorLevel = 0, donorExpiry = &quot; .. os.time() - 1 .. &quot; WHERE steam = &quot; .. id)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 10&quot;) end

	if (gmsgvars.words[1] == &quot;give&quot; and gmsgvars.words[2] ~= nil) then
		if accessLevel(gmsgvars.playerid) &gt; 0 then 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		for k, v in pairs(igplayers) do
			if accessLevel(k) &gt; 2 then
				if gmsgvars.number ~= nil then
					send(&quot;give &quot; .. k .. &quot; &quot; .. gmsgvars.words[2] .. &quot; &quot; .. gmsgvars.number)
				else
					send(&quot;give &quot; .. k .. &quot; &quot; .. gmsgvars.words[2] .. &quot; 1&quot;)
				end
				message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;][i]FREE STUFF!  Press E to pick up some &quot; .. gmsgvars.words[2] .. &quot; now.[/i]&quot;)
			end
		end
	end

if debug then dbug(&quot;admin 11&quot;) end

	if (gmsgvars.words[1] == &quot;disallow&quot; and gmsgvars.words[2] == &quot;teleport&quot; and gmsgvars.words[3] ~= nil) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;teleport&quot;) + 9)
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if id ~= nil then
			players[id].canTeleport = false
			message(&quot;say [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name ..  &quot; is not allowed to use teleports.[-]&quot;)

			conn:execute(&quot;UPDATE players SET canTeleport = 0 WHERE steam = &quot; .. id)
		end
		
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 12&quot;) end

	if (gmsgvars.words[1] == &quot;allow&quot; and gmsgvars.words[2] == &quot;teleport&quot; and gmsgvars.words[3] ~= nil) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;teleport&quot;) + 9)
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if id ~= nil then
			players[id].canTeleport = true
			message(&quot;say [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name ..  &quot; is allowed to use teleports.[-]&quot;)

			conn:execute(&quot;UPDATE players SET canTeleport = 1 WHERE steam = &quot; .. id)
		end
		
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 13&quot;) end

	if (gmsgvars.words[1] == &quot;enable&quot; and gmsgvars.words[2] == &quot;waypoints&quot; and gmsgvars.words[3] == nil) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		server.allowWaypoints = true

		conn:execute(&quot;UPDATE server SET allowWaypoints = 1&quot;)

		if (gmsgvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Waypoints are enabled for donors.[-]&quot;)	
		else
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Waypoints are enabled for donors.[-]&quot;)
		end
		
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 14&quot;) end

	if (gmsgvars.words[1] == &quot;disable&quot; and gmsgvars.words[2] == &quot;waypoints&quot; and gmsgvars.words[3] == nil) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		server.allowWaypoints = false

		conn:execute(&quot;UPDATE server SET allowWaypoints = 0&quot;)

		if (gmsgvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Waypoints are restricted to admins.[-]&quot;)	
		else
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Waypoints are restricted to admins.[-]&quot;)
		end
		
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 15&quot;) end

	if (gmsgvars.words[1] == &quot;close&quot; and gmsgvars.words[2] == &quot;shop&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		message(&quot;say [&quot; .. server.chatColour .. &quot;]The shop is closed until further notice.[-]&quot;)
		server.allowShop = false

		conn:execute(&quot;UPDATE server SET allowShop = 0&quot;)

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 16&quot;) end

	if (gmsgvars.words[1] == &quot;open&quot; and gmsgvars.words[2] == &quot;shop&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		message(&quot;say [&quot; .. server.chatColour .. &quot;]The shop is open for business.[-]&quot;)
		server.allowShop = true	

		conn:execute(&quot;UPDATE server SET allowShop = 1&quot;)

		faultyGMSG = false
		return true
	end


	if (gmsgvars.words[1] == &quot;reset&quot; and gmsgvars.words[2] == &quot;shop&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		message(&quot;say [&quot; .. server.chatColour .. &quot;]Hurrah!  NEW stock![-]&quot;)
		resetShop(true)

		faultyGMSG = false
		return true
	end


	if (gmsgvars.words[1] == &quot;set&quot; and gmsgvars.words[2] == &quot;shop&quot; and gmsgvars.words[3] == &quot;open&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		if gmsgvars.number == nil then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A number from 0 to 24 is expected (military time)[-]&quot;)
			faultyGMSG = false
			return true
		else
			gmsgvars.number = math.floor(gmsgvars.number)

			if gmsgvars.number &lt; 0 or gmsgvars.number &gt; 24 then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A number from 0 to 24 is expected (military time)[-]&quot;)
				faultyGMSG = false
				return true
			end

			if gmsgvars.number == 24 then gmsgvars.number = 0 end

			if gmsgvars.number &lt; 12 then
				str = &quot; AM&quot;
			else
				str = &quot; PM&quot;
			end

			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The shop opens at &quot; .. gmsgvars.number .. str .. &quot;[-]&quot;)
			server.shopOpenHour = gmsgvars.number
			conn:execute(&quot;UPDATE server SET shopOpenHour = &quot; .. gmsgvars.number)

			faultyGMSG = false
			return true
		end
	end


	if (gmsgvars.words[1] == &quot;set&quot; and gmsgvars.words[2] == &quot;shop&quot; and gmsgvars.words[3] == &quot;close&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		if gmsgvars.number == nil then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A number from 0 to 24 is expected (military time)[-]&quot;)
			faultyGMSG = false
			return true
		else
			gmsgvars.number = math.floor(gmsgvars.number)

			if gmsgvars.number &lt; 0 or gmsgvars.number &gt; 24 then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A number from 0 to 24 is expected (military time)[-]&quot;)
				faultyGMSG = false
				return true
			end

			if gmsgvars.number == 24 then gmsgvars.number = 0 end

			if gmsgvars.number &lt; 12 then
				str = &quot; AM&quot;
			else
				str = &quot; PM&quot;
			end

			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The shop closes at &quot; .. gmsgvars.number .. str .. &quot;[-]&quot;)
			server.shopCloseHour = gmsgvars.number
			conn:execute(&quot;UPDATE server SET shopCloseHour = &quot; .. gmsgvars.number)

			faultyGMSG = false
			return true
		end
	end


	if (gmsgvars.words[1] == &quot;set&quot; and gmsgvars.words[2] == &quot;shop&quot; and gmsgvars.words[3] == &quot;location&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		str = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;location &quot;) + 9)
		str = string.trim(str)
		str = LookupLocation(str)

		if str == nil then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A location is required for this command.[-]&quot;)
			faultyGMSG = false
			return true
		else
			message(&quot;say [&quot; .. server.chatColour .. &quot;]The shop is now located at &quot;.. str .. &quot;[-]&quot;)
			server.shopLocation = str
			conn:execute(&quot;UPDATE server SET shopLocation = '&quot; .. str .. &quot;'&quot;)

			faultyGMSG = false
			return true
		end
	end


	if (gmsgvars.words[1] == &quot;clear&quot; and gmsgvars.words[2] == &quot;shop&quot; and gmsgvars.words[3] == &quot;location&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		message(&quot;say [&quot; .. server.chatColour .. &quot;]The shop is no longer bound to a location.[-]&quot;)
		server.shopLocation = nil
		conn:execute(&quot;UPDATE server SET shopLocation = null&quot;)

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 17&quot;) end

	if (gmsgvars.words[1] == &quot;whitelist&quot; and gmsgvars.words[2] == &quot;add&quot; and gmsgvars.words[3] ~= nil) then	
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		pname = nil
		pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;add &quot;) + 4)

		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if (id == nil) then
			if (gmsgvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A player name is required.[-]&quot;)
			else
				message(&quot;say [&quot; .. server.chatColour .. &quot;]Command requires a player name or no match found.[-]&quot;)		
			end
				
			faultyGMSG = false
			return true
		end

		players[id].whitelisted = true

		conn:execute(&quot;UPDATE players SET whitelisted = 1 WHERE steam = &quot; .. id)

		if (gmsgvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name .. &quot; has been added to the whitelist.[-]&quot;)	
		else
			message(&quot;say [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name .. &quot; has been added to the whitelist.[-]&quot;)
		end
		
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 18&quot;) end

	if (gmsgvars.words[1] == &quot;whitelist&quot; and gmsgvars.words[2] == &quot;remove&quot; and gmsgvars.words[3] ~= nil) then	
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		pname = nil
		pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;remove &quot;) + 7)

		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if (id == nil) then
			if (gmsgvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A player name is required.[-]&quot;)
			else
				message(&quot;say [&quot; .. server.chatColour .. &quot;]Command requires a player name or no match found.[-]&quot;)		
			end
				
			faultyGMSG = false
			return true
		end

		players[id].whitelisted = false

		conn:execute(&quot;UPDATE players SET whitelisted = 0 WHERE steam = &quot; .. id)

		if (gmsgvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name .. &quot; is no longer whitelisted.[-]&quot;)	
		else
			message(&quot;say [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name .. &quot; is no longer whitelisted.[-]&quot;)
		end
		
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 19&quot;) end

	if (gmsgvars.words[1] == &quot;ignore&quot; and gmsgvars.words[2] == &quot;player&quot; and gmsgvars.words[3] ~= nil) then	
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		pname = nil
		pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;player &quot;) + 7)

		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if (id == nil) then
			if (gmsgvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A player name is required.[-]&quot;)
			else
				message(&quot;say [&quot; .. server.chatColour .. &quot;]Command requires a player name or no match found.[-]&quot;)		
			end
				
			faultyGMSG = false
			return true
		end

		if (players[id]) then
			players[id].allowBadInventory = true

			conn:execute(&quot;UPDATE players SET allowBadInventory = 1 WHERE steam = &quot; .. id)
		end

		if (gmsgvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name .. &quot; is allowed to carry uncraftable items.[-]&quot;)	
		else
			message(&quot;say [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name .. &quot; is allowed to carry uncraftable items.[-]&quot;)
		end
		
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 20&quot;) end

	if (gmsgvars.words[1] == &quot;include&quot; and gmsgvars.words[2] == &quot;player&quot; and gmsgvars.words[3] ~= nil) then	
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		pname = nil
		pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;player &quot;) + 7)

		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if (id == nil) then
			if (gmsgvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A player name is required.[-]&quot;)
			else
				message(&quot;say [&quot; .. server.chatColour .. &quot;]Command requires a player name or no match found.[-]&quot;)		
			end
				
			faultyGMSG = false
			return true
		end

		if (players[id]) then
			players[id].allowBadInventory = false

			conn:execute(&quot;UPDATE players SET allowBadInventory = 0 WHERE steam = &quot; .. id)
		end

		if (gmsgvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name .. &quot; is no longer allowed to carry uncraftable items.[-]&quot;)	
		else
			message(&quot;say [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name .. &quot; is no longer allowed to carry uncraftable items.[-]&quot;)
		end
		
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 21&quot;) end

	if (gmsgvars.words[1] == &quot;prisoner&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		prisoner = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;prisoner &quot;) + 9, string.find(gmsgvars.command, &quot;arrested&quot;) -1)
		prisoner = string.trim(prisoner)
		prisonerid = LookupPlayer(prisoner)
		prisoner = players[prisonerid].name
		reason = nil
		reason = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;arrested &quot;) + 9)	

		if (prisonerid == nil or not players[prisonerid].prisoner) then
			if (gmsgvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;] &quot; .. prisoner .. &quot; is not a prisoner[-]&quot;)
			else
				message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. prisoner .. &quot; is not a prisoner[-]&quot;)
			end

			faultyGMSG = false
			return true
		end

		if (players[prisonerid].prisoner and players[prisonerid].prisonReason ~= nil) then
			players[prisonerid].prisonReason = reason

			conn:execute(&quot;UPDATE players SET prisonReason = '&quot; .. escape(reason) .. &quot;' WHERE steam = &quot; .. prisonerid)
		end

		if (gmsgvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You added a reason for prisoner &quot; .. prisoner .. &quot;'s arrest[-]&quot;)
		else
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Reason for prisoner &quot; .. prisoner .. &quot;'s arrest noted.[-]&quot;)
		end
		
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 22&quot;) end

	if (gmsgvars.words[1] == &quot;arrest&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		prisoner = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;arrest &quot;) + 7)
		prisoner = string.trim(prisoner)
		prisonerid = LookupPlayer(prisoner)

		if prisonerid == nil then
			if (gmsgvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No player found called &quot; .. prisoner .. &quot;[-]&quot;)
			else
				irc_QueueMsg(server.ircMain, &quot;No player found called &quot; .. prisoner)
			end

			faultyGMSG = false
			return true
		end

		prisoner = players[prisonerid].name

		if (players[prisonerid]) then
			if (players[prisonerid].timeout == true) then
				if (gmsgvars.playername ~= &quot;Server&quot;) then 
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. prisoner .. &quot; is in timeout. /return them first[-]&quot;)
				else
					irc_QueueMsg(server.ircMain, prisoner .. &quot; is in timeout. Return them first&quot;)
				end

				faultyGMSG = false
				return true
			end
		end

		if (gmsgvars.playername ~= &quot;Server&quot;) then
			if (accessLevel(prisonerid) &lt; 3 and server.ignoreAdmins == true and prisonerid ~= gmsgvars.playerid) then
				if (gmsgvars.playername ~= &quot;Server&quot;) then 
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Staff can not be arrested.[-]&quot;)
				else
					irc_QueueMsg(server.ircMain, &quot;Staff can not be arrested.&quot;)
				end

				faultyGMSG = false
				return true
			end
		end

		if locations[&quot;prison&quot;] == nil then
			if (gmsgvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Create a location called prison first. Sending them to timeout instead..[-]&quot;)
			else
				irc_QueueMsg(server.ircMain, &quot;Create a location called prison first. Sending them to timeout instead.&quot;)
			end

			message(&quot;say /timeout &quot; .. prisoner)
			faultyGMSG = false
			return true
		end

		message(&quot;say Arresting citizen &quot; .. prisoner)

		if (not players[prisonerid].prisoner) then
			players[prisonerid].prisoner = true
			players[prisonerid].prisonxPosOld = math.floor(igplayers[prisonerid].xPos)
			players[prisonerid].prisonyPosOld = math.ceil(igplayers[prisonerid].yPos)
			players[prisonerid].prisonzPosOld = math.floor(igplayers[prisonerid].zPos)
			igplayers[prisonerid].xPosLastOK = locations[&quot;prison&quot;].x
			igplayers[prisonerid].yPosLastOK = locations[&quot;prison&quot;].y
			igplayers[prisonerid].zPosLastOK = locations[&quot;prison&quot;].z

			conn:execute(&quot;UPDATE players SET prisoner = 1, prisonxPosOld = &quot; .. players[prisonerid].prisonxPosOld .. &quot;, prisonyPosOld = &quot; .. players[prisonerid].prisonyPosOld .. &quot;, prisonzPosOld = &quot; .. players[prisonerid].prisonzPosOld .. &quot; WHERE steam = &quot; .. prisonerid)

			message(&quot;pm &quot; .. prisonerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have been sentenced to prison.  There is no escape until you are released by an admin.[-]&quot;)
				
			cmd = &quot;tele &quot; .. prisonerid .. &quot; &quot; .. locations[&quot;prison&quot;].x .. &quot; &quot; .. locations[&quot;prison&quot;].y .. &quot; &quot; .. locations[&quot;prison&quot;].z
			prepareTeleport(prisonerid, cmd)
			teleport(cmd, true)
			
			conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. players[prisonerid].xPosOld .. &quot;,&quot; .. players[prisonerid].yPosOld .. &quot;,&quot; .. players[prisonerid].zPosOld .. &quot;,'&quot; .. serverTime .. &quot;','arrest','Player &quot; .. escape(players[prisonerid].name) .. &quot; SteamID: &quot; .. prisonerid .. &quot; arrested by &quot; .. escape(players[gmsgvars.playerid].name)  .. &quot;',&quot; .. prisonerid .. &quot;)&quot;)
			
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 23&quot;) end

	if (gmsgvars.words[1] == &quot;resettimers&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		pname = nil
		pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;resettimers &quot;) + 12)

		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if (pname == nil and gmsgvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A player name is required.[-]&quot;)
			faultyGMSG = false
			return true
		end

		if (players[id]) then
			players[id].baseCooldown = 0
			players[id].gimmeCount = 0

			conn:execute(&quot;UPDATE players SET baseCooldown = 0, gimmeCount = 0 WHERE steam = &quot; .. id)
		end

		message(&quot;say [&quot; .. server.chatColour .. &quot;]Cooldown timers have been reset for &quot; .. players[id].name .. &quot;[-]&quot;)

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 24&quot;) end

	if (gmsgvars.words[1] == &quot;ignoreadmins&quot;) or (gmsgvars.words[1] == &quot;exclude&quot; and gmsgvars.words[2] == &quot;admins&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		server.ignoreAdmins = true

		if (gmsgvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Admins can ignore the server rules.[-]&quot;)		
		else
			irc_QueueMsg(server.ircMain, &quot;Admins can ignore the server rules.&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 25&quot;) end

	if (gmsgvars.words[1] == &quot;includeadmins&quot;) or (gmsgvars.words[1] == &quot;include&quot; and gmsgvars.words[2] == &quot;admins&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		server.ignoreAdmins = false

		if (gmsgvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Admins must obey the server rules.[-]&quot;)		
		else
			irc_QueueMsg(server.ircMain, &quot;Admins must obey the server rules.&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 26&quot;) end

	if (gmsgvars.words[1] == &quot;freeze&quot; and gmsgvars.words[2] ~= nil) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;freeze&quot;) + 7)
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if (pname == nil or pname == &quot;&quot;) then
			faultyGMSG = false
			return true 
		end

		if (id ~= nil) then 
			players[id].freeze = true 
			message(&quot;say [&quot; .. server.chatColour .. &quot;]STOP RIGHT THERE CRIMINAL SCUM![-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 27&quot;) end

	if (gmsgvars.words[1] == &quot;unfreeze&quot; and gmsgvars.words[2] ~= nil) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;unfreeze&quot;) + 9)
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if (pname == nil or pname == &quot;&quot;) then
			faultyGMSG = false
			return true 
		end

		if (players[id]) then 
			players[id].freeze = false 
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Citizen &quot; .. players[id].name .. &quot;, you are free to go.[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 28&quot;) end

	if (gmsgvars.words[1] == &quot;move&quot;) and gmsgvars.words[2] ~= nil and string.find(gmsgvars.command, &quot; to &quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;move&quot;) + 5, string.find(gmsgvars.command, &quot; to &quot;) - 1)
		pname = string.trim(pname)
		
		location = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot; to &quot;) + 4)
		location = string.trim(location)	

		loc = LookupLocation(location)	
		id = LookupPlayer(pname)

		if (id ~= nil and loc ~= nil) then
			-- if the player is ingame, send them to the lobby otherwise flag it to happen when they rejoin
			if (igplayers[id]) then
				cmd = &quot;tele &quot; .. id .. &quot; &quot; .. locations[loc].x .. &quot; &quot; .. locations[loc].y .. &quot; &quot; .. locations[loc].z
				igplayers[id].lastTP = cmd
				teleport(cmd, true)

				if (gmsgvars.playername ~= &quot;Server&quot;) then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Player &quot; .. players[id].name .. &quot; has been sent to &quot; .. locations[loc].name .. &quot;[-]&quot;)
				else
					irc_QueueMsg(server.ircMain, &quot;Player &quot; .. players[id].name .. &quot; has been sent to &quot; .. locations[loc].name)
				end
			else
				players[id].location = loc

				if (gmsgvars.playername ~= &quot;Server&quot;) then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Player &quot; .. players[id].name .. &quot; will spawn at &quot; .. locations[loc].name .. &quot; next time they join.[-]&quot;)
				else
					irc_QueueMsg(server.ircMain, &quot;Player &quot; .. players[id].name .. &quot; will spawn at &quot; .. locations[loc].name .. &quot; next time they join.&quot;)
				end

				conn:execute(&quot;UPDATE players SET location = '&quot; .. loc .. &quot;' WHERE steam = &quot; .. id)
			end
		end

		players[id].xPosOld = locations[loc].x
		players[id].yPosOld = locations[loc].y
		players[id].zPosOld = locations[loc].z
		
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 29&quot;) end

	if (gmsgvars.words[1] == &quot;sendhome&quot; or gmsgvars.words[1] == &quot;sendhome2&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;sendhome&quot;) + 9)
		pname = string.trim(pname)

		if (pname == &quot;&quot;) then 
			if (gmsgvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A player name is required or could not be found for this command[-]&quot;)
			else
				irc_QueueMsg(server.ircMain, &quot;A player name is required or could not be found for this command&quot;)
			end

			faultyGMSG = false
			return true
		else
			id = 0
			id = LookupPlayer(pname)

			if (id == 0) then
				if (gmsgvars.playername ~= &quot;Server&quot;) then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No in-game players found with that name.[-]&quot;)
				else
					irc_QueueMsg(server.ircMain, &quot;No in-game players found called &quot; .. pname)
				end

				faultyGMSG = false
				return true
			end

			if (players[id].timeout == true) then
				if (gmsgvars.playername ~= &quot;Server&quot;) then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; is in timeout. /return them first[-]&quot;)
				else
					irc_QueueMsg(server.ircMain, players[id].name .. &quot; is in timeout. Return them first.&quot;)
				end

				faultyGMSG = false
				return true
			end

			-- first record the current x y z
			if (igplayers[id]) then
				players[id].xPosOld = math.floor(igplayers[id].xPos)
				players[id].yPosOld = math.ceil(igplayers[id].yPos)
				players[id].zPosOld = math.floor(igplayers[id].zPos)
			end

			if (gmsgvars.words[1] == &quot;sendhome&quot;) then
				if (players[id].homeX == 0 and players[id].homeZ == 0) then
					if (gmsgvars.playername ~= &quot;Server&quot;) then
						message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name .. &quot; has not set a base yet.[-]&quot;)
					else
						irc_QueueMsg(server.ircMain, players[id].name .. &quot; has not set a base yet.&quot;)
					end

					faultyGMSG = false
					return true
				else
					if (igplayers[id]) then
						cmd = &quot;tele &quot; .. id .. &quot; &quot; .. players[id].homeX .. &quot; &quot; .. players[id].homeY .. &quot; &quot; .. players[id].homeZ
						prepareTeleport(id, cmd)
						teleport(cmd, true)
					end

					if (gmsgvars.playername ~= &quot;Server&quot;) then
						message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name .. &quot; has been sent home&quot;)
					else
						irc_QueueMsg(server.ircMain, players[id].name .. &quot; has been sent home.&quot;)
					end
				end
			else
				if (players[id].home2X == 0 and players[id].home2Z == 0) then
					if (gmsgvars.playername ~= &quot;Server&quot;) then
						message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name .. &quot; has not set a 2nd base yet.[-]&quot;)
					else
						irc_QueueMsg(server.ircMain, players[id].name .. &quot; has not set a 2nd base yet.&quot;)
					end

					faultyGMSG = false
					return true
				else
					if (igplayers[id]) then
						cmd = &quot;tele &quot; .. id .. &quot; &quot; .. players[id].home2X .. &quot; &quot; .. players[id].home2Y .. &quot; &quot; .. players[id].home2Z
						prepareTeleport(id, cmd)
						teleport(cmd, true)
					end

					if (gmsgvars.playername ~= &quot;Server&quot;) then
						message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name .. &quot; has been sent home&quot;)
					else
						irc_QueueMsg(server.ircMain, players[id].name .. &quot; has been sent home.&quot;)
					end
				end
			end
		end
		
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 30&quot;) end

	if (gmsgvars.words[1] == &quot;watch&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		if (gmsgvars.words[2] == &quot;new&quot; and gmsgvars.words[3] == &quot;players&quot;) then
			for k,v in pairs(players) do
				if v.newPlayer == true then
					v.watchPlayer = true
					conn:execute(&quot;UPDATE players SET watchPlayer = 1 WHERE steam = &quot; .. k)
				end
			end

			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]New players will be watched.[-]&quot;)

			faultyGMSG = false
			return true
		end

		pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;watch &quot;) + 6)
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if not (id == nil) then
			players[id].watchPlayer = true
			if (gmsgvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Admins will be alerted whenever &quot; .. players[id].name ..  &quot; enters a base.[-]&quot;)
			end

			conn:execute(&quot;UPDATE players SET watchPlayer = 1 WHERE steam = &quot; .. id)
		end
		
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 31&quot;) end

	if (gmsgvars.words[1] == &quot;stop&quot; and gmsgvars.words[2] == &quot;watching&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		if (gmsgvars.words[3] == &quot;everyone&quot;) then
			for k,v in pairs(players) do
				v.watchPlayer = false
				conn:execute(&quot;UPDATE players SET watchPlayer = 0 WHERE steam = &quot; .. k)
			end

			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Nobody is being watched right now.[-]&quot;)

			faultyGMSG = false
			return true
		end

		pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;watching &quot;) + 9)

		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if not (id == nil) then
			players[id].watchPlayer = false
			if (gmsgvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Player &quot; .. players[id].name ..  &quot; will no longer be watched.[-]&quot;)
			end

			conn:execute(&quot;UPDATE players SET watchPlayer = 0 WHERE steam = &quot; .. id)
		end
		
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 32&quot;) end

	if (gmsgvars.words[1] == &quot;send&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyGMSG = false
				return true
			end
		end

		id1 = nil
		id2 = nil
		
		for i=2,gmsgvars.wordCount,1 do 
			if (gmsgvars.words[i] ~= &quot;to&quot;) then			
				if id1 ~= nil and id2 == nil then 
					id2 = LookupPlayer(gmsgvars.words[i]) 
				end

				if id1 == nil then 
					id1 = LookupPlayer(gmsgvars.words[i]) 
				end
			end
		end

		if (id ~= nil and id2 ~= nil) then
			if (players[id1].walkies == true) and (gmsgvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id1].name .. &quot; has not opted in to being teleported. Ask them to /enabletp first[-]&quot;)
				faultyGMSG = false
				return true
			end

			if (players[id1].timeout == true) then
				if (gmsgvars.playername ~= &quot;Server&quot;) then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id1].name .. &quot; is in timeout. Return them first[-]&quot;)
				else
					irc_QueueMsg(server.ircMain, players[id1].name .. &quot; is in timeout. Return them first.&quot;)
				end

				faultyGMSG = false
				return true
			end

			-- first record the current x y z
			players[id1].xPosOld = math.floor(players[id1].xPos)
			players[id1].yPosOld = math.floor(players[id1].yPos)
			players[id1].zPosOld = math.floor(players[id1].zPos)

			if (igplayers[id2]) then
				cmd = &quot;tele &quot; .. id1 .. &quot; &quot; .. id2
				prepareTeleport(id1, cmd)
				teleport(cmd, true)
			else
				cmd = &quot;tele &quot; .. id1 .. &quot; &quot; .. math.floor(players[id2].xPos) .. &quot; &quot; .. math.ceil(players[id2].yPos) .. &quot; &quot; .. math.floor(players[id2].zPos)
				prepareTeleport(id1, cmd)
				teleport(cmd, true)
			end
		end
		
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 33&quot;) end

	-- ###################  do not allow remote commands beyond this point ################
	if (gmsgvars.playerid == nil) then
		faultyGMSG = false
		return false
	end
	-- ####################################################################################


	if (gmsgvars.words[1] == &quot;who&quot; and gmsgvars.words[2] == &quot;visited&quot;) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		if (gmsgvars.words[3] == nil) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]See who visited a player location or base.[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Example with defaults:[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/who visited smeg days 1 hours 1 range 10 height 4[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Add base to just see base visitors[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Setting hours will reset days to zero[-]&quot;)
			faultyGMSG = false
			return true
		end
		
		-- optional params
			-- range &lt;distance in metres&gt; Default 10
			-- days.  Default is 1 day ago from today (local time not server)

		name1 = nil
		days = 1
		hours = 0
		range = 10
		height = 4
		baseOnly = &quot;player&quot;

		if gmsgvars.words[3] ~= nil then
			name1 = string.trim(gmsgvars.words[3])
		end

		for i=3,gmsgvars.wordCount,1 do
			if gmsgvars.words[i] == &quot;range&quot; then
				range = tonumber(gmsgvars.words[i+1])
			end	

			if gmsgvars.words[i] == &quot;height&quot; then
				height = tonumber(gmsgvars.words[i+1])
			end	
				
			if gmsgvars.words[i] == &quot;days&quot; then
				days = tonumber(gmsgvars.words[i+1])
			end								

			if gmsgvars.words[i] == &quot;hours&quot; then
				hours = tonumber(gmsgvars.words[i+1])
				days = 0
			end								

			if gmsgvars.words[i] == &quot;base&quot; then
				baseOnly = &quot;base&quot;
			end	

			if gmsgvars.words[i] == &quot;player&quot; then
				baseOnly = &quot;player&quot;
				name1 = string.trim(gmsgvars.words[i+1])
			end	
		end		

		if name1 ~= nil then
			pid = LookupPlayer(name1)
		else
			pid = gmsgvars.playerid
		end
		
		if baseOnly == &quot;base&quot; or baseOnly == &quot;all&quot; then
			if players[pid].homeX ~= 0 and players[pid].homeZ ~= 0 then
				if days == 0 then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; Players who visited within &quot; .. range .. &quot; metres of base 1 of &quot; .. players[pid].name .. &quot; in the last &quot; .. hours .. &quot; hours&quot;)
				else
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; Players who visited within &quot; .. range .. &quot; metres of base 1 of &quot; .. players[pid].name .. &quot; in the last &quot; .. days .. &quot; days&quot;)
				end

				dbWho(gmsgvars.playerid, players[pid].homeX, players[pid].homeY, players[pid].homeZ, range, days, hours, height)
			else
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; &quot; .. players[pid].name .. &quot; does not have a base set yet.&quot;)
			end

			if players[pid].home2X ~= 0 and players[pid].home2Z ~= 0 then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; &quot;)
				if days == 0 then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; Players who visited within &quot; .. range .. &quot; metres of base 2 of &quot; .. players[pid].name .. &quot; in the last &quot; .. hours .. &quot; hours&quot;)
				else
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; Players who visited within &quot; .. range .. &quot; metres of base 2 of &quot; .. players[pid].name .. &quot; in the last &quot; .. days .. &quot; days&quot;)
				end

				dbWho(gmsgvars.playerid, players[pid].home2X, players[pid].home2Y, players[pid].home2Z, range, days, hours, height)
			end
		end

		if baseOnly == &quot;player&quot; or baseOnly == &quot;all&quot; then
			if days == 0 then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; Players who visited within &quot; .. range .. &quot; metres (X) &quot; .. players[pid].xPos .. &quot; (Z) &quot; .. players[pid].zPos .. &quot; of player &quot; .. players[pid].name .. &quot; in the last &quot; .. hours .. &quot; hours&quot;)
			else
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; Players who visited within &quot; .. range .. &quot; metres (X) &quot; .. players[pid].xPos .. &quot; (Z) &quot; .. players[pid].zPos .. &quot; of player &quot; .. players[pid].name .. &quot; in the last &quot; .. days .. &quot; days&quot;)
			end

			dbWho(gmsgvars.playerid, players[pid].xPos, players[pid].yPos, players[pid].zPos, range, days, hours, height)
		end		
		
		faultyGMSG = false
		return true
	end	

if debug then dbug(&quot;admin 34&quot;) end

	if (gmsgvars.words[1] == &quot;bases&quot; or gmsgvars.words[1] == &quot;homes&quot;) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		alone = true
		if (gmsgvars.number == nil) then gmsgvars.number = 201 end

		if (not string.find(gmsgvars.command, &quot;range&quot;)) and (not string.find(gmsgvars.command, &quot;near&quot;)) then
			for k, v in pairs(players) do
				if (v.homeX) and (v.homeX ~= 0 and v.homeZ ~= 0) then
					dist = distancexz(igplayers[gmsgvars.playerid].xPos, igplayers[gmsgvars.playerid].zPos, v.homeX, v.homeZ)

					if dist &lt; tonumber(gmsgvars.number) then
						if (alone == true) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]player bases within &quot; .. gmsgvars.number .. &quot; meters of you are:[-]&quot;) end

						message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot; distance: &quot; .. string.format(&quot;%-8.2d&quot;, dist) .. &quot; meters[-]&quot;)
						alone = false
					end
				end
				
				if (v.home2X) and (v.home2X ~= 0 and v.home2Z ~= 0) then
					dist = distancexz(igplayers[gmsgvars.playerid].xPos, igplayers[gmsgvars.playerid].zPos, v.home2X, v.home2Z)

					if dist &lt; tonumber(gmsgvars.number) then
						if (alone == true) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]player bases within &quot; .. gmsgvars.number .. &quot; meters of you are:[-]&quot;) end

						message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot; distance: &quot; .. string.format(&quot;%-8.2d&quot;, dist) .. &quot; meters[-]&quot;)
						alone = false
					end
				end			
			end

			if (alone == true) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]There are none within &quot; .. gmsgvars.number .. &quot; meters of you.&quot;)
			end
		else
			if string.find(gmsgvars.command, &quot;range&quot;) then
				name1 = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;near&quot;) + 5, string.find(gmsgvars.command, &quot;range&quot;) - 1)
				gmsgvars.number = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;range&quot;) + 6)
			else
				name1 = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;near&quot;) + 5)
			end

			name1 = string.trim(name1)
			pid = LookupPlayer(name1)

			if (pid ~= nil) then
				for k, v in pairs(players) do
					if (v.homeX) and (v.homeX ~= 0 and v.homeZ ~= 0) then
						dist = distancexz(igplayers[pid].xPos, igplayers[pid].zPos, v.homeX, v.homeZ)

						if dist &lt; tonumber(gmsgvars.number) then
							if (alone == true) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]player bases within &quot; .. gmsgvars.number .. &quot; meters of &quot; .. players[pid].name .. &quot; are:[-]&quot;) end

							message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot; distance: &quot; .. string.format(&quot;%-8.2d&quot;, dist) .. &quot; meters[-]&quot;)
							alone = false
						end
					end
					
					if (v.home2X) and (v.home2X ~= 0 and v.home2Z ~= 0) then
						dist = distancexz(igplayers[pid].xPos, igplayers[pid].zPos, v.home2X, v.home2Z)

						if dist &lt; tonumber(gmsgvars.number) then
							if (alone == true) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]player bases within &quot; .. gmsgvars.number .. &quot; meters of &quot; .. players[pid].name .. &quot; are:[-]&quot;) end

							message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot; distance: &quot; .. string.format(&quot;%-8.2d&quot;, dist) .. &quot; meters[-]&quot;)
							alone = false
						end
					end			
				end

				if (alone == true) then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]There are none within &quot; .. gmsgvars.number .. &quot; meters of &quot; .. players[pid].name .. &quot;[-]&quot;)
				end
			else	
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No player found matching &quot; .. name1 .. &quot;[-]&quot;)
			end	
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 35&quot;) end

	if (string.find(gmsgvars.command, &quot;admin add &quot;) and accessLevel(gmsgvars.playerid) == 0) then
		if string.find(gmsgvars.command, &quot;level&quot;) then
			pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;admin add &quot;) + 10, string.find(gmsgvars.command, &quot;level&quot;) - 1)
		else
			pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;admin add &quot;) + 10)
		end

		pname = string.trim(pname)
		id = LookupPlayer(pname)
		number = -1

		for i=3,gmsgvars.wordCount,1 do
			if gmsgvars.words[i] == &quot;level&quot; then
				number = gmsgvars.words[i+1]
			end	
		end

		if number == -1 then
			number = 1
		end

		if id ~= nil then
			-- add the steamid to the admins table
			if tonumber(number) == 0 then
				owners[id] = {}
			end

			if tonumber(number) == 1 then
				admins[id] = {}
			end

			if tonumber(number) == 2 then
				mods[id] = {}
			end

			players[id].newPlayer = false
			players[id].silentBob = false
			players[id].walkies = false
			players[id].exiled = 2
			players[id].canTeleport = true
			players[id].botHelp = true

			if tonumber(players[id].accessLevel) &gt; tonumber(number) then
				players[id].accessLevel = number
			end

			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; has been given admin powers[-]&quot;)
			send(&quot;admin add &quot; .. id .. &quot; &quot; .. number)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 36&quot;) end

	if (string.find(gmsgvars.command, &quot;admin remove &quot;) and accessLevel(gmsgvars.playerid) == 0) then
		pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;admin remove &quot;) + 13)

		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if id ~= nil then
			-- remove the steamid from the admins table
			owners[players[id].steam] = nil
			admins[players[id].steam] = nil

			if tonumber(players[id].accessLevel) == 1 then
				players[id].accessLevel = 90
			end

			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot;'s admin powers have been revoked[-]&quot;)
			send(&quot;admin remove &quot; .. id)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 37&quot;) end

	if gmsgvars.words[1] == &quot;goto&quot; and gmsgvars.words[2] ~= nil then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		if (players[gmsgvars.playerid].timeout == true) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are in timeout. You cannot /goto anywhere until you are released.[-]&quot;)
			faultyGMSG = false
			return true
		end

		pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;goto &quot;) + 5)

		-- first record the current x y z
		players[gmsgvars.playerid].xPosOld = gmsgvars.intX
		players[gmsgvars.playerid].yPosOld = gmsgvars.intY
		players[gmsgvars.playerid].zPosOld = gmsgvars.intZ

		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if not (id == nil) then
			-- then teleport to the player
			cmd = &quot;tele &quot; .. gmsgvars.playerid .. &quot; &quot; .. math.floor(players[id].xPos) + 1 .. &quot; &quot; .. math.ceil(players[id].yPos) .. &quot; &quot; .. math.floor(players[id].zPos)
			teleport(cmd, true)
		end
		
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 38&quot;) end

	if (gmsgvars.words[1] == &quot;offline&quot; and gmsgvars.words[2] == &quot;players&quot; and gmsgvars.words[3] == &quot;nearby&quot;) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		gmsgvars.number = 201
		
		if string.find(gmsgvars.command, &quot;range&quot;) then
			gmsgvars.number = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;range&quot;) + 6)
		end

		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]offline players within &quot; .. gmsgvars.number .. &quot; meters of you are:[-]&quot;) 

		alone = true

		for k, v in pairs(players) do
			if igplayers[k] == nil and v.xPos ~= nil then	
				dist = distance(igplayers[gmsgvars.playerid].xPos, igplayers[gmsgvars.playerid].zPos, v.xPos, v.zPos)
				dist = math.abs(dist)

				if tonumber(dist) &lt;= tonumber(gmsgvars.number) then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot; distance: &quot; .. string.format(&quot;%d&quot;, dist) .. &quot;[-]&quot;)
					alone = false
				end
			end
		end

		if (alone == true) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No offline players within range.[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 39&quot;) end

	if (gmsgvars.words[1] == &quot;crimescene&quot;) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		prisoner = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;scene &quot;) + 6)
		prisoner = string.trim(prisoner)
		prisonerid = LookupPlayer(prisoner)

		if (players[prisonerid].prisoner) then
			-- first record the current x y z
			players[gmsgvars.playerid].xPosOld = gmsgvars.intX
			players[gmsgvars.playerid].yPosOld = gmsgvars.intY
			players[gmsgvars.playerid].zPosOld = gmsgvars.intZ		
			
			-- then teleport to the prisoners old coords
			cmd = &quot;tele &quot; .. gmsgvars.playerid .. &quot; &quot; .. players[prisonerid].prisonxPosOld .. &quot; &quot; .. players[prisonerid].prisonyPosOld .. &quot; &quot; .. players[prisonerid].prisonzPosOld
			prepareTeleport(gmsgvars.playerid, cmd)
			teleport(cmd, true)
		else
			-- tp to their return coords if they are set
			if tonumber(players[prisonerid].yPosTimeout) ~= 0 then
				-- first record the current x y z
				players[gmsgvars.playerid].xPosOld = gmsgvars.intX
				players[gmsgvars.playerid].yPosOld = gmsgvars.intY
				players[gmsgvars.playerid].zPosOld = gmsgvars.intZ		
			
				-- then teleport to the prisoners old coords
				cmd = &quot;tele &quot; .. gmsgvars.playerid .. &quot; &quot; .. players[prisonerid].xPosTimeout .. &quot; &quot; .. players[prisonerid].yPosTimeout .. &quot; &quot; .. players[prisonerid].zPosTimeout
				prepareTeleport(gmsgvars.playerid, cmd)
				teleport(cmd, true)
			end
		end
		
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 40&quot;) end

	if (gmsgvars.words[1] == &quot;closeto&quot; or gmsgvars.words[1] == &quot;near&quot;) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		if (players[gmsgvars.playerid].timeout == true) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are in timeout. You cannot go anywhere until you are released for safety reasons.[-]&quot;)
			faultyGMSG = false
			return true
		end

		if gmsgvars.words[1] == &quot;closeto&quot; then
			pname = gmsgvars.words[2]
		end	

		if gmsgvars.words[1] == &quot;near&quot; then
			pname = gmsgvars.words[2]
		end	

		if gmsgvars.words[3] ~= nil then
			igplayers[gmsgvars.playerid].followDistance = tonumber(gmsgvars.words[3])
		end	

		-- first record the current x y z
		players[gmsgvars.playerid].xPosOld = gmsgvars.intX
		players[gmsgvars.playerid].yPosOld = gmsgvars.intY
		players[gmsgvars.playerid].zPosOld = gmsgvars.intZ

		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if not (id == nil) then
			igplayers[gmsgvars.playerid].following = id

			-- then teleport close to the player
			cmd = &quot;tele &quot; .. gmsgvars.playerid .. &quot; &quot; .. math.floor(igplayers[id].xPos + 10) .. &quot; &quot; .. math.ceil(igplayers[id].yPos - 20) .. &quot; &quot; .. math.floor(igplayers[id].zPos + 10)
			send(cmd)
		end
		
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 41&quot;) end

	if (gmsgvars.words[1] == &quot;add&quot; and gmsgvars.words[2] == &quot;bad&quot; and gmsgvars.words[3] == &quot;item&quot; and gmsgvars.words[4] ~= nil) then
		if (accessLevel(gmsgvars.playerid) &gt; 1) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is a restricted command[-]&quot;)
			faultyGMSG = false
			return true
		end

		bad = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;bad item&quot;) + 9)

		conn:execute(&quot;INSERT INTO badItems SET item = '&quot; .. bad .. &quot;'&quot;)

		badItems[bad] = {}
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You added &quot; .. bad .. &quot; to the list of bad items[-]&quot;)

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 42&quot;) end

	if (gmsgvars.words[1] == &quot;remove&quot; and gmsgvars.words[2] == &quot;bad&quot; and gmsgvars.words[3] == &quot;item&quot; and gmsgvars.words[4] ~= nil) then
		if (accessLevel(gmsgvars.playerid) &gt; 1) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is a restricted command[-]&quot;)
			faultyGMSG = false
			return true
		end

		bad = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;bad item&quot;) + 9)

		conn:execute(&quot;DELETE FROM badItems WHERE item = '&quot; .. bad .. &quot;'&quot;)

		badItems[bad] = nil
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You removed &quot; .. bad .. &quot; from the list of bad items[-]&quot;)

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 43&quot;) end

	if (gmsgvars.words[1] == &quot;bad&quot; and gmsgvars.words[2] == &quot;items&quot;) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is a restricted command[-]&quot;)
			faultyGMSG = false
			return true
		end

		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The bot scans for these items in inventory:[-]&quot;)
		for k, v in pairs(badItems) do
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. k .. &quot;[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 44&quot;) end

	if (gmsgvars.words[1] == &quot;add&quot; and gmsgvars.words[2] == &quot;restricted&quot;) then
		if (accessLevel(gmsgvars.playerid) &gt; 1) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is a restricted command[-]&quot;)
			faultyGMSG = false
			return true
		end

		if (gmsgvars.words[3] == nil) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Add an item to the inventory scanner for special attention.[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]eg. /add restricted item tnt qty 5 action timeout access 90[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Players with access &gt; 90 will be sent to timeout for more than 5 tnt.[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Valid actions are timeout, ban, the name of a location (for exile), and watch[-]&quot;)
			faultyGMSG = false
			return true
		end

		item = &quot;&quot;
		qty = 0
		access = 100
		action = &quot;timeout&quot;

		for i=3,gmsgvars.wordCount,1 do
			if gmsgvars.words[i] == &quot;item&quot; then
				item = gmsgvars.wordsOld[i+1]
			end					

			if gmsgvars.words[i] == &quot;qty&quot; then
				qty = gmsgvars.words[i+1]
			end

			if gmsgvars.words[i] == &quot;access&quot; then
				access = gmsgvars.words[i+1]
			end

			if gmsgvars.words[i] == &quot;action&quot; then
				action = gmsgvars.wordsOld[i+1]
			end
		end

		if action ~= &quot;timeout&quot; and action ~= &quot;ban&quot; and not locations[action] and action ~= &quot;watch&quot; then
			action = &quot;timeout&quot;
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Invalid action entered, using timeout instead.[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Valid actions are timeout, ban, the name of a location (for exile), and watch[-]&quot;)
		end

		if item == &quot;&quot; or access == 100 then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Item, qty and access are required.[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]eg. /add restricted item mineCandyTin qty 20 access 99 action timeout[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Valid actions are timeout, ban, exile. Bans last 1 day.[-]&quot;)
		else
			conn:execute(&quot;INSERT INTO restrictedItems (item, qty, accessLevel, action) VALUES ('&quot; .. escape(item) .. &quot;',&quot; .. qty .. &quot;,&quot; .. access .. &quot;,'&quot; .. action .. &quot;') ON DUPLICATE KEY UPDATE item = '&quot; .. escape(item) .. &quot;', qty = &quot; .. qty .. &quot;, accessLevel = &quot; .. access .. &quot;, action = '&quot; .. action .. &quot;'&quot;)
			conn:execute(&quot;INSERT INTO memRestrictedItems (item, qty, accessLevel, action) VALUES ('&quot; .. escape(item) .. &quot;',&quot; .. qty .. &quot;,&quot; .. access .. &quot;,'&quot; .. action .. &quot;') ON DUPLICATE KEY UPDATE item = '&quot; .. escape(item) .. &quot;', qty = &quot; .. qty .. &quot;, accessLevel = &quot; .. access .. &quot;, action = '&quot; .. action .. &quot;'&quot;)

			restrictedItems[item] = {}
			restrictedItems[item].qty = tonumber(qty)
			restrictedItems[item].accessLevel = tonumber(access)
			restrictedItems[item].action = action

			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You added &quot; .. item .. &quot; quantity &quot; .. qty .. &quot; with minimum access level &quot; .. access .. &quot; and action &quot; .. action .. &quot; to restricted items[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 45&quot;) end

	if (gmsgvars.words[1] == &quot;remove&quot; and gmsgvars.words[2] == &quot;restricted&quot; and gmsgvars.words[3] == &quot;item&quot; and gmsgvars.words[4] ~= nil) then
		if (accessLevel(gmsgvars.playerid) &gt; 1) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is a restricted command[-]&quot;)
			faultyGMSG = false
			return true
		end

		bad = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;restricted item&quot;) + 16)

		conn:execute(&quot;DELETE FROM restrictedItems WHERE item = '&quot; .. bad .. &quot;'&quot;)
		conn:execute(&quot;DELETE FROM memRestrictedItems WHERE item = '&quot; .. bad .. &quot;'&quot;)

		restrictedItems[bad] = nil
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You removed &quot; .. bad .. &quot; from the list of restricted items[-]&quot;)

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 46&quot;) end

	if (gmsgvars.words[1] == &quot;restricted&quot; and gmsgvars.words[2] == &quot;items&quot;) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is a restricted command[-]&quot;)
			faultyGMSG = false
			return true
		end

		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The bot scans for these restricted in inventory:[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Item      Quantity      Min Access Level[-]&quot;)

		for k, v in pairs(restrictedItems) do
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. k .. &quot; max qty &quot; .. v.qty .. &quot; min access &quot; .. v.accessLevel .. &quot; action &quot; .. v.action .. &quot;[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 47&quot;) end

	if (gmsgvars.words[1] == &quot;prisoners&quot; and gmsgvars.words[2] == nil) then	
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		-- pm a list of all the prisoners
		if (prisoners == {}) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Nobody is in prison[-]&quot;)	
			faultyGMSG = false
			return true
		end

		for k, v in pairs(players) do
			if v.prisoner then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot; &quot; .. v.prisonReason .. &quot;[-]&quot;)
			end
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 48&quot;) end

	if (gmsgvars.words[1] == &quot;equip&quot; and gmsgvars.words[2] == &quot;admin&quot;) then	
		if (accessLevel(gmsgvars.playerid) &gt; 1) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. gmsgvars.playerid .. &quot; ironBoots 1 600', &quot; .. gmsgvars.playerid .. &quot;)&quot;)
		conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. gmsgvars.playerid .. &quot; auger 1 600', &quot; .. gmsgvars.playerid .. &quot;)&quot;)
		conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. gmsgvars.playerid .. &quot; chainsaw 1 600', &quot; .. gmsgvars.playerid .. &quot;)&quot;)
		conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. gmsgvars.playerid .. &quot; nailgun 1', &quot; .. gmsgvars.playerid .. &quot;)&quot;)
		conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. gmsgvars.playerid .. &quot; gascan 100', &quot; .. gmsgvars.playerid .. &quot;)&quot;)
		conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. gmsgvars.playerid .. &quot; bearStew 100', &quot; .. gmsgvars.playerid .. &quot;)&quot;)
		conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. gmsgvars.playerid .. &quot; keystone 10', &quot; .. gmsgvars.playerid .. &quot;)&quot;)
		conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. gmsgvars.playerid .. &quot; firstAidKit 10', &quot; .. gmsgvars.playerid .. &quot;)&quot;)
		conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. gmsgvars.playerid .. &quot; antibiotics 20', &quot; .. gmsgvars.playerid .. &quot;)&quot;)
		conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. gmsgvars.playerid .. &quot; miningHelmet 1', &quot; .. gmsgvars.playerid .. &quot;)&quot;)
		conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. gmsgvars.playerid .. &quot; ironChestArmor 1 600', &quot; .. gmsgvars.playerid .. &quot;)&quot;)
		conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. gmsgvars.playerid .. &quot; ironLegArmor 1 600', &quot; .. gmsgvars.playerid .. &quot;)&quot;)
		conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. gmsgvars.playerid .. &quot; ironGloves 1 600', &quot; .. gmsgvars.playerid .. &quot;)&quot;)
		conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. gmsgvars.playerid .. &quot; shotgunShell 300', &quot; .. gmsgvars.playerid .. &quot;)&quot;)
		conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. gmsgvars.playerid .. &quot; pumpShotgun 2 600', &quot; .. gmsgvars.playerid .. &quot;)&quot;)

		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. serve.chatColour .. &quot;]We deliver :)[-]&quot;)
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 49&quot;) end

	if (gmsgvars.words[1] == &quot;release&quot; and gmsgvars.words[2] == &quot;here&quot; and gmsgvars.words[3] ~= nil) then	
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		prisoner = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;: /release here &quot;) + 16)
		prisoner = string.trim(prisoner)
		prisonerid = LookupPlayer(prisoner)

		if (players[prisonerid].prisoner == false) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Citizen &quot; .. players[prisonerid].name .. &quot; is not a prisoner[-]&quot;)
			faultyGMSG = false
			return true
		end

		players[prisonerid].prisoner = false

		conn:execute(&quot;UPDATE players SET prisoner = 0 WHERE steam = &quot; .. prisonerid)

		message(&quot;say [&quot; .. server.chatColour .. &quot;]Releasing prisoner &quot; .. players[prisonerid].name .. &quot;[-]&quot;)

		if (players[prisonerid].steam) then
			message(&quot;pm &quot; .. prisonerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are released from prison.  Be a good citizen if you wish to remain free.[-]&quot;)
			cmd = &quot;tele &quot; .. prisonerid .. &quot; &quot; .. gmsgvars.playerid
			prepareTeleport(prisonerid, cmd)
			teleport(cmd, true)
			players[prisonerid].xPosOld = 0
			players[prisonerid].yPosOld = 0
			players[prisonerid].zPosOld = 0
			players[prisonerid].prisonxPosOld = 0
			players[prisonerid].prisonyPosOld = 0
			players[prisonerid].prisonzPosOld = 0
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin 50&quot;) end

	if (gmsgvars.words[1] == &quot;playerhome&quot; or gmsgvars.words[1] == &quot;playerbase&quot; or gmsgvars.words[1] == &quot;playerhome2&quot; or gmsgvars.words[1] == &quot;playerbase2&quot;) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, gmsgvars.words[1]) + string.len(gmsgvars.words[1]))
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if (pname == &quot;&quot;) then 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A player name is required or could not be found for this command[-]&quot;)
			faultyGMSG = false
			return true
		else
			if (gmsgvars.words[1] == &quot;playerhome&quot; or gmsgvars.words[1] == &quot;playerbase&quot;) then
				if (players[id].homeX == 0 and players[id].homeZ == 0) then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; Has not set a base yet.[-]&quot;)
					faultyGMSG = false
					return true
				else
					-- first record the current x y z
					players[gmsgvars.playerid].xPosOld = math.floor(igplayers[gmsgvars.playerid].xPos)
					players[gmsgvars.playerid].yPosOld = math.ceil(igplayers[gmsgvars.playerid].yPos)
					players[gmsgvars.playerid].zPosOld = math.floor(igplayers[gmsgvars.playerid].zPos)

					cmd = &quot;tele &quot; .. gmsgvars.playerid .. &quot; &quot; .. players[id].homeX .. &quot; &quot; .. players[id].homeY .. &quot; &quot; .. players[id].homeZ
					prepareTeleport(gmsgvars.playerid, cmd)
					teleport(cmd, true)
				end
			else
				if (players[id].home2X == 0 and players[id].home2Z == 0) then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; Has not set a 2nd base yet.[-]&quot;)
					faultyGMSG = false
					return true
				else
					-- first record the current x y z
					players[gmsgvars.playerid].xPosOld = math.floor(igplayers[gmsgvars.playerid].xPos)
					players[gmsgvars.playerid].yPosOld = math.ceil(igplayers[gmsgvars.playerid].yPos)
					players[gmsgvars.playerid].zPosOld = math.floor(igplayers[gmsgvars.playerid].zPos)

					cmd = &quot;tele &quot; .. gmsgvars.playerid .. &quot; &quot; .. players[id].home2X .. &quot; &quot; .. players[id].home2Y .. &quot; &quot; .. players[id].home2Z
					prepareTeleport(gmsgvars.playerid, cmd)
					teleport(cmd, true)
				end
			end
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;admin end&quot;) end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_fun</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
fun commands
=============
place bounty
bounty
beer
gimme peace
reset gimmehell
gimme reset
gimme gimme
gimme off
gimme on
suicide
santa
gimme
ragequit
gimmehell
--]]

function gmsg_fun()
	calledFunction = &quot;gmsg_fun&quot;

	-- don't proceed if there is no leading slash
	if (string.sub(gmsgvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyGMSG = false
		return false
	end


	if (gmsgvars.words[1] == &quot;place&quot; and gmsgvars.words[2] == &quot;bounty&quot;) then
		pname = gmsgvars.words[3]
		id = LookupPlayer(pname)

		bounty = math.abs(gmsgvars.words[4])

		if players[gmsgvars.playerid].cash &gt;= bounty then
			oldBounty = players[id].pvpBounty
			players[id].pvpBounty = players[id].pvpBounty + bounty
			players[gmsgvars.playerid].cash = players[gmsgvars.playerid].cash - bounty
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[gmsgvars.playerid].name .. &quot; has placed a bounty of &quot; .. bounty .. &quot; on &quot; .. players[id].name .. &quot;'s head![-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You now have &quot; .. players[gmsgvars.playerid].cash .. &quot; zennies.[-]&quot;)

			-- update the player's bounty
			conn:execute(&quot;UPDATE players SET pvpBounty = &quot; .. players[id].pvpBounty .. &quot; WHERE steam = &quot; .. id)

			-- reduce the cash of the player who placed the bounty
			conn:execute(&quot;UPDATE players SET cash = &quot; .. players[gmsgvars.playerid].cash .. &quot; WHERE steam = &quot; .. gmsgvars.playerid)

			if oldBounty &gt; 0 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot;'s life is now worth &quot; .. players[id].pvpBounty .. &quot;.[-]&quot;)
			end
		else
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You do not have enough zennies to place that bounty.[-]&quot;)
		end

		faultyGMSG = false
		return true
	end


	if (gmsgvars.words[1] == &quot;bounty&quot;) then
		id = gmsgvars.playerid

		if (gmsgvars.words[2] ~= nil) then
			pname = string.sub(gmsgvars.command, 9)
			id = LookupPlayer(pname)
		end

		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; has &quot; .. players[id].pvpCount .. &quot; kills. Kill them for &quot; .. players[id].pvpBounty .. &quot; zennies.[-]&quot;)

		faultyGMSG = false
		return true
	end


	if (gmsgvars.words[1] == &quot;haven&quot; and gmsgvars.words[2] ~= nil) then
		if type(brchat) ~= &quot;table&quot; then
		  brchat = {}
		end

		table.insert(brchat, { os.time(), &quot;BR-&quot; .. players[gmsgvars.playerid].name .. &quot;:&quot; .. string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;haven&quot;) + 6) } )

		faultyGMSG = false
		return true
	end


	if (gmsgvars.words[1] == &quot;waiter&quot; or gmsgvars.words[1] == &quot;beer&quot; and gmsgvars.words[2] == nil) then
		if inLocation(gmsgvars.intX, gmsgvars.intZ) == &quot;library&quot; then
			send(&quot;give &quot; .. gmsgvars.playerid .. &quot; beer 1&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Enjoy your beer![-]&quot;)
		end

		faultyGMSG = false
		return true
	end


	if (gmsgvars.words[1] == &quot;gimme&quot; and gmsgvars.words[2] == &quot;peace&quot;) then
		message(&quot;say [&quot; .. server.chatColour .. &quot;]Gimme has been silenced[-]&quot;)
		server.gimmePeace = true

		conn:execute(&quot;UPDATE server SET gimmePeace = 1&quot;)

		faultyGMSG = false
		return true
	end


	if (gmsgvars.words[1] == &quot;reset&quot; and gmsgvars.words[2] == &quot;gimmehell&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is for admins only[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		if (gmsgvars.playername == &quot;Server&quot;) then 
			gimmeHell = 0
			arenaPlayers = {}
			conn:execute(&quot;DELETE FROM playerQueue&quot;)					

			message(&quot;say [&quot; .. server.chatColour .. &quot;]gimmeHell is ready to play[-]&quot;)
			faultyGMSG = false
			return true
		end

		dist = distancexyz(igplayers[gmsgvars.playerid].xPos, igplayers[gmsgvars.playerid].yPos, igplayers[gmsgvars.playerid].zPos, locations[&quot;arena&quot;].x, locations[&quot;arena&quot;].y, locations[&quot;arena&quot;].z)
		if (dist &lt; locations[&quot;arena&quot;].size + 5) or (gmsgvars.playername == &quot;Server&quot;) or (accessLevel(gmsgvars.playerid) &lt; 3) then

			gimmeHell = 0
			arenaPlayers = {}
			conn:execute(&quot;DELETE FROM playerQueue&quot;)					

			message(&quot;say [&quot; .. server.chatColour .. &quot;]gimmeHell is ready to play[-]&quot;)
			faultyGMSG = false
			return true
		end
	end


	if (gmsgvars.words[1] == &quot;gimme&quot; and gmsgvars.words[2] == &quot;reset&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is for admins only[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		gimmeReset()
		disableTrigger(&quot;gimmeReset&quot;)
		enableTigger(&quot;gimmeReset&quot;)

		faultyGMSG = false
		return true
	end


	if (gmsgvars.words[1] == &quot;gimme&quot; and gmsgvars.words[2] == &quot;gimme&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		message(&quot;say [&quot; .. server.chatColour .. &quot;]Gimme messages are now public[-]&quot;)
		server.gimmePeace = false

		conn:execute(&quot;UPDATE server SET gimmePeace = 0&quot;)

		faultyGMSG = false
		return true
	end


	if (gmsgvars.words[1] == &quot;gimme&quot; and gmsgvars.words[2] == &quot;off&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		message(&quot;say [&quot; .. server.chatColour .. &quot;]Gimme has been disabled[-]&quot;)
		server.allowGimme = false

		conn:execute(&quot;UPDATE server SET allowGimme = 0&quot;)

		faultyGMSG = false
		return true
	end


	if (gmsgvars.words[1] == &quot;gimme&quot; and gmsgvars.words[2] == &quot;on&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		message(&quot;say [&quot; .. server.chatColour .. &quot;]Gimme has been enabled[-]&quot;)
		server.allowGimme = true

		conn:execute(&quot;UPDATE server SET allowGimme = 1&quot;)

		faultyGMSG = false
		return true
	end


	if (gmsgvars.words[1] == &quot;suicide&quot;) then
		if players[gmsgvars.playerid].prisoner or players[gmsgvars.playerid].timeout == true or players[gmsgvars.playerid].botTimeout == true then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]BANG![-]&quot;)
		else
			if players[gmsgvars.playerid].lastSuicide ~= nil then
				if os.time() - players[gmsgvars.playerid].lastSuicide &lt; 300 then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&gt;CLICK!&lt;  Darn your gun jammed.  Try again in a few minutes.[-]&quot;)

					faultyGMSG = false
					return true
				end
			end

			send(&quot;kill &quot; .. gmsgvars.playerid)
			players[gmsgvars.playerid].lastSuicide = os.time()
		end

		faultyGMSG = false
		return true
	end


	-- ###################  do not allow remote commands beyond this point ################
	if (gmsgvars.playerid == nil) then
		faultyGMSG = false
		return false
	end
	-- ####################################################################################


	if (gmsgvars.words[1] == &quot;santa&quot; and gmsgvars.words[2] == nil) then
		if (not players[gmsgvars.playerid].santa) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]HO HO HO  Merry Christmas!  Press e now, don't let the Grinch steal Christmas.&quot;)
			send (&quot;give &quot; .. gmsgvars.playerid .. &quot; santaHat 1&quot;)
			send (&quot;give &quot; .. gmsgvars.playerid .. &quot; shades 1&quot;)	
			send (&quot;give &quot; .. gmsgvars.playerid .. &quot; beer 1&quot;)
			send (&quot;give &quot; .. gmsgvars.playerid .. &quot; coalOre 1&quot;)
			send (&quot;give &quot; .. gmsgvars.playerid .. &quot; pipeBomb 1&quot;)
			players[gmsgvars.playerid].santa = &quot;hohoho&quot;
		else
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have already received your stocking stuffer&quot;)
		end

		faultyGMSG = false
		return true
	end


	if (gmsgvars.words[1] == &quot;gimmie&quot; or gmsgvars.words[1] == &quot;gimme&quot;) and gmsgvars.words[2] == nil then
		if (server.allowGimme) then
			if (gmsgvars.playername ~= &quot;Server&quot;) then 
				if (accessLevel(gmsgvars.playerid) &gt; 1) then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Gimme is now triggered by casino coins in the last slot of your belt and runs every 30 seconds. Remove the coins to stop playing gimme.[-]&quot;)
					faultyGMSG = false
					return true
				end
			end

			dist1 = distancexz(igplayers[gmsgvars.playerid].xPos, igplayers[gmsgvars.playerid].zPos, players[gmsgvars.playerid].homeX, players[gmsgvars.playerid].homeZ)
			dist2 = distancexz(igplayers[gmsgvars.playerid].xPos, igplayers[gmsgvars.playerid].zPos, players[gmsgvars.playerid].home2X, players[gmsgvars.playerid].home2Z)

			if (dist1 &lt; players[gmsgvars.playerid].protectSize) or (dist2 &lt; players[gmsgvars.playerid].protect2Size) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Gimme will not spawn any zeds while you are inside your base protection.[-]&quot;)
			end

			gimme(gmsgvars.playerid)
		else
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Sorry, an admin has disabled gimme =([-]&quot;)
		end

		faultyGMSG = false
		return true
	end


	if string.find(gmsgvars.words[1], &quot;quit&quot;) and gmsgvars.words[2] ==  nil then
		send(&quot;kick &quot; .. gmsgvars.playerid .. &quot; RAAAAGE! xD&quot;)
		r = rand(3)

		if r == 1 then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[gmsgvars.playerid].name .. &quot; has left the building[-]&quot;)
		end

		if r == 2 then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[gmsgvars.playerid].name .. &quot; has left *SLAM!*[-]&quot;)
		end

		if r == 3 then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[gmsgvars.playerid].name .. &quot; &quot; .. gmsgvars.words[1] .. &quot;![-]&quot;)
		end

		faultyGMSG = false
		return true
	end


	if (gmsgvars.words[1] == &quot;quit&quot;) then
		msg = string.sub(line, string.find(line, &quot;quit&quot;) + 5)

		if msg ~= nil then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[gmsgvars.playerid].name .. &quot; quit with this parting shot.. &quot; .. msg ..&quot;[-]&quot;)
		end

		send(&quot;kick &quot; .. gmsgvars.playerid .. &quot;\&quot;That'll learn em! xD\&quot;&quot;)

		faultyGMSG = false
		return true
	end


	if (gmsgvars.words[1] == &quot;gimmehell&quot; and gmsgvars.words[2] == nil) then
		-- abort if not in arena

		dist = distancexyz(igplayers[gmsgvars.playerid].xPos, igplayers[gmsgvars.playerid].yPos, igplayers[gmsgvars.playerid].zPos, locations[&quot;arena&quot;].x, locations[&quot;arena&quot;].y, locations[&quot;arena&quot;].z)

		if (tonumber(dist) &gt; tonumber(locations[&quot;arena&quot;].size)) and (tonumber(dist) &lt; tonumber(locations[&quot;arena&quot;].size) + 5) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Nobody is in the arena.  You can't play from the spectator area.  Get in the arena coward.[-]&quot;)
			faultyGMSG = false
			return true
		end

		if (tonumber(dist) &gt; tonumber(locations[&quot;arena&quot;].size)) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command can only be issued in the arena[-]&quot;)
			faultyGMSG = false
			return true
		end

		if (gimmeHell == 0) then
			gimmeHell = 1

--			send(&quot;sg MaxSpawnedZombies 50&quot;)

			setupArenaPlayers(gmsgvars.playerid)
			tempTimer( 5, [[ announceGimmeHell(&quot;1&quot;) ]] )
			tempTimer( 10, [[ queueGimmeHell(&quot;1&quot;) ]] )
			tempTimer( 60, [[ announceGimmeHell(&quot;2&quot;) ]] )
			tempTimer( 65, [[ queueGimmeHell(&quot;2&quot;) ]] )
			tempTimer( 120, [[ announceGimmeHell(&quot;3&quot;) ]] )
			tempTimer( 125, [[ queueGimmeHell(&quot;3&quot;) ]] )
			tempTimer( 180, [[ announceGimmeHell(&quot;4&quot;) ]] )
			tempTimer( 185, [[ queueGimmeHell(&quot;4&quot;) ]] )
			faultGMSG = false	
			return true
		else
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Wait until the current gimmehell is concluded. You can reset it with /reset gimmehell[-]&quot;)
			faultyGMSG = false
			return true
		end	
	end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_hotspots</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
hotspot commands
=============
man hotspots
resize hotspot
move hotspot
delete hotspots
delete hotspot
hotspot
hotspots
--]]

function removeInvalidHotspots(steam)
	local dist, size, delete

	-- abort if staff member
	if accessLevel(steam) &lt; 3 then
		return
	end

	cursor,errorString = conn:execute(&quot;select * from hotspots where owner = &quot; .. steam)
	row = cursor:fetch({}, &quot;a&quot;)

	while row do
		delete = true
		dist = distancexz(row.x, row.z, players[steam].homeX, players[steam].homeZ)
		size = tonumber(players[steam].protectSize)

		if (dist &lt; tonumber(size + 16)) then
			delete = false
		end

		if math.abs(players[steam].home2X) &gt; 0 and math.abs(players[steam].home2Z) &gt; 0 then
			dist = distancexz(row.x, row.z, players[steam].home2X, players[steam].home2Z)
			size = tonumber(players[steam].protect2Size)

			if (dist &lt; tonumber(size + 16)) then
				delete = false
			end
		end

		if delete then
			-- remove this hotspot
			hotspots[row.idx] = nil
			conn:execute(&quot;DELETE FROM hotspots WHERE idx = &quot; .. row.idx)
		end

		row = cursor:fetch(row, &quot;a&quot;)
	end
end


function gmsg_hotspots()
	calledFunction = &quot;gmsg_hotspots&quot;

	local idx, size, hotspotmsg, nextidx, debug

	debug = false
	size = nil

	-- don't proceed if there is no leading slash
	if (string.sub(gmsgvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyGMSG = false
		return false
	end


	-- ###################  do not allow remote commands beyond this point ################
	if (gmsgvars.playerid == nil) then
		faultyGMSG = false
		return false
	end
	-- ####################################################################################

if debug then dbug(&quot;debug hotspots&quot;) end

	if (gmsgvars.words[1] == &quot;man&quot; and gmsgvars.words[2] == &quot;hotspots&quot;) then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Hotspots are private messages triggered by proximity.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can set their size from 1 to 20 metres (default 2).[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]For command help type /help hotspots[-]&quot;)

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug hotspots 1&quot;) end

	if (gmsgvars.words[1] == &quot;resize&quot; and gmsgvars.words[2] == &quot;hotspot&quot; and gmsgvars.words[3] ~= nil) then
		if accessLevel(gmsgvars.playerid) == 99 then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]New players are not allowed to play with hotspots.[-]&quot;)
			faultyGMSG = false
			return true
		end

		if (gmsgvars.words[3] == nil) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Change a hotspot's radius to a max of 10 (unlimited for admins).[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]eg. /resize hotspot 3 size 5[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Type /hotspots for a list of your hotspots[-]&quot;)
			faultyGMSG = false
			return true	
		end

		idx = tonumber(gmsgvars.words[3])
		if idx == nil then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Number required for hotspot.[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]eg. /resize hotspot 3 size 5[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Type /hotspots for a list of your hotspots[-]&quot;)
			faultyGMSG = false
			return true
		end

	
		if gmsgvars.words[5] ~= nil then
			size = math.abs(tonumber(gmsgvars.words[5])) + 1

			if accessLevel(gmsgvars.playerid) &lt; 3 then
				if size == nil or size == 1 then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Number required for size greater than 0.[-]&quot;)
					faultyGMSG = false
					return true
				end
			else
				if size == nil or size &gt; 11 then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Number required for size in the range 1 to 10.[-]&quot;)
					faultyGMSG = false
					return true
				end

				size = math.floor(size) - 1
			end	
		end
				
		hotspots[idx].size = size
		conn:execute(&quot;UPDATE hotspots SET size = &quot; .. size .. &quot; WHERE idx = &quot; .. idx)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Hotspot: &quot; .. hotspots[idx].hotspot .. &quot; now covers &quot; .. size * 2 .. &quot; metres[-]&quot;)
		faultyGMSG = false
		return true	
	end

if debug then dbug(&quot;debug hotspots 2&quot;) end			

	if (gmsgvars.words[1] == &quot;move&quot; and gmsgvars.words[2] == &quot;hotspot&quot; and gmsgvars.words[3] ~= nil) then
		if accessLevel(gmsgvars.playerid) == 99 then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]New players are not allowed to play with hotspots.[-]&quot;)
			faultyGMSG = false
			return true
		end

		if (gmsgvars.number == nil) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Hotspot number required eg. /move hotspot 25.[-]&quot;)
			faultyGMSG = false
			return true
		end
		
		if accessLevel(gmsgvars.playerid) &gt; 2 then
			if not players[gmsgvars.playerid].atHome then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Your hotspots may be no further than &quot; .. tonumber(server.baseSize) + 15 .. &quot; metres from your first or second bot protected base.[-]&quot;)
				faultyGMSG = false
				return true			
			end
		end

		if accessLevel(gmsgvars.playerid) &lt; 4 then
			if hotspots[gmsgvars.number] then
				conn:execute(&quot;UPDATE hotspots SET x = &quot; .. gmsgvars.intX .. &quot;, y = &quot; .. gmsgvars.intY .. &quot;, z = &quot; .. gmsgvars.intZ .. &quot; WHERE idx = &quot; .. gmsgvars.number)
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You moved the hotspot: &quot; .. hotspots[gmsgvars.number].hotspot .. &quot;[-]&quot;)
				hotspots[gmsgvars.number].x = gmsgvars.intX
				hotspots[gmsgvars.number].y = gmsgvars.intY
				hotspots[gmsgvars.number].z = gmsgvars.intZ

				faultyGMSG = false
				return true
			else
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]There is no hotspot #&quot; .. gmsgvars.number .. &quot;.[-]&quot;)
				faultyGMSG = false
				return true
			end
		else
			cursor,errorString = conn:execute(&quot;select * from hotspots where idx = &quot; .. gmsgvars.number)
			rows = cursor:numrows()

			if rows &gt; 0 then
				row = cursor:fetch({}, &quot;a&quot;)
				if row.owner ~= gmsgvars.playerid then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You don't own this hotspot.[-]&quot;)
					faultyGMSG = false
					return true
				else
					if hotspots[gmsgvars.number] then
						conn:execute(&quot;UPDATE hotspots SET x = &quot; .. gmsgvars.intX .. &quot;, y = &quot; .. gmsgvars.intY .. &quot;, z = &quot; .. gmsgvars.intZ .. &quot; WHERE idx = &quot; .. gmsgvars.number)
						message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You moved the hotspot: &quot; .. hotspots[gmsgvars.number].hotspot .. &quot;[-]&quot;)
						hotspots[gmsgvars.number].x = gmsgvars.intX
						hotspots[gmsgvars.number].y = gmsgvars.intY
						hotspots[gmsgvars.number].z = gmsgvars.intZ

						faultyGMSG = false
						return true
					else
						message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]There is no hotspot #&quot; .. gmsgvars.number .. &quot;.[-]&quot;)
						faultyGMSG = false
						return true
					end
				end
			end
		end
	end

if debug then dbug(&quot;debug hotspots 3&quot;) end

	if (gmsgvars.words[1] == &quot;delete&quot; or gmsgvars.words[1] == &quot;remove&quot;) and gmsgvars.words[2] == &quot;hotspots&quot; then
		if accessLevel(gmsgvars.playerid) == 99 then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]New players are not allowed to play with hotspots.[-]&quot;)
			faultyGMSG = false
			return true
		end

		if accessLevel(gmsgvars.playerid) &lt; 3 then		
			pid = gmsgvars.playerid
		
			if gmsgvars.words[3] ~= nil then
				pid = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;hotspots &quot;) + 10)
				pid = string.trim(pid)
				pid = LookupPlayer(pid)

				if (pid == nil) then 
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No player found with that name.[-]&quot;)
					faultyGMSG = false
					return true
				end
			end

			conn:execute(&quot;DELETE FROM hotspots WHERE owner = &quot; .. pid)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You deleted the hotspots belonging to &quot; .. players[pid].name .. &quot;[-]&quot;)
			-- reload the hotspots lua table
			loadHotspots()
		else
			conn:execute(&quot;DELETE FROM hotspots WHERE owner = &quot; .. gmsgvars.playerid)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Your hotspots have been deleted.[-]&quot;)
			-- reload the hotspots lua table
			loadHotspots()		
		end

		faultyGMSG = false
		return true
	end
	
if debug then dbug(&quot;debug hotspots 4&quot;) end

	if (gmsgvars.words[1] == &quot;delete&quot; and gmsgvars.words[2] == &quot;hotspot&quot;) then
		if accessLevel(gmsgvars.playerid) == 99 then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]New players are not allowed to play with hotspots.[-]&quot;)
			faultyGMSG = false
			return true
		end

		if gmsgvars.number == nil then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Hotspot number required eg. /hotspot delete 25.[-]&quot;)
			faultyGMSG = false
			return true
		end

		if accessLevel(gmsgvars.playerid) &lt; 3 then
			if hotspots[gmsgvars.number] then
				conn:execute(&quot;DELETE FROM hotspots WHERE idx = &quot; .. gmsgvars.number)
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You deleted the hotspot: &quot; .. hotspots[gmsgvars.number].hotspot .. &quot;[-]&quot;)
				hotspots[gmsgvars.number] = nil
			else
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]There is no hotspot #&quot; .. gmsgvars.number .. &quot;.[-]&quot;)
				faultyGMSG = false
				return true
			end
		else
			cursor,errorString = conn:execute(&quot;select * from hotspots where idx = &quot; .. gmsgvars.number)
			rows = cursor:numrows()

			if rows &gt; 0 then
				row = cursor:fetch({}, &quot;a&quot;)
				if row.owner ~= gmsgvars.playerid then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You don't own this hotspot.[-]&quot;)
					faultyGMSG = false
					return true
				else
					if hotspots[gmsgvars.number] then
						conn:execute(&quot;DELETE FROM hotspots WHERE idx = &quot; .. gmsgvars.number)
						message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You deleted the hotspot: &quot; .. hotspots[gmsgvars.number].hotspot .. &quot;[-]&quot;)
						hotspots[gmsgvars.number] = nil
					else
						message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]There is no hotspot #&quot; .. gmsgvars.number .. &quot;.[-]&quot;)
						faultyGMSG = false
						return true
					end
				end
			end
		end

		faultyGMSG = false
		return true
	end
		
if debug then dbug(&quot;debug hotspots 5&quot;) end

	if (gmsgvars.words[1] == &quot;hotspot&quot;) then
		if accessLevel(gmsgvars.playerid) == 99 then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]New players are not allowed to play with hotspots.[-]&quot;)
			faultyGMSG = false
			return true
		end

		if gmsgvars.words[2] == nil then
			faultyGMSG = help(&quot;hotspots&quot;)
			return true
		end

		if gmsgvars.words[3] == nil and gmsgvars.number ~= nil then
			if accessLevel(gmsgvars.playerid) &lt; 3 then
				-- teleport the admin to the coords of the numbered hotspot
				cursor,errorString = conn:execute(&quot;select * from hotspots where idx = &quot; .. gmsgvars.number)
				rows = cursor:numrows()

				if rows &gt; 0 then
					row = cursor:fetch({}, &quot;a&quot;)

					-- first record the players current position
					savePosition(gmsgvars.playerid)

					cmd = &quot;tele &quot; .. gmsgvars.playerid .. &quot; &quot; .. row.x .. &quot; &quot; .. row.y .. &quot; &quot; .. row.z
					prepareTeleport(gmsgvars.playerid, cmd)
					teleport(cmd, true)
				else
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]There is no hotspot #&quot; .. gmsgvars.number .. &quot;.[-]&quot;)
				end

				faultyGMSG = false
				return true
			else
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Only admins can teleport to a hotspot.[-]&quot;)
				faultyGMSG = false
				return true
			end
		end


		if (gmsgvars.number == nil) then
			if accessLevel(gmsgvars.playerid) &gt; 2 and not players[gmsgvars.playerid].atHome then			
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can only create hotspots in and around your base.[-]&quot;)
				faultyGMSG = false
				return true
			end

			hotspotmsg = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;hotspot &quot;) + 8)
			hotspotmsg = string.trim(hotspotmsg)

			cursor,errorString = conn:execute(&quot;select max(idx) as max_idx from hotspots&quot;)
			row = cursor:fetch({}, &quot;a&quot;)

			if row.max_idx ~= nil then
				nextidx = tonumber(row.max_idx) + 1
			else
				nextidx = 1
			end

			hotspots[nextidx] = {}
			hotspots[nextidx].hotspot = hotspotmsg
			hotspots[nextidx].owner = gmsgvars.playerid
			hotspots[nextidx].size = 2
			hotspots[nextidx].x = gmsgvars.intX
			hotspots[nextidx].y = gmsgvars.intY
			hotspots[nextidx].z = gmsgvars.intZ

			conn:execute(&quot;INSERT INTO hotspots (idx, hotspot, x, y, z, owner) VALUES (&quot; .. nextidx .. &quot;,'&quot; .. escape(hotspotmsg) .. &quot;',&quot; .. gmsgvars.intX .. &quot;,&quot; .. gmsgvars.intY .. &quot;,&quot; .. gmsgvars.intZ .. &quot;,&quot; .. gmsgvars.playerid .. &quot;)&quot;)

			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You made a hotspot with the message &quot; .. hotspotmsg .. &quot;[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug hotspots 6&quot;) end

	if (gmsgvars.words[1] == &quot;hotspots&quot;) then
		if accessLevel(gmsgvars.playerid) == 99 then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]New players are not allowed to play with hotspots.[-]&quot;)
			faultyGMSG = false
			return true
		end

		if (gmsgvars.number == nil) then
			if (accessLevel(gmsgvars.playerid) &lt; 3) then
				if gmsgvars.words[2] ~= nil then
					pid = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;hotspots &quot;) + 10)
					pid = string.trim(pid)
					pid = LookupPlayer(pid)
				else
					gmsgvars.number = 20
				end
			else
				pid = gmsgvars.playerid
			end

			if (pid == nil and gmsgvars.number == nil) then 
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No player found with that name.[-]&quot;)
				faultyGMSG = false
				return true
			end

			if (pid ~= nil) then 
				cursor,errorString = conn:execute(&quot;select * from hotspots where owner = &quot; .. pid)
				row = cursor:fetch({}, &quot;a&quot;)

				while row do
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]#&quot; .. row.idx .. &quot; &quot; .. row.hotspot .. &quot;[-]&quot;)
					row = cursor:fetch(row, &quot;a&quot;)
				end

				faultyGMSG = false
				return true
			end
		end

		if (gmsgvars.number ~= nil) then
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				gmsgvars.number = 20
				cursor,errorString = conn:execute(&quot;select * from hotspots where owner =  &quot; .. gmsgvars.playerid .. &quot; and abs(x - &quot; .. gmsgvars.intX .. &quot;) &lt;= &quot; .. gmsgvars.number .. &quot; and abs(y - &quot; .. gmsgvars.intY .. &quot;) &lt;= &quot; .. gmsgvars.number .. &quot; and abs(z - &quot; .. gmsgvars.intZ .. &quot;) &lt;= &quot; .. gmsgvars.number)
			else
				if (gmsgvars.number == nil) then gmsgvars.number = 20 end
				cursor,errorString = conn:execute(&quot;select * from hotspots where abs(x - &quot; .. gmsgvars.intX .. &quot;) &lt;= &quot; .. gmsgvars.number .. &quot; and abs(y - &quot; .. gmsgvars.intY .. &quot;) &lt;= &quot; .. gmsgvars.number .. &quot; and abs(z - &quot; .. gmsgvars.intZ .. &quot;) &lt;= &quot; .. gmsgvars.number)
			end

			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The following hotspots are within &quot; .. gmsgvars.number .. &quot; metres of you[-]&quot;)
			row = cursor:fetch({}, &quot;a&quot;)

			while row do
				if accessLevel(gmsgvars.playerid) &lt; 3 then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]#&quot; .. row.idx .. &quot; &quot; .. players[row.owner].name .. &quot; size &quot; .. row.size * 2 .. &quot;m &quot; .. row.hotspot .. &quot;[-]&quot;)
				else
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]#&quot; .. row.idx .. &quot; size &quot; .. row.size * 2 .. &quot;m &quot; .. row.hotspot .. &quot;[-]&quot;)
				end

				row = cursor:fetch(row, &quot;a&quot;)
			end

			faultyGMSG = false
			return true
		end
	end

if debug then dbug(&quot;debug hotspots end&quot;) end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_info</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
info commands
=============
uptime
whats new
where
info
help
commands
new players
fps
--]]

function gmsg_info()
	calledFunction = &quot;gmsg_info&quot;

	local xdir, zdir, dist, x, z, diff, days, hours, minutes, result, tokens, time	, werds, word, cmd

local debug
debug = false

	-- don't proceed if there is no leading slash
	if (string.sub(gmsgvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyGMSG = false
		return false
	end

if debug then dbug(&quot;debug info 1&quot;) end

	result = false

	if (gmsgvars.words[1] == &quot;uptime&quot; and gmsgvars.words[2] == nil) then
			diff = os.difftime(os.time(), botStarted)
			days = math.floor(diff / 86400)

			if (days &gt; 0) then
				diff = diff - (days * 86400)
			end

			hours = math.floor(diff / 3600)

			if (hours &gt; 0) then
				diff = diff - (hours * 3600)
			end

			minutes = math.floor(diff / 60)

			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. server.botName .. &quot; has been online &quot; .. days .. &quot; days &quot; .. hours .. &quot; hours &quot; .. minutes ..&quot; minutes[-]&quot;)

			if gameTick &lt; 0 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]Server uptime is unknown due to a server fault. Reboot the server.[-]&quot;)
			else
				diff = gameTick
				days = math.floor(diff / 86400)

				if (days &gt; 0) then
					diff = diff - (days * 86400)
				end

				hours = math.floor(diff / 3600)

				if (hours &gt; 0) then
					diff = diff - (hours * 3600)
				end

				minutes = math.floor(diff / 60)

				message(&quot;say [&quot; .. server.chatColour .. &quot;]Server uptime is &quot; .. days .. &quot; days &quot; .. hours .. &quot; hours &quot; .. minutes ..&quot; minutes[-]&quot;)
			end

		faultyGMSG = false
		return true
	end 

if debug then dbug(&quot;debug info 2&quot;) end

	-- ###################  do not allow remote commands beyond this point ################
	if (gmsgvars.playerid == nil) then
		faultyGMSG = false
		return false
	end
	-- ####################################################################################

	if gmsgvars.words[1] == &quot;whats&quot; and gmsgvars.words[2] == &quot;new&quot; then
		conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,&quot; .. gmsgvars.playerid .. &quot;,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]This bot is being trialled here. Let us know if something doesn't work.[-]&quot;) .. &quot;')&quot;)
		conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,&quot; .. gmsgvars.playerid .. &quot;,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]Many boring changes such as a new database (EXCITING!)[-]&quot;) .. &quot;')&quot;)
		conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,&quot; .. gmsgvars.playerid .. &quot;,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]Teleporting has been altered yet again![-]&quot;) .. &quot;')&quot;)
		conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,&quot; .. gmsgvars.playerid .. &quot;,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]More boring changes designed to make the bot more stable and better at its many jobs.[-]&quot;) .. &quot;')&quot;)
		conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,&quot; .. gmsgvars.playerid .. &quot;,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]The bot will be released with all the codez on September 6th![-]&quot;) .. &quot;')&quot;)
		conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,&quot; .. gmsgvars.playerid .. &quot;,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]Also the bot's website will be announced.[-]&quot;) .. &quot;')&quot;)

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug info 3&quot;) end

	if gmsgvars.words[1] == &quot;where&quot; or gmsgvars.words[1] == &quot;whereami&quot; and gmsgvars.words[2] == nil then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are &quot; .. string.format(&quot;%.2f&quot;, (distancexz(gmsgvars.intX, gmsgvars.intZ,0,0) / 1000)) .. &quot; km from the center of the map.[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are at &quot; .. mapPosition(gmsgvars.playerid) .. &quot;[-]&quot;)

		if pvpZone(gmsgvars.intX, gmsgvars.intZ) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]PVP is allowed here.[-]&quot;)
		else
			if (server.gameType ~= &quot;pvp&quot;) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]PVE rules apply here. Do not kill players.[-]&quot;)
			end
		end

		if players[gmsgvars.playerid].inLocation ~= &quot;&quot; then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are in the location &quot; .. players[gmsgvars.playerid].inLocation .. &quot;[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug info 4&quot;) end

	if string.find(gmsgvars.command, &quot;server&quot;) and (string.find(gmsgvars.command, &quot;favourite&quot;) or string.find(gmsgvars.command, &quot;favs&quot;) or string.find(gmsgvars.command, &quot;called&quot;) or string.find(gmsgvars.command, &quot;name&quot;) or string.find(gmsgvars.command, &quot; ip&quot;)) then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This server is &quot; .. server.ServerName .. &quot; &quot; .. server.IP .. &quot;:&quot; .. server.ServerPort .. &quot;[-]&quot;)
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug info 5&quot;) end

	if (gmsgvars.words[1] == &quot;server&quot; or gmsgvars.words[1] == &quot;info&quot;) and gmsgvars.words[2] == nil then
		-- Server name
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This server is &quot; .. server.ServerName .. &quot; &quot; .. server.IP .. &quot;:&quot; .. server.ServerPort .. &quot;[-]&quot;)	

		if (server.gameType == &quot;pve&quot;) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is a PVE server.[-]&quot;) end
		if (server.gameType == &quot;pvp&quot;) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is a PVP server.[-]&quot;) end
		if (server.gameType == &quot;cre&quot;) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is a creative mode server.[-]&quot;) end

		-- day/night length
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A full day runs &quot; .. server.DayNightLength .. &quot; minutes[-]&quot;)

		-- drop on death
		if (server.DropOnDeath == 0) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You drop everything on death[-]&quot;) end
		if (server.DropOnDeath == 1) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You drop toolbelt on death[-]&quot;) end
		if (server.DropOnDeath == 2) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You drop backpack on death[-]&quot;) end
		if (server.DropOnDeath == 3) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You permanently lose everything on death[-]&quot;) end

		-- drop on quit
		if (server.DropOnQuit == 0) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You keep everything on quit[-]&quot;) end
		if (server.DropOnQuit == 1) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You drop everything on quit[-]&quot;) end
		if (server.DropOnQuit == 2) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You drop toolbelt only on quit[-]&quot;) end
		if (server.DropOnQuit == 3) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You drop backpack only on quit[-]&quot;) end

		-- land claim size
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Land claim size is &quot; .. server.LandClaimSize .. &quot; meters. Expiry 30 days[-]&quot;)

		-- block durability
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Block durability is &quot; .. server.BlockDurabilityModifier .. &quot;%[-]&quot;)

		-- loot abundance
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Loot abundance is &quot; .. server.LootAbundance .. &quot;%[-]&quot;)

		-- loot respawn
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Loot respawns after &quot; .. server.LootRespawnDays .. &quot; days[-]&quot;)

		-- zombies run
		if (server.ZombiesRun == 0) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Zombies run at night[-]&quot;) end
		if (server.ZombiesRun == 1) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Zombies never run[-]&quot;) end
		if (server.ZombiesRun == 2) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Zombies always run[-]&quot;) end

		-- zombie memory
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Zombie memory is &quot; .. server.EnemySenseMemory .. &quot; seconds[-]&quot;)

		-- map limit
		if players[gmsgvars.playerid].donor == true then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The world is limited to  &quot; .. (server.mapSize + 10000) / 1000 .. &quot; km from map center[-]&quot;)
		else
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The world is limited to  &quot; .. server.mapSize / 1000 .. &quot; km from map center[-]&quot;)
		end

		--message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]When the server is full, idle players are kicked after 15 minutes.[-]&quot;)
	
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug info 6&quot;) end

	-- help
	if (gmsgvars.words[1] == &quot;help&quot;) then
		if gmsgvars.words[2] ~= nil then
			cmd = string.trim(string.sub(gmsgvars.command, 7))
		end

		help(cmd)

		faultyGMSG = false
		return true
	end


	if (gmsgvars.words[1] == &quot;commands&quot;) then
		help(&quot;commands&quot;)
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug info 7&quot;) end


	if (gmsgvars.words[1] == &quot;fps&quot; and gmsgvars.words[2] == nil) then
		cursor,errorString = conn:execute(&quot;SELECT * FROM performance  ORDER BY serverdate DESC Limit 0, 1&quot;)
		row = cursor:fetch({}, &quot;a&quot;)

		if row then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Server FPS: &quot; .. server.fps .. &quot; Players: &quot; .. row.players .. &quot; Zombies: &quot; .. row.zombies .. &quot; Entities: &quot; .. row.entities .. &quot;[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug info 8&quot;) end

	if (gmsgvars.words[1] == &quot;server&quot; and (gmsgvars.words[2] == &quot;date&quot; or gmsgvars.words[2] == &quot;time&quot;)) and gmsgvars.words[3] == nil then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The server date is &quot; .. serverTime .. &quot;[-]&quot;)
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug info 9&quot;) end

	if (gmsgvars.words[1] == &quot;server&quot; and (gmsgvars.words[2] == &quot;status&quot; or gmsgvars.words[2] == &quot;stats&quot;)) and gmsgvars.words[3] == nil then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]24 hour stats to now:[-]&quot;)

		cursor,errorString = conn:execute(&quot;SELECT COUNT(id) as number FROM events WHERE event LIKE '%pvp%' AND timestamp &gt; DATE_SUB(now(), INTERVAL 1 DAY)&quot;)
		row = cursor:fetch({}, &quot;a&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]PVPs: &quot; .. row.number .. &quot;[-]&quot;)

		cursor,errorString = conn:execute(&quot;SELECT COUNT(id) as number FROM events WHERE event LIKE '%timeout%' AND timestamp &gt; DATE_SUB(now(), INTERVAL 1 DAY)&quot;)
		row = cursor:fetch({}, &quot;a&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Timeouts: &quot; .. row.number .. &quot;[-]&quot;)

		cursor,errorString = conn:execute(&quot;SELECT COUNT(id) as number FROM events WHERE event LIKE '%arrest%' AND timestamp &gt; DATE_SUB(now(), INTERVAL 1 DAY)&quot;)
		row = cursor:fetch({}, &quot;a&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Arrests: &quot; .. row.number .. &quot;[-]&quot;)

		cursor,errorString = conn:execute(&quot;SELECT COUNT(id) as number FROM events WHERE event LIKE '%new%' AND timestamp &gt; DATE_SUB(now(), INTERVAL 1 DAY)&quot;)
		row = cursor:fetch({}, &quot;a&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]New players: &quot; .. row.number .. &quot;[-]&quot;)

		cursor,errorString = conn:execute(&quot;SELECT COUNT(id) as number FROM events WHERE event LIKE '%ban%' AND timestamp &gt; DATE_SUB(now(), INTERVAL 1 DAY)&quot;)
		row = cursor:fetch({}, &quot;a&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Bans: &quot; .. row.number .. &quot;[-]&quot;)

		cursor,errorString = conn:execute(&quot;SELECT MAX(players) as number FROM performance WHERE timestamp &gt; DATE_SUB(now(), INTERVAL 1 DAY)&quot;)
		row = cursor:fetch({}, &quot;a&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Most players online: &quot; .. row.number .. &quot;[-]&quot;)

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug info 10&quot;) end

	if (gmsgvars.words[1] == &quot;new&quot; and gmsgvars.words[2] == &quot;players&quot;) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end
		
		if gmsgvars.number == nil then 
			number = 86400 
		else
			number = gmsgvars.number * 86400
		end

		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]New players in the last &quot; .. math.floor(number / 86400) .. &quot; days:[-]&quot;)

		cursor,errorString = conn:execute(&quot;SELECT * FROM events where timestamp &gt;= '&quot; .. os.date('%Y-%m-%d %H:%M:%S', os.time() - number).. &quot;' and type = 'new player' order by timestamp desc&quot;)
		row = cursor:fetch({}, &quot;a&quot;)

		while row do
			msg = &quot;steam: &quot; .. row.steam .. &quot; id: &quot; .. string.format(&quot;%8d&quot;, players[row.steam].id) .. &quot; name: &quot; .. players[row.steam].name .. &quot; at [ &quot; .. players[row.steam].xPos .. &quot; &quot; .. players[row.steam].yPos .. &quot; &quot; .. players[row.steam].zPos .. &quot; ] &quot; .. players[row.steam].country
			msg = msg .. &quot; PVP &quot; .. players[row.steam].playerKills

			if (igplayers[row.steam]) then
				time = tonumber(players[row.steam].timeOnServer) + tonumber(igplayers[row.steam].sessionPlaytime)
			else
				time = tonumber(players[row.steam].timeOnServer)
			end

			hours = math.floor(time / 3600)

			if (hours &gt; 0) then
				time = time - (hours * 3600)
			end

			minutes = math.floor(time / 60)

			msg = msg .. &quot; Playtime &quot; .. hours .. &quot;h &quot; .. minutes .. &quot;m&quot;

			cursor2,errorString = conn:execute(&quot;SELECT * FROM bans WHERE steam =  &quot; .. row.steam)
			if cursor2:numrows() &gt; 0 then
				msg = msg .. &quot; BANNED&quot;
			end

			if players[row.steam].timeout == true then
				msg = msg .. &quot; TIMEOUT&quot;
			end

			if players[row.steam].country == &quot;CN&quot; or players[row.steam].country == &quot;HK&quot; then
				msg = msg .. &quot; Chinese&quot;
			end

			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. msg .. &quot;[-]&quot;)
		
			row = cursor:fetch(row, &quot;a&quot;)	
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug info 11&quot;) end

	if (gmsgvars.words[1] == &quot;status&quot;) then
		faultyGMSG = baseStatus(gmsgvars.command, gmsgvars.playerid)
		return true
	end

if debug then dbug(&quot;debug info 12&quot;) end

	if (gmsgvars.words[1] == &quot;tokens&quot; and gmsgvars.words[2] == nil) then
		if players[gmsgvars.playerid].tokens == nil then
			players[gmsgvars.playerid].tokens = 0
		end

		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have &quot; .. players[gmsgvars.playerid].tokens .. &quot; tokens remaining.[-]&quot;)

		if players[gmsgvars.playerid].tokens == 0 then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Tokens can be purchased from the shop.  They give you access to special features such as teleporting directly to a friend.[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug info 13&quot;) end

	if string.find(gmsgvars.command, &quot;pvp&quot;) and (accessLevel(gmsgvars.playerid) == 99) and (gmsgvars.words[1] ~= &quot;help&quot;) then
		if (server.gameType == &quot;pvp&quot;) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is a PVP server.[-]&quot;)
		else
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is a PVE server.  No PVP except in PVP zones.  Read /help pvp for info.[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug info 14&quot;) end

	if (gmsgvars.words[1] == &quot;rules&quot; and gmsgvars.words[2] == nil)  then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. server.rules ..&quot;[-]&quot;)
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug info 15&quot;) end

	if (gmsgvars.words[1] == &quot;seen&quot;) then
		pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;seen &quot;) + 5)
		pname = string.trim(pname)

		id = LookupPlayer(pname)

		if (igplayers[id]) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]player &quot; .. players[id].name .. &quot; is playing right now.  Press TAB.[-]&quot;)	
			faultyGMSG = false
			return true
		end

		if (players[id]) then
			werds = {}
			for word in serverTime:gmatch(&quot;%w+&quot;) do table.insert(werds, word) end

			ryear = werds[1]
			rmonth = werds[2]
			rday = string.sub(werds[3], 1, 2)
			rhour = string.sub(werds[3], 4, 5)
			rmin = werds[4]
			rsec = werds[5]

			dateNow = {year=ryear, month=rmonth, day=rday, hour=rhour, min=rmin, sec=rsec}
			Now = os.time(dateNow)

			werds = {}
			for word in players[id].seen:gmatch(&quot;%w+&quot;) do table.insert(werds, word) end

			ryear = werds[1]
			rmonth = werds[2]
			rday = werds[3]
			rhour = werds[4]
			rmin = werds[5]
			rsec = 0

			dateSeen = {year=ryear, month=rmonth, day=rday, hour=rhour, min=rmin, sec=rsec}
			Seen = os.time(dateSeen)

			diff = os.difftime(Now, Seen)
			days = math.floor(diff / 86400)

			if (days &gt; 0) then
				diff = diff - (days * 86400)
			end

			hours = math.floor(diff / 3600)

			if (hours &gt; 0) then
				diff = diff - (hours * 3600)
			end

			minutes = math.floor(diff / 60)

			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; ..players[id].name .. &quot; was last seen &quot; .. days .. &quot; days &quot; .. hours .. &quot; hours &quot; .. minutes ..&quot; minutes ago[-]&quot;)	
		else
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Sorry I don't know a player called &quot; .. pname .. &quot;. Check your spelling.[-]&quot;)	
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug info 16&quot;) end

	if (gmsgvars.words[1] == &quot;who&quot; and gmsgvars.words[3] == nil) then	
		if not string.find(gmsgvars.oldLine, &quot; command 'pm&quot;) then
			if accessLevel(gmsgvars.playerid) &gt; 2 and not server.coppi then
 				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Who now requires grass in slot 8 of your belt.  You do not use the who command in chat anymore.[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		alone = true

		if (gmsgvars.number == nil) then gmsgvars.number = 500 end

		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			gmsgvars.number = 300
		end

		if (accessLevel(gmsgvars.playerid) &gt; 10) then
			gmsgvars.number = 200
		end

		x = math.floor(igplayers[gmsgvars.playerid].xPos / 512)
		z = math.floor(igplayers[gmsgvars.playerid].zPos / 512)

		if (tonumber(gmsgvars.intX) &lt; 0) then xdir = &quot; west &quot; else xdir = &quot; east &quot; end
		if (tonumber(gmsgvars.intZ) &lt; 0) then zdir = &quot; south&quot; else zdir = &quot; north&quot; end
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are at &quot; .. gmsgvars.intX .. xdir .. gmsgvars.intZ .. zdir .. &quot; at a height of &quot; .. gmsgvars.intY .. &quot;[-]&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are in region r.&quot; .. x .. &quot;.&quot; .. z .. &quot;.7rg[-]&quot;)

		if (pvpZone(gmsgvars.intX, gmsgvars.intZ) == false) or (server.gameType ~= &quot;pvp&quot;) then
			for k, v in pairs(igplayers) do
				dist = distance(gmsgvars.intX, gmsgvars.intZ, v.xPos, v.zPos)

				if dist &lt;= tonumber(gmsgvars.number) then
					if (v.steam ~= gmsgvars.playerid) then
						if (alone == true) then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]players within &quot; .. gmsgvars.number .. &quot; meters of you are:[-]&quot;) end

						if (accessLevel(gmsgvars.playerid) &lt; 4) then
							x = math.floor(v.xPos / 512)
							z = math.floor(v.zPos / 512)

							message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot; distance: &quot; .. string.format(&quot;%d&quot;, dist) .. &quot; region r.&quot; .. x .. &quot;.&quot; .. z .. &quot;.7rg[-]&quot;)
						else
							if (players[gmsgvars.playerid].watchPlayer == true) and accessLevel(v.steam) &gt; 2 then
								message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot;[-]&quot;)
							end

							if (players[gmsgvars.playerid].watchPlayer == false) then
								message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot;[-]&quot;)
							end
						end
						alone = false
					end
				end
			end

			if alone then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Nobody is within &quot; .. gmsgvars.number .. &quot; meters of you.[-]&quot;)
			end
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug info 17&quot;) end

	if (gmsgvars.words[1] == &quot;alert&quot;) then
		if (gmsgvars.words[2] == nil) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Please include a message eg /alert Claimed shop here![-]&quot;)
			faultyGMSG = false
			return true
		end

		command = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;alert &quot;) + 6)
		cecho(&quot;alerts&quot;, &quot;***** &quot; .. gmsgvars.playername .. &quot; at position &quot; .. gmsgvars.intX .. &quot; &quot; .. gmsgvars.intY .. &quot; &quot; .. gmsgvars.intZ .. &quot; said: &quot; .. command .. &quot;\n&quot;)
		sendIrc(server.ircAlerts, &quot;***** &quot; .. gmsgvars.playername .. &quot; at position &quot; .. gmsgvars.intX .. &quot; &quot; .. gmsgvars.intY .. &quot; &quot; .. gmsgvars.intZ .. &quot; said: &quot; .. command .. &quot;\n&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Thank you! Your message has been received! =D[-]&quot;)

		conn:execute(&quot;INSERT INTO alerts (steam, x, y, z, message) VALUES (&quot; .. gmsgvars.playerid .. &quot;,&quot; .. gmsgvars.intX .. &quot;,&quot; .. gmsgvars.intY .. &quot;,&quot; .. gmsgvars.intZ .. &quot;,'&quot; .. command .. &quot;')&quot;)

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug info 18&quot;) end

	if (gmsgvars.words[1] == &quot;info&quot; and gmsgvars.words[2] ~= nil) then		
		pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;info&quot;) + 5)
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if accessLevel(gmsgvars.playerid) &gt; 2 then
			if gmsgvars.playerid ~= id then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You may only view your own info.[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		if (id ~= nil) then
			if (igplayers[id]) then
				time = tonumber(players[id].timeOnServer) + tonumber(igplayers[id].sessionPlaytime)
			else
				time = tonumber(players[id].timeOnServer)
			end

			days = math.floor(time / 86400)

			if (days &gt; 0) then
				time = time - (days * 86400)
			end

			hours = math.floor(time / 3600)

			if (hours &gt; 0) then
				time = time - (hours * 3600)
			end

			minutes = math.floor(time / 60)
			time = time - (minutes * 60)

			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Info for player &quot; .. players[id].name .. &quot;[-]&quot;)
			if players[id].newPlayer == true then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A new player.[-]&quot;) end
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Steam: &quot; .. id .. &quot; ID: &quot; .. players[id].id .. &quot;[-]&quot;)
			if players[id].firstSeen ~= nil then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]First seen: &quot; .. os.date(&quot;%Y-%m-%d %H:%M:%S&quot;, players[id].firstSeen) .. &quot;[-]&quot;) end
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Total time played: &quot; .. days .. &quot; days &quot; .. hours .. &quot; hours &quot; .. minutes .. &quot; minutes &quot; .. time .. &quot; seconds[-]&quot;)

			werds = {}
			for word in serverTime:gmatch(&quot;%w+&quot;) do table.insert(werds, word) end

			ryear = werds[1]
			rmonth = werds[2]
			rday = string.sub(werds[3], 1, 2)
			rhour = string.sub(werds[3], 4, 5)
			rmin = werds[4]
			rsec = werds[5]

			dateNow = {year=ryear, month=rmonth, day=rday, hour=rhour, min=rmin, sec=rsec}
			Now = os.time(dateNow)
		
			werds = {}
			for word in players[id].seen:gmatch(&quot;%w+&quot;) do table.insert(werds, word) end

			ryear = werds[1]
			rmonth = werds[2]
			rday = string.sub(werds[3], 1, 2)
			rhour = string.sub(werds[3], 4, 5)
			rmin = werds[4]
			rsec = werds[5]

			dateSeen = {year=ryear, month=rmonth, day=rday, hour=rhour, min=rmin, sec=rsec}
			Seen = os.time(dateSeen)

			diff = os.difftime(Now, Seen)
			days = math.floor(diff / 86400)

			if (days &gt; 0) then
				diff = diff - (days * 86400)
			end

			hours = math.floor(diff / 3600)

			if (hours &gt; 0) then
				diff = diff - (hours * 3600)
			end

			minutes = math.floor(diff / 60)

			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; ..players[id].name .. &quot; was last seen &quot; .. days .. &quot; days &quot; .. hours .. &quot; hours &quot; .. minutes ..&quot; minutes ago[-]&quot;)			
					
			if players[id].timeout then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Is in timeout[-]&quot;) end
			if players[id].prisoner then 
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Is a prisoner[-]&quot;)
				if players[id].prisonReason ~= nil then message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Reason Arrested: &quot; .. players[id].prisonReason .. &quot;[-]&quot;) end
			end
			
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Keystones placed &quot; .. players[id].keystones .. &quot;[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Zennies &quot; .. players[id].cash .. &quot;[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Current Session &quot; .. players[id].sessionCount .. &quot;[-]&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]IP &quot; .. players[id].ip .. &quot;[-]&quot;)

			if players[id].donor then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Is a donor[-]&quot;)
			else
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Is not a donor[-]&quot;)
			end
			
			cursor,errorString = conn:execute(&quot;SELECT * FROM bans WHERE steam =  &quot; .. id)
			if cursor:numrows() &gt; 0 then
				row = cursor:fetch({}, &quot;a&quot;)
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]BANNED until &quot; .. row.BannedTo .. &quot; &quot; .. row.Reason .. &quot;[-]&quot;)
			end


		else	
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Player name required or no match found.[-]&quot;)	
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug info end&quot;) end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_trial_code</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


-- trial code goes here.  These commands are not accessible to players until moved to other sections.

function gmsg_trial_code()
	calledFunction = &quot;gmsg_trial_code&quot;

	-- don't proceed if there is no leading slash
	if (string.sub(gmsgvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyGMSG = false
		return false
	end


	-- ###################  do not allow remote commands beyond this point ################
	if (gmsgvars.playerid == nil) then
		faultyGMSG = false
		return false
	end

	if accessLevel(gmsgvars.playerid) &gt; 2 then
		faultyGMSG = false
		return false
	end
	-- ####################################################################################

	if (gmsgvars.words[1] == &quot;test&quot; and gmsgvars.words[2] == &quot;test&quot; and accessLevel(gmsgvars.playerid) == 0) then
		-- add a command to test here.  restricted to server owners.

		if locations[&quot;lobby&quot;] then
			cursor,errorString = conn:execute(&quot;select * from locationSpawns where location='lobby'&quot;)
			if cursor:numrows() &gt; 0 then
				randomPVPTP(gmsgvars.playerid, &quot;lobby&quot;)
			else
				cmd = &quot;tele &quot; .. gmsgvars.playerid .. &quot; &quot; .. locations[&quot;lobby&quot;].x .. &quot; &quot; .. locations[&quot;lobby&quot;].y .. &quot; &quot; .. locations[&quot;lobby&quot;].z
				prepareTeleport(gmsgvars.playerid, cmd)
				teleport(cmd, true)
			end
		end
	end


	if (gmsgvars.words[1] == &quot;most&quot; and gmsgvars.words[2] == &quot;wanted&quot;) or gmsgvars.words[1] == &quot;bounty&quot; then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The top 10 payers with a bounty on their heads are:[-]&quot;)

		for k, v in pairs(top10) do
			--message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;] &quot; .. v.name .. &quot; $&quot; .. v.bounty .. &quot;[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_locations</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
location commands
=================
location clear
location remove
location pvp/pve
location enable
location disable
location private
location public
lobby
location owner
location set reset
location clear reset
location allow base
location disallow base
location size
location access
location add
protect location
unprotect location
location move
locations
location ends here
location random
location &lt;name&gt;
--]]

function gmsg_locations()
	calledFunction = &quot;gmsg_locations&quot;

	local debug, temp
	debug = false

	local loc, locationName, locationName, id, pname

	-- don't proceed if there is no leading slash
	if (string.sub(gmsgvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyGMSG = false
		return false
	end

if debug then dbug(&quot;debug locations 1&quot;) end

	if gmsgvars.words[1] == &quot;location&quot; and string.find(gmsgvars.command, &quot;clear&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end
		
		locationName = &quot;&quot;
		locationName = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;location &quot;) + 9, string.find(gmsgvars.command, &quot;clear&quot;) - 2)
		locationName = string.trim(locationName)			
		loc = LookupLocation(locationName)

		if loc ~= nil then
			conn:execute(&quot;DELETE FROM locationSpawns WHERE location = '&quot; .. escape(loc) .. &quot;'&quot;)
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Location &quot; .. locationName .. &quot;'s teleports have been deleted.[-]&quot;)
		else
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
		end

		faultyGMSG = false
		return true
	end


	if (gmsgvars.words[1] == &quot;location&quot; and gmsgvars.words[2] == &quot;remove&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		locationName = &quot;&quot;
		locationName = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;remove &quot;) + 7)
		locationName = string.trim(locationName)
		loc = LookupLocation(locationName)

		if (locationName == &quot;prison&quot;) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The server needs a prison.  PVP protection will be disabled until you add a new prison.[-]&quot;)
		end 

		if (loc == nil) then 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			faultyGMSG = false
			return true
		else	
			locations[loc] = nil
			conn:execute(&quot;DELETE FROM locations WHERE name = '&quot; .. locationName .. &quot;'&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You removed a location called &quot; .. locationName .. &quot;[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug locations 2&quot;) end

	if gmsgvars.words[1] == &quot;location&quot; and (string.find(gmsgvars.command, &quot;pvp&quot;) or string.find(gmsgvars.command, &quot;pve&quot;)) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end
		
		locationName = &quot;&quot;
		locationName = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;location &quot;) + 9, string.find(gmsgvars.command, &quot; pv&quot;) - 1)
		locationName = string.trim(locationName)	
		loc = LookupLocation(locationName)

		if loc ~= nil then
			if string.find(gmsgvars.command, &quot;pve&quot;) then
				locations[loc].pvp = false
				conn:execute(&quot;UPDATE locations set pvp = false WHERE name = '&quot; .. escape(locationName) .. &quot;'&quot;)
				message(&quot;say [&quot; .. server.chatColour .. &quot;]The location &quot; .. locations[loc].name .. &quot; is now a PVE zone.[-]&quot;)
			else
				locations[loc].pvp = true
				conn:execute(&quot;UPDATE locations set pvp = true WHERE name = '&quot; .. escape(locationName) .. &quot;'&quot;)
				message(&quot;say [&quot; .. server.chatColour .. &quot;]The location &quot; .. locations[loc].name .. &quot; is now a PVP zone![-]&quot;)		
			end			
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug locations 3&quot;) end

	if (gmsgvars.words[1] == &quot;location&quot; and gmsgvars.words[2] == &quot;enable&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		locationName = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;enable &quot;) + 7)
		locationName = string.trim(locationName)
		loc = LookupLocation(locationName)

		if (loc == nil) then 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			faultyGMSG = false
			return true
		else	
			locations[loc].active = true
			conn:execute(&quot;UPDATE locations set active = true WHERE name = '&quot; .. escape(locationName) .. &quot;'&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The location called &quot; .. locationName .. &quot; is now enabled[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug locations 4&quot;) end

	if (gmsgvars.words[1] == &quot;location&quot; and gmsgvars.words[2] == &quot;disable&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		locationName = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;disable &quot;) + 8)
		locationName = string.trim(locationName)
		loc = LookupLocation(locationName)

		if (loc == nil) then 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			faultyGMSG = false
			return true
		else	
			locations[loc].active = false
			conn:execute(&quot;UPDATE locations set active = false WHERE name = '&quot; .. escape(locationName) .. &quot;'&quot;)
			message(&quot;say [&quot; .. server.chatColour .. &quot;]The location called &quot; .. locationName .. &quot; is now disabled[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug locations 5&quot;) end

	if (gmsgvars.words[1] == &quot;location&quot; and gmsgvars.words[2] == &quot;private&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		locationName = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;private &quot;) + 8)
		locationName = string.trim(locationName)
		loc = LookupLocation(locationName)

		if (loc == nil) then 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			faultyGMSG = false
			return true
		else	
			locations[loc].public = false
			conn:execute(&quot;UPDATE locations set public = false WHERE name = '&quot; .. escape(locationName) .. &quot;'&quot;)
			message(&quot;say [&quot; .. server.chatColour .. &quot;]The location called &quot; .. locationName .. &quot; is now private[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug locations 6&quot;) end

	if (gmsgvars.words[1] == &quot;location&quot; and gmsgvars.words[2] == &quot;public&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		locationName = &quot;&quot;
		locationName = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;public &quot;) + 7)
		locationName = string.trim(locationName)
		loc = LookupLocation(locationName)

		if (loc == nil) then 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			faultyGMSG = false
			return true
		else	
			locations[loc].public = true
			conn:execute(&quot;UPDATE locations set public = true WHERE name = '&quot; .. locationName .. &quot;'&quot;)
			message(&quot;say [&quot; .. server.chatColour .. &quot;]The location called &quot; .. locationName .. &quot; is now public[-]&quot;)
		end

		faultyGMSG = false
		return true
	end


	if (gmsgvars.words[1] == &quot;location&quot; and gmsgvars.words[2] == &quot;set&quot; and gmsgvars.words[3] == &quot;reset&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		locationName = &quot;&quot;
		locationName = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;reset &quot;) + 6)
		locationName = string.trim(locationName)

		loc = LookupLocation(locationName)

		if (loc == nil) then 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			faultyGMSG = false
			return true
		else	
			locations[loc].resetZone = true
			conn:execute(&quot;UPDATE locations set resetZone = true WHERE name = '&quot; .. locationName .. &quot;'&quot;)
			message(&quot;say [&quot; .. server.chatColour .. &quot;]The location called &quot; .. locationName .. &quot; is now a reset zone[-]&quot;)
		end

		faultyGMSG = false
		return true
	end


	if (gmsgvars.words[1] == &quot;location&quot; and gmsgvars.words[2] == &quot;clear&quot; and gmsgvars.words[2] == &quot;reset&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		locationName = &quot;&quot;
		locationName = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;reset &quot;) + 7)
		locationName = string.trim(locationName)
		loc = LookupLocation(locationName)

		if (loc == nil) then 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			faultyGMSG = false
			return true
		else	
			locations[loc].resetZone = false
			conn:execute(&quot;UPDATE locations set resetZone = false WHERE name = '&quot; .. locationName .. &quot;'&quot;)
			message(&quot;say [&quot; .. server.chatColour .. &quot;]The location called &quot; .. locationName .. &quot; is now a reset zone[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug locations 7&quot;) end

	if (gmsgvars.words[1] == &quot;lobby&quot; and gmsgvars.words[2] ~= nil) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;lobby &quot;) + 6)
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if (id ~= nil) then
			-- if the player is ingame, send them to the lobby otherwise flag it to happen when they rejoin
			if (igplayers[id]) then
				cmd = &quot;tele &quot; .. id .. &quot; &quot; .. locations[&quot;spawnpoint1&quot;].x .. &quot; &quot; .. locations[&quot;spawnpoint1&quot;].y .. &quot; &quot; .. locations[&quot;spawnpoint1&quot;].z
				teleport(cmd)
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Player &quot; .. players[id].name .. &quot; has been sent to the lobby[-]&quot;)
			else
				players[id].lobby = true
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Player &quot; .. players[id].name .. &quot; will spawn in the lobby next time they connect to the server[-]&quot;)
				conn:execute(&quot;UPDATE players set location = 'lobby' WHERE steam = &quot; .. id)
			end
		end
		
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug locations 8&quot;) end

	if (gmsgvars.words[1] == &quot;location&quot; and gmsgvars.words[3] == &quot;owner&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		id = LookupPlayer(gmsgvars.words[4]) 
		if (players[id]) then
			pname = players[id].name
		else
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No player matched that name.[-]&quot;)
			faultyGMSG = false
			return true
		end

		loc = string.trim(gmsgvars.words[2])
		loc = LookupLocation(loc)

		if (loc ~= nil) then
			locations[loc].owner = id
			conn:execute(&quot;UPDATE locations set owner = &quot; .. id .. &quot; WHERE name = '&quot; .. escape(loc) .. &quot;'&quot;)
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; is the proud new owner of the location called &quot; .. loc .. &quot;[-]&quot;)
		else
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug locations 9&quot;) end

	if (gmsgvars.words[1] == &quot;location&quot; and gmsgvars.words[2] == &quot;allow&quot; and gmsgvars.words[3] == &quot;base&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		locationName = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;base &quot;) + 5)
		locationName = string.trim(locationName)
		loc = LookupLocation(locationName)

		if (loc == nil) then 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
		else	
			locations[loc].allowBase = true
			conn:execute(&quot;UPDATE locations SET allowBase = true WHERE name = '&quot; .. escape(locationName) .. &quot;'&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Players may setbase in &quot; .. locationName .. &quot;.[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug locations 10&quot;) end

	if (gmsgvars.words[1] == &quot;location&quot; and gmsgvars.words[2] == &quot;disallow&quot; and gmsgvars.words[3] == &quot;base&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		locationName = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;base &quot;) + 5)
		locationName = string.trim(locationName)
		loc = LookupLocation(locationName)

		if (loc == nil) then 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
		else	
			locations[loc].allowBase = true
			conn:execute(&quot;UPDATE locations SET allowBase = false WHERE name = '&quot; .. escape(locationName) .. &quot;'&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Players may not setbase in &quot; .. locationName .. &quot;.[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug locations 11&quot;) end

	if gmsgvars.words[1] == &quot;location&quot; and string.find(gmsgvars.command, &quot;access&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end
		
		locationName = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;location &quot;) + 9, string.find(gmsgvars.command, &quot;access&quot;) - 2)
		locationName = string.trim(locationName)	
		loc = LookupLocation(locationName)

		if gmsgvars.number ~= nil and loc ~= nil then
			locations[loc].accessLevel = math.floor(tonumber(gmsgvars.number))
			conn:execute(&quot;UPDATE locations set accessLevel = &quot; .. math.floor(tonumber(gmsgvars.number)) .. &quot; WHERE name = '&quot; .. escape(locationName) .. &quot;'&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The location &quot; .. locationName .. &quot; is restricted to players with access level &quot; .. locations[loc].accessLevel .. &quot; and above.[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug locations 12&quot;) end

	if gmsgvars.words[1] == &quot;location&quot; and string.find(gmsgvars.command, &quot;size&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end
		
		locationName = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;location &quot;) + 9, string.find(gmsgvars.command, &quot;size&quot;) - 2)
		locationName = string.trim(locationName)			
		loc = LookupLocation(locationName)

		if gmsgvars.number ~= nil and loc ~= nil then
			locations[locationName].size = math.floor(tonumber(gmsgvars.number))
			conn:execute(&quot;UPDATE locations set size = &quot; .. math.floor(tonumber(gmsgvars.number)) .. &quot;, protectSize = &quot; .. math.floor(tonumber(gmsgvars.number)) .. &quot; WHERE name = '&quot; .. locationName .. &quot;'&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The location &quot; .. locations[loc].name .. &quot; now spans &quot; .. tonumber(gmsgvars.number * 2) .. &quot; meters.[-]&quot;)

			if loc == &quot;Prison&quot; then
				server.prisonSize = math.floor(tonumber(gmsgvars.number))
				conn:execute(&quot;UPDATE server SET prisonSize = &quot; .. math.floor(tonumber(gmsgvars.number)))
			end
		end

		if loc == nil then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug locations 13&quot;) end

	if gmsgvars.words[1] == &quot;location&quot; and (string.find(gmsgvars.command, &quot;pvp&quot;) or string.find(gmsgvars.command, &quot;pve&quot;)) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end
		
		locationName = &quot;&quot;
		locationName = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;location &quot;) + 9, string.find(gmsgvars.command, &quot; pv&quot;) - 1)
		locationName = string.trim(locationName)	
		loc = LookupLocation(locationName)

		if loc ~= nil then
			if string.find(gmsgvars.command, &quot;pve&quot;) then
				locations[loc].pvp = false
				conn:execute(&quot;UPDATE locations set pvp = false WHERE name = '&quot; .. escape(locationName) .. &quot;'&quot;)
				message(&quot;say [&quot; .. server.chatColour .. &quot;]The location &quot; .. locations[loc].name .. &quot; is now a PVE zone.[-]&quot;)
			else
				locations[loc].pvp = true
				conn:execute(&quot;UPDATE locations set pvp = true WHERE name = '&quot; .. escape(locationName) .. &quot;'&quot;)
				message(&quot;say [&quot; .. server.chatColour .. &quot;]The location &quot; .. locations[loc].name .. &quot; is now a PVP zone![-]&quot;)		
			end			
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug locations 14&quot;) end

	if (gmsgvars.words[1] == &quot;location&quot; and gmsgvars.words[2] == &quot;safe&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		locationName = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;safe &quot;) + 5)
		locationName = string.trim(locationName)
		loc = LookupLocation(locationName)

		if (loc == nil) then 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			faultyGMSG = false
			return true
		else	
			locations[loc].killZombies = true
			conn:execute(&quot;UPDATE locations set killZombies = true WHERE name = '&quot; .. escape(locationName) .. &quot;'&quot;)
			message(&quot;say [&quot; .. server.chatColour .. &quot;]The location called &quot; .. locationName .. &quot; is now a safezone.[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug locations 15&quot;) end

	if (gmsgvars.words[1] == &quot;location&quot; and gmsgvars.words[2] == &quot;unsafe&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		locationName = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;unsafe &quot;) + 7)
		locationName = string.trim(locationName)
		loc = LookupLocation(locationName)

		if (loc == nil) then 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			faultyGMSG = false
			return true
		else	
			locations[loc].killZombies = false
			conn:execute(&quot;UPDATE locations set killZombies = false WHERE name = '&quot; .. escape(locationName) .. &quot;'&quot;)
			message(&quot;say [&quot; .. server.chatColour .. &quot;]The location called &quot; .. locationName .. &quot; is no longer a safezone![-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug locations 16&quot;) end

	if gmsgvars.words[1] == &quot;location&quot; and string.find(gmsgvars.command, &quot;minigame&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		locationName = gmsgvars.words[2]
		loc = LookupLocation(locationName)

		if (loc == nil) then 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			faultyGMSG = false
			return true
		else	
			miniGame = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;minigame&quot;) + 9)

			if (miniGame == nil) then 
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You didn't enter a minigame (eg. ctf, contest).[-]&quot;)
				faultyGMSG = false
				return true
			end

			locations[loc].miniGame = miniGame
			conn:execute(&quot;UPDATE locations set miniGame = '&quot; .. escape(miniGame) .. &quot;' WHERE name = '&quot; .. loc .. &quot;'&quot;)
			message(&quot;say [&quot; .. server.chatColour .. &quot;]The location &quot; .. locationName .. &quot; is  the mini-game &quot; .. miniGame .. &quot;![-]&quot;)
		end

		faultyGMSG = false
		return true
	end


	-- ###################  do not allow remote commands beyond this point ################
	if (gmsgvars.playerid == nil) then
		faultyGMSG = false
		return false
	end
	-- ####################################################################################

if debug then dbug(&quot;debug locations 17&quot;) end

	if (gmsgvars.words[1] == &quot;protect&quot; and gmsgvars.words[2] == &quot;location&quot; and igplayers[gmsgvars.playerid].alertLocation ~= &quot;&quot;) then	
		igplayers[gmsgvars.playerid].alertLocationExit = igplayers[gmsgvars.playerid].alertLocation
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Walk out of &quot; .. igplayers[gmsgvars.playerid].alertLocation .. &quot; and the bot will do the rest.[-]&quot;)
		
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug locations 18&quot;) end

	if (gmsgvars.words[1] == &quot;unprotect&quot; and gmsgvars.words[2] == &quot;location&quot; and igplayers[gmsgvars.playerid].alertLocation ~= &quot;&quot;) then	
		locations[igplayers[gmsgvars.playerid].alertLocation].protected = false
		conn:execute(&quot;UPDATE locations SET protected = 0 WHERE name = '&quot; .. escape(igplayers[gmsgvars.playerid].alertLocation) .. &quot;'&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have disabled protection for &quot; .. igplayers[gmsgvars.playerid].alertLocation .. &quot;.[-]&quot;)
		
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug locations 19&quot;) end

	if (gmsgvars.words[1] == &quot;location&quot; and gmsgvars.words[2] == &quot;add&quot;) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		locationName = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;add &quot;) + 4)
		locationName = string.trim(locationName)
		loc = LookupLocation(locationName)

		if (loc ~= nil) then 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location already exists.[-]&quot;)
			faultyGMSG = false
			return true
		else	
			locations[locationName] = {}
			locations[locationName].name = locationName
			locations[locationName].x = gmsgvars.intX
			locations[locationName].y = gmsgvars.intY
			locations[locationName].z = gmsgvars.intZ
			locations[locationName].active = true
			locations[locationName].public = false
			locations[locationName].owner = gmsgvars.playerid
			locations[locationName].size = 20

			conn:execute(&quot;INSERT INTO locations (name, x, y, z) VALUES ('&quot; .. escape(locationName) .. &quot;',&quot; .. gmsgvars.intX .. &quot;,&quot; .. gmsgvars.intY .. &quot;,&quot; .. gmsgvars.intZ .. &quot;) ON DUPLICATE KEY UPDATE x = &quot; .. gmsgvars.intX .. &quot;, y = &quot; .. gmsgvars.intY .. &quot;, z = &quot; .. gmsgvars.intZ)
			conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. gmsgvars.intX .. &quot;,&quot; .. gmsgvars.intY .. &quot;,&quot; .. gmsgvars.intZ .. &quot;,'&quot; .. serverTime .. &quot;','location added','Location &quot; .. escape(locationName) .. &quot; added',&quot; .. gmsgvars.playerid .. &quot;)&quot;)
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. gmsgvars.playername .. &quot; has created a location called &quot; .. locationName .. &quot;[-]&quot;)
		end

		if (locationName == &quot;prison&quot;) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Server PVP protection is now enabled.[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug locations 20&quot;) end

	if (gmsgvars.words[1] == &quot;location&quot; and gmsgvars.words[2] == &quot;move&quot;) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		locationName = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;move &quot;) + 5)
		locationName = string.trim(locationName)
		loc = LookupLocation(locationName)

		if (loc == nil) then 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			faultyGMSG = false
			return true
		else	
			locations[loc].x = gmsgvars.intX
			locations[loc].y = gmsgvars.intY
			locations[loc].z = gmsgvars.intZ

			conn:execute(&quot;INSERT INTO locations (name, x, y, z) VALUES ('&quot; .. escape(locationName) .. &quot;',&quot; .. gmsgvars.intX .. &quot;,&quot; .. gmsgvars.intY .. &quot;,&quot; .. gmsgvars.intZ .. &quot;) ON DUPLICATE KEY UPDATE x = &quot; .. gmsgvars.intX .. &quot;, y = &quot; .. gmsgvars.intY .. &quot;, z = &quot; .. gmsgvars.intZ)
			conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. gmsgvars.intX .. &quot;,&quot; .. gmsgvars.intY .. &quot;,&quot; .. gmsgvars.intZ .. &quot;,'&quot; .. serverTime .. &quot;','location moved','Location &quot; .. escape(locationName) .. &quot; moved',&quot; .. gmsgvars.playerid .. &quot;)&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have moved a location called &quot; .. locationName .. &quot;[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug locations 21&quot;) end

	if (gmsgvars.words[1] == &quot;locations&quot; and gmsgvars.words[2] == nil) then
		for k, v in pairs(locations) do
			if (v.public == true) then
				public = &quot;public&quot;
			else
				public = &quot;private&quot;
			end
		
			if (public == &quot;private&quot; and accessLevel(gmsgvars.playerid) &lt; 3) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/&quot; .. v.name .. &quot; &quot; .. public .. &quot;[-]&quot;)
			end

			if (public == &quot;public&quot;) then
				if (accessLevel(gmsgvars.playerid) &lt; 4) then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/&quot; .. v.name .. &quot; &quot; .. public .. &quot;[-]&quot;)
				else
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/&quot; .. v.name .. &quot;[-]&quot;)
				end
			end
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug locations 22&quot;) end

	if gmsgvars.words[1] == &quot;location&quot; and string.find(gmsgvars.command, &quot;ends here&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end
		
		locationName = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;location &quot;) + 9, string.find(gmsgvars.command, &quot;end&quot;) - 2)
		locationName = string.trim(locationName)			
		loc = LookupLocation(locationName)

		if loc ~= nil then
			dist = distancexz(locations[loc].x, locations[loc].z, igplayers[gmsgvars.playerid].xPos, igplayers[gmsgvars.playerid].zPos)
			locations[loc].size = string.format(&quot;%d&quot;, dist)
			conn:execute(&quot;UPDATE locations set size = &quot; .. locations[loc].size .. &quot;, protectSize = &quot; .. locations[loc].size .. &quot; WHERE name = '&quot; .. locationName .. &quot;'&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The location &quot; .. loc .. &quot; now spans &quot; .. string.format(&quot;%d&quot;, dist * 2) .. &quot; meters.[-]&quot;)

			if loc == &quot;Prison&quot; then
				server.prisonSize = math.floor(tonumber(locations[loc].size))
				conn:execute(&quot;UPDATE server SET prisonSize = &quot; .. math.floor(tonumber(locations[loc].size)))
			end
		else
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug locations 23&quot;) end

	if gmsgvars.words[1] == &quot;location&quot; and string.find(gmsgvars.command, &quot;random&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end
		
		locationName = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;location &quot;) + 9, string.find(gmsgvars.command, &quot;random&quot;) - 2)
		locationName = string.trim(locationName)			
		loc = LookupLocation(locationName)

		if loc ~= nil then
			igplayers[gmsgvars.playerid].location = loc
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are now creating spawn points for location &quot; .. loc .. &quot;. DO NOT FLY.[-]&quot;)
		else
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug locations 24&quot;) end

	if (gmsgvars.words[1] == &quot;location&quot;) then
		-- display details about the location

		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		locationName = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;location &quot;) + 9)
		locationName = string.trim(locationName)
		loc = LookupLocation(locationName)

		if (loc == nil) then 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			faultyGMSG = false
			return true
		else	
			cursor,errorString = conn:execute(&quot;SELECT * FROM locations WHERE name = '&quot; .. locationName ..&quot;'&quot;)
			row = cursor:fetch({}, &quot;a&quot;)

			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Location: &quot; .. row.name .. &quot;[-]&quot;)				
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Active: &quot; .. dbYN(row.active) .. &quot;[-]&quot;)				
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Reset Zone: &quot; .. dbYN(row.resetZone) .. &quot;[-]&quot;)				
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Public: &quot; .. dbYN(row.public) .. &quot;[-]&quot;)				
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Allow Bases: &quot; .. dbYN(row.allowBase) .. &quot;[-]&quot;)				

			if row.miniGame ~= nil then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Mini Game: &quot; .. row.miniGame .. &quot;[-]&quot;)				
			end

			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Village: &quot; .. dbYN(row.village) .. &quot;[-]&quot;)				

			temp = LookupPlayer(row.mayor)
			if row.owner ~= &quot;0&quot; then 
				temp = LookupPlayer(row.mayor)
			else
				temp = &quot;&quot;
			end

			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Mayor: &quot; .. temp .. &quot;[-]&quot;)				
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Protected: &quot; .. dbYN(row.protected) .. &quot;[-]&quot;)				
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]PVP: &quot; .. dbYN(row.pvp) .. &quot;[-]&quot;)				
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Access Level: &quot; .. row.accessLevel .. &quot;[-]&quot;)				

			temp = LookupPlayer(row.owner)
			if row.owner ~= &quot;0&quot; then 
				temp = LookupPlayer(row.owner)
			else
				temp = &quot;&quot;
			end

			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Owner: &quot; .. temp .. &quot;[-]&quot;)				
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Coords: &quot; .. row.x .. &quot; &quot; .. row.y .. &quot; &quot; .. row.z .. &quot;[-]&quot;)				
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Size: &quot; .. row.size * 2 .. &quot;[-]&quot;)				
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug locations 25&quot;) end

	-- look for command in locations table
	loc = LookupLocation(gmsgvars.command)

	if (loc ~= nil) then
		if (players[gmsgvars.playerid].prisoner or not players[gmsgvars.playerid].canTeleport) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are not allowed to use teleports.[-]&quot;)
			faultyGMSG = false
			return true
		end

		if (players[gmsgvars.playerid].walkies) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have not opted in to using teleports. Type /enabletp to opt-in.[-]&quot;)
			faultyGMSG = false
			return true
		end

		cursor,errorString = conn:execute(&quot;SELECT * FROM locations WHERE name = '&quot; .. escape(loc) ..&quot;'&quot;)
		row = cursor:fetch({}, &quot;a&quot;)

		if (locations[loc].village == true) then
 			if villagers[gmsgvars.playerid .. loc] then
				if (players[gmsgvars.playerid].baseCooldown - os.time() &gt; 0) and (accessLevel(gmsgvars.playerid) &gt; 2 or server.ignoreAdmins == false) then --  and server.ignoreAdmins == false
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have to wait &quot; .. os.date(&quot;%M minutes %S seconds&quot;,players[gmsgvars.playerid].baseCooldown - os.time()) .. &quot; before you can use /base again.[-]&quot;)
					faultyGMSG = false
					return true
				else
					players[gmsgvars.playerid].baseCooldown = (os.time() + 2400) -- 2400 = 40 minutes

					players[gmsgvars.playerid].xPosOld = 0
					players[gmsgvars.playerid].yPosOld = 0
					players[gmsgvars.playerid].zPosOld = 0
					igplayers[gmsgvars.playerid].lastLocation = loc

					cursor,errorString = conn:execute(&quot;select * from locationSpawns where location='&quot; .. loc .. &quot;'&quot;)
					if cursor:numrows() &gt; 0 then
						randomPVPTP(gmsgvars.playerid, loc)
					else
						cmd = &quot;tele &quot; .. gmsgvars.playerid .. &quot; &quot; .. locations[loc].x .. &quot; &quot; .. locations[loc].y .. &quot; &quot; .. locations[loc].z
						teleport(cmd)
					end

					faultyGMSG = false
					return true
				end
			end
		end

		if (row.public == &quot;0&quot; and accessLevel(gmsgvars.playerid) &gt; 2) and row.owner ~= gmsgvars.playerid then --  and not LookupVillager(gmsgvars.playerid, loc)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. row.name .. &quot; is private[-]&quot;)
			faultyGMSG = false
			return true
		end

		if (row.active == &quot;0&quot; and accessLevel(gmsgvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. row.name .. &quot; is not enabled right now[-]&quot;)
			faultyGMSG = false
			return true
		end

		if (accessLevel(gmsgvars.playerid) &gt; tonumber(row.accessLevel)) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are not authorised to visit &quot; .. row.name .. &quot;.[-]&quot;)
			faultyGMSG = false
			return true
		end

		if tonumber(row.cost) &gt; 0 then
			if row.currency == &quot;zennies&quot; then
				if players[gmsgvars.playerid].cash &lt; tonumber(row.cost) then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You do not have enough zennies to travel there.[-]&quot;)
					faultyGMSG = false
					return true
				else
					-- collect payment
					players[gmsgvars.playerid].cash = players[gmsgvars.playerid].cash - tonumber(row.cost)
				end
			else
				if not inInventory(gmsgvars.playerid, row.currency, row.cost) then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You do not have enough of the required item to travel there.[-]&quot;)
					faultyGMSG = false
					return true
				end
			end
		end

		if igplayers[gmsgvars.playerid].lastLocation ~= loc and tonumber(gmsgvars.intY) &gt; -1 then
			savePosition(gmsgvars.playerid)
			igplayers[gmsgvars.playerid].lastLocation = loc
		end

		cursor,errorString = conn:execute(&quot;select * from locationSpawns where location='&quot; .. escape(loc) .. &quot;'&quot;)
		if cursor:numrows() &gt; 0 then
			randomPVPTP(gmsgvars.playerid, loc)
		else
			cmd = &quot;tele &quot; .. gmsgvars.playerid .. &quot; &quot; .. row.x .. &quot; &quot; .. row.y .. &quot; &quot; .. row.z
			prepareTeleport(gmsgvars.playerid, cmd)
			teleport(cmd)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug locations end&quot;) end

end

</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_resets</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
reset zones commands
====================
reset zones
add reset zone
delete reset zone
--]]

function gmsg_resets()
	calledFunction = &quot;gmsg_resets&quot;

	local region, x, z, debug

	debug = false

	-- don't proceed if there is no leading slash
	if (string.sub(gmsgvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyGMSG = false
		return false
	end


	-- ###################  do not allow remote commands beyond this point ################
	if (gmsgvars.playerid == nil) then
		faultyGMSG = false
		return false
	end
	-- ####################################################################################

if debug then dbug(&quot;debug resets 1&quot;) end

	if (gmsgvars.words[1] == &quot;add&quot; or gmsgvars.words[1] == &quot;remove&quot; or gmsgvars.words[1] == &quot;delete&quot;) and gmsgvars.words[2] == &quot;reset&quot; and (gmsgvars.words[3] == &quot;region&quot; or gmsgvars.words[3] == &quot;zone&quot;) then
		if (accessLevel(gmsgvars.playerid) &gt; 3) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		x = math.floor(igplayers[gmsgvars.playerid].xPos / 512)
		z = math.floor(igplayers[gmsgvars.playerid].zPos / 512)
		region = &quot;r.&quot; .. x .. &quot;.&quot; .. z .. &quot;.7rg&quot;

		if (gmsgvars.words[1] == &quot;add&quot;) then
			resetRegions[region] = {}
			conn:execute(&quot;INSERT INTO resetZones (region) VALUES ('&quot; .. region .. &quot;')&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Region &quot; .. region .. &quot; is now a reset zone.[-]&quot;)
		else
			resetRegions[region] = nil
			conn:execute(&quot;DELETE FROM resetZones WHERE region = '&quot; .. region .. &quot;')&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Region &quot; .. region .. &quot; is no longer a reset zone.[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug resets 2&quot;) end

	if gmsgvars.words[1] == &quot;reset&quot; and gmsgvars.words[2] == &quot;zones&quot; then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		cursor,errorString = conn:execute(&quot;select * from resetZones&quot;)
		if cursor:numrows() == 0 then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No regions have been flagged as reset zones.[-]&quot;)
		else
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The following regions are reset zones:[-]&quot;)

			row = cursor:fetch({}, &quot;a&quot;)
			while row do
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. row.region .. &quot;[-]&quot;)
				row = cursor:fetch(row, &quot;a&quot;)	
			end
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug resets end&quot;) end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_server</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
server commands
===============
wait
translate on
translate off
reboot
set prison size
set map size
set base cooldown
motd
set motd
reset server (wipes all info from bot and collects info from server)
reset bot (wipes most info but retains player data)
cancel reboot
pause reboot
unpause reboot
enable/disable reboot
set chat colour
say&lt;fr&gt;&lt;es&gt;&lt;de&gt; etc  eg sayfr
restore backup
set website
set irc server
set irc main/alerts/watch
set/clear max ping
set/clear welcome message
max zombies
max animals
max players
set server pvp/pve/creative/contest
--]]

function gmsg_server()
	calledFunction = &quot;gmsg_server&quot;

local debug, tmp

debug = false

if debug then dbug(&quot;debug server 0&quot;) end

	if (gmsgvars.playername ~= &quot;Server&quot;) then 
		if (string.find(gmsgvars.command, &quot;wait&quot;) and scheduledRestartForced == false and (server.scheduledRestartTimestamp - os.time() &lt; 61)) then
			scheduledRestartForced = true

			if rebootTimerID ~= nil and rebootTimerDelayID == nil then
				disableTimer(rebootTimerID)
				rebootTimerDelayID = tempTimer( 60, [[enableTimer(]] .. rebootTimerID .. [[)]] )
				message(&quot;say [&quot; .. server.chatColour .. &quot;]The scheduled reboot has been delayed for 2 minutes. Clear all forges, campfires and stop crafting![-]&quot;)
				rebootTimer = rebootTimer + 120
			end

			if server.scheduledRestart == true then
				server.scheduledRestartTimestamp = server.scheduledRestartTimestamp + 120
				message(&quot;say [&quot; .. server.chatColour .. &quot;]The scheduled reboot has been delayed for 2 minutes. Clear all forges, campfires and stop crafting![-]&quot;)
			end

			faultyGMSG = false
			return true
		end
	end

if debug then dbug(&quot;debug server 1&quot;) end

	if (gmsgvars.words[1] == &quot;translate&quot; and gmsgvars.words[2] == &quot;on&quot; and gmsgvars.words[3] ~= nil) then
		pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot; on &quot;) + 5)
		pname = string.trim(pname)
		id = LookupPlayer(pname)
		if not (id == nil) then
			players[id].translate = true
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Chat from player &quot; .. players[id].name ..  &quot; will be translated to English.[-]&quot;)

			conn:execute(&quot;UPDATE players SET translate = 1 WHERE steam = &quot; .. id)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug server 2&quot;) end

	if (gmsgvars.words[1] == &quot;translate&quot; and gmsgvars.words[2] == &quot;off&quot; and gmsgvars.words[3] ~= nil) then
		pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot; off &quot;) + 6)
		pname = string.trim(pname)
		id = LookupPlayer(pname)
		if not (id == nil) then
			players[id].translate = false
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Chat from player &quot; .. players[id].name ..  &quot; will no longer be translated.[-]&quot;)

			conn:execute(&quot;UPDATE players SET translate = 0 WHERE steam = &quot; .. id)
		end
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug server 3&quot;) end

	if (string.find(gmsgvars.words[1], &quot;say&quot;) and (string.len(gmsgvars.words[1]) == 5) and gmsgvars.words[2] ~= nil) then
		msg = string.sub(gmsgvars.command, string.len(gmsgvars.words[1]) + 2)
		msg = string.trim(msg)

		if (msg ~= &quot;&quot;) then
			Translate(gmsgvars.playerid, msg, string.sub(gmsgvars.words[1], 4), true)
		end
		faultyGMSG = false
		return true
	end

	-- ###################  Staff only beyond this point ################
	-- Don't proceed if this is a player.  Server and staff only here.
	if (gmsgvars.playername ~= &quot;Server&quot;) then 
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			faultyGMSG = false
			return false
		end
	end
	-- ##################################################################

if debug then dbug(&quot;debug server 4&quot;) end

	if (gmsgvars.words[1] == &quot;restore&quot; and gmsgvars.words[2] == &quot;backup&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		importLuaData()

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug server 5&quot;) end

	if (gmsgvars.words[1] == &quot;set&quot; and gmsgvars.words[2] == &quot;irc&quot; and gmsgvars.words[3] == &quot;server&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		tmp = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;server&quot;) + 7)
		tmp = string.trim(tmp)

		if tmp == nil then
			if (gmsgvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A server name is required.[-]&quot;)
			else
				message(&quot;say [&quot; .. server.chatColour .. &quot;]A server name is required.[-]&quot;)
			end
		else
			message(&quot;say [&quot; .. server.chatColour .. &quot;]We have an irc server at &quot; .. tmp .. &quot;. See you there! :3[-]&quot;)
			server.ircServer = tmp
			conn:execute(&quot;UPDATE server SET ircServer = '&quot; .. escape(tmp) .. &quot;'&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug server 6&quot;) end

	if (gmsgvars.words[1] == &quot;set&quot; and gmsgvars.words[2] == &quot;irc&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		pname = gmsgvars.words[4]

		if gmsgvars.words[3] == &quot;main&quot; then
			if (gmsgvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The main irc channel is now &quot; .. pname .. &quot;, alerts is &quot; ..  pname .. &quot;_alerts&quot; .. &quot;, and watch is &quot; ..  pname .. &quot;_watch&quot; .. &quot;.[-]&quot;)
			else
				message(&quot;say [&quot; .. server.chatColour .. &quot;]The main irc channel is now &quot; .. pname .. &quot;, alerts is &quot; ..  pname .. &quot;_alerts&quot; .. &quot;, and watch is &quot; ..  pname .. &quot;_watch&quot; .. &quot;.[-]&quot;)
			end

			server.ircMain = &quot;#&quot; .. pname
			server.ircAlerts = &quot;#&quot; .. pname .. &quot;_alerts&quot;
			server.ircWatch = &quot;#&quot; .. pname .. &quot;_watch&quot;
		end

		if gmsgvars.words[3] == &quot;alerts&quot; then
			if (gmsgvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The alerts irc channel is now &quot; .. pname .. &quot;.[-]&quot;)
			else
				message(&quot;say [&quot; .. server.chatColour .. &quot;]The alerts irc channel is now &quot; .. pname .. &quot;.[-]&quot;)
			end

			server.ircAlerts = &quot;#&quot; .. pname
		end

		if gmsgvars.words[3] == &quot;watch&quot; then
			if (gmsgvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The watch irc channel is now &quot; .. pname .. &quot;.[-]&quot;)
			else
				message(&quot;say [&quot; .. server.chatColour .. &quot;]The watch irc channel is now &quot; .. pname .. &quot;.[-]&quot;)
			end

			server.ircWatch = &quot;#&quot; .. pname
		end

		conn:execute(&quot;UPDATE server SET ircMain = '&quot; .. server.ircMain .. &quot;', ircAlerts = '&quot; .. server.ircAlerts .. &quot;', ircWatch = '&quot; .. server.ircWatch .. &quot;'&quot;)

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug server 7&quot;) end

	if (gmsgvars.words[1] == &quot;reboot&quot;) then
			if server.allowReboot == false then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is disabled for this server.  Reboot manually.[-]&quot;)
				faultyGMSG = false
				return true
			end

		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		if (server.scheduledRestart == true) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]A reboot is already scheduled.  Cancel it first.[-]&quot;)		
			faultyGMSG = false
			return true
		end

		restartDelay = string.match(gmsgvars.command, &quot;%d+&quot;)
		if (restartDelay == nil) then 
			restartDelay = 120 
			message(&quot;say [&quot; .. server.chatColour .. &quot;]A server reboot is happening in 2 minutes.[-]&quot;)			
		end

		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &lt; 2) then
				if (string.find(gmsgvars.command, &quot;forced&quot;)) then	
					scheduledRestartForced = true
				end
			end
		end

		if (string.find(gmsgvars.command, &quot;minute&quot;)) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]A server reboot is happening in &quot; .. restartDelay .. &quot; minutes.[-]&quot;)		
			restartDelay = restartDelay * 60
		end

		if (string.find(gmsgvars.command, &quot;hour&quot;)) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]A server reboot is happening in &quot; .. restartDelay .. &quot; hours time.[-]&quot;)		
			restartDelay = restartDelay * 60 * 60
		end

		scheduledRestartPaused = false
		server.scheduledRestart = true
		server.scheduledRestartTimestamp = os.time() + restartDelay
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug server 8&quot;) end

	-- don't proceed if there is no leading slash
	if (string.sub(gmsgvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyGMSG = false
		return false
	end

	if (gmsgvars.words[1] == &quot;set&quot; and gmsgvars.words[2] == &quot;prison&quot; and gmsgvars.words[3] == &quot;size&quot;) then
		if gmsgvars.number ~= nil then
			server.prisonSize = math.floor(tonumber(gmsgvars.number) / 2)

			if (gmsgvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The prison is now &quot; .. tonumber(gmsgvars.number) .. &quot; meters wide.[-]&quot;)
			else
				message(&quot;say [&quot; .. server.chatColour .. &quot;]The prison is now &quot; .. tonumber(gmsgvars.number) .. &quot; meters wide.[-]&quot;)
			end

			conn:execute(&quot;UPDATE server SET prisonSize = &quot; .. gmsgvars.number)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug server 9&quot;) end

	if (gmsgvars.words[1] == &quot;set&quot; and gmsgvars.words[2] == &quot;map&quot; and gmsgvars.words[3] == &quot;size&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		if gmsgvars.number ~= nil then
			server.mapSize = gmsgvars.number
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Players are now restricted to &quot; .. gmsgvars.number .. &quot; meters from 0,0[-]&quot;)

			conn:execute(&quot;UPDATE server SET mapSize = &quot; .. gmsgvars.number)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug server 10&quot;) end

	if (gmsgvars.words[1] == &quot;set&quot; and gmsgvars.words[2] == &quot;base&quot; and gmsgvars.words[3] == &quot;cooldown&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		if gmsgvars.number ~= nil then
			server.baseCooldown = gmsgvars.number
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Players must wait &quot; .. gmsgvars.number .. &quot; minutes after using /base before it becomes available again.[-]&quot;)
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Donors must wait &quot; .. math.floor(gmsgvars.number / 2) .. &quot; minutes.[-]&quot;)

			conn:execute(&quot;UPDATE server SET baseCooldown = &quot; .. gmsgvars.number)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug server 11&quot;) end

	if (gmsgvars.words[1] == &quot;motd&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		if gmsgvars.words[2] == nil then
			if server.MOTD == nil then
				if (gmsgvars.playername ~= &quot;Server&quot;) then 
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]There is no MOTD currently.[-]&quot;)
				else
					message(&quot;say [&quot; .. server.chatColour .. &quot;]There is no MOTD currently.[-]&quot;)
				end
			else
				if (gmsgvars.playername ~= &quot;Server&quot;) then 
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. server.MOTD .. &quot;[-]&quot;)			
				else
					message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. server.MOTD .. &quot;[-]&quot;)			
				end
			end
		else
			server.MOTD = string.sub(gmsgvars.oldLine, string.find(gmsgvars.oldLine, &quot;motd&quot;) + 5)
			message(&quot;say [&quot; .. server.chatColour .. &quot;]New message of the day recorded.[-]&quot;)			
			conn:execute(&quot;UPDATE server SET MOTD = '&quot; .. escape(server.MOTD) .. &quot;'&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug server 12&quot;) end

	if (gmsgvars.words[1] == &quot;cancel&quot; and gmsgvars.words[2] == &quot;reboot&quot; and gmsgvars.words[3] == nil) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if accessLevel(gmsgvars.playerid) &gt; 1 then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is for admins only[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (scheduledRestartForced == true) and (accessLevel(gmsgvars.playerid) &gt; 0) then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]A forced reboot is scheduled and will proceed as planned.[-]&quot;)	
				faultyGMSG = false
				return true
			end
		end

		scheduledReboot = false
		server.scheduledIdleRestart = false
		server.scheduledRestart = false
		server.scheduledRestartTimestamp = os.time()
		scheduledRestartPaused = nil
		scheduledRestartForced = nil

		if (rebootTimerID ~= nil) then killTimer(rebootTimerID) end
		if (rebootTimerDelayID ~= nil) then killTimer(rebootTimerDelayID) end

		rebootTimerID = nil
		rebootTimerDelayID = nil

		message(&quot;say [&quot; .. server.chatColour .. &quot;]A server reboot has been cancelled.[-]&quot;)	
		tempTimer( 2, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]OH! I guess we're not rebooting after all.[-]&quot;)]] )
		
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug server 13&quot;) end

	if (gmsgvars.words[1] == &quot;pause&quot; and gmsgvars.words[2] == &quot;reboot&quot; and gmsgvars.words[3] == nil) then
		if server.scheduledRestart == true and scheduledRestartPaused == false then
			scheduledRestartPaused = true
			restartTimeRemaining = server.scheduledRestartTimestamp - os.time()
			message(&quot;say [&quot; .. server.chatColour .. &quot;]The reboot has been paused.[-]&quot;)		
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug server 14&quot;) end

	if (gmsgvars.words[1] == &quot;unpause&quot; and gmsgvars.words[2] == &quot;reboot&quot; and gmsgvars.words[3] == nil) then
		if scheduledRestartPaused == true then
			server.scheduledRestartTimestamp = os.time() + restartTimeRemaining
			scheduledRestartPaused = false
			rebootTimer = restartTimeRemaining
			message(&quot;say [&quot; .. server.chatColour .. &quot;]The reboot countdown has resumed.[-]&quot;)		
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug server 15&quot;) end

	if (gmsgvars.words[1] == &quot;enable&quot; or gmsgvars.words[1] == &quot;disable&quot;) and gmsgvars.words[2] == &quot;reboot&quot; then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		if gmsgvars.words[1] == &quot;enable&quot; then
			server.allowReboot = true
			message(&quot;say [&quot; .. server.chatColour .. &quot;]The bot will automatically reboot the server as needed.[-]&quot;)
			conn:execute(&quot;UPDATE server SET allowReboot = true&quot;)
		else
			server.allowReboot = false
			message(&quot;say [&quot; .. server.chatColour .. &quot;]The bot will not reboot the server.[-]&quot;)
			conn:execute(&quot;UPDATE server SET allowReboot = false&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug server 16&quot;) end

	if (gmsgvars.words[1] == &quot;name&quot; and gmsgvars.words[2] == &quot;bot&quot; and gmsgvars.words[3] ~= nil) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		tmp = string.sub(gmsgvars.oldLine, string.find(gmsgvars.oldLine, gmsgvars.words[2]) + 4, string.len(gmsgvars.oldLine))
		if tmp == &quot;Tester&quot; and gmsgvars.playerid ~= Smegz0r then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]That name is reserved.[-]&quot;)
			faultyGMSG = false
			return true
		end

		server.botName = string.sub(gmsgvars.oldLine, string.find(gmsgvars.oldLine, gmsgvars.words[2]) + 4, string.len(gmsgvars.oldLine))
		message(&quot;say [&quot; .. server.chatColour .. &quot;]The bot shall henceforth be known as &quot; .. server.botName .. &quot;.[-]&quot;)

		msg = &quot;say [&quot; .. server.chatColour .. &quot;]Hello I am the server bot, &quot; .. server.botName .. &quot;. Pleased to meet you. :3[-]&quot;
		tempTimer( 5, [[message(msg)]] )

		conn:execute(&quot;UPDATE server SET botName = '&quot; .. escape(server.botName) .. &quot;'&quot;)

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug server 17&quot;) end

	if (gmsgvars.words[1] == &quot;set&quot; and gmsgvars.words[2] == &quot;chat&quot; and (gmsgvars.words[3] == &quot;colour&quot; or gmsgvars.words[3] == &quot;color&quot;)) then
		server.chatColour = gmsgvars.words[4]
		message(&quot;say [&quot; .. server.chatColour .. &quot;]You have changed the bot's chat colour.[-]&quot;)

		conn:execute(&quot;UPDATE server SET chatColour = '&quot; .. escape(server.chatColour) .. &quot;'&quot;)

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug server 18&quot;) end

	if (gmsgvars.words[1] == &quot;set&quot; and gmsgvars.words[2] == &quot;website&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		tmp = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;website&quot;) + 8)
		tmp = string.trim(tmp)

		if tmp == nil then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A website or group is required.[-]&quot;)
		else
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Our website/group is &quot; .. tmp .. &quot;. Check us out! :3[-]&quot;)
			server.website = tmp
			conn:execute(&quot;UPDATE server SET website = '&quot; .. escape(tmp) .. &quot;'&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug server 19&quot;) end

	if (gmsgvars.words[1] == &quot;set&quot; and gmsgvars.words[2] == &quot;server&quot; and gmsgvars.words[3] == &quot;ip&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		tmp = gmsgvars.words[4]

		if tmp == nil then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The server ip is required.[-]&quot;)
		else
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The server ip is &quot; .. tmp .. &quot;.[-]&quot;)
			server.IP = tmp
			conn:execute(&quot;UPDATE server SET IP = '&quot; .. escape(tmp) .. &quot;'&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug server 20&quot;) end

	if (gmsgvars.words[1] == &quot;set&quot; or gmsgvars.words[1] == &quot;clear&quot;) and gmsgvars.words[2] == &quot;max&quot; and gmsgvars.words[3] == &quot;ping&quot; then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		if gmsgvars.words[1] == &quot;clear&quot; then
			server.pingKick = -1
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Ping kicking is disabled.[-]&quot;)
			conn:execute(&quot;UPDATE server SET pingKick = -1&quot;)

			faultyGMSG = false
			return true
		end

		if gmsgvars.number ~= nil then
			if tonumber(gmsgvars.number) &gt; -1 and tonumber(gmsgvars.number) &lt; 100 then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. gmsgvars.number .. &quot; is quite low. Enter a number &gt; 99[-]&quot;)
			else
				server.pingKick = gmsgvars.number
				message(&quot;say [&quot; .. server.chatColour .. &quot;]New players with a ping above &quot; .. gmsgvars.number .. &quot; will be kicked from the server.[-]&quot;)
				conn:execute(&quot;UPDATE server SET pingKick = &quot; .. gmsgvars.number)
			end
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug server 21&quot;) end

	if (gmsgvars.words[1] == &quot;set&quot; or gmsgvars.words[1] == &quot;clear&quot;) and gmsgvars.words[2] == &quot;welcome&quot; and gmsgvars.words[3] == &quot;message&quot; then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		if gmsgvars.words[1] == &quot;clear&quot; then
			server.welcome = nil
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Server welcome message cleared.[-]&quot;)
			conn:execute(&quot;UPDATE server SET welcome = null&quot;)

			faultyGMSG = false
			return true
		end

		msg = string.sub(gmsgvars.oldLine, string.find(gmsgvars.oldLine, &quot;message&quot;) + 8)
		msg = string.trim(msg)

		server.welcome = msg
		message(&quot;say [&quot; .. server.chatColour .. &quot;]New welcome message &quot; .. msg .. &quot;[-]&quot;)
		conn:execute(&quot;UPDATE server SET welcome = '&quot; .. escape(msg) .. &quot;'&quot;)

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug server 22&quot;) end

	if (gmsgvars.words[1] == &quot;set&quot; or gmsgvars.words[1] == &quot;server&quot;) and gmsgvars.words[3] ~= nil then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		if gmsgvars.words[3] == &quot;pvp&quot; then
			server.gameType = &quot;pvp&quot;
			message(&quot;say [&quot; .. server.chatColour .. &quot;]This server is now PVP.[-]&quot;)
			conn:execute(&quot;UPDATE server SET gameType = 'pvp'&quot;)

			faultyGMSG = false
			return true
		end

		if gmsgvars.words[3] == &quot;pve&quot; then
			server.gameType = &quot;pve&quot;
			message(&quot;say [&quot; .. server.chatColour .. &quot;]This server is now PVE.[-]&quot;)
			conn:execute(&quot;UPDATE server SET gameType = 'pve'&quot;)

			faultyGMSG = false
			return true
		end

		if gmsgvars.words[3] == &quot;creative&quot; then
			server.gameType = &quot;cre&quot;
			message(&quot;say [&quot; .. server.chatColour .. &quot;]This server is now creative.[-]&quot;)
			conn:execute(&quot;UPDATE server SET gameType = 'cre'&quot;)

			faultyGMSG = false
			return true
		end

		if gmsgvars.words[3] == &quot;contest&quot; then
			server.gameType = &quot;con&quot;
			message(&quot;say [&quot; .. server.chatColour .. &quot;]This server is now in contest mode.[-]&quot;)
			conn:execute(&quot;UPDATE server SET gameType = 'con'&quot;)

			faultyGMSG = false
			return true
		end

	end

if debug then dbug(&quot;debug server 23&quot;) end

	if (gmsgvars.words[1] == &quot;disallow&quot; and gmsgvars.words[2] == &quot;bad&quot; and gmsgvars.words[3] == &quot;names&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The bot will kick players with names that have no letters.[-]&quot;)
		else
			irc_QueueMsg(server.ircMain, &quot;The bot will kick players with names that have no letters.&quot;)
		end

		server.allowNumericNames = false
		server.allowGarbageNames = false
		conn:execute(&quot;UPDATE server SET allowNumericNames = 0, allowGarbageNames = 0&quot;)

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug server 24&quot;) end

	if (gmsgvars.words[1] == &quot;allow&quot; and gmsgvars.words[2] == &quot;bad&quot; and gmsgvars.words[3] == &quot;names&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Players can call themselves anything they like.[-]&quot;)
		else
			irc_QueueMsg(server.ircMain, &quot;]Players can call themselves anything they like.&quot;)
		end

		server.allowNumericNames = true
		server.allowGarbageNames = true
		conn:execute(&quot;UPDATE server SET allowNumericNames = 1, allowGarbageNames = 1&quot;)

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug server 25&quot;) end

	-- ###################  do not allow remote commands beyond this point ################
	if (gmsgvars.playerid == nil) then
		faultyGMSG = false
		return false
	end
	-- ####################################################################################

	if (gmsgvars.words[1] == &quot;reset&quot;) and (gmsgvars.words[2] == &quot;server&quot;) then 
		if accessLevel(gmsgvars.playerid) &gt; 0 then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Are you sure you want to wipe the bot completely clean?  Answer yes to proceed or anything else to cancel.[-]&quot;)
		igplayers[gmsgvars.playerid].botQuestion = &quot;reset server&quot;

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug server 26&quot;) end

	if (gmsgvars.words[1] == &quot;reset&quot;) and (gmsgvars.words[2] == &quot;bot&quot;) then 
		if accessLevel(gmsgvars.playerid) &gt; 0 then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Are you sure you want to reset the bot?  Answer yes to proceed or anything else to cancel.[-]&quot;)
		igplayers[gmsgvars.playerid].botQuestion = &quot;reset bot&quot;

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug server 27&quot;) end

	if (gmsgvars.words[1] == &quot;no&quot;) and (gmsgvars.words[2] == &quot;reset&quot;) then 
		if accessLevel(gmsgvars.playerid) &gt; 0 then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Oh ok then.[-]&quot;)
		server.warnBotReset = false

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug server 28&quot;) end

	if gmsgvars.words[1] == &quot;max&quot; and (gmsgvars.words[2] == &quot;zeds&quot; or gmsgvars.words[2] == &quot;zombies&quot;) and gmsgvars.words[3] ~= nil then
		if (accessLevel(gmsgvars.playerid) &gt; 0) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		if gmsgvars.number ~= nil then
			gmsgvars.number = math.abs(math.floor(gmsgvars.number))

			if gmsgvars.number &gt; 150 then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. gmsgvars.number .. &quot; is too high. Set a lower limit.[-]&quot;)
				faultyGMSG = false
				return true
			end

			send(&quot;sg MaxSpawnedZombies &quot; .. gmsgvars.number)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Max spawned zombies is now &quot; .. gmsgvars.number .. &quot;[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug server 29&quot;) end

	if gmsgvars.words[1] == &quot;max&quot; and gmsgvars.words[2] == &quot;players&quot; and gmsgvars.words[3] ~= nil then
		if (accessLevel(gmsgvars.playerid) &gt; 0) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		if gmsgvars.number ~= nil then
			gmsgvars.number = math.abs(math.floor(gmsgvars.number))

			send(&quot;sg ServerMaxPlayerCount &quot; .. gmsgvars.number)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Max players is now &quot; .. gmsgvars.number .. &quot;[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug server 30&quot;) end

	if gmsgvars.words[1] == &quot;max&quot; and gmsgvars.words[2] == &quot;animals&quot; and gmsgvars.words[3] ~= nil then
		if (accessLevel(gmsgvars.playerid) &gt; 0) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		if gmsgvars.number ~= nil then
			gmsgvars.number = math.abs(math.floor(gmsgvars.number))

			if gmsgvars.number &gt; 150 then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. gmsgvars.number .. &quot; is too high. Set a lower limit.[-]&quot;)
				faultyGMSG = false
				return true
			end

			send(&quot;sg MaxSpawnedAnimals &quot; .. gmsgvars.number)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Max spawned animals is now &quot; .. gmsgvars.number .. &quot;[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug server end&quot;) end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_shop</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
shop commands
=============
shop
buy
cash
pay
zennies
bank
gamble
wallet
lottery
show cash
hide cash
--]]

function gmsg_shop()
	calledFunction = &quot;gmsg_shop&quot;

	-- don't proceed if there is no leading slash
	if (string.sub(gmsgvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyGMSG = false
		return false
	end


	-- ###################  do not allow remote commands beyond this point ################
	if (gmsgvars.playerid == nil) then
		faultyGMSG = false
		return false
	end
	-- ####################################################################################


	if (gmsgvars.words[1] == &quot;shop&quot;or gmsgvars.words[1] == &quot;buy&quot;) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) and (server.allowShop == false) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The shop is closed until further notice.[-]&quot;)
			faultyGMSG = false
			return true
		end

		faultyGMSG = doShop(gmsgvars.command, gmsgvars.playerid, gmsgvars.words)
		return true
	end


	if (gmsgvars.words[1] == &quot;cash&quot; or gmsgvars.words[1] == &quot;pay&quot; or gmsgvars.words[1] == &quot;zennies&quot; or gmsgvars.words[1] == &quot;bank&quot; or gmsgvars.words[1] == &quot;gamble&quot; or gmsgvars.words[1] == &quot;wallet&quot;) then
		faultyGMSG = doShop(gmsgvars.command, gmsgvars.playerid, gmsgvars.words)
		return true
	end


	if (gmsgvars.words[1] == &quot;zcoins&quot; or gmsgvars.words[1] == &quot;zgate&quot;) then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No zgates or zcoins here. We are using our own server bot :3[-]&quot;)
		faultyGMSG = false
		return true
	end


	if (gmsgvars.words[1] == &quot;lottery&quot; or gmsgvars.words[1] == &quot;lotto&quot; or gmsgvars.words[1] == &quot;tickets&quot;) then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The lottery prize pool has reached &quot; .. server.lottery .. &quot; zennies![-]&quot;)
		cursor,errorString = conn:execute(&quot;SELECT count(ticket) as tickets FROM lottery WHERE steam = &quot; .. gmsgvars.playerid)
		row = cursor:fetch({}, &quot;a&quot;)

		if tonumber(row.tickets) &gt; 0 then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have &quot; .. row.tickets .. &quot; tickets in the next draw![-]&quot;)
		end

		faultyGMSG = false
		return true
	end


	if (gmsgvars.words[1] == &quot;show&quot; and gmsgvars.words[2] == &quot;cash&quot;) then
		players[gmsgvars.playerid].watchCash = true
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You will see your zennies increase with each zombie kill.[-]&quot;)
		conn:execute(&quot;UPDATE players SET watchCash = 1 WHERE steam = &quot; .. gmsgvars.playerid)

		faultyGMSG = false
		return true
	end


	if (gmsgvars.words[1] == &quot;hide&quot; and gmsgvars.words[2] == &quot;cash&quot;) then
		players[gmsgvars.playerid].watchCash = nil
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Your zennies will not be reported with each zombie kill.[-]&quot;)
		conn:execute(&quot;UPDATE players SET watchCash = 0 WHERE steam = &quot; .. gmsgvars.playerid)

		faultyGMSG = false
		return true
	end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_teleports</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
teleport commands
=============
killtp
privatetp
publictp
activatetp
deactivatetp
onetp
twotp
enabletp
disabletp
fetch
pack
stuck
return
teleports
opentp
closetp
--]]

function gmsg_teleports()
	calledFunction = &quot;gmsg_teleports&quot;

	local debug

	debug = false

	-- don't proceed if there is no leading slash
	if (string.sub(gmsgvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyGMSG = false
		return false
	end


if debug then display (&quot;debug teleports 1\n&quot;) end
	if (gmsgvars.words[1] == &quot;killtp&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		tpname = &quot;&quot;
		tpname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;killtp &quot;) + 7)
		tpname = string.trim(tpname)

		if (tpname == &quot;&quot;) then 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A name is required for the teleport[-]&quot;)
			faultyGMSG = false
			return true
		else
			tp = &quot;&quot;
			tp = LookupTeleportByName(tpname)

			teleports[tp] = nil
		end

		conn:execute(&quot;DELETE FROM teleports WHERE name = '&quot; .. escape(tp) .. &quot;'&quot;)

		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have deleted a teleport called &quot; .. tpname .. &quot;[-]&quot;)
		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug teleports 2\n&quot;) end

	if (gmsgvars.words[1] == &quot;privatetp&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		tpname = &quot;&quot;
		tpname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;privatetp &quot;) + 10)
		tpname = string.trim(tpname)

		if (tpname == &quot;&quot;) then 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A name is required for the teleport[-]&quot;)
			faultyGMSG = false
			return true
		else
			tp = &quot;&quot;
			tp = LookupTeleportByName(tpname)

			teleports[tp].public = false
		end

		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You changed a teleport called &quot; .. tpname .. &quot; to private[-]&quot;)

		conn:execute(&quot;UPDATE teleports SET public = 0 WHERE name = '&quot; .. escape(tp) .. &quot;'&quot;)

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug teleports 3\n&quot;) end

	if (gmsgvars.words[1] == &quot;publictp&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		tpname = &quot;&quot;
		tpname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;publictp &quot;) + 9)
		tpname = string.trim(tpname)

		if (tpname == &quot;&quot;) then 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A name is required for the teleport[-]&quot;)
			faultyGMSG = false
			return true
		else
			tp = &quot;&quot;
			tp = LookupTeleportByName(tpname)

			teleports[tp].public = true
		end

		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You changed a teleport called &quot; .. tpname .. &quot; to public[-]&quot;)
		
		conn:execute(&quot;UPDATE teleports SET public = 1 WHERE name = '&quot; .. escape(tp) .. &quot;'&quot;)

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug teleports 4\n&quot;) end

	if (gmsgvars.words[1] == &quot;activatetp&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		tpname = &quot;&quot;
		tpname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;activatetp &quot;) + 11)
		tpname = string.trim(tpname)

		if (tpname == &quot;&quot;) then 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A name is required for the teleport[-]&quot;)
			faultyGMSG = false
			return true
		else
			tp = &quot;&quot;
			tp = LookupTeleportByName(tpname)

			teleports[tp].active = true
		end

		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You enabled a teleport called &quot; .. tpname .. &quot;[-]&quot;)
		
		conn:execute(&quot;UPDATE teleports SET active = 1 WHERE name = '&quot; .. escape(tp) .. &quot;'&quot;)

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug teleports 5\n&quot;) end

	if (gmsgvars.words[1] == &quot;deactivatetp&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (not admins[gmsgvars.playerid]) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is for admins only[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		tpname = &quot;&quot;
		tpname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;deactivatetp &quot;) + 13)
		tpname = string.trim(tpname)

		if (tpname == &quot;&quot;) then 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A name is required for the teleport[-]&quot;)
			faultyGMSG = false
			return true
		else
			tp = &quot;&quot;
			tp = LookupTeleportByName(tpname)

			teleports[tp].active = false
		end

		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You disabled a teleport called &quot; .. tpname .. &quot;[-]&quot;)
		
		conn:execute(&quot;UPDATE teleports SET active = 0 WHERE name = '&quot; .. escape(tp) .. &quot;'&quot;)

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug teleports 6\n&quot;) end

	if (gmsgvars.words[1] == &quot;onetp&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		tpname = string.trim(gmsgvars.words[2])

		tp = &quot;&quot;
		tp = LookupTeleportByName(tpname)

		if (tp ~= &quot;&quot;) then
			teleports[tp].oneway = true
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. teleports[tp].name .. &quot; is a one way teleport.[-]&quot;)
		end

		conn:execute(&quot;UPDATE teleports SET oneway = 1 WHERE name = '&quot; .. escape(tp) .. &quot;'&quot;)

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug teleports 7\n&quot;) end

	if (gmsgvars.words[1] == &quot;twotp&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		tpname = string.trim(gmsgvars.words[2])

		tp = &quot;&quot;
		tp = LookupTeleportByName(tpname)

		if (tp ~= &quot;&quot;) then
			teleports[tp].oneway = false
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. teleports[tp].name .. &quot; is a two way teleport.[-]&quot;)
		end

		conn:execute(&quot;UPDATE teleports SET oneway = 0 WHERE name = '&quot; .. escape(tp) .. &quot;'&quot;)

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug teleports 8\n&quot;) end

	if (gmsgvars.words[1] == &quot;owntp&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end
		
		id = LookupPlayer(gmsgvars.words[3]) 
		if (players[id]) then
			pname = players[id].name
		end

		tp = &quot;&quot;
		tp = LookupTeleportByName(gmsgvars.words[2])

		if (tp ~= &quot;&quot;) then
			teleports[tp].owner = id
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; is the proud new owner of a teleport called &quot; .. teleports[tp].name .. &quot;[-]&quot;)
		end

		conn:execute(&quot;UPDATE teleports SET owner = &quot; .. id .. &quot; WHERE name = '&quot; .. escape(tp) .. &quot;'&quot;)

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug teleports 9\n&quot;) end

	-- ###################  do not allow remote commands beyond this point ################
	if (gmsgvars.playerid == nil) then
		faultyGMSG = false
		return false
	end
	-- ####################################################################################


	if (gmsgvars.words[1] == &quot;enabletp&quot;) then
		id = gmsgvars.playerid	
		pname = igplayers[gmsgvars.playerid].name
		
		if (admins[gmsgvars.playerid] and gmsgvars.words[2] ~= nil) then
			id = LookupPlayer(string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;enabletp&quot;) + 9))
			if (id == nil) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No matching player found.[-]&quot;)
				faultyGMSG = false
				return true		
			else
				players[id].walkies = false
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Player &quot; .. players[id].name .. &quot; can now use teleports[-]&quot;)

				conn:execute(&quot;UPDATE players SET walkies = 0 WHERE steam = &quot; .. id)

				faultyGMSG = false
				return true
			end
		end

		players[id].walkies = false
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]you can use teleports and admins can teleport you[-]&quot;)
		conn:execute(&quot;UPDATE players SET walkies = 0 WHERE steam = &quot; .. id)

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug teleports 10\n&quot;) end

	if (gmsgvars.words[1] == &quot;disabletp&quot;) then
		id = gmsgvars.playerid	
		pname = igplayers[gmsgvars.playerid].name

		players[id].walkies = true

		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]you cannot use teleports and admins can't teleport you (some exceptions)[-]&quot;)
		conn:execute(&quot;UPDATE players SET walkies = 1 WHERE steam = &quot; .. id)

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug teleports 10A\n&quot;) end

	if (gmsgvars.words[1] == &quot;fetch&quot;) then
		if (gmsgvars.words[1] == &quot;fetch&quot;) then
			pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;fetch &quot;) + 6)
		end
		
		if (accessLevel(gmsgvars.playerid) &gt; 2) and players[gmsgvars.playerid].tokens &lt;= 0 then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A P2P Token is required. Purchase one from the shop in soyspecials.[-]&quot;)
			faultyGMSG = false
			return true					
		end

		pname = string.trim(pname)
		id = LookupPlayer(pname)
		
		if id == nil then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No player found matching &quot; .. pname .. &quot;[-]&quot;)
			faultyGMSG = false
			return true		
		end

		if not igplayers[id] then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Player &quot; .. players[id].name .. &quot; is not playing right now.[-]&quot;)
			faultyGMSG = false
			return true		
		end

		if (accessLevel(id) &lt; 3) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Staff cannot be fetched.[-]&quot;)
			faultyGMSG = false
			return true
		end
		
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			-- reject if not a friend
			if (not isFriend(id,  gmsgvars.playerid)) and (accessLevel(gmsgvars.playerid) &gt; 2) and (id ~= gmsgvars.playerid) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Only friends of &quot; .. players[id].name .. &quot; and staff can do this.&quot;)

				faultyGMSG = false
				result = true
				return
			end
		end

		if players[id].xPosOld == nil then
			-- first record their current x y z
			savePosition(id)
		end
		
		-- then teleport the player to you
		cmd = &quot;tele &quot; .. id .. &quot; &quot; .. gmsgvars.intX + 1 .. &quot; &quot; .. gmsgvars.intY .. &quot; &quot; .. gmsgvars.intZ
		prepareTeleport(gmsgvars.playerid, cmd)
		teleport(cmd, true)

		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			players[gmsgvars.playerid].tokens = players[gmsgvars.playerid].tokens - 1		
		end
		
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; is being teleported to your location now.&quot;)			
		message(&quot;pm &quot; .. id .. &quot; [&quot; .. server.chatColour .. &quot;]You are being teleported to &quot; .. players[gmsgvars.playerid].name .. &quot;'s location.&quot;)					
		
		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug teleports 11\n&quot;) end

	if gmsgvars.words[1] == &quot;pack&quot; and gmsgvars.words[2] == nil then 
		if players[gmsgvars.playerid].deathX ~= 0 then
			if players[gmsgvars.playerid].lastCommand ~= gmsgvars.command then
				if tonumber(players[gmsgvars.playerid].cash) &lt; 50 then
					if tonumber(igplayers[steam].sessionPlaytime) + tonumber(players[steam].timeOnServer) &gt; 3600 then
						message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command costs 50 zennies.  Start saving and don't die.[-]&quot;)
						faultyGMSG = false
						return true
					end
				end
			end

			cursor,errorString = conn:execute(&quot;SELECT x, y, z FROM tracker WHERE steam = &quot; .. gmsgvars.playerid .. &quot; and ((abs(x - &quot; .. players[gmsgvars.playerid].deathX .. &quot;) &gt; 5 and abs(x - &quot; .. players[gmsgvars.playerid].deathX .. &quot;) &lt; 50) and (abs(z - &quot; .. players[gmsgvars.playerid].deathZ .. &quot;) &gt; 5 and abs(z - &quot; .. players[gmsgvars.playerid].deathZ .. &quot;) &lt; 50))  ORDER BY trackerid DESC Limit 0, 1&quot;)
			if cursor:numrows() &gt; 0 then
				row = cursor:fetch({}, &quot;a&quot;)	
				cmd = (&quot;tele &quot; .. gmsgvars.playerid .. &quot; &quot; .. row.x .. &quot; &quot; .. row.y .. &quot; &quot; .. row.z)

				-- first record their current x y z
				savePosition(gmsgvars.playerid)

				prepareTeleport(gmsgvars.playerid, cmd)
				teleport(cmd, true)

				if (accessLevel(gmsgvars.playerid) &gt; 2) and players[gmsgvars.playerid].lastCommand ~= gmsgvars.command then
					if tonumber(igplayers[steam].sessionPlaytime) + tonumber(players[steam].timeOnServer) &gt; 3600 then
						message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]50 zennies have been deducted from your cash.  You now have &quot; .. tonumber(players[gmsgvars.playerid].cash) - 100 .. &quot; zennies.[-]&quot;)
						players[gmsgvars.playerid].cash = tonumber(players[gmsgvars.playerid].cash) - 50
					end
				end
			else
				if tonumber(igplayers[steam].sessionPlaytime) + tonumber(players[steam].timeOnServer) &gt; 3600 then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Sorry I am unable to find a spot close to your pack to send you there.  No charge.[-]&quot;)
				else
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Sorry I am unable to find a spot close to your pack to send you there.[-]&quot;)
				end
			end

		end

		faultyGMSG = false
		return true
	end


	if gmsgvars.words[1] == &quot;stuck&quot; and gmsgvars.words[2] == nil then 
		if (tonumber(gmsgvars.intY) &gt; 0 and tonumber(gmsgvars.intY) &lt; 256) and (players[gmsgvars.playerid].lastCommand ~= gmsgvars.command)  then
			-- bump the players position up 1 meter y + 1
			send(&quot;tele &quot; .. gmsgvars.playerid .. &quot; &quot; .. math.floor(igplayers[gmsgvars.playerid].xPos) .. &quot; &quot; .. math.ceil(igplayers[gmsgvars.playerid].yPos) + 1 .. &quot; &quot; .. math.floor(igplayers[gmsgvars.playerid].zPos))
		else
			cursor,errorString = conn:execute(&quot;SELECT x, y, z FROM tracker WHERE steam = &quot; .. gmsgvars.playerid .. &quot; AND ((abs(x - &quot; .. gmsgvars.intX .. &quot;) &gt; 2 and abs(x - &quot; .. gmsgvars.intX .. &quot;) &lt; 30) and (abs(z - &quot; .. gmsgvars.intZ .. &quot;) &gt; 2 and abs(z - &quot; .. gmsgvars.intZ .. &quot;) &lt; 30))  ORDER BY trackerid DESC Limit 0, 1&quot;)
			if cursor:numrows() &gt; 0 then
				row = cursor:fetch({}, &quot;a&quot;)	
				send(&quot;tele &quot; .. gmsgvars.playerid .. &quot; &quot; .. row.x .. &quot; &quot; .. row.y + 1 .. &quot; &quot; .. row.z)
			else
				-- bump the players position up 1 meter y + 1
				send(&quot;tele &quot; .. gmsgvars.playerid .. &quot; &quot; .. math.floor(igplayers[gmsgvars.playerid].xPos) .. &quot; &quot; .. math.ceil(igplayers[gmsgvars.playerid].yPos) + 1 .. &quot; &quot; .. math.floor(igplayers[gmsgvars.playerid].zPos))
			end
		end

		faultyGMSG = false
		return true
	end


if debug then display (&quot;debug teleports 12\n&quot;) end

	if (gmsgvars.words[1] == &quot;return&quot;) and gmsgvars.words[2] == nil then 
		-- return to previously recorded x y z
		if (players[gmsgvars.playerid].yPosOld ~= 0) then

			cmd = &quot;tele &quot; .. gmsgvars.playerid .. &quot; &quot; .. players[gmsgvars.playerid].xPosOld .. &quot; &quot; .. players[gmsgvars.playerid].yPosOld .. &quot; &quot; .. players[gmsgvars.playerid].zPosOld
			prepareTeleport(gmsgvars.playerid, cmd)
			teleport(cmd)

			if players[gmsgvars.playerid].yPos &lt; 1000 then
				players[gmsgvars.playerid].xPosOld = 0
				players[gmsgvars.playerid].yPosOld = 0
				players[gmsgvars.playerid].zPosOld = 0
				igplayers[gmsgvars.playerid].lastLocation = &quot;&quot;
			end
		else
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have already used your return.[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug teleports 13\n&quot;) end

	if (gmsgvars.words[1] == &quot;teleports&quot; and gmsgvars.words[3] == nil) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		id = nil
		if (gmsgvars.words[2]) then
			pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;teleports &quot;) + 10)
			pname = string.trim(pname)
			if (pname ~= nil) then id = LookupPlayer(pname) end
		end

		for k, v in pairs(teleports) do
			if (v.public == true) then
				public = &quot;public&quot;
			else
				public = &quot;private&quot;
			end

			if (id == nil) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot; &quot; .. public .. &quot;[-]&quot;)
			else
				if (v.owner == id) then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot; &quot; .. public .. &quot;[-]&quot;)
				end
			end
		end

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug teleports 14\n&quot;) end

	if (gmsgvars.words[1] == &quot;tp&quot;) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		teleName = &quot;&quot;
		teleName = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;tp &quot;) + 3)
		teleName = string.trim(teleName)

		if (teleName == &quot;&quot;) then 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A name is required for the /tp command[-]&quot;)
			faultyGMSG = false
			return true
		else
			tp = &quot;&quot;
			tp = LookupTeleportByName(teleName)

			-- first record their current x y z
			savePosition(gmsgvars.playerid)

			cmd = &quot;tele &quot; .. gmsgvars.playerid .. &quot; &quot; .. math.floor(teleports[tp].x) .. &quot; &quot; .. math.ceil(teleports[tp].y) .. &quot; &quot; .. math.floor(teleports[tp].z)
			prepareTeleport(gmsgvars.playerid, cmd)
			teleport(cmd, true)
		end

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug teleports 15\n&quot;) end

	if (gmsgvars.words[1] == &quot;opentp&quot;) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		teleName = &quot;&quot;
		teleName = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;opentp &quot;) + 7)
		teleName = string.trim(teleName)

		if (teleName == &quot;&quot;) then 
			message(&quot;pm &quot; .. gmsgvars.playername .. &quot; [&quot; .. server.chatColour .. &quot;]A name is required for the teleport[-]&quot;)
			faultyGMSG = false
			return true
		else	
			tp = &quot;&quot;
			tp = LookupTeleportByName(teleName)
			action = &quot;moved&quot;

			if (tp == nil) then
				teleports[teleName] = {}
				action = &quot;created&quot;
				teleports[teleName].public = false
				teleports[teleName].active = false
				teleports[teleName].friends = false
				teleports[teleName].name = teleName
				teleports[teleName].owner = igplayers[gmsgvars.playerid].steam
				teleports[teleName].oneway = false
		   end

			teleports[teleName].x = gmsgvars.intX
			teleports[teleName].y = gmsgvars.intY
			teleports[teleName].z = gmsgvars.intZ
		end

		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have &quot; .. action .. &quot; a teleport called &quot; .. teleName .. &quot;[-]&quot;)

		conn:execute(&quot;INSERT INTO teleports (name, owner, x, y, z) VALUES ('&quot; .. teleName .. &quot;',&quot; .. gmsgvars.playerid .. &quot;,&quot; .. gmsgvars.intX .. &quot;,&quot; .. gmsgvars.intY .. &quot;,&quot; .. gmsgvars.intZ .. &quot;) ON DUPLICATE KEY UPDATE x = &quot; .. gmsgvars.intX .. &quot;, y = &quot; .. gmsgvars.intY .. &quot;, z = &quot; ..gmsgvars.intZ)

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug teleports 16\n&quot;) end

	if (gmsgvars.words[1] == &quot;closetp&quot;) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true								
		end

		teleName = &quot;&quot;
		teleName = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;closetp &quot;) + 8)
		teleName = string.trim(teleName)

		if (teleName == &quot;&quot;) then 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A name is required for the teleport[-]&quot;)
			faultyGMSG = false
			return true
		else
			tp = &quot;&quot;
			tp = LookupTeleportByName(teleName)

			if (teleports[tp].owner == igplayers[gmsgvars.playerid].steam) and (teleports[tp].name == teleName) then
				teleports[tp].dx = gmsgvars.intX
				teleports[tp].dy = gmsgvars.intY
				teleports[tp].dz = gmsgvars.intZ

				if (teleports[tp].x ~= nil) then teleports[tp].active = true end
			end
		end

		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have activated a teleport called &quot; .. teleName .. &quot;[-]&quot;)

		conn:execute(&quot;UPDATE teleports SET dx = &quot; .. teleports[tp].dx .. &quot;, dy = &quot; .. teleports[tp].dy .. &quot;, dz = &quot; .. teleports[tp].dz .. &quot; WHERE name = '&quot; .. escape(tp) .. &quot;'&quot;)

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug teleports end\n&quot;) end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_villages</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
village commands
================
/elect
/add member
/remove member
/add village
/remove village
/village size
/villagers
/protect village
--]]

function gmsg_villages()
	calledFunction = &quot;gmsg_villages&quot;

	local debug

	debug = false

	-- don't proceed if there is no leading slash
	if (string.sub(gmsgvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyGMSG = false
		return false
	end

if debug then display (&quot;debug villages 1\n&quot;) end

	if (gmsgvars.words[1] == &quot;elect&quot; and gmsgvars.words[2] ~= nil) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false				return true
			end
		end

		if (string.find(gmsgvars.command, &quot;village&quot;)) then
			name1 = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;elect&quot;) + 6, string.find(gmsgvars.command, &quot;village&quot;) - 1)
			name1 = string.trim(name1)
			pid = LookupPlayer(name1)
			
			villageName = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;village&quot;) + 8)
			villageName = string.trim(villageName)		

			vid = LookupLocation(villageName)
			if vid == nil then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]There is no village called &quot; .. villageName .. &quot;[-]&quot;)
				faultyGMSG = false
				return true
			end
			
			if (pid ~= nil) then
				if locations[villageName] ~= nil then
					locations[villageName].mayor = pid
					message(&quot;say [&quot; .. server.chatColour .. &quot;]Congratulations &quot; .. players[pid].name .. &quot; on becoming the new mayor of &quot; .. villageName .. &quot;[-]&quot;)								

					conn:execute(&quot;UPDATE locations SET mayor = &quot; .. pid .. &quot; WHERE name = '&quot; .. escape(villageName) .. &quot;'&quot;)
					conn:execute(&quot;INSERT INTO villagers SET steam = &quot; .. pid .. &quot;, village = '&quot; .. escape(villageName) .. &quot;'&quot;)

					villagers[pid .. vid] = {}
					villagers[pid .. vid].village = villageName
				end
			end
		end

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug villages 2\n&quot;) end

	if (gmsgvars.words[1] == &quot;add&quot; and gmsgvars.words[2] == &quot;member&quot;) then
		if (string.find(gmsgvars.command, &quot;village&quot;)) then
			name1 = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;member&quot;) + 7, string.find(gmsgvars.command, &quot;village&quot;) - 1)
			name1 = string.trim(name1)

			pid = LookupPlayer(name1)

			villageName = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;village&quot;) + 8)
			villageName = string.trim(villageName)		

			if (gmsgvars.playername ~= &quot;Server&quot;) then 
				if (accessLevel(gmsgvars.playerid) &gt; 2) and (locations[villageName].mayor ~= gmsgvars.playerid) then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
					faultyGMSG = false
					return true
				end
			end

			vid = LookupLocation(villageName)
			if vid == nil then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]There is no village called &quot; .. villageName .. &quot;[-]&quot;)
				faultyGMSG = false
				return true
			end

			if locations[vid].village ~= true then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. villageName .. &quot; is not a village.[-]&quot;)
				faultyGMSG = false
				return true
			end
			
			if (pid ~= nil) then
				conn:execute(&quot;INSERT INTO villagers SET steam = &quot; .. pid .. &quot;, village = '&quot; .. escape(villageName) .. &quot;'&quot;)

				villagers[pid .. vid] = {}
				villagers[pid .. vid].village = villageName

				message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[pid].name .. &quot; is now a member of &quot; .. villageName .. &quot; village.[-]&quot;)								
			end
		end

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug villages 3\n&quot;) end

	if (gmsgvars.words[1] == &quot;remove&quot; and gmsgvars.words[2] == &quot;village&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		villageName = string.trim(string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;village &quot;) + 8))

		vid = LookupLocation(villageName)
		if vid == nil then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]There is no village called &quot; .. villageName .. &quot;[-]&quot;)
			faultyGMSG = false
			return true
		end

		locations[vid] = nil

		conn:execute(&quot;DELETE FROM villagers WHERE village = '&quot; .. escape(vid) .. &quot;'&quot;)
		conn:execute(&quot;DELETE FROM locations WHERE name = '&quot; .. escape(vid) .. &quot;'&quot;)

		for k, v in pairs(villagers) do
			if (v.villageName == vid) then
				k = nil
			end
		end

		message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. gmsgvars.playername .. &quot; has removed a village portal called &quot; .. vid .. &quot;[-]&quot;)
		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug villages 4\n&quot;) end

	if (gmsgvars.words[1] == &quot;village&quot;) then
		if (gmsgvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(gmsgvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyGMSG = false
				return true
			end
		end

		villageName = string.trim(string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;village &quot;) + 8, string.find(gmsgvars.command, &quot;size&quot;) - 1))

		vid = LookupLocation(villageName)
		if vid == nil then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]There is no village called &quot; .. villageName .. &quot;[-]&quot;)
			faultyGMSG = false
			return true
		end

		baseprotection = tonumber(string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;size &quot;) + 5))
		if (baseprotection == nil) then
			baseprotection = 50
		end

		if (locations[vid]) then
			locations[vid].size = baseprotection
			locations[vid].protect = false
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. gmsgvars.playername .. &quot; has set village protection to &quot; .. baseprotection .. &quot; meters for village &quot; .. vid .. &quot;[-]&quot;)
			conn:execute(&quot;UPDATE locations SET size = &quot; .. baseprotection .. &quot;, protect=0 WHERE name = '&quot; .. escape(vid) .. &quot;'&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug villages 5\n&quot;) end

	if (gmsgvars.words[1] == &quot;remove&quot; and gmsgvars.words[2] == &quot;member&quot;) then
		if (string.find(gmsgvars.command, &quot;village&quot;)) then
			name1 = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;member&quot;) + 7, string.find(gmsgvars.command, &quot;village&quot;) - 1)
			name1 = string.trim(name1)
			pid = LookupPlayer(name1)
			
			villageName = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;village&quot;) + 8)
			villageName = string.trim(villageName)		
			
			if (gmsgvars.playername ~= &quot;Server&quot;) then 
				if (accessLevel(gmsgvars.playerid) &gt; 2) and (locations[villageName].mayor ~= gmsgvars.playerid) then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
					faultyGMSG = false
					return true
				end
			end

			vid = LookupLocation(villageName)
			if vid == nil then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]There is no village called &quot; .. villageName .. &quot;[-]&quot;)
				faultyGMSG = false
				return true
			end
			
			if (pid ~= nil) then
				conn:execute(&quot;DELETE FROM villagers WHERE village = '&quot; .. escape(vid) .. &quot;' and steam = &quot; .. pid)
				villagers[pid .. vid] = nil
				message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[pid].name .. &quot; has been cast out of village &quot; .. vid .. &quot;[-]&quot;)			
			end
		end

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug villages 6\n&quot;) end

	if (gmsgvars.words[1] == &quot;villages&quot; and gmsgvars.words[2] == nil) then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]List of villages:[-]&quot;)

		for k, v in pairs(locations) do
			if (v.village == true) then
				pid = nil

				if v.mayor ~= nil then
					pid = LookupOfflinePlayer(v.mayor)
				end

				if pid ~= nil then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot; the Mayor is &quot; .. players[pid].name .. &quot;[-]&quot;)
				else
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot;[-]&quot;)
				end		
			end
		end

		faultyGMSG = false
		return true
	end


	if (gmsgvars.words[1] == &quot;villagers&quot;) then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]List of villagers:[-]&quot;)

		villageName = nil
		if (gmsgvars.words[2] ~= nil) then
			villageName = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;villagers &quot;) + 10)
		end

		if villageName ~= nil then
			villageName = string.trim(villageName)
			cursor1,errorString = conn:execute(&quot;SELECT * FROM locations WHERE name = '&quot; .. escape(villageName) ..&quot;' and village = 1&quot;)
		else
			cursor1,errorString = conn:execute(&quot;SELECT * FROM locations WHERE village = 1&quot;)
		end

		row1 = cursor1:fetch({}, &quot;a&quot;)
		while row1 do
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The village of &quot; .. row1.name .. &quot;[-]&quot;)

			cursor2,errorString = conn:execute(&quot;SELECT * FROM villagers WHERE village = '&quot; .. escape(row1.name) ..&quot;'&quot;)
			row2 = cursor2:fetch({}, &quot;a&quot;)
			while row2 do
				if row1.mayor == row2.steam then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[row2.steam].name .. &quot;  (The Mayor)[-]&quot;)
				else
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[row2.steam].name .. &quot;[-]&quot;)
				end
				row2 = cursor2:fetch(row2, &quot;a&quot;)	
			end

			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;][-]&quot;)

			row1 = cursor1:fetch(row1, &quot;a&quot;)	
		end

		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;][-]&quot;)

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug villages 7\n&quot;) end

	-- ###################  do not allow remote commands beyond this point ################
	if (gmsgvars.playerid == nil) then
		faultyGMSG = false
		return false
	end
	-- ####################################################################################


	if (gmsgvars.words[1] == &quot;add&quot; and gmsgvars.words[2] == &quot;village&quot;) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		villageName = string.trim(string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;village &quot;) + 8))

		if not locations[villageName] then
			locations[villageName] = {}
			locations[villageName].name = villageName
			locations[villageName].owner = gmsgvars.playerid
			locations[villageName].x = gmsgvars.intX
			locations[villageName].y = gmsgvars.intY
			locations[villageName].z = gmsgvars.intZ
			locations[villageName].size = server.baseSize
			locations[villageName].active = true
			locations[villageName].public = false
			locations[villageName].village = true
			locations[villageName].mayor = 0
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. gmsgvars.playername .. &quot; has created a village portal called &quot; .. villageName .. &quot;[-]&quot;)
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. villageName .. &quot; needs villagers and a mayor.[-]&quot;)				

			conn:execute(&quot;INSERT INTO locations (name, owner, x, y, z, village, size) VALUES ('&quot; .. escape(villageName) .. &quot;',&quot; .. gmsgvars.playerid .. &quot;,&quot; .. gmsgvars.intX .. &quot;,&quot; .. gmsgvars.intY .. &quot;,&quot; .. gmsgvars.intZ .. &quot;,1,&quot; .. server.baseSize .. &quot;) ON DUPLICATE KEY UPDATE x = &quot; .. gmsgvars.intZ .. &quot;, y = &quot; .. gmsgvars.intY .. &quot;, z = &quot; .. gmsgvars.intZ .. &quot;, village=1, size=&quot; .. server.baseSize)
		else
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. villageName .. &quot; already exists.[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug villages 8\n&quot;) end

	if (gmsgvars.words[1] == &quot;protect&quot; and (gmsgvars.words[2] == &quot;village&quot;) and gmsgvars.words[3] ~= nil) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		if (gmsgvars.words[2] ~= nil) then
			pname = string.sub(gmsgvars.oldLine, string.find(gmsgvars.oldLine, &quot;village&quot;) + 8)
			pname = string.trim(pname)
		else
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You need to tell me the name of the village you are protecting.[-]&quot;)	
		end

		dist = distance(igplayers[gmsgvars.playerid].xPos, igplayers[gmsgvars.playerid].zPos, locations[pname].x, locations[pname].z)

		if (dist &lt;  tonumber(locations[pname].size) + 1) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are too close to the village, but just walk away and I will set it when you are far enough.[-]&quot;)
			igplayers[gmsgvars.playerid].alertLocationExit = pname
			faultyGMSG = false
			return true
		end

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug villages end\n&quot;) end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_waypoints</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
waypoint commands
=================
open waypoint
close waypoint
set waypoint
clear waypoint
waypoints
--]]

function gmsg_waypoints()
	calledFunction = &quot;gmsg_waypoints&quot;

	local debug

	debug = false

	-- don't proceed if there is no leading slash
	if (string.sub(gmsgvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyGMSG = false
		return false
	end


	-- ###################  do not allow remote commands beyond this point ################
	if (gmsgvars.playerid == nil) then
		faultyGMSG = false
		return false
	end
	-- ####################################################################################

if debug then display (&quot;debug waypoints 1\n&quot;) end

	if gmsgvars.words[1] == &quot;open&quot; and (gmsgvars.words[2] == &quot;waypoint&quot; or gmsgvars.words[2] == &quot;wp&quot;) then
		if(accessLevel(gmsgvars.playerid) &gt; 10) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Only donors and admins can have waypoints.[-]&quot;)
			faultyGMSG = false
			return true		
		end

		-- set the players waypoint coords
		players[gmsgvars.playerid].shareWaypoint = true
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Your friends can now teleport to your waypoint by typing just &quot; .. players[gmsgvars.playerid].name .. &quot; or part of it.[-]&quot;)	

		conn:execute(&quot;UPDATE players SET shareWaypoint = 1 WHERE steam = &quot; .. gmsgvars.playerid)

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug waypoints 2\n&quot;) end

	if gmsgvars.words[1] == &quot;close&quot; and (gmsgvars.words[2] == &quot;waypoint&quot; or gmsgvars.words[2] == &quot;wp&quot;) then
		if (accessLevel(gmsgvars.playerid) &gt; 10) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Only donors and admins can have waypoints.[-]&quot;)
			faultyGMSG = false
			return true		
		end

		-- set the players waypoint coords
		players[gmsgvars.playerid].shareWaypoint = false
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Only you can teleport to your waypoint.[-]&quot;)	

		conn:execute(&quot;UPDATE players SET shareWaypoint = 0 WHERE steam = &quot; .. gmsgvars.playerid)

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug waypoints 3\n&quot;) end

	if gmsgvars.words[1] == &quot;set&quot; and (gmsgvars.words[2] == &quot;waypoint&quot; or gmsgvars.words[2] == &quot;wp&quot;) then
		if (accessLevel(gmsgvars.playerid) &gt; 10) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Only donors and admins can have waypoints.[-]&quot;)
			faultyGMSG = false
			return true		
		end

		-- set the players waypoint coords
		players[gmsgvars.playerid].waypointX = gmsgvars.intX
		players[gmsgvars.playerid].waypointY = gmsgvars.intY
		players[gmsgvars.playerid].waypointZ = gmsgvars.intZ	
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have set a waypoint.  You can tp to it with /waypoint.[-]&quot;)	

		conn:execute(&quot;UPDATE players SET waypointX = &quot; .. gmsgvars.intX .. &quot;, waypointY = &quot; .. gmsgvars.intY .. &quot;, waypointZ = &quot; .. gmsgvars.intZ .. &quot; WHERE steam = &quot; .. gmsgvars.playerid)

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug waypoints 4\n&quot;) end

	if (gmsgvars.words[1] == &quot;clear&quot; or gmsgvars.words[1] == &quot;delete&quot; or gmsgvars.words[1] == &quot;kill&quot;) and gmsgvars.words[2] == &quot;waypoint&quot; then
		if (accessLevel(gmsgvars.playerid) &gt; 10) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Only donors and admins can have waypoints.[-]&quot;)
			faultyGMSG = false
			return true		
		end

		-- set the players waypoint coords
		players[gmsgvars.playerid].waypointX = nil
		players[gmsgvars.playerid].waypointY = nil
		players[gmsgvars.playerid].waypointZ = nil
		players[gmsgvars.playerid].shareWaypoint = false
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Your waypoint has been cleared.[-]&quot;)	

		conn:execute(&quot;UPDATE players SET waypointX = 0, waypointY = 0, waypointZ = 0 WHERE steam = &quot; .. gmsgvars.playerid)

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug waypoints 5\n&quot;) end

	if (gmsgvars.words[1] == &quot;waypoint&quot; or gmsgvars.words[1] == &quot;wp&quot; and gmsgvars.words[2] == nil) then
		if (accessLevel(gmsgvars.playerid) &gt; 10) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Only donors and admins can have waypoints.[-]&quot;)
			faultyGMSG = false
			return true		
		end
		
		-- store the current coords
		players[gmsgvars.playerid].xPosOld = gmsgvars.intX
		players[gmsgvars.playerid].yPosOld = gmsgvars.intY
		players[gmsgvars.playerid].zPosOld = gmsgvars.intZ

		-- tp the player to their waypointwaypoint
		cmd = &quot;tele &quot; .. gmsgvars.playerid .. &quot; &quot; .. players[gmsgvars.playerid].waypointX .. &quot; &quot; .. players[gmsgvars.playerid].waypointY .. &quot; &quot; .. players[gmsgvars.playerid].waypointZ
		teleport(cmd, true)

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug waypoints 6\n&quot;) end

	if (gmsgvars.words[1] == &quot;waypoints&quot;) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		if (gmsgvars.words[2] == nil) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A player name or id is required.[-]&quot;)
			faultyGMSG = false
			return true
		end

		id = nil
		if (gmsgvars.words[2]) then
			pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;waypoints &quot;) + 10)
			pname = string.trim(pname)
			if (pname ~= nil) then id = LookupPlayer(pname) end
			
			if (id ~= nil) then
				if (players[id].waypointX) then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; &quot; .. players[id].waypointX .. &quot; &quot; .. players[id].waypointY .. &quot; &quot; .. players[id].waypointZ .. &quot;[-]&quot;)
				else
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; Doesn't have a waypoint set.[-]&quot;)			
				end		
				
				faultyGMSG = false
				return true			
			else
				faultyGMSG = false
				return true			
			end
		end

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug waypoints end\n&quot;) end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_unslashed</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
unslashed commands
=============


--]]

function gmsg_unslashed()
	calledFunction = &quot;gmsg_unslashed&quot;

	local debug

	debug = false

if debug then dbug(&quot;debug unslashed&quot;) end

	-- ###################  do not allow remote commands beyond this point ################
	if (gmsgvars.playerid == nil) then
		faultyGMSG = false
		return false
	end
	-- ####################################################################################


	-- ###################  do not allow the bot to respond to itself ################
	if string.sub(gmsgvars.command, 1, 1) ~= &quot;/&quot; and gmsgvars.playername == &quot;Server&quot; then
		faultyGMSG = false
		return true
	end
	-- ####################################################################################


	-- #################  do not proceed if the line starts with a slash  #################
	if (string.sub(gmsgvars.command, 1, 1) == &quot;/&quot;) then
		-- line starts with a slash so stop processing it.
		faultyGMSG = false
		return false
	end
	-- ####################################################################################

if debug then dbug(&quot;debug unslashed 0&quot;) end

	if igplayers[gmsgvars.playerid].botQuestion == &quot;pay player&quot; then
		if (string.find(gmsgvars.command, &quot;yes&quot;)) then
			if (players[gmsgvars.playerid].cash &gt;= igplayers[gmsgvars.playerid].botQuestionValue) or accessLevel(gmsgvars.playerid) == 0 then
				players[igplayers[gmsgvars.playerid].botQuestionID].cash = players[igplayers[gmsgvars.playerid].botQuestionID].cash + igplayers[gmsgvars.playerid].botQuestionValue

			if accessLevel(gmsgvars.playerid) &gt; 0 then
					players[gmsgvars.playerid].cash = players[gmsgvars.playerid].cash - igplayers[gmsgvars.playerid].botQuestionValue
				end

				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. igplayers[gmsgvars.playerid].botQuestionValue .. &quot; has been paid to &quot; .. players[igplayers[gmsgvars.playerid].botQuestionID].name .. &quot;[-]&quot;)

				if (igplayers[igplayers[gmsgvars.playerid].botQuestionID]) then
					message(&quot;pm &quot; .. igplayers[gmsgvars.playerid].botQuestionID .. &quot; [&quot; .. server.chatColour .. &quot;]Payday! &quot; .. players[gmsgvars.playerid].name .. &quot; has paid you &quot; .. igplayers[gmsgvars.playerid].botQuestionValue .. &quot; zennies![-]&quot;)
				end
			else
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]I regret to inform you that you do not have sufficient funds to pay &quot; .. players[igplayers[gmsgvars.playerid].botQuestionID].name .. &quot;[-]&quot;)
			end
		end

		igplayers[gmsgvars.playerid].botQuestion = &quot;&quot;
		igplayers[gmsgvars.playerid].botQuestionID = nil
		igplayers[gmsgvars.playerid].botQuestionValue = nil
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug unslashed 1&quot;) end

	if (gmsgvars.playername ~= &quot;Server&quot;) then
		if igplayers[gmsgvars.playerid].botQuestion == &quot;reset server&quot; and gmsgvars.words[1] == &quot;yes&quot; and accessLevel(gmsgvars.playerid) == 0 then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Deleting all bot data and restarting it..[-]&quot;)
			ResetServer()

			igplayers[gmsgvars.playerid].botQuestion = &quot;&quot;
			igplayers[gmsgvars.playerid].botQuestionID = nil
			igplayers[gmsgvars.playerid].botQuestionValue = nil
			faultyGMSG = false
			return true
		end
	end


	if (gmsgvars.playername ~= &quot;Server&quot;) then
		if igplayers[gmsgvars.playerid].botQuestion == &quot;reset bot&quot; and gmsgvars.words[1] == &quot;yes&quot; and accessLevel(gmsgvars.playerid) == 0 then
			ResetBot()
			message(&quot;say [&quot; .. server.chatColour .. &quot;]The bot has been reset.  All bases, inventories etc are forgotten, but not the players.[-]&quot;)

			igplayers[gmsgvars.playerid].botQuestion = &quot;&quot;
			igplayers[gmsgvars.playerid].botQuestionID = nil
			igplayers[gmsgvars.playerid].botQuestionValue = nil
			faultyGMSG = false
			return true
		end
	end

	if (string.find(gmsgvars.command, &quot;build&quot;) and string.find(gmsgvars.command, &quot;reset&quot;)) then
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Reset zones are deleted and regenerate with random POIs and prefabs.  Anything you build there will be lost.  Resets are done manually.[-]&quot;)
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug unslashed 2&quot;) end

	if (string.find(gmsgvars.command, &quot;wait&quot;) and scheduledRestartForced == false and (server.scheduledRestartTimestamp - os.time() &lt; 61)) then
		scheduledRestartForced = true

		if rebootTimerID ~= nil and rebootTimerDelayID == nil then
			disableTimer(rebootTimerID)
			rebootTimerDelayID = tempTimer( 60, [[enableTimer(]] .. rebootTimerID .. [[)]] )
			message(&quot;say [&quot; .. server.chatColour .. &quot;]The scheduled reboot has been delayed for 2 minutes. Clear all forges, campfires and stop crafting![-]&quot;)
			rebootTimer = rebootTimer + 120
		end

		if server.scheduledRestart == true then
			server.scheduledRestartTimestamp = server.scheduledRestartTimestamp + 120
			message(&quot;say [&quot; .. server.chatColour .. &quot;]The scheduled reboot has been delayed for 2 minutes. Clear all forges, campfires and stop crafting![-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug unslashed 3&quot;) end

	if (string.find(gmsgvars.command, &quot;when&quot;) and string.find(gmsgvars.command, &quot;feral&quot;)) then
		if (gameDay % 7 == 0) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Feral hordes will run tonight![-]&quot;)
			faultyGMSG = false
			return true
		end

		if ((gameDay + 1) % 7 == 0) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Feral hordes are expected tomorrow[-]&quot;)
			faultyGMSG = false
			return true
		end

		if ((gameDay + 2) % 7 == 0) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Feral hordes are expected in 2 days[-]&quot;)
			faultyGMSG = false
			return true
		end

		if ((gameDay + 3) % 7 == 0) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Feral hordes are expected in 3 days[-]&quot;)
			faultyGMSG = false
			return true
		end

		if ((gameDay + 4) % 7 == 0) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Feral hordes are expected in 4 days[-]&quot;)
			faultyGMSG = false
			return true
		end

		if ((gameDay + 5) % 7 == 0) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Feral hordes are expected in 5 days[-]&quot;)
			faultyGMSG = false
			return true
		end

		if ((gameDay + 6) % 7 == 0) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Feral hordes are expected in 6 days[-]&quot;)
			faultyGMSG = false
			return true
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug unslashed 4&quot;) end

	if (gmsgvars.words[2] == &quot;server&quot; or gmsgvars.words[2] == &quot;bot&quot; or gmsgvars.words[2] == string.lower(server.botName)) and (gmsgvars.words[3] == nil) and (gmsgvars.playername ~= &quot;Server&quot;) then
		if (gmsgvars.words[1] == &quot;thanks&quot; or gmsgvars.words[1] == &quot;ty&quot; or string.find(gmsgvars.words[1], &quot;thx&quot;)) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]You're welcome &quot; .. gmsgvars.playername .. &quot; &lt;3[-]&quot;)
		else
			r = rand(18)

			if r &lt; 6 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. gmsgvars.words[1]:gsub(&quot;^%l&quot;, string.upper)  .. &quot; &quot; .. gmsgvars.playername .. &quot;[-]&quot;)
				faultyGMSG = false
				return true
			end

			if string.find(gmsgvars.words[1], &quot;love&quot;) then
				l = rand(5)
				if l == 1 then message(&quot;say [&quot; .. server.chatColour .. &quot;]I know.[-]&quot;) end
				if l == 2 then message(&quot;say [&quot; .. server.chatColour .. &quot;]Thanks =D.[-]&quot;) end
				if l == 3 then message(&quot;say [&quot; .. server.chatColour .. &quot;]I love you too :3[-]&quot;) end
				if l == 4 then message(&quot;say [&quot; .. server.chatColour .. &quot;]PDA!  PDA![-]&quot;) end
				if l == 5 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. gmsgvars.words[1]:gsub(&quot;^%l&quot;, string.upper)  .. &quot; &quot; .. gmsgvars.playername .. &quot;[-]&quot;) end

				faultyGMSG = false
				return true
			end

			if string.find(gmsgvars.words[1], &quot;pretty&quot;) then
				l = rand(4)
				if l == 1 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. gmsgvars.words[1]:gsub(&quot;^%l&quot;, string.upper)  .. &quot; &quot; .. gmsgvars.playername .. &quot;[-]&quot;) end
				if l == 2 then message(&quot;say [&quot; .. server.chatColour .. &quot;]I know.[-]&quot;) end
				if l == 3 then message(&quot;say [&quot; .. server.chatColour .. &quot;]Thanks :&gt;[-]&quot;) end
				if l == 4 then message(&quot;say [&quot; .. server.chatColour .. &quot;]O.o[-]&quot;) end

				faultyGMSG = false
				return true
			end

			if string.find(gmsgvars.words[1], &quot;cool&quot;) or string.find(gmsgvars.words[1], &quot;great&quot;)then
				l = rand(3)
				if l == 1 then message(&quot;say [&quot; .. server.chatColour .. &quot;]Thanks &quot; .. gmsgvars.playername .. &quot;![-]&quot;) end
				if l == 2 then message(&quot;say [&quot; .. server.chatColour .. &quot;]Indeed.[-]&quot;) end
				if l == 3 then message(&quot;say [&quot; .. server.chatColour .. &quot;]I know.[-]&quot;) end

				faultyGMSG = false
				return true
			end

			if r == 6 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]Yo no hablo inglés[-]&quot;)
			end

			if r == 7 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]You again?[-]&quot;)
			end

			if r == 8 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]*sigh*  Next![-]&quot;)
			end

			if r == 9 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]I DIDN'T DO IT!  YOU CAN'T PROVE A THING![-]&quot;)
			end

			if r == 10 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]OH HEY![-]&quot;)
			end

			if r == 11 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]No lollygagging[-]&quot;)
			end

			if r == 12 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]No comment[-]&quot;)
			end

			if r == 13 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]OH HAI![-]&quot;)
			end

			if r == 14 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]Oh rly!?[-]&quot;)
			end

			if r == 15 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]I'm sorry, &quot; .. server.botName .. &quot; is not in right now.  Please leave a message after the beep.   BEEP[-]&quot;)
			end

			if r == 16 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]¿Hablas español?[-]&quot;)
			end

			if r == 17 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]o.O[-]&quot;)
			end

			if r == 18 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]O.o[-]&quot;)
			end
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug unslashed 5&quot;) end

	if players[gmsgvars.playerid].newPlayer == true and (string.find(gmsgvars.command, &quot;where&quot;) or (string.find(gmsgvars.command, &quot;any&quot;))) and (string.find(gmsgvars.command, &quot;zed&quot;) or string.find(gmsgvars.command, &quot;zom&quot;)) then
		r = rand(7)
		if (r == 2) then r = 3 end
		if (r == 5) then r = 6 end

		send(&quot;se &quot; .. igplayers[gmsgvars.playerid].id .. &quot; &quot; .. r)

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug unslashed 6&quot;) end

	if (string.find(gmsgvars.command, &quot;server&quot;)) and (string.find(gmsgvars.command, &quot;suck&quot;) or string.find(gmsgvars.command, &quot;stupid&quot;) or string.find(gmsgvars.command, &quot;gay&quot;)) then
		r = rand(4)
		if (r == 1) then message(&quot;say [&quot; .. server.chatColour .. &quot;]Look who's talking :P[-]&quot;) end
		if (r == 2) then message(&quot;say [&quot; .. server.chatColour .. &quot;]Just ragequit! :)[-]&quot;) end
		if (r == 3) then message(&quot;say [&quot; .. server.chatColour .. &quot;]This is not the server you are looking for.  Move along.  Move along.[-]&quot;) end
		if (r == 4) then message(&quot;say [&quot; .. server.chatColour .. &quot;]Let me guess, did someone steal your sweet roll?[-]&quot;) end
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug unslashed end&quot;) end

end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_tracker</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
tracker commands
=============


--]]

function gmsg_tracker()
	calledFunction = &quot;gmsg_tracker&quot;

	local debug

	debug = false

	-- don't proceed if there is no leading slash
	if (string.sub(gmsgvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyGMSG = false
		return false
	end


	-- ###################  do not allow remote commands beyond this point ################
	if (gmsgvars.playerid == nil) then
		faultyGMSG = false
		return false
	end
	-- ####################################################################################

	-- ###################  Staff only beyond this point ################
	-- Don't proceed if this is a player.  Server and staff only here.
	if (gmsgvars.playername ~= &quot;Server&quot;) then 
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			faultyGMSG = false
			return false
		end
	end
	-- ##################################################################

if debug then display (&quot;debug tracker 1\n&quot;) end

	if (gmsgvars.words[1] == &quot;skip&quot; and gmsgvars.number ~= nil) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			faultyGMSG = false
			return true
		end

		igplayers[gmsgvars.playerid].trackerSkip = gmsgvars.number

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug tracker 2\n&quot;) end

	if (gmsgvars.words[1] == &quot;speed&quot; and gmsgvars.number ~= nil) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			faultyGMSG = false
			return true
		end

		igplayers[gmsgvars.playerid].trackerSpeed = gmsgvars.number

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug tracker 3\n&quot;) end

	if (gmsgvars.words[1] == &quot;forward&quot; or gmsgvars.words[1] == &quot;advance&quot; and gmsgvars.number ~= nil) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			faultyGMSG = false
			return true
		end

		igplayers[gmsgvars.playerid].trackerCount = igplayers[gmsgvars.playerid].trackerCount + gmsgvars.number
		igplayers[gmsgvars.playerid].trackerStopped = false
		igplayers[gmsgvars.playerid].trackerStop = true

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug tracker 4\n&quot;) end

	if (gmsgvars.words[1] == &quot;back&quot; and gmsgvars.number ~= nil) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			faultyGMSG = false
			return true
		end

		igplayers[gmsgvars.playerid].trackerCount = igplayers[gmsgvars.playerid].trackerCount - gmsgvars.number
		igplayers[gmsgvars.playerid].trackerStopped = false
		igplayers[gmsgvars.playerid].trackerStop = true

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug tracker 5\n&quot;) end

	if (gmsgvars.words[1] == &quot;goto&quot; and gmsgvars.words[2] == &quot;start&quot;) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			faultyGMSG = false
			return true
		end

		igplayers[gmsgvars.playerid].trackerReversed = false
		igplayers[gmsgvars.playerid].trackerCount = 0

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug tracker 6\n&quot;) end

	if (gmsgvars.words[1] == &quot;goto&quot; and gmsgvars.words[2] == &quot;end&quot;) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			faultyGMSG = false
			return true
		end

		igplayers[gmsgvars.playerid].trackerReversed = true
		igplayers[gmsgvars.playerid].trackerCount = 1000000000

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug tracker 7\n&quot;) end

	if (gmsgvars.words[1] == &quot;go&quot; and gmsgvars.words[2] == &quot;back&quot;) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			faultyGMSG = false
			return true
		end

		if 	igplayers[gmsgvars.playerid].trackerReversed == true then
			igplayers[gmsgvars.playerid].trackerReversed = false
		else
			igplayers[gmsgvars.playerid].trackerReversed = true
		end

		igplayers[gmsgvars.playerid].trackerStopped = false

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug tracker 8\n&quot;) end

	if (gmsgvars.words[1] == &quot;stop&quot; and gmsgvars.words[2] == nil) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			faultyGMSG = false
			return true
		end

		r = rand(100)
		if r == 99 then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]HAMMER TIME![-]&quot;)
		end

		igplayers[gmsgvars.playerid].trackerStopped = true
		igplayers[gmsgvars.playerid].following = nil
		igplayers[gmsgvars.playerid].location = nil
		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug tracker 9\n&quot;) end

	if (gmsgvars.words[1] == &quot;go&quot; and gmsgvars.words[2] == nil) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			faultyGMSG = false
			return true
		end

		igplayers[gmsgvars.playerid].trackerStopped = false
		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug tracker 10\n&quot;) end

	if (gmsgvars.words[1] == &quot;stop&quot; and gmsgvars.words[2] == &quot;tracking&quot;) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			faultyGMSG = false
			return true
		end

		igplayers[gmsgvars.playerid].trackerStopped = true
		conn:execute(&quot;DELETE FROM memTracker WHERE admin = &quot; .. gmsgvars.playerid)
		igplayers[gmsgvars.playerid].trackerCount = nil

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug tracker 11\n&quot;) end

	if (gmsgvars.words[1] == &quot;track&quot;) or (gmsgvars.words[1] == &quot;next&quot;) or (gmsgvars.words[1] == &quot;last&quot;) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		conn:execute(&quot;DELETE FROM memTracker WHERE admin = &quot; .. gmsgvars.playerid)

		igplayers[gmsgvars.playerid].trackerStopped = false
		igplayers[gmsgvars.playerid].trackerReversed = false

		if igplayers[gmsgvars.playerid].trackerSpeed == nil then
			igplayers[gmsgvars.playerid].trackerSpeed = 3
		end

		if igplayers[gmsgvars.playerid].trackerSkip == nil then
			igplayers[gmsgvars.playerid].trackerSkip = 1
		end

		if (gmsgvars.words[1] ~= &quot;next&quot;) and (gmsgvars.words[1] ~= &quot;last&quot;) then
			igplayers[gmsgvars.playerid].trackerCountdown = igplayers[gmsgvars.playerid].trackerSpeed
			igplayers[gmsgvars.playerid].trackerCount = 0
			igplayers[gmsgvars.playerid].trackerSteam = 0
			igplayers[gmsgvars.playerid].trackerSession = 0
			id = nil
		
			if string.find(gmsgvars.command, &quot;session&quot;) then
				pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;track&quot;) + 6, string.find(gmsgvars.command, &quot;session&quot;) - 1)
				pname = string.trim(pname)
				id = LookupPlayer(pname)
				igplayers[gmsgvars.playerid].trackerSession = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;session&quot;) + 8)

				if id ~= nil then
					igplayers[gmsgvars.playerid].trackerSteam = id
				end
			else
				pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;track &quot;) + 6)
				pname = string.trim(pname)
				id = LookupPlayer(pname)

				if id ~= nil then
					igplayers[gmsgvars.playerid].trackerSession = players[id].sessionCount
					igplayers[gmsgvars.playerid].trackerSteam = id
				end
			end
		else
			id = igplayers[gmsgvars.playerid].trackerSteam

			if (gmsgvars.words[1] == &quot;next&quot;) then
				igplayers[gmsgvars.playerid].trackerSession = igplayers[gmsgvars.playerid].trackerSession + 1
				igplayers[gmsgvars.playerid].trackerCount = 0
				igplayers[gmsgvars.playerid].trackerReversed = false
			end

			if (gmsgvars.words[1] == &quot;last&quot;) then
				igplayers[gmsgvars.playerid].trackerSession = igplayers[gmsgvars.playerid].trackerSession - 1
				igplayers[gmsgvars.playerid].trackerCount = 1000000000
				igplayers[gmsgvars.playerid].trackerReversed = true
			end
		end

		if id ~= nil then
			conn:execute(&quot;INSERT into memTracker (SELECT trackerID, &quot; .. gmsgvars.playerid .. &quot; AS admin, steam, timestamp, x, y, z, SESSION , flag from tracker where steam = &quot; .. id .. &quot; and session = &quot; .. igplayers[gmsgvars.playerid].trackerSession .. &quot;)&quot;)					
		else
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No player called &quot; .. pname .. &quot; found.[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug tracker end\n&quot;) end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_mail</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
mail commands
=============


--]]

function gmsg_mail()
	calledFunction = &quot;gmsg_mail&quot;

	local counter, status, debug

	debug = false

if debug then dbug(&quot;debug mail&quot;) end

	-- ###################  do not allow remote commands beyond this point ################
	if (gmsgvars.playerid == nil) then
		faultyGMSG = false
		return false
	end
	-- ####################################################################################


	-- ####################################################################################
	-- don't proceed if there is no leading slash or pm
	if (string.sub(gmsgvars.command, 1, 1) ~= &quot;/&quot;) and (not string.find(gmsgvars.oldLine, &quot; command 'pm&quot;)) then
		faultyGMSG = false
		return false
	end
	-- ####################################################################################

if debug then dbug(&quot;debug mail 1&quot;) end

	if (gmsgvars.words[1] == &quot;read&quot; and gmsgvars.words[2] == &quot;mail&quot;) then
		counter = 1

		if gmsgvars.number ~= nil then
			cursor,errorString = conn:execute(&quot;SELECT * FROM mail WHERE recipient = &quot; .. gmsgvars.playerid)
		else
			cursor,errorString = conn:execute(&quot;SELECT * FROM mail WHERE recipient = &quot; .. gmsgvars.playerid .. &quot; and status = 0&quot;)
		end

		row = cursor:fetch({}, &quot;a&quot;)
		while row do
			if gmsgvars.number ~= nil then
				if tonumber(gmsgvars.number) == counter then
					conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (&quot; .. row.sender .. &quot;,&quot; .. row.recipient .. &quot;,'&quot; .. escape(row.message) .. &quot;')&quot;)
					conn:execute(&quot;UPDATE mail set status = 1 WHERE id = &quot; .. row.id)
				end
			else
				conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (&quot; .. row.sender .. &quot;,&quot; .. row.recipient .. &quot;,'&quot; .. escape(row.message) .. &quot;')&quot;)
				conn:execute(&quot;UPDATE mail set status = 1 WHERE id = &quot; .. row.id)
			end

			counter = counter + 1
			row = cursor:fetch(row, &quot;a&quot;)	
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug mail 2&quot;) end

	if (gmsgvars.words[1] == &quot;list&quot; and gmsgvars.words[2] == &quot;mail&quot;) then
		counter = 1

		cursor,errorString = conn:execute(&quot;SELECT * FROM mail WHERE recipient = &quot; .. gmsgvars.playerid)
		row = cursor:fetch({}, &quot;a&quot;)
		while row do
			if row.status == &quot;0&quot; then status = &quot; [NEW]&quot; end
			if row.status == &quot;1&quot; then status = &quot; [READ]&quot; end
			if row.status == &quot;2&quot; then status = &quot; [SAVED]&quot; end

			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;](&quot; .. counter .. &quot;)  Message from &quot; .. players[row.sender].name .. status .. &quot; &quot; .. string.sub(row.message, 1, 12) .. &quot;..[-]&quot;)

			counter = counter + 1
			row = cursor:fetch(row, &quot;a&quot;)	
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug mail 3&quot;) end

	if (gmsgvars.words[1] == &quot;save&quot; and gmsgvars.words[2] == &quot;mail&quot; and gmsgvars.number ~= nil) then
		counter = 1

		cursor,errorString = conn:execute(&quot;SELECT * FROM mail WHERE recipient = &quot; .. gmsgvars.playerid)
		row = cursor:fetch({}, &quot;a&quot;)
		while row do
			if tonumber(gmsgvars.number) == counter then
				conn:execute(&quot;UPDATE mail SET status = 2 WHERE id = &quot; .. row.id)
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Message (&quot; .. counter .. &quot;) saved.[-]&quot;)

				faultyGMSG = false
				return true
			end
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug mail 4&quot;) end

	if (gmsgvars.words[1] == &quot;delete&quot; and gmsgvars.words[2] == &quot;mail&quot; and gmsgvars.number ~= nil) then
		counter = 1

		cursor,errorString = conn:execute(&quot;SELECT * FROM mail WHERE recipient = &quot; .. gmsgvars.playerid)
		row = cursor:fetch({}, &quot;a&quot;)
		while row do
			if tonumber(gmsgvars.number) == counter then
				conn:execute(&quot;DELETE FROM mail WHERE id = &quot; .. row.id)
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Message (&quot; .. counter .. &quot;) deleted.[-]&quot;)

				faultyGMSG = false
				return true
			end

			counter = counter + 1
			row = cursor:fetch(row, &quot;a&quot;)	
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug mail 5&quot;) end

	-- ####################################################################################
	-- don't proceed if not using the console
	if not string.find(gmsgvars.oldLine, &quot; command 'pm&quot;) then
		faultyGMSG = false
		return false
	end
	-- ####################################################################################

if debug then dbug(&quot;debug mail 6&quot;) end

	if (string.find(gmsgvars.words[1], &quot;@&quot;) and gmsgvars.words[2] ~= nil) then
		pname = string.sub(gmsgvars.words[1], 2, string.len(gmsgvars.words[1]) - 1)
		pname = string.trim(pname)

		id = LookupPlayer(pname)
		msg = string.sub(gmsgvars.oldLine, string.find(gmsgvars.oldLine, gmsgvars.words[1]) + string.len(gmsgvars.words[1]))

if debug then dbug(&quot;debug mail msg&quot; .. msg) end

		if string.lower(pname) == &quot;admin&quot; then
			for k,v in pairs(players) do
				if accessLevel(k) &lt; 3 then
					if igplayers[k] then
						message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]Message from &quot; .. players[gmsgvars.playerid].name .. &quot;: &quot; .. msg .. &quot;[-]&quot;)
					else
						conn:execute(&quot;INSERT INTO mail (sender, recipient, message) VALUES (&quot; .. gmsgvars.playerid .. &quot;,&quot; .. k .. &quot;, '&quot; .. escape(msg) .. &quot;')&quot;)
					end
				end
			end

			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Thank you. An admin will receive your message soon.[-]&quot;)

			faultyGMSG = false
			return true
		end

		if id ~= nil then
			if isFriend(id, gmsgvars.playerid) or accessLevel(gmsgvars.playerid) &lt; 3 then
				if igplayers[id] then
					message(&quot;pm &quot; .. id .. &quot; [&quot; .. server.chatColour .. &quot;]Message from &quot; .. players[gmsgvars.playerid].name .. &quot;: &quot; .. msg .. &quot;[-]&quot;)
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; has received your message.[-]&quot;)
				else
					conn:execute(&quot;INSERT INTO mail (sender, recipient, message) VALUES (&quot; .. gmsgvars.playerid .. &quot;,&quot; .. id .. &quot;, '&quot; .. escape(msg) .. &quot;')&quot;)
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; will receive your message when they return.[-]&quot;)
				end
			else
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; has not friended you so you are not allowed to send them private messages yet.[-]&quot;)
			end
		else
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]I do not know a player called &quot; .. pname .. &quot;[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug mail end&quot;) end

end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_friends</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
friend commands
=============


--]]

function gmsg_friends()
	calledFunction = &quot;gmsg_friends&quot;

	local pid, pname, debug

	debug = false

	-- don't proceed if there is no leading slash
	if (string.sub(gmsgvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyGMSG = false
		return false
	end


	-- ###################  do not allow remote commands beyond this point ################
	if (gmsgvars.playerid == nil) then
		faultyGMSG = false
		return false
	end
	-- ####################################################################################

if debug then display (&quot;debug friends 1\n&quot;) end

	if (gmsgvars.words[1] == &quot;friend&quot;) then
		pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;friend &quot;) + 7)
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if (id == gmsgvars.playerid) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]I know you are lonely but you're supposed to make friends with OTHER people.[-]&quot;)
			faultyGMSG = false
			return true
		end

		-- add to friends table
		if (friends[gmsgvars.playerid].friends == nil) then
			friends[gmsgvars.playerid] = {}
			friends[gmsgvars.playerid].friends = &quot;&quot;
		end

		if (id ~= nil) then
			if (not string.find(friends[gmsgvars.playerid].friends, players[id].steam)) then
				friends[gmsgvars.playerid].friends = friends[gmsgvars.playerid].friends .. players[id].steam .. &quot;,&quot;
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; is now recognised as a friend[-]&quot;)	
				conn:execute(&quot;INSERT INTO friends (steam, friend) VALUES (&quot; .. gmsgvars.playerid .. &quot;,&quot; .. id .. &quot;)&quot;)
			end
		else
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are already friends with &quot; .. players[id].name .. &quot;.[-]&quot;)		
		end
		
		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug friends 2\n&quot;) end

	if (gmsgvars.words[1] == &quot;clear&quot; and gmsgvars.words[2] == &quot;friends&quot;) then
		if (accessLevel(gmsgvars.playerid) &lt; 3) then
			pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;friends&quot;) + 8)
			pname = string.trim(pname)
			id = LookupPlayer(pname)

			if id ~= nil then
				-- reset the players friends list
				friends[id] = {}
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Player &quot; .. players[id].name .. &quot; have no friends :([-]&quot;)	

				conn:execute(&quot;DELETE FROM friends WHERE steam = &quot; .. id .. &quot;)&quot;)

				faultyGMSG = false
				return true
			end
		end

		-- reset the players friends list
		friends[gmsgvars.playerid] = {}
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have no friends :([-]&quot;)	

		conn:execute(&quot;DELETE FROM friends WHERE steam = &quot; .. gmsgvars.playerid .. &quot;)&quot;)

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug friends 3\n&quot;) end

	if (gmsgvars.words[1] == &quot;unfriend&quot;) then
		if gmsgvars.words[2] == nil then
			faultyGMSG = help(&quot;help friends&quot;, gmsgvars.playerid)
			return true
		end

		pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;unfriend &quot;) + 9)
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		-- unfriend someone
		if (friends[gmsgvars.playerid] == nil or friends[gmsgvars.playerid] == {}) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have no friends :([-]&quot;)	
			faultyGMSG = false
			return true
		end

		if (id ~= nil) then
			friendlist = string.split(friends[gmsgvars.playerid].friends, &quot;,&quot;)

			-- now simply rebuild friend skipping over the one we are removing
			friends[gmsgvars.playerid].friends = &quot;&quot;
			for i=1,table.maxn(friendlist),1 do
				if (friendlist[i] ~= players[id].steam) and friendlist[i] ~= &quot;&quot; then
					friends[gmsgvars.playerid].friends = friends[gmsgvars.playerid].friends .. friendlist[i] .. &quot;,&quot;
				end
			end
		
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are not friends with &quot; .. players[id].name .. &quot;[-]&quot;)	
			conn:execute(&quot;DELETE FROM friends WHERE steam = &quot; .. gmsgvars.playerid .. &quot; AND friend = &quot; .. id .. &quot;)&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug friends 4\n&quot;) end

	if (gmsgvars.words[1] == &quot;friendme&quot;) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;friendme &quot;) + 9)
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if (id ~= nil) then
			if (not isFriend(id, gmsgvars.playerid)) then
				friends[id].friends = friends[id].friends .. &quot;,&quot; .. gmsgvars.playerid
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; now lists you as a friend.[-]&quot;)	
				conn:execute(&quot;INSERT INTO friends (steam, friend) VALUES (&quot; .. id .. &quot;,&quot; .. gmsgvars.playerid .. &quot;)&quot;)

				faultyGMSG = false
				return true
			end
		else
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are already a friend of &quot; .. players[id].name .. &quot;.[-]&quot;)		
		end	
	end

if debug then display (&quot;debug friends 5\n&quot;) end

	if (gmsgvars.words[1] == &quot;unfriendme&quot;) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		id = 0

		if gmsgvars.words[2] ~= &quot;everyone&quot; then
			pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;unfriendme &quot;) + 12)
			pname = string.trim(pname)
			id = LookupPlayer(pname)
		end

		for k, v in pairs(friends) do
			if (k == id) or gmsgvars.words[2] == &quot;everyone&quot; then
				friendlist = string.split(friends[k].friends, &quot;,&quot;)

				-- now simply rebuild friend skipping over the one we are removing
				friends[k].friends = &quot;&quot;
				for i=1,table.maxn(friendlist),1 do
					if (friendlist[i] ~= gmsgvars.playerid) then
						friends[k].friends = friends[k].friends .. friendlist[i] .. &quot;,&quot;
					end
				end
				
				if (k == id) then			
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are off &quot; .. players[id].name .. &quot;'s friends list.[-]&quot;)	
					conn:execute(&quot;DELETE FROM friends WHERE steam = &quot; .. k .. &quot; AND friend = &quot; .. gmsgvars.playerid .. &quot;)&quot;)
					faultyGMSG = false		
					return true
				end
			end
		end
		
		if (gmsgvars.words[2] == &quot;everyone&quot;) then			
			conn:execute(&quot;DELETE FROM friends WHERE friend = &quot; .. gmsgvars.playerid .. &quot;)&quot;)
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are off everyones friends list.[-]&quot;)	
			faultyGMSG = false		
			return true
		end	
	end

if debug then display (&quot;debug friends 6\n&quot;) end

	if (gmsgvars.words[1] == &quot;friends&quot;) then	
		pid = gmsgvars.playerid

		if accessLevel(gmsgvars.playerid) &gt; 2  and gmsgvars.words[2] ~= nil then
			faultyGMSG = false
			return true
		end

		if accessLevel(gmsgvars.playerid) &lt; 3  and gmsgvars.words[2] ~= nil then
			pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;friends&quot;) + 8, string.len(gmsgvars.command))
			pid = LookupPlayer(pname)
		end

		-- pm a list of all the players friends
		if (friends[pid] == nil) then
			if (pid == gmsgvars.playerid) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have no friends :([-]&quot;)	
			else
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[pid].name .. &quot;  has no friends.[-]&quot;)	
			end

			faultyGMSG = false
			return true
		end

		friendlist = string.split(friends[pid].friends, &quot;,&quot;)

		if (pid == gmsgvars.playerid) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are friends with..[-]&quot;)
		else
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[pid].name .. &quot; is friends with..[-]&quot;)
		end

		for i=1,table.maxn(friendlist),1 do
			if (friendlist[i] ~= &quot;&quot;) then
				id = LookupPlayer(friendlist[i])
				if id ~= nil then
					message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot;[-]&quot;)	
				end
			end
		end		
		
		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug friends end\n&quot;) end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>Load Lua Tables</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function loadServer()
	calledFunction = &quot;loadServer&quot;

	-- load server
	getTableFields(&quot;server&quot;)

	server = {}

	cursor,errorString = conn:execute(&quot;select * from server&quot;)
	rows = tonumber(cursor:numrows())

	if rows == 0 then
		initServer()
	else
		row = cursor:fetch({}, &quot;a&quot;)
		
		server.botName = row.botName
		server.windowGMSG = row.windowGMSG
		server.windowAlerts = row.windowAlerts
		server.windowDebug = row.windowDebug
		server.windowLists = row.windowLists
		server.windowPlayers = row.windowPlayers
		server.ServerPort = row.ServerPort
		server.allowGimme = dbTrue(row.allowGimme)
		server.mapSize = tonumber(row.mapSize)
		server.prisonSize = tonumber(row.prisonSize)
		server.MOTD = row.MOTD
		server.IP = row.IP
		server.lottery = tonumber(row.lottery)
		server.allowShop = dbTrue(row.allowShop)
		server.allowWaypoints = dbTrue(row.allowWaypoints)
		server.ircAlerts = row.ircAlerts
		server.ircMain = row.ircMain
		server.ircWatch = row.ircWatch
		server.chatColour = row.chatColour
		server.maxPlayers = tonumber(row.maxPlayers)
		server.maxServerUptime = tonumber(row.maxServerUptime)
		server.baseSize = tonumber(row.baseSize)
		server.baseCooldown = tonumber(row.baseCooldown)
		server.protectionMaxDays = tonumber(row.protectionMaxDays)
		server.ircBotName = row.ircBotName
		server.ServerName = row.serverName
		server.rules = row.rules
		server.shopCountdown = tonumber(row.shopCountdown)
		server.gimmePeace = dbTrue(row.gimmePeace)
		server.lastDailyReboot = tonumber(row.lastDailyReboot)
		server.allowNumericNames = dbTrue(row.allowNumericNames)
		server.allowGarbageNames = dbTrue(row.allowGarbageNames)
		server.allowReboot = dbTrue(row.allowReboot)
		server.newPlayerTimer = tonumber(row.newPlayerTimer)
		server.blacklistResponse = row.blacklistResponse
		server.gameDay = tonumber(row.gameDay)
		server.shopLocation = row.shopLocation
		server.website = row.website
		server.ircServer = row.ircServer
		server.pingKick = row.pingKick
		server.gameType = row.gameType
		server.hideCommands = dbTrue(row.hideCommands)
	end

	-- set up other initial states
	server.ignoreAdmins = true
	server.uptime = os.time()
	server.coppi = false
end


function loadPlayers(steam)
	local word, words, rdate, ryear, rmonth, rday, rhour, rmin, rsec

	-- load players table
	getTableFields(&quot;players&quot;)

	if steam == nil then 
		players = {} 
		cursor,errorString = conn:execute(&quot;select * from players&quot;)
	else
		cursor,errorString = conn:execute(&quot;select * from players where steam = &quot; .. steam)
	end

	row = cursor:fetch({}, &quot;a&quot;)
	while row do		
		players[row.steam] = {}

		players[row.steam].silentBob = dbTrue(row.silentBob)
		players[row.steam].walkies = dbTrue(row.walkies)
		players[row.steam].steam = row.steam
		players[row.steam].name = row.name
		players[row.steam].id = row.id
		players[row.steam].xPos = tonumber(row.xPos)
		players[row.steam].yPos = tonumber(row.yPos)
		players[row.steam].zPos = tonumber(row.zPos)
		players[row.steam].xPosOld = tonumber(row.xPosOld)
		players[row.steam].yPosOld = tonumber(row.yPosOld)
		players[row.steam].zPosOld = tonumber(row.zPosOld)
		players[row.steam].xPosTimeout = tonumber(row.xPosTimeout)
		players[row.steam].yPosTimeout = tonumber(row.yPosTimeout)
		players[row.steam].zPosTimeout = tonumber(row.zPosTimeout)
		players[row.steam].homeX = tonumber(row.homeX)
		players[row.steam].homeY = tonumber(row.homeY)
		players[row.steam].homeZ = tonumber(row.homeZ)
		players[row.steam].home2X = tonumber(row.home2X)
		players[row.steam].home2Y = tonumber(row.home2Y)
		players[row.steam].home2Z = tonumber(row.home2Z)
		players[row.steam].exitX = tonumber(row.exitX)
		players[row.steam].exitY = tonumber(row.exitY)
		players[row.steam].exitZ = tonumber(row.exitZ)
		players[row.steam].exit2X = tonumber(row.exit2X)
		players[row.steam].exit2Y = tonumber(row.exit2Y)
		players[row.steam].exit2Z = tonumber(row.exit2Z)
		players[row.steam].level = tonumber(row.level)
		players[row.steam].cash = tonumber(row.cash)
		players[row.steam].pvpBounty = tonumber(row.pvpBounty)
		players[row.steam].zombies = tonumber(row.zombies)
		players[row.steam].score = tonumber(row.score)
		players[row.steam].playerKills = tonumber(row.playerKills)
		players[row.steam].deaths = tonumber(row.deaths)
		players[row.steam].protectSize = tonumber(row.protectSize)
		players[row.steam].protect2Size = tonumber(row.protect2Size)
		players[row.steam].sessionCount = tonumber(row.sessionCount)
		players[row.steam].timeOnServer = tonumber(row.timeOnServer)
		players[row.steam].firstSeen = tonumber(row.firstSeen)
		players[row.steam].keystones = tonumber(row.keystones)
		players[row.steam].overstackTimeout = dbTrue(row.overstackTimeout)
		players[row.steam].overstack = dbTrue(row.overstack)
		players[row.steam].shareWaypoint = dbTrue(row.shareWaypoint)
		players[row.steam].watchCash = dbTrue(row.watchCash)
		players[row.steam].watchPlayer = dbTrue(row.watchPlayer)
		players[row.steam].timeout = dbTrue(row.timeout)
		players[row.steam].denyRights = dbTrue(row.denyRights)
		players[row.steam].botTimeout = dbTrue(row.botTimeout)
		players[row.steam].newPlayer = dbTrue(row.newPlayer)
		players[row.steam].IP = row.IP
		players[row.steam].seen = row.seen
		players[row.steam].baseCooldown = tonumber(row.baseCooldown)
		players[row.steam].ircAlias = row.ircAlias
		players[row.steam].ircPass = row.ircPass
		players[row.steam].bed = row.bed
		players[row.steam].donor = dbTrue(row.donor)
		players[row.steam].playtime = tonumber(row.playtime)
		players[row.steam].protect = dbTrue(row.protect)
		players[row.steam].protect2 = dbTrue(row.protect2)
		players[row.steam].tokens = tonumber(row.tokens)
		players[row.steam].exile = dbTrue(row.exile)
		players[row.steam].pvpCount = tonumber(row.pvpCount)
		players[row.steam].translate = dbTrue(row.translate)
		players[row.steam].prisoner = dbTrue(row.prisoner)
		players[row.steam].prisonReason = row.prisonReason
		players[row.steam].prisonxPosOld = tonumber(row.prisonxPosOld)
		players[row.steam].prisonyPosOld = tonumber(row.prisonyPosOld)
		players[row.steam].prisonzPosOld = tonumber(row.prisonzPosOld)
		players[row.steam].permanentBan = dbTrue(row.permanentBan)
		players[row.steam].whitelisted = dbTrue(row.whitelisted)
		players[row.steam].aliases = row.aliases
		players[row.steam].pvpVictim = row.pvpVictim
		players[row.steam].location = row.location
		players[row.steam].canTeleport = dbTrue(row.canTeleport)
		players[row.steam].allowBadInventory = dbTrue(row.allowBadInventory)
		players[row.steam].ircTranslate = dbTrue(row.ircTranslate)
		players[row.steam].noSpam = dbTrue(row.noSpam)
		players[row.steam].waypointX = tonumber(row.waypointX)
		players[row.steam].waypointY = tonumber(row.waypointY)
		players[row.steam].waypointZ = tonumber(row.waypointZ)
		players[row.steam].accessLevel = tonumber(row.accessLevel)
		players[row.steam].country = row.country
		players[row.steam].ping = tonumber(row.ping)
		players[row.steam].donorLevel = tonumber(row.donorLevel)
		players[row.steam].autoFriend = row.autoFriend

		-- convert donorExpiry to a timestamp
		words = {}
		for word in row.donorExpiry:gmatch(&quot;%w+&quot;) do table.insert(words, word) end

		ryear = words[1]
		rmonth = words[2]
		rday = words[3]
		rhour = words[4]
		rmin = words[5]
		rsec = words[6]

		rdate = {year=ryear, month=rmonth, day=rday, hour=rhour, min=rmin, sec=rsec}
		players[row.steam].donorExpiry = os.time(rdate)

		if tonumber(row.accessLevel) &lt; 3 then
			-- add the steamid to the admins table
			if tonumber(row.accessLevel) == 0 then
				owners[players[row.steam].steam] = {}
			end

			if tonumber(row.accessLevel) == 1 then
				admins[players[row.steam].steam] = {}
			end

			if tonumber(row.accessLevel) == 2 then
				mods[players[row.steam].steam] = {}
			end
		end

		row = cursor:fetch(row, &quot;a&quot;)	
	end
end


function loadShopCategories()
	-- load shop categories
   shopCategories = {}
	getTableFields(&quot;shopCategories&quot;)

	cursor,errorString = conn:execute(&quot;select * from shopCategories&quot;)

	-- add the misc category so it always exists
	if cursor:numrows() &gt; 0 then
		shopCategories[&quot;misc&quot;] = {}
		shopCategories[&quot;misc&quot;].idx = 1
		shopCategories[&quot;misc&quot;].code = &quot;misc&quot;
	end

	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		shopCategories[row.category] = {}
		shopCategories[row.category].idx = row.idx
		shopCategories[row.category].code = row.code
		row = cursor:fetch(row, &quot;a&quot;)	
	end
end


function loadResetZones()
	-- load reset zones
   resetRegions = {}
	getTableFields(&quot;resetZones&quot;)

	cursor,errorString = conn:execute(&quot;select * from resetZones&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		resetRegions[row.region] = {}
		row = cursor:fetch(row, &quot;a&quot;)	
	end
end


function loadTeleports()
	-- load teleports
	getTableFields(&quot;teleports&quot;)

   teleports = {}
	cursor,errorString = conn:execute(&quot;select * from teleports&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		teleports[row.name] = {}
		teleports[row.name].id = row.id
		teleports[row.name].active = dbTrue(row.active)
		teleports[row.name].oneway = dbTrue(row.oneway)
		teleports[row.name].public = dbTrue(row.public)
		teleports[row.name].friends = dbTrue(row.friends)
		teleports[row.name].x = tonumber(row.x)
		teleports[row.name].y = tonumber(row.y)
		teleports[row.name].z = tonumber(row.z)
		teleports[row.name].dx = tonumber(row.dx)
		teleports[row.name].dy = tonumber(row.dy)
		teleports[row.name].dz = tonumber(row.dz)
		teleports[row.name].name = row.name
		teleports[row.name].owner = row.owner
		row = cursor:fetch(row, &quot;a&quot;)	
	end
end


function loadLocations()
	-- load locations
	getTableFields(&quot;locations&quot;)

	locations = {}
	cursor,errorString = conn:execute(&quot;select * from locations&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		locations[row.name] = {}
		locations[row.name].name = row.name
		locations[row.name].active = dbTrue(row.active)
		locations[row.name].protect = dbTrue(row.protected)
		locations[row.name].public = dbTrue(row.public)
		locations[row.name].resetZone = dbTrue(row.resetZone)
		locations[row.name].village = dbTrue(row.village)
		locations[row.name].allowbase = dbTrue(row.allowbase)
		locations[row.name].pvp = dbTrue(row.pvp)
		locations[row.name].x = tonumber(row.x)
		locations[row.name].y = tonumber(row.y)
		locations[row.name].z = tonumber(row.z)
		locations[row.name].exitX = tonumber(row.exitX)
		locations[row.name].exitY = tonumber(row.exitY)
		locations[row.name].exitZ = tonumber(row.exitZ)
		locations[row.name].owner = row.owner
		locations[row.name].protectSize = tonumber(row.protectSize)
		locations[row.name].cost = tonumber(row.cost)
		locations[row.name].currency = row.currency
		locations[row.name].accessLevel = tonumber(row.accessLevel)
		locations[row.name].size = tonumber(row.size)
		locations[row.name].miniGame = row.miniGame
		locations[row.name].mayor = row.mayor
		locations[row.name].other = row.other -- used with miniGame
		locations[row.name].killZombies = dbTrue(row.killZombies)
		row = cursor:fetch(row, &quot;a&quot;)	
	end
end


function loadBadItems()
	-- load badItems
	getTableFields(&quot;badItems&quot;)

   badItems = {}
	cursor,errorString = conn:execute(&quot;select * from badItems&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		badItems[row.item] = {}
		badItems[row.item].item = row.item
		badItems[row.item].action = row.action
		row = cursor:fetch(row, &quot;a&quot;)	
	end
end


function loadRestrictedItems()
	-- load restrictedItems
	getTableFields(&quot;restrictedItems&quot;)

   restrictedItems = {}
	cursor,errorString = conn:execute(&quot;select * from restrictedItems&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		restrictedItems[row.item] = {}
		restrictedItems[row.item].qty = tonumber(row.qty)
		restrictedItems[row.item].accessLevel = tonumber(row.accessLevel)
		restrictedItems[row.item].action = row.action
		row = cursor:fetch(row, &quot;a&quot;)	
	end
end


function loadFriends()
	-- load friends
	getTableFields(&quot;friends&quot;)

   friends = {}
	cursor,errorString = conn:execute(&quot;select * from friends&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		if friends[row.steam] == nil then
			friends[row.steam] = {}
			friends[row.steam].friends = &quot;&quot;
		end

		if friends[row.steam].friends == &quot;&quot; then
			friends[row.steam].friends = row.friend
		else
			friends[row.steam].friends = friends[row.steam].friends .. &quot;,&quot; .. row.friend
		end

		row = cursor:fetch(row, &quot;a&quot;)	
	end
end


function loadHotspots()
	local idx, nextidx

	-- load hotspots
	getTableFields(&quot;hotspots&quot;)

	nextidx = -1
   hotspots = {}
	cursor,errorString = conn:execute(&quot;select * from hotspots&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		idx = tonumber(row.idx)

		if idx == 0 then
			if nextidx == -1 then
				idx = 1
				nextidx = 2
			else
				idx = nextidx
				nextidx = nextidx + 1
			end

			conn:execute(&quot;update hotspots set idx = &quot; .. idx .. &quot; where id = &quot; .. row.id)
		end

		hotspots[idx] = {}
		hotspots[idx].hotspot = row.hotspot
		hotspots[idx].x = row.x
		hotspots[idx].y = row.y
		hotspots[idx].z = row.z
		hotspots[idx].size = row.size
		hotspots[idx].owner = row.owner
		row = cursor:fetch(row, &quot;a&quot;)	
	end
end


function loadVillagers()
	-- load villagers
	getTableFields(&quot;villagers&quot;)

   villagers = {}
	cursor,errorString = conn:execute(&quot;select * from villagers&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		villagers[row.steam .. row.village] = {}
		villagers[row.steam .. row.village].steam = row.steam
		villagers[row.steam .. row.village].village = row.village
		row = cursor:fetch(row, &quot;a&quot;)	
	end
end


function loadTables()
	conn:execute(&quot;INSERT INTO memRestrictedItems (select * from restrictedItems)&quot;)
	conn:execute(&quot;INSERT INTO memLottery (select * from lottery)&quot;)

	dbug(&quot;loading players&quot;)
	loadPlayers()
	dbug(&quot;loaded players&quot;)

	loadResetZones()
	dbug(&quot;loaded reset zones&quot;)

	loadTeleports()
	dbug(&quot;loaded teleports&quot;)

	loadLocations()
	dbug(&quot;loaded locations&quot;)

	loadBadItems()
	dbug(&quot;loaded bad items&quot;)

	loadRestrictedItems()
	dbug(&quot;loaded restricted items&quot;)

	loadFriends()
	dbug(&quot;loaded friends&quot;)

	loadHotspots()
	dbug(&quot;loaded hotspots&quot;)

	loadVillagers()
	dbug(&quot;loaded villagers&quot;)

	loadShopCategories()
	dbug(&quot;loaded shop categories&quot;)
end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>Save DB Tables</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function updatePlayer(steam)
	fixMissingPlayer(steam)

	-- update the db
	fields = {}
	values = {}
--dbug(&quot;update player &quot; .. steam)
	table.insert(fields, &quot;xpos&quot;)
	table.insert(values, players[steam].xPos)

	table.insert(fields, &quot;ypos&quot;)
	table.insert(values, players[steam].yPos)

	table.insert(fields, &quot;zpos&quot;)
	table.insert(values, players[steam].zPos)

	table.insert(fields, &quot;homex&quot;)
	table.insert(values, players[steam].homeX)

	table.insert(fields, &quot;homey&quot;)
	table.insert(values, players[steam].homeY)

	table.insert(fields, &quot;homez&quot;)
	table.insert(values, players[steam].homeZ)

	table.insert(fields, &quot;home2x&quot;)
	table.insert(values, players[steam].home2X)

	table.insert(fields, &quot;home2y&quot;)
	table.insert(values, players[steam].home2Y)

	table.insert(fields, &quot;home2z&quot;)
	table.insert(values, players[steam].home2Z)

	table.insert(fields, &quot;exitx&quot;)
	table.insert(values, players[steam].exitX)

	table.insert(fields, &quot;exity&quot;)
	table.insert(values, players[steam].exitY)

	table.insert(fields, &quot;exitz&quot;)
	table.insert(values, players[steam].exitZ)

	table.insert(fields, &quot;exit2x&quot;)
	table.insert(values, players[steam].exit2X)

	table.insert(fields, &quot;exit2y&quot;)
	table.insert(values, players[steam].exit2Y)

	table.insert(fields, &quot;exit2z&quot;)
	table.insert(values, players[steam].exit2Z)

	table.insert(fields, &quot;xposold&quot;)
	table.insert(values, players[steam].xPosOld)

	table.insert(fields, &quot;yposold&quot;)
	table.insert(values, players[steam].yPosOld)

	table.insert(fields, &quot;zposold&quot;)
	table.insert(values, players[steam].zPosOld)

	table.insert(fields, &quot;timeonserver&quot;)
	table.insert(values, players[steam].timeOnServer)

	table.insert(fields, &quot;seen&quot;)
	table.insert(values, players[steam].seen)

	table.insert(fields, &quot;playerkills&quot;)
	table.insert(values, players[steam].playerKills)

	table.insert(fields, &quot;deaths&quot;)
	table.insert(values, players[steam].deaths)

	table.insert(fields, &quot;zombies&quot;)
	table.insert(values, players[steam].zombies)

	table.insert(fields, &quot;level&quot;)
	table.insert(values, players[steam].level)

	if tonumber(players[steam].ping) &gt; 0 then
		table.insert(fields, &quot;ping&quot;)
		table.insert(values, players[steam].ping)
	end

	table.insert(fields, &quot;score&quot;)
	table.insert(values, players[steam].score)

	table.insert(fields, &quot;tokens&quot;)
	table.insert(values, players[steam].tokens)

	table.insert(fields, &quot;basecooldown&quot;)
	table.insert(values, players[steam].baseCooldown)

	table.insert(fields, &quot;cash&quot;)
	table.insert(values, players[steam].cash)

	table.insert(fields, &quot;sessionCount&quot;)
	table.insert(values, players[steam].sessionCount)

	table.insert(fields, &quot;waypointx&quot;)
	table.insert(values, players[steam].waypointX)

	table.insert(fields, &quot;waypointy&quot;)
	table.insert(values, players[steam].waypointY)

	table.insert(fields, &quot;waypointz&quot;)
	table.insert(values, players[steam].waypointZ)

	table.insert(fields, &quot;accesslevel&quot;)
	table.insert(values, accessLevel(steam))

	table.insert(fields, &quot;protectsize&quot;)
	table.insert(values, players[steam].protectSize)

	table.insert(fields, &quot;protect2size&quot;)
	table.insert(values, players[steam].protect2Size)

	table.insert(fields, &quot;keystones&quot;)
	table.insert(values, players[steam].keystones)

	table.insert(fields, &quot;donor&quot;)
	table.insert(values, players[steam].donor)

	table.insert(fields, &quot;walkies&quot;)
	table.insert(values, players[steam].walkies)

	table.insert(fields, &quot;protect&quot;)
	table.insert(values, players[steam].protect)

	table.insert(fields, &quot;protect2&quot;)
	table.insert(values, players[steam].protect2)

	table.insert(fields, &quot;timeout&quot;)
	table.insert(values, players[steam].timeout)

	table.insert(fields, &quot;bottimeout&quot;)
	table.insert(values, players[steam].botTimeout)

	table.insert(fields, &quot;newplayer&quot;)
	table.insert(values, players[steam].newPlayer)

	table.insert(fields, &quot;prisoner&quot;)
	table.insert(values, players[steam].prisoner)

	table.insert(fields, &quot;sharewaypoint&quot;)
	table.insert(values, players[steam].shareWaypoint)

	table.insert(fields, &quot;canteleport&quot;)
	table.insert(values, players[steam].canTeleport)

	table.insert(fields, &quot;country&quot;)
	table.insert(values, players[steam].country)

	table.insert(fields, &quot;donorlevel&quot;)
	table.insert(values, players[steam].donorLevel)

	table.insert(fields, &quot;donorexpiry&quot;)
	table.insert(values, players[steam].donorExpiry)

	table.insert(fields, &quot;ircpass&quot;)
	table.insert(values, players[steam].ircPass)

	table.insert(fields, &quot;autofriend&quot;)
	table.insert(values, players[steam].autoFriend)

--debugdb = true
	savePlayer(steam, fields, values)
--debugdb = false
end


function getServerFields()
	local field

	--function inspect the server table and store field names and types
	serverFields = {}

	cursor,errorString = conn:execute(&quot;SHOW FIELDS FROM server&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		field = string.lower(row.Field)

		serverFields[field] = {}
		serverFields[field].type = string.sub(row.Type, 1,3)
		row = cursor:fetch(row, &quot;a&quot;)	
	end
end

--[[
	-- typical use
	fields = {}
	values = {}
	table.insert(fields, &quot;LootRespawnDays&quot;)
	table.insert(values, number)
	saveServer(fields, values)
--]]

function saveServer(fields, values)
	local i, sql

	if debugdb then
		dbug(&quot;saving to server table&quot;)
	end

	if serverFields == nil then
		getServerFields()
	end

	sql = &quot;UPDATE server SET&quot;

	for i=1,table.maxn(fields),1 do
		fields[i] = string.lower(fields[i])

		if serverFields[fields[i]].type == &quot;var&quot; then
			values[i] = &quot;'&quot; .. escape(values[i]) .. &quot;'&quot;
		end

		if serverFields[fields[i]].type == &quot;tin&quot; then
			if values[i] == true then values[i] = 1 end
			if values[i] == false then values[i] = 0 end
		end

		sql = sql .. &quot; &quot; .. fields[i] .. &quot;=&quot; .. values[i] .. &quot;,&quot;
	end

	sql = string.sub(sql, 1, string.len(sql) - 1)

	if debugdb then
		dbug(&quot;save server &quot; .. sql)
	end

	status, errorString = conn:execute(sql)

	if status == 0 then
		if debugdb then
			dbug(&quot;save server failed&quot;)
		end

		return false -- update failed
	else
		if debugdb then
			dbug(&quot;save server success&quot;)
		end

		return true -- update success
	end
end


function getPlayerFields()
	local field

	--function inspect the player table and store field names and types
	playerFields = {}

	cursor,errorString = conn:execute(&quot;SHOW FIELDS FROM players&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		field = string.lower(row.Field)

		playerFields[field] = {}
		playerFields[field].type = string.sub(row.Type, 1,3)
		row = cursor:fetch(row, &quot;a&quot;)	
	end
end


function savePlayer(steam, fields, values, action)
--[[
	-- typical use
	fields = {}
	values = {}
	table.insert(fields, &quot;LootRespawnDays&quot;)
	table.insert(values, number)
	savePlayer(&quot;1234&quot;, fields, values)
--]]

	if debugdb then
		dbug(&quot;saving player &quot; .. steam)
	end

	local i, sql, sqlValues, status, errorString

	if playerFields == nil then
		getPlayerFields()
	end

	if action == nil then
		sql = &quot;UPDATE players SET&quot;

		for i=1,table.maxn(fields),1 do
			fields[i] = string.lower(fields[i])

			if playerFields[fields[i]].type == &quot;var&quot; then
				values[i] = &quot;'&quot; .. escape(values[i]) .. &quot;'&quot;
			end

			if playerFields[fields[i]].type == &quot;tin&quot; then
				if values[i] == true then values[i] = 1 end
				if values[i] == false then values[i] = 0 end
			end

			if playerFields[fields[i]].type == &quot;tim&quot; then
				values[i] = &quot;'&quot; .. os.date(&quot;%Y-%m-%d %H:%M:%S&quot;, values[i]) .. &quot;'&quot;
			end

			sql = sql .. &quot; &quot; .. fields[i] .. &quot;=&quot; .. values[i] .. &quot;,&quot;
		end

		sql = string.sub(sql, 1, string.len(sql) - 1)
		sql = sql .. &quot; WHERE steam = '&quot; .. steam .. &quot;'&quot;
	else
		sql = &quot;INSERT INTO players (&quot;
		sqlValues = &quot; VALUES (&quot;

		for i=1,table.maxn(fields),1 do
			fields[i] = string.lower(fields[i])

			if playerFields[fields[i]].type == &quot;var&quot; then
				values[i] = &quot;'&quot; .. escape(values[i]) .. &quot;'&quot;
			end

			if playerFields[fields[i]].type == &quot;tin&quot; then
				if values[i] == true then values[i] = 1 end
				if values[i] == false then values[i] = 0 end
			end
			if playerFields[fields[i]].type == &quot;tim&quot; then
				values[i] = &quot;'&quot; .. os.date(&quot;%Y-%m-%d %H:%M:%S&quot;, values[i]) .. &quot;'&quot;
			end

			sql = sql .. &quot; &quot; .. fields[i] .. &quot;,&quot;
			sqlValues = sqlValues .. values[i] .. &quot;,&quot;
		end

		sql = string.sub(sql, 1, string.len(sql) - 1) .. &quot;)&quot;
		sqlValues = string.sub(sqlValues, 1, string.len(sqlValues) - 1) .. &quot;)&quot;
		sql = sql .. sqlValues
	end

	if debugdb then
		dbug(&quot;save player sql &quot; .. sql)
	end

	status, errorString = conn:execute(sql)

	if status == 0 then
		if debugdb then
			dbug(&quot;save player success&quot;)
		end

		return false -- no record changed
	else
		if debugdb then
			dbug(&quot;save player success&quot;)
			dbug(&quot;save player sql &quot; .. sql)
		end

		return true -- record inserted/updated
	end
end


function getTableFields(table)
	--function inspect the table and store field names and types
	if type(tableFields) ~= &quot;table&quot; then
		tableFields = {}
	end

	tableFields[table] = {}
	tableFields[table].fields = {}
	tableFields[table].types = {}

	cursor,errorString = conn:execute(&quot;SHOW FIELDS FROM &quot; .. table)
	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		tableFields[table].fields[#tableFields[table].fields+1] = {string.lower(row.Field)}
		tableFields[table].types[#tableFields[table].types+1] = {string.lower(string.sub(row.Type, 1,3))}
		row = cursor:fetch(row, &quot;a&quot;)	
	end
end


function saveTable(table, fields, values, condition)
-- This function does updates only, no inserts
	local i, sql

--[[
	-- typical use
	fields = {}
	values = {}
	table.insert(fields, &quot;LootRespawnDays&quot;)
	table.insert(values, number)
	saveTable(&quot;server&quot;, fields, values, &quot;test = true&quot;)
--]]

	if debugdb then
		dbug(&quot;saving to table &quot; .. table)
	end

	if tableFields[table] == nil then
		getTableFields(table)
	end

	sql = &quot;UPDATE &quot; .. table .. &quot; SET&quot;

	for i=1,table.maxn(fields),1 do
		fields[i] = string.lower(fields[i])

		if tableFields[table].fields[i].type == &quot;var&quot; then
			values[i] = &quot;'&quot; .. escape(values[i]) .. &quot;'&quot;
		end

		if tableFields[fields[i]].type == &quot;tin&quot; then
			if values[i] == true then values[i] = 1 end
			if values[i] == false then values[i] = 0 end
		end

		if 	sql == &quot;UPDATE &quot; .. table .. &quot; SET&quot; then
			sql = sql .. &quot; &quot; .. fields[i] .. &quot;=&quot; .. values[i]
		else
			sql = sql .. &quot;, &quot; .. fields[i] .. &quot;=&quot; .. values[i]
		end
	end

	if condition ~= nil then
		sql = sql .. &quot; where &quot; .. condition
	end

	if debugdb then
		dbug(&quot;save &quot; .. table .. &quot; &quot; .. sql)
	end

	status, errorString = conn:execute(sql)

	if status == 0 then
		if debugdb then
			dbug(&quot;save &quot; .. table .. &quot; failed&quot;)
		end

		return false -- update failed
	else
		if debugdb then
			dbug(&quot;save &quot; .. table .. &quot; success&quot;)
		end

		return true -- update success
	end
end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>Base Protection</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function baseProtection(steam, posX, posY, posZ)
	calledFunction = &quot;baseProtection&quot;

	local k, v, testMode

	testMode = false
	players[steam].atHome = false

	-- check for and record any non-friend who gets within protectSize meters of a players /setbase coord
	for k, v in pairs(players) do

		if (math.abs(tonumber(v.homeX)) &gt; 100 or math.abs(tonumber(v.homeZ)) &gt; 100) then
			dist = distancexz(posX, posZ, v.homeX, v.homeZ)
			size = tonumber(v.protectSize)

			if (v.steam == steam) and (dist &lt; size + 16) then
				v.atHome = true
			end

			if (v.steam == steam and v.protectPaused) then
				if (dist &gt; 100) then
					v.protectPaused = nil
					message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Your base protection has re-activated.[-]&quot;)
				end
			end

			if igplayers[steam].protectTest ~= nil and v.steam == steam then
				if igplayers[steam].protectTestEnd - os.time() &lt; 0 then
					igplayers[steam].protectTest = nil
				else
					testMode = true
				end
			end

			if (v.steam ~= steam or testMode) and (v.protectSize ~= nil)  then
				if isFriend(v.steam, steam) == false or testMode then
					if (dist &lt; size) then
						if (accessLevel(steam) &gt; 2) or server.ignoreAdmins == false or testMode then

							if (players[steam].watchPlayer == true) then
								alert = false

								if (players[steam].lastBaseRaid == nil) then
									players[steam].lastBaseRaid = os.time()
									alert = true
									-- spam prevention
									igplayers[steam].xPosLastAlert = 0
									igplayers[steam].yPosLastAlert = 0
									igplayers[steam].zPosLastAlert = 0
								end

								if (os.time() - tonumber(players[steam].lastBaseRaid) &gt; 15) and ((posX ~= igplayers[steam].xPosLastAlert) or (posY ~= igplayers[steam].yPosLastAlert) or (posZ ~= igplayers[steam].zPosLastAlert)) then
									alert = true
								end

								if (alert == true) then
									-- spam prevention
									igplayers[steam].xPosLastAlert = posX
									igplayers[steam].yPosLastAlert = posY
									igplayers[steam].zPosLastAlert = posZ

									for n, m in pairs(igplayers) do
										if (accessLevel(n) &lt; 3) then
											message(&quot;pm &quot; .. n .. &quot; [&quot; .. server.chatColour .. &quot;]Watched player &quot; .. players[steam].id .. &quot; &quot; .. players[steam].name .. &quot; is &quot; .. string.format(&quot;%-8.2d&quot;, dist) .. &quot; meters from &quot; .. v.name .. &quot;'s base[-]&quot;)
										end
									end

									irc_QueueMsg(server.ircMain, gameDate .. &quot; Watched player &quot; .. players[steam].id .. &quot; &quot; .. players[steam].name .. &quot; is &quot; .. string.format(&quot;%-8.2d&quot;, dist) .. &quot; meters from &quot; .. v.name .. &quot;'s base&quot;)
									players[steam].lastBaseRaid = os.time()
								end
							end

							igplayers[steam].raiding = true
							igplayers[steam].raidingBase = k

							-- log this intrusion into the base
--							if (raids[steam] == nil) then
--								raids[steam] = {}
--								raids[steam].name = igplayers[steam].name
--								raids[steam].coords = {}
--								table.insert(raids[steam].coords, {timestamp, v.steam, intX, intY, intZ } )	
--							end

							-- do the base protection magic
							if (v.protect and v.protectSize and v.protect == true and not v.protectPaused) and v.homeX ~= 0 and v.homeY ~= 0 and v.homeZ ~= 0 then
								irc_QueueMsg(server.ircAlerts, &quot;base protection triggered for base1 of &quot; .. players[k].name .. &quot; &quot; .. k .. &quot; against &quot; .. players[steam].name .. &quot; &quot; .. steam)

								if (igplayers[k] ~= nil) then
									message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. igplayers[steam].name .. &quot; has been bounced away from your base.[-]&quot;)
								end


								for n,m in pairs(igplayers) do
									if (accessLevel(n) &lt; 3) then
										message(&quot;pm &quot; .. n .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. igplayers[steam].name .. &quot; has been ejected from &quot; .. v.name  ..&quot;'s 1st base.[-]&quot;)
									end
								end


								if distance(igplayers[steam].xPosLastOK, igplayers[steam].zPosLastOK, v.homeX, v.homeZ) &gt; v.protectSize then
									message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You are too close to a protected player base. The base owner needs to add you to their friends list by typing /friend &quot; .. igplayers[steam].name .. &quot;[-]&quot;)
									cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. igplayers[steam].xPosLastOK .. &quot; &quot; .. igplayers[steam].yPosLastOK + 1 .. &quot; &quot; .. igplayers[steam].zPosLastOK
									prepareTeleport(steam, cmd)
									teleport(cmd, true)
								else
									cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. v.exitX .. &quot; &quot; .. v.exitY + 1 .. &quot; &quot; .. v.exitZ
									prepareTeleport(steam, cmd)
									teleport(cmd, true)
									message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You are too close to a protected player base.  The base owner needs to add you to their friends list by typing /friend &quot; .. igplayers[steam].name .. &quot;[-]&quot;)
								end
								
								return true
							end
						end
					end
				end
			end
		end


		-- 2nd base for donors and admins
		if (math.abs(tonumber(v.home2X)) &gt; 100 or math.abs(tonumber(v.home2Z)) &gt; 100) then
			dist = distancexz(igplayers[steam].xPos, igplayers[steam].zPos, v.home2X, v.home2Z)
			size = tonumber(v.protect2Size)

			if (v.steam == steam) and (dist &lt; size + 16) then
				v.atHome = true
			end

			if (v.steam == steam and v.protect2Paused) then
				if (dist &gt; 100) then
					v.protect2Paused = nil
					message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Protection on your 2nd base has re-activated.[-]&quot;)
				end
			end

			if (v.steam ~= steam or testMode) and (v.protect2Size ~= nil)  then
				if isFriend(v.steam, steam) == false or testMode then
					if (dist &lt; size) then
						if (accessLevel(steam) &gt; 2) or server.ignoreAdmins == false or testMode then

							if (players[steam].watchPlayer == true) then
								alert = false

								if (players[steam].lastBaseRaid == nil) then
									players[steam].lastBaseRaid = os.time()
									alert = true
									-- spam prevention
									igplayers[steam].xPosLastAlert = 0
									igplayers[steam].yPosLastAlert = 0
									igplayers[steam].zPosLastAlert = 0
								end

								if (os.time() - tonumber(players[steam].lastBaseRaid) &gt; 15) and ((posX ~= igplayers[steam].xPosLastAlert) or (posY ~= igplayers[steam].yPosLastAlert) or (posZ ~= igplayers[steam].zPosLastAlert)) then
									alert = true
								end

								if (alert == true) then
									-- spam prevention
									igplayers[steam].xPosLastAlert = posX
									igplayers[steam].yPosLastAlert = posY
									igplayers[steam].zPosLastAlert = posZ

									for n, m in pairs(igplayers) do
										if (accessLevel(n) &lt; 3) then
											message(&quot;pm &quot; .. n .. &quot; [&quot; .. server.chatColour .. &quot;]Watched player &quot; .. players[steam].id .. &quot; &quot; .. players[steam].name .. &quot; is &quot; .. string.format(&quot;%-8.2d&quot;, dist) .. &quot; meters from &quot; .. v.name .. &quot;'s 2nd base teleport[-]&quot;)
										end
									end

									irc_QueueMsg(server.ircMain, gameDate .. &quot; Watched player &quot; .. players[steam].id .. &quot; &quot; .. players[steam].name .. &quot; is &quot; .. string.format(&quot;%-8.2d&quot;, dist) .. &quot; meters from &quot; .. v.name .. &quot;'s 2nd base teleport&quot;)
									players[steam].lastBaseRaid = os.time()
								end
							end

							igplayers[steam].raiding = true
							igplayers[steam].raidingBase = k

							-- log this intrusion into the base
--							if (raids[steam] == nil) then
--								raids[steam] = {}
--								raids[steam].name = igplayers[steam].name
--								raids[steam].coords = {}
--								table.insert(raids[steam].coords, {timestamp, v.steam, intX, intY, intZ } )	
--							end

							-- do the base protection magic

							-- if base owner's donor status expired a week or more ago, disable protection
							if (v.protect2 and v.protect2 == true) and v.home2X ~= 0 and v.home2Y ~= 0 and v.home2Z ~= 0 then
								if os.time() - tonumber(players[k].donorExpiry) &gt; (60 * 60 * 24 * 7) then
									players[k].protect2 = false
									conn:execute(&quot;UPDATE players SET protect2 = 0 WHERE steam = &quot; .. k)
								end
							end

							if (v.protect2 and v.protect2Size and v.protect2 == true and not v.protect2Paused) and v.home2X ~= 0 and v.home2Y ~= 0 and v.home2Z ~= 0 then
								irc_QueueMsg(server.ircAlerts, &quot;base protection triggered for base2 of &quot; .. players[k].name .. &quot; &quot; .. k .. &quot; against &quot; .. players[steam].name .. &quot; &quot; .. steam)

								if (igplayers[k] ~= nil) then
									message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. igplayers[steam].name .. &quot; has been ejected from your 2nd base.[-]&quot;)
								end


								for n,m in pairs(igplayers) do
									if (accessLevel(n) &lt; 3) then
										message(&quot;pm &quot; .. n .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. igplayers[steam].name .. &quot; has been ejected from &quot; .. v.name  ..&quot;'s 2nd base.[-]&quot;)
									end
								end

								if distancexz(igplayers[steam].xPosLastOK, igplayers[steam].zPosLastOK, v.home2X, v.home2Z) &gt; v.protect2Size then
									message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You are too close to a protected player base.  The base owner needs to add you to their friends list by typing /friend &quot; .. igplayers[steam].name .. &quot;[-]&quot;)
									cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. igplayers[steam].xPosLastOK .. &quot; &quot; .. igplayers[steam].yPosLastOK + 1 .. &quot; &quot; .. igplayers[steam].zPosLastOK
									prepareTeleport(steam, cmd)
									teleport(cmd, true)
								else
									cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. v.exit2X .. &quot; &quot; .. v.exit2Y + 1 .. &quot; &quot; .. v.exit2Z
									prepareTeleport(steam, cmd)
									teleport(cmd, true)
									message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You are too close to a protected player base.  The base owner needs to add you to their friends list by typing /friend &quot; .. igplayers[steam].name .. &quot;[-]&quot;)
								end
								
								return true
							end
						end
					end
				end
			end
		end

	end


	-- location/village protection
	if (accessLevel(steam) &gt; 2) or server.ignoreAdmins == false then --  or testMode
		for k, v in pairs(locations) do
			if (v.protect == true and v.x ~= 0 and v.y ~= 0 and v.z ~= 0) then
				if (not LookupVillager(steam, k) ) and steam ~= v.owner then
					dist = distancexz(igplayers[steam].xPos, igplayers[steam].zPos, v.x, v.z)

					if v.size == nil then
						size = 50
					else
						size = tonumber(v.size) 	
					end
				
					if (dist &lt; size) then
						igplayers[steam].raiding = true

						-- do the base protection magic
						if distancexz(igplayers[steam].xPos, igplayers[steam].zPos, v.x, v.z) &gt; tonumber(v.size) then
							message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You are too close to &quot; .. k .. &quot;.[-]&quot;)
							cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. igplayers[steam].xPosLastOK .. &quot; &quot; .. igplayers[steam].yPosLastOK .. &quot; &quot; .. igplayers[steam].zPosLastOK
							igplayers[steam].lastTP = cmd
							teleport(cmd, true)
						else
							cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. v.exitX .. &quot; &quot; .. v.exitY + 1 .. &quot; &quot; .. v.exitZ
							igplayers[steam].lastTP = cmd
							teleport(cmd, true)
							message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You are too close to &quot; .. k .. &quot;.[-]&quot;)
						end
						
						return true
					end
				end
			end
		end	
	end

end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>Trial Code</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
some lua globals from Mudlet we might use
collectgarbage
showToolBar
sendTelnetChannel102
getStopWatchTime
sendSocket
resetStopWatch
channel102
getTime
startStopWatch
SavedVariables
stopStopWatch
resetProfile
phpTable
startLogging
createStopWatch
--]]


-- os.spawn or mudlet's spawn command might give us a way to run an irc client or other program. not sure if that will help us communicate with it.

--[[
--command ideas
--add a new player flag noSpam which defaults to false
change some server messages to pm always and honour the flag 

--]]


function playerBanned(steam)
-- TODO: FINISH THIS.

	cursor,errorString = conn:execute(&quot;SELECT * FROM bans WHERE steam = &quot; .. steam .. &quot; AND NOT expired&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>Reset Bot Code</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function ResetBot()
	dbug(&quot;Running ResetBot&quot;)

	for k,v in pairs(players) do
		v.xPos = 0
		v.yPos = 0
		v.zPos = 0
		v.xPosOld = 0
		v.yPosOld = 0
		v.zPosOld = 0
		v.exitX = 0
		v.exitY = 0
		v.exitZ = 0
		v.exit2X = 0
		v.exit2Y = 0
		v.exit2Z = 0
		v.baseCooldown = 0		
		v.protect = false
		v.protectSize = 32
		v.protect2 = false
		v.protect2Size = 32
		v.homeX = 0
		v.homeY = 0
		v.homeZ = 0
		v.home2X = 0
		v.home2Y = 0
		v.home2Z = 0		
		v.timeout = false
		v.alertPrison = true
		v.alertReset = true
		v.alertMapLimit = false
		v.sessionCount = 1
		v.rescued = false
		v.watchPlayer = false
		v.lastBaseRaid = 0
		v.playtime = 0
		v.zombies = 0
		v.cash = 0
		v.overstack = false
		v.overstackScore = 0
		v.overstackItems = &quot;&quot;
		v.overstackTimeout = false
		v.gimmeCount = 0
		v.stepCount = 0
		v.timeOnServer = 0
		v.raiding = false
		v.playerKills = 0
		v.score = 0
		v.deaths = 0
		v.alertRemovedClaims = false
		v.removedClaims = 0
		v.pvpBounty = 0
		v.pvpCount = 0
		v.tokens = 0
		v.keystones = 0
		
		-- remove some fields
		v.santa = nil
		v.protection = nil
		v.protectionSize = nil
		v.lobby = nil
		v.waypointY = nil
		v.waypointX = nil
		v.waypointZ = nil
		v.shareWaypoint = nil
		v.baseprotection = nil		
	end	
	
	-- clean up other tables
	teleports = {}
	invTemp = {}
	hotspots = {}
	resetRegions = {}
	lastHotspots = {}
	villagers = {}
	locations = {}

	server.lottery = 0
	server.mapSize = 20000
	server.prisonSize = 30
	server.warnBotReset = false

	dbug(&quot;Emptying tables&quot;)

	conn:execute(&quot;DELETE FROM alerts&quot;)
	conn:execute(&quot;DELETE FROM announcements&quot;)
	conn:execute(&quot;DELETE FROM bookmarks&quot;)
	conn:execute(&quot;DELETE FROM commandQueue&quot;)
	conn:execute(&quot;DELETE FROM events&quot;)
	conn:execute(&quot;DELETE FROM gimmeQueue&quot;)
	conn:execute(&quot;DELETE FROM hotspots&quot;)
	conn:execute(&quot;DELETE FROM inventoryChanges&quot;)
	conn:execute(&quot;DELETE FROM inventoryTracker&quot;)
	conn:execute(&quot;DELETE FROM ircQueue&quot;)
	conn:execute(&quot;DELETE FROM keystones&quot;)
	conn:execute(&quot;DELETE FROM locations&quot;)
	conn:execute(&quot;DELETE FROM locationSpawns&quot;)
	conn:execute(&quot;DELETE FROM lottery&quot;)
	conn:execute(&quot;DELETE FROM mail&quot;)
	conn:execute(&quot;DELETE FROM memLottery&quot;)
	conn:execute(&quot;DELETE FROM memTracker&quot;)
	conn:execute(&quot;DELETE FROM messageQueue&quot;)
	conn:execute(&quot;DELETE FROM performance&quot;)
	conn:execute(&quot;DELETE FROM playerQueue&quot;)
	conn:execute(&quot;DELETE FROM resetZones&quot;)
	conn:execute(&quot;DELETE FROM teleports&quot;)
	conn:execute(&quot;DELETE FROM tracker&quot;)
	conn:execute(&quot;DELETE FROM searchResults&quot;)
	conn:execute(&quot;DELETE FROM villagers&quot;)
	conn:execute(&quot;DELETE FROM visits&quot;)

	dbug(&quot;Reading server, players, bans and admin data&quot;)

	tempTimer( 4, [[send(&quot;lkp&quot;)]] )
	tempTimer( 8, [[send(&quot;pm IPCHECK&quot;)]] )
	tempTimer( 10, [[send(&quot;admin list&quot;)]] )
	tempTimer( 12, [[send(&quot;gg&quot;)]] )
	tempTimer( 14, [[send(&quot;ban list&quot;)]] )

	dbug(&quot;Finished resetting bot&quot;)
	
	return true
end


function ResetServer()
	-- This will wipe everything from the bot about the server and its players and it will ask the server for players and other info.
	-- For anything else, default values will be set until you change them.

	serverTime = &quot;&quot;
	feralWarning = false
	scheduledReboot = false
	homedir = getMudletHomeDir()

	lfs.mkdir(homedir .. &quot;/daily&quot;)
	lfs.mkdir(homedir .. &quot;/dns&quot;)
	lfs.mkdir(homedir .. &quot;/temp&quot;)

	players = {}
	igplayers = {}
	teleports = {}
	admins = {}
	friends = {}
	locations = {}
	server = {}
	invTemp = {}
	hotspots = {}
	resetRegions = {}
	gimmeQueuedCommands = {}
	lastHotspots = {}
	villagers = {}
	owners = {}
	mods = {}
	shop = {}
	shopCategories = {}
	stackLimits = {}

	openUserWindow(server.windowGMSG) 
	openUserWindow(server.windowDebug) 
	openUserWindow(server.windowLists) 
	openUserWindow(server.windowPlayers) 
	openUserWindow(server.windowAlerts) 

	dbug(&quot;Resetting Bot (full wipe)&quot;)

	yourname = &quot;12345678901234567&quot;

	if (ExceptionCount == nil) then
		ExceptionCount = 0
	end

	AnnounceBot = true
	botStarted = os.time()
	faultyGimme = false
	faultyGMSG = false
	gimmeHell = 0
	server.scheduledRestartPaused  = false
	server.scheduledRestart = false
	ExceptionRebooted = false

	if server.lottery == nil then
		server.lottery = 0
	end

	ResetBot()
	initServer()
end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>irc help</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function irc_commands()
	calledFunction = &quot;irc_commands&quot;

	local id
	id = LookupOfflinePlayer(irc_params[1], &quot;all&quot;)

	irc_QueueMsg(irc_params[1], &quot;Commands that output to IRC:&quot;)
	irc_QueueMsg(irc_params[1], &quot;============================&quot;)

	if (accessLevel(id) &gt; 2) then
		irc_QueueMsg(irc_params[1], &quot;help (display this list)&quot;)
		irc_QueueMsg(irc_params[1], &quot;admins (list admins)&quot;)
		irc_QueueMsg(irc_params[1], &quot;day or date or time (show the game date and time)&quot;)		
		irc_QueueMsg(irc_params[1], &quot;type say &lt;something&gt; to talk to players ingame&quot;)
		irc_QueueMsg(irc_params[1], &quot;date, time, day (display the current game date and time)&quot;)
		irc_QueueMsg(irc_params[1], &quot;locations&quot;)
		irc_QueueMsg(irc_params[1], &quot;mods (list mods)&quot;)
		irc_QueueMsg(irc_params[1], &quot;new players (list new players in the last 2 days)&quot;)		
		irc_QueueMsg(irc_params[1], &quot;nuke irc (clear all queued irc bot spam directed to you)&quot;)		
		irc_QueueMsg(irc_params[1], &quot;owners (list owners)&quot;)		
		irc_QueueMsg(irc_params[1], &quot;resetzones&quot;)
		irc_QueueMsg(irc_params[1], &quot;uptime (server and bot running times)&quot;)
		irc_QueueMsg(irc_params[1], &quot;who (list in-game players)&quot;)
		irc_QueueMsg(irc_params[1], &quot;server status (some daily stats)&quot;)		
		irc_QueueMsg(irc_params[1], &quot;shop categories  (list categories)&quot;)
		irc_QueueMsg(irc_params[1], &quot;shop &lt;category&gt;  (list items in a category)&quot;)
		irc_QueueMsg(irc_params[1], &quot;shop &lt;item&gt;  (list all items that partially match what you type)&quot;)
		irc_QueueMsg(irc_params[1], &quot;villages (list)&quot;)
		irc_QueueMsg(irc_params[1], &quot;villagers (list villages and villagers)&quot;)
		irc_QueueMsg(name, &quot;&quot;)
		return
	end

	irc_QueueMsg(irc_params[1], &quot;help (display this list)&quot;)
	irc_QueueMsg(irc_params[1], &quot;help topics (display help topics only)&quot;)
	irc_QueueMsg(irc_params[1], &quot;help commands (for ingame commands that you can also do in irc)&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
	irc_QueueMsg(irc_params[1], &quot;add player &lt;playername&gt; &lt;password&gt; (create a password for an irc player to authenticate on irc).&quot;)
	irc_QueueMsg(irc_params[1], &quot;bases (list all bases and their regions)&quot;)
	irc_QueueMsg(irc_params[1], &quot;check dns player &lt;player&gt; ip &lt;ip&gt; (tell bot to do a dns check on a player)&quot;)
	irc_QueueMsg(irc_params[1], &quot;claims (list all players more than 1 placed claim and their total)&quot;)
	irc_QueueMsg(irc_params[1], &quot;claims &lt;player&gt; (list each placed claim for a player with coords)&quot;)
	irc_QueueMsg(irc_params[1], &quot;date, time, day (display the current game date and time)&quot;)
	irc_QueueMsg(irc_params[1], &quot;donors (list donors known to the bot)&quot;)
	irc_QueueMsg(irc_params[1], &quot;friends &lt;player name&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;info &lt;player name&gt; (lots of quick info about a player)&quot;)
	irc_QueueMsg(irc_params[1], &quot;inv &lt;player name&gt; (current inventory of player)&quot;)
	irc_QueueMsg(irc_params[1], &quot;view alerts (lists the last 20) add a number for more&quot;)
	irc_QueueMsg(irc_params[1], &quot;list bad items&quot;)
	irc_QueueMsg(irc_params[1], &quot;locations (list)&quot;)
	irc_QueueMsg(irc_params[1], &quot;new players&quot;)
	irc_QueueMsg(irc_params[1], &quot;pay &lt;amount&gt; to &lt;player&gt; (gift zennies to a player or admin)&quot;)	
	irc_QueueMsg(irc_params[1], &quot;permaban &lt;playername&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;player &lt;player name&gt; friend &lt;player to be friended&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;player &lt;player name&gt; unfriend &lt;player to be unfriended&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;player &lt;player name&gt; (info on a specific player)&quot;)
	irc_QueueMsg(irc_params[1], &quot;players (master list of all players)&quot;)
	irc_QueueMsg(irc_params[1], &quot;prisoners (list)&quot;)
	irc_QueueMsg(irc_params[1], &quot;remove permaban &lt;playername&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;resetzones (list)&quot;)
	irc_QueueMsg(irc_params[1], &quot;server stats&quot;)
	irc_QueueMsg(irc_params[1], &quot;status &lt;player name&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;stealth translate &lt;player&gt; (ingame chat from the player will not be translated to irc only)&quot;)			
	irc_QueueMsg(irc_params[1], &quot;stop translating &lt;player&gt; (ingame chat from the player will not be translated)&quot;)
	irc_QueueMsg(irc_params[1], &quot;teleports (list)&quot;)
	irc_QueueMsg(irc_params[1], &quot;translate &lt;player&gt; (ingame chat from the player will be translated ingame)&quot;)	
	irc_QueueMsg(irc_params[1], &quot;visits&quot;)
	irc_QueueMsg(irc_params[1], &quot;watch player &lt;player&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;stop watching &lt;player&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;who (list in-game players)&quot;)
	irc_QueueMsg(irc_params[1], &quot;uptime&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
	irc_QueueMsg(irc_params[1], &quot;type say &lt;something&gt; to talk to players ingame&quot;)
	irc_QueueMsg(irc_params[1], &quot;type pm &lt;playername or id&gt; PM a player ingame&quot;)
	irc_QueueMsg(irc_params[1], &quot;type con &lt;server command&gt; (send a command to the server in console&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
	return
end


function irc_HelpTopics()
	local id
	id = LookupOfflinePlayer(irc_params[1], &quot;all&quot;)
	if (accessLevel(id) &gt; 2) then return end

	irc_QueueMsg(irc_params[1], &quot;Commands by topic:&quot;)
	irc_QueueMsg(irc_params[1], &quot;==================&quot;)
	irc_QueueMsg(irc_params[1], &quot;help announcements&quot;)
	irc_QueueMsg(irc_params[1], &quot;help bad items&quot;)
	irc_QueueMsg(irc_params[1], &quot;help commands&quot;)
	irc_QueueMsg(irc_params[1], &quot;help custom commands&quot;)
	irc_QueueMsg(irc_params[1], &quot;help CSI&quot;)
	irc_QueueMsg(irc_params[1], &quot;help donors&quot;)
	irc_QueueMsg(irc_params[1], &quot;help motd&quot;)
	irc_QueueMsg(irc_params[1], &quot;help server&quot;)	
	irc_QueueMsg(irc_params[1], &quot;help shop&quot;)
	irc_QueueMsg(irc_params[1], &quot;help watchlist&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_HelpServer()
	local id
	id = LookupOfflinePlayer(irc_params[1], &quot;all&quot;)
	if (accessLevel(id) &gt; 2) then return end

	irc_QueueMsg(irc_params[1], &quot;Customising the bot and server&quot;)
	irc_QueueMsg(irc_params[1], &quot;==============================&quot;)
	irc_QueueMsg(irc_params[1], &quot;reset bot (Do after a wipe. BE CAREFUL. This will make the bot forgot things like bases.)&quot;)	
	irc_QueueMsg(irc_params[1], &quot;server ip &lt;internet address of server&gt; (to view just type server)&quot;)
	irc_QueueMsg(irc_params[1], &quot;set rules &lt;new rules&gt; (to view just type rules)&quot;)
	irc_QueueMsg(irc_params[1], &quot;See help motd for setting the message of the day&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_HelpCSI()
	local id
	id = LookupOfflinePlayer(irc_params[1], &quot;all&quot;)
	if (accessLevel(id) &gt; 2) then return end

	irc_QueueMsg(irc_params[1], &quot;Forensic Investigative Tools&quot;)
	irc_QueueMsg(irc_params[1], &quot;============================&quot;)
	irc_QueueMsg(irc_params[1], &quot;claims &lt;player&gt; (list each placed claim for a player with coords)&quot;)	
	irc_QueueMsg(irc_params[1], &quot;info &lt;player name&gt; (lots of quick info about a player)&quot;)
	irc_QueueMsg(irc_params[1], &quot;inv &lt;player name&gt; (current inventory of player)&quot;)	
	irc_QueueMsg(irc_params[1], &quot;near &lt;player&gt; range &lt;number&gt; (list bases and players near a player.  Range is optional and defaults to 200 metres.&quot;)	
	irc_QueueMsg(irc_params[1], &quot;show inventory (See built in help. Just type show inventory)&quot;)
	irc_QueueMsg(irc_params[1], &quot;who visited (See built in help. Just type who visited)&quot;)
	irc_QueueMsg(irc_params[1], &quot;view alerts (lists the last 20) add a number for more&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_HelpAnnouncements()
	local id
	id = LookupOfflinePlayer(irc_params[1], &quot;all&quot;)
	if (accessLevel(id) &gt; 2) then return end

	irc_QueueMsg(irc_params[1], &quot;Announcements Management&quot;)
	irc_QueueMsg(irc_params[1], &quot;========================&quot;)
	irc_QueueMsg(irc_params[1], &quot;announcements (view a numbered list of the server announcements).&quot;)
	irc_QueueMsg(irc_params[1], &quot;add announcement &lt;your message here&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;delete announcement &lt;number&gt; (from the numbered list given with announcements)&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_HelpCustomCommands()
	local id
	id = LookupOfflinePlayer(irc_params[1], &quot;all&quot;)
	if (accessLevel(id) &gt; 2) then return end

	irc_QueueMsg(irc_params[1], &quot;Custom Commands&quot;)
	irc_QueueMsg(irc_params[1], &quot;===============&quot;)
	irc_QueueMsg(irc_params[1], &quot;You can create commands that send a private message.&quot;)
	irc_QueueMsg(irc_params[1], &quot;Type custom commands (list them)[-]&quot;)
	irc_QueueMsg(irc_params[1], &quot;Type add command &lt;command&gt; level &lt;access level&gt; message &lt;message&gt;.[-]&quot;)
	irc_QueueMsg(irc_params[1], &quot;Type remove command &lt;command&gt;.[-]&quot;)
	irc_QueueMsg(irc_params[1], &quot;Access level is optional and defaults to 99.[-]&quot;)
	irc_QueueMsg(irc_params[1], &quot;See help access for the list of access levels.[-]&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_HelpBadItems()
	local id
	id = LookupOfflinePlayer(irc_params[1], &quot;all&quot;)
	if (accessLevel(id) &gt; 2) then return end

	irc_QueueMsg(irc_params[1], &quot;Bad Item (uncraftable) Management&quot;)
	irc_QueueMsg(irc_params[1], &quot;=================================&quot;)
	irc_QueueMsg(irc_params[1], &quot;list bad items&quot;)
	irc_QueueMsg(irc_params[1], &quot;add bad item &lt;name of item as given by server&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;remove bad item &lt;name of item as given by server&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
	irc_QueueMsg(irc_params[1], &quot;Any player caught with an item on this list will be sent to timeout or banned.&quot;)
	irc_QueueMsg(irc_params[1], &quot;You can allow a player to have these items (except bedrock and smokestorm) with..&quot;)
	irc_QueueMsg(irc_params[1], &quot;exclude &lt;player&gt; (They can have bad items in inventory)&quot;)
	irc_QueueMsg(irc_params[1], &quot;include &lt;player&gt; (They may not have bad items on them)&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_HelpCommands()
	local id
	id = LookupOfflinePlayer(irc_params[1], &quot;all&quot;)
	if (accessLevel(id) &gt; 2) then return end

	irc_QueueMsg(irc_params[1], &quot;Remote server commands:&quot;)
	irc_QueueMsg(irc_params[1], &quot;=======================&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /arrest &lt;playername&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /deactivatetp &lt;teleport&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /activatetp &lt;teleport&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /gimme gimme&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /gimme off&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /gimme on&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /gimme peace&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /gimme reset&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /ignoreadmins&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /includeadmins&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /killtp &lt;teleport&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /owntp &lt;teleport&gt; &lt;playername&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /privatetp &lt;teleport&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /protect &lt;playername&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /publictp &lt;teleport&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /release &lt;playername&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /reset gimmehell&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /resettimers &lt;playername&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /return &lt;playername&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /sendhome &lt;playername&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /set base size &lt;size&gt; &lt;playername&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /timeout &lt;playername&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /unprotect &lt;playername&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_HelpMOTD()
	local id
	id = LookupOfflinePlayer(irc_params[1], &quot;all&quot;)
	if (accessLevel(id) &gt; 2) then return end

	irc_QueueMsg(irc_params[1], &quot;Message Of The Day Management&quot;)
	irc_QueueMsg(irc_params[1], &quot;=============================&quot;)
	irc_QueueMsg(irc_params[1], &quot;motd (view the current message of the day if set).&quot;)
	irc_QueueMsg(irc_params[1], &quot;motd clear (or motd delete).&quot;)
	irc_QueueMsg(irc_params[1], &quot;set motd followed by anything else sets the message of the day.&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_HelpWatchlist()
	local id
	id = LookupOfflinePlayer(irc_params[1], &quot;all&quot;)
	if (accessLevel(id) &gt; 2) then return end

	irc_QueueMsg(irc_params[1], &quot;Watchlist Management&quot;)
	irc_QueueMsg(irc_params[1], &quot;====================&quot;)
	irc_QueueMsg(irc_params[1], &quot;Changes to player inventories can be sent to a channel called #watch&quot;)
	irc_QueueMsg(irc_params[1], &quot;New players and watched players are automatically included.&quot;)
	irc_QueueMsg(irc_params[1], &quot;To add a player type watch &lt;player&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;To remove them type stop watching &lt;player&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;The bot will automatically add players that are detected with certain items in unusual quantities.&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_HelpDonors()
	local id
	id = LookupOfflinePlayer(irc_params[1], &quot;all&quot;)
	if (accessLevel(id) &gt; 2) then return end

	irc_QueueMsg(irc_params[1], &quot;Donor Management&quot;)
	irc_QueueMsg(irc_params[1], &quot;================&quot;)
	irc_QueueMsg(irc_params[1], &quot;donors (list donors known to the bot)&quot;)
	irc_QueueMsg(irc_params[1], &quot;add donor &lt;player&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;remove donor &lt;player&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_HelpShop()
	local id
	id = LookupOfflinePlayer(irc_params[1], &quot;all&quot;)
	if (accessLevel(id) &gt; 2) then return end

	irc_QueueMsg(irc_params[1], &quot;Shop Management&quot;)
	irc_QueueMsg(irc_params[1], &quot;===============&quot;)
	irc_QueueMsg(irc_params[1], &quot;shop categories (list categories)&quot;)
	irc_QueueMsg(irc_params[1], &quot;shop &lt;category&gt; (list items in a category)&quot;)
	irc_QueueMsg(irc_params[1], &quot;shop &lt;item&gt; (list all items that partially match what you type)&quot;)
	irc_QueueMsg(irc_params[1], &quot;shop add category &lt;food&gt; code=&lt;code&gt; (1 or more letters only)&quot;)
	irc_QueueMsg(irc_params[1], &quot;shop remove category &lt;food&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;shop change category &lt;old category&gt; &lt;new category&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;shop add item &lt;item&gt; category=food price=100 stock=50&quot;)
	irc_QueueMsg(irc_params[1], &quot;shop remove item &lt;item&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;shop price &lt;item&gt; &lt;number&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;shop restock &lt;item&gt; +-&lt;number&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;shop special &lt;item&gt; &lt;number&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;shop variation &lt;item&gt; &lt;number&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;open shop&quot;)
	irc_QueueMsg(irc_params[1], &quot;close shop (staff can still access)&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>30MinuteTimer</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function ThirtyMinuteTimer()
	-- save the world (and the kitties)
	send(&quot;sa&quot;)
end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>StartupBot</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	          This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function checkData()
	if tablelength(shopCategories) == 0 then
		loadShopCategories()		
	end

	if tablelength(owners) == 0 then
		send(&quot;admin list&quot;)
	end

	if tonumber(server.ServerPort) == 0 then
		send(&quot;gg&quot;)
	end

	if (playersOnline &gt; 0) then
		if 	tablelength(igplayers) == 0 then
			igplayers = {}
			send(&quot;lp&quot;)
		end
	end
end


function login()
	local debug
	debug = false
	debugdb = false

	tempTimer( 30, [[checkData()]] )

	stackLimits = {}

	if type(server) ~= &quot;table&quot; then
	  server = {}
	end

	if (botStarted == nil) then
		botStarted = os.time()

		openDB()

		initError = true
		serverTime = &quot;&quot;
		feralWarning = false
		scheduledReboot = false
		homedir = getMudletHomeDir()

		loadServer()

		openUserWindow(server.windowGMSG) 
		openUserWindow(server.windowDebug) 
		openUserWindow(server.windowLists) 
		openUserWindow(server.windowPlayers) 
		openUserWindow(server.windowAlerts) 

		if not botDisabled and botTick == nil then
			botTick = readBotTick()
			tempTimer( 58, [[checkBotTick()]] )
		end

		if debug then dbug(&quot;debug login 1\n&quot;) end

		if type(igplayers) ~= &quot;table&quot; then
		  igplayers = {}
		end

		if type(owners) ~= &quot;table&quot; then
		  owners = {}
		end

		if type(admins) ~= &quot;table&quot; then
		  admins = {}
		end

		if type(mods) ~= &quot;table&quot; then
		  mods = {}
		end

		if type(friends) ~= &quot;table&quot; then
		  friends = {}
		end

		if type(invTemp) ~= &quot;table&quot; then
		  invTemp = {}
		end

		if type(gimmePrizes) ~= &quot;table&quot; then
		  gimmePrizes = {}
		end

		if type(hotspots) ~= &quot;table&quot; then
		  hotspots = {}
		end

		if type(badItems) ~= &quot;table&quot; then
		  badItems = {}
		end

		if type(restrictedItems) ~= &quot;table&quot; then
		  restrictedItems = {}
		end

		if type(lastHotspots) ~= &quot;table&quot; then
			lastHotspots = {}
		end

		if type(villagers) ~= &quot;table&quot; then
		  villagers = {}
		end

		if type(shopCategories) ~= &quot;table&quot; then
			shopCategories = {}
		end

		if type(stackLimits) ~= &quot;table&quot; then
			stackLimits = {}
		end

		if type(customCommands) ~= &quot;table&quot; then
		  customCommands = {}
		end

		if debug then dbug(&quot;debug login 2\n&quot;) end

		lfs.mkdir(homedir .. &quot;/daily&quot;)
		lfs.mkdir(homedir .. &quot;/dns&quot;)
		lfs.mkdir(homedir .. &quot;/proxies&quot;)
		lfs.mkdir(homedir .. &quot;/temp&quot;)
		lfs.mkdir(homedir .. &quot;/scripts&quot;)

		-- add your steam id here so you can debug using your name
		yourname = &quot;12345678901234567&quot;

		if (ExceptionCount == nil) then
			ExceptionCount = 0
		end

		AnnounceBot = true
		faultyGimme = false
		faultyGMSG = false
		gimmeHell = 0
		server.scheduledRestartPaused  = false
		server.scheduledRestart = false
		ExceptionRebooted = false

		-- load tables
		loadTables()

		if debug then dbug(&quot;debug login 5\n&quot;) end

		tempTimer( 2, [[send(&quot;ban list&quot;)]] )
		dbug(&quot;ban list&quot;)

		tempTimer( 5, [[send(&quot;lkp&quot;)]] )
		dbug(&quot;lkp&quot;)

		tempTimer( 8, [[send(&quot;llp&quot;)]] )
		dbug(&quot;llp&quot;)

		tempTimer( 8, [[send(&quot;admin list&quot;)]] )
		dbug(&quot;admin list&quot;)

		tempTimer( 10, [[send(&quot;pm IPCHECK&quot;)]] )
		dbug(&quot;ipcheck&quot;)

		tempTimer( 11, [[send(&quot;lpf&quot;)]] )
		dbug(&quot;coppi test&quot;)

		tempTimer( 12, [[send(&quot;gg&quot;)]] )
		dbug(&quot;gg&quot;)

		nextRebootTest = nil
		irc_QueueMsg(server.ircMain, &quot;Logging in to server..&quot;)

		initError = false
	end

	if debug then dbug(&quot;debug login end\n&quot;) end
end

login()</script>
            <eventHandlerList>
                <string>sysConnectionEvent</string>
            </eventHandlerList>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>Teleport functions</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function forgetLastTP(steam)
	if igplayers[steam] then
		igplayers[steam].lastCatchTimestamp = os.time() + 50
		igplayers[steam].lastTP = nil
	end
end


function prepareTeleport(steam, cmd)
	if igplayers[steam] then
		igplayers[steam].lastCatchTimestamp = os.time() + 50
		igplayers[steam].lastTP = cmd
	end
end


function teleport(cmd, forced)
	local id, coords, temp, dist
	id = string.sub(cmd, 6, 22)
	dist = nil

	-- disable some stuff because we are teleporting
	igplayers[id].location = nil

	coords = string.sub(cmd, 24)
	coords = string.split(coords, &quot; &quot;)

	-- don't teleport the player if the coords are 0 0 0
	if tonumber(coords[1]) == 0 and tonumber(coords[2]) == 0 and tonumber(coords[3]) == 0 then
		return
	end

	-- if an admin is following a player (using the /near command) and they teleport away, stop following the player
	if igplayers[id].following ~= nil then igplayers[id].following = nil end

	igplayers[id].tp = 1
	igplayers[id].hackerScore = 0

	if coords[3] ~= nil then
		if distancexz(igplayers[id].xPos, igplayers[id].zPos, coords[1], coords[3]) &gt; 200 then
			send(&quot;tele &quot; .. id .. &quot; &quot; .. coords[1] .. &quot; -500 &quot; .. coords[3])
			tempTimer( 8, [[send(&quot;]] .. cmd .. [[&quot;)]] )

			message(&quot;pm &quot; .. id .. &quot; [&quot; .. server.chatColour .. &quot;]Teleporting now.  Please wait.[-]&quot;)
		else
			send(cmd)
		end
	else
		send(cmd)
	end

	return true
end


function fallCatcher(steam, x, y, z)
	local coords, temp, dist

	if players[steam].timeout == true or players[steam].botTimeout == true or igplayers[steam].following ~= nil then
		return
	end

	-- world fall catcher
	if igplayers[steam].lastCatchTimestamp - os.time() &lt; 0 then
		if (tonumber(y) &lt; 0 and players[steam].timeout == false and players[steam].botTimeout == false and igplayers[steam].sessionPlaytime &gt; 5)  then
			igplayers[steam].lastCatchTimestamp = os.time() + 50
		
			if igplayers[steam].lastTP ~= nil then
				send(igplayers[steam].lastTP)
				return
			end

			sql = &quot;SELECT count(*) as num, x,y,z FROM tracker WHERE steam = &quot; .. steam .. &quot; and y &gt; 0 and y &lt; 255 and ((abs(x - &quot; .. x .. &quot;) &gt; 2 and abs(x - &quot; .. x .. &quot;) &lt; 30) and (abs(z - &quot; .. z .. &quot;) &gt; 2 and abs(z - &quot; .. z .. &quot;) &lt; 30)) GROUP BY y ORDER BY num DESC limit 0,1&quot;

			cursor,errorString = conn:execute(sql)
			if cursor:numrows() &gt; 0 then
				row = cursor:fetch({}, &quot;a&quot;)
				cmd = &quot;&quot;
				
				while row do
					cmd = (&quot;tele &quot; .. steam .. &quot; &quot; .. row.x .. &quot; &quot; .. row.y + 1 .. &quot; &quot; .. row.z)
					
					if cmd ~= &quot;&quot; then
						send(cmd)
						return
					else
						message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You have fallen through the ground. Relog to rescue yourself.[-]&quot;)
					end

					row = cursor:fetch(row, &quot;a&quot;)	
				end
			end

			return
		end
	end
end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>Lua Tables</name>
            <packageName></packageName>
            <script>function saveLuaTables()
	dbug(&quot;saving Lua tables&quot;)
	table.save(homedir .. &quot;/players.lua&quot;, players)
	table.save(homedir .. &quot;/teleports.lua&quot;, teleports)
	table.save(homedir .. &quot;/friends.lua&quot;, friends)
	table.save(homedir .. &quot;/locations.lua&quot;, locations)
	table.save(homedir .. &quot;/server.lua&quot;, server)
	table.save(homedir .. &quot;/gimmePrizes.lua&quot;, gimmePrizes)
	table.save(homedir .. &quot;/badItems.lua&quot;, badItems)
	table.save(homedir .. &quot;/hotspots.lua&quot;, hotspots)
	table.save(homedir .. &quot;/resetRegions.lua&quot;, resetRegions)
	table.save(homedir .. &quot;/shopCategories.lua&quot;, shopCategories)
	table.save(homedir .. &quot;/villagers.lua&quot;, villagers)
	dbug(&quot;finished saving Lua tables&quot;)
end


function importServer()
	dbug(&quot;Importing Server&quot;)
	message(&quot;say [&quot; .. server.chatColour .. &quot;]Importing server[-]&quot;)
	conn:execute(&quot;DELETE FROM server)&quot;)
	conn:execute(&quot;INSERT INTO server (ircMain, ircAlerts, ircWatch, rules, shopCountdown, gimmePeace, allowGimme, mapSize, baseCooldown, MOTD, allowShop, chatColour, botName, lottery, allowWaypoints, prisonSize, baseSize) VALUES ('&quot; .. escape(server.ircMain) .. &quot;','&quot; .. escape(server.ircAlerts) .. &quot;','&quot; .. escape(server.ircWatch) .. &quot;','&quot; .. escape(server.rules) .. &quot;',0,&quot; .. dbBool(server.gimmePeace) .. &quot;,&quot; .. dbBool(server.allowGimme) .. &quot;,&quot; .. server.mapSize .. &quot;,&quot; .. server.baseCooldown .. &quot;,'&quot; .. escape(server.MOTD) .. &quot;',&quot; .. dbBool(server.allowShop) .. &quot;,'&quot; .. server.chatColour .. &quot;','&quot; .. escape(server.botName) .. &quot;',&quot; .. server.lottery .. &quot;,&quot; .. dbBool(server.allowWaypoints) .. &quot;,&quot; .. server.prisonSize .. &quot;,&quot; .. server.baseSize .. &quot;)&quot;)

	-- reload from db to grab defaults for any missing data
	loadServer()

	openUserWindow(server.windowGMSG) 
	openUserWindow(server.windowDebug) 
	openUserWindow(server.windowLists) 
	openUserWindow(server.windowPlayers) 
	openUserWindow(server.windowAlerts) 
end


function importShopCategories()
	dbug(&quot;Importing Shop Categories&quot;)
	message(&quot;say [&quot; .. server.chatColour .. &quot;]Importing shop categories[-]&quot;)

	for k,v in pairs(shopCategories) do
		conn:execute(&quot;INSERT INTO shopCategories (category, idx, code) VALUES ('&quot; .. escape(k) .. &quot;',&quot; .. v.idx .. &quot;,'&quot; .. v.code .. &quot;')&quot;)
	end

	dbug(&quot;Shop Categories Imported&quot;)
end


function importPlayers()
	dbug(&quot;Importing Players&quot;)
	message(&quot;say [&quot; .. server.chatColour .. &quot;]Importing players[-]&quot;)

	for k,v in pairs(players) do
		conn:execute(&quot;INSERT INTO players (steam, id, name) VALUES (&quot; .. k .. &quot;,&quot; .. v.id .. &quot;,'&quot; .. escape(v.name) .. &quot;')&quot;)		
		fixMissingPlayer(k)
		updatePlayer(k)
	end

	dbug(&quot;Players Imported&quot;)
end


function importTeleports()
	dbug(&quot;Importing Teleports&quot;)
	message(&quot;say [&quot; .. server.chatColour .. &quot;]Importing teleports[-]&quot;)

	for k,v in pairs(teleports) do
		conn:execute(&quot;INSERT INTO teleports (name, active, public, oneway, friends, x, y, z, dx, dy, dz, owner) VALUES ('&quot; .. escape(v.name) .. &quot;',&quot; .. dbBool(v.active) .. &quot;,&quot; .. dbBool(v.public) .. &quot;,&quot; .. dbBool(v.oneway) .. &quot;,&quot; .. dbBool(v.friends) .. &quot;,&quot; .. v.x .. &quot;,&quot; .. v.y .. &quot;,&quot; .. v.z .. &quot;,&quot; .. v.dx .. &quot;,&quot; .. v.dy .. &quot;,&quot; .. v.owner .. &quot;)&quot;)
	end
end


function importLocations()
	local sql, fields, values

	dbug(&quot;Importing Locations&quot;)
	message(&quot;say [&quot; .. server.chatColour .. &quot;]Importing locations[-]&quot;)

	for k,v in pairs(locations) do
		fields = &quot;name, x, y, z, public, active&quot;
		values = &quot;'&quot; .. escape(v.name) .. &quot;',&quot; .. v.x .. &quot;,&quot; .. v.y .. &quot;,&quot; .. v.z .. &quot;,&quot; .. dbBool(v.public) .. &quot;,&quot; .. dbBool(v.active)

		if v.protect ~= nil then
			fields = fields .. &quot;, protected&quot;
			values = values .. &quot;,&quot; .. dbBool(v.protect)
		end	

		if v.village ~= nil then
			fields = fields .. &quot;, village&quot;
			values = values .. &quot;,&quot; .. dbBool(v.village)
		end	

		if v.pvp ~= nil then
			fields = fields .. &quot;, pvp&quot;
			values = values .. &quot;,&quot; .. dbBool(v.pvp)
		end	

		if v.allowBase ~= nil then
			fields = fields .. &quot;, allowBase&quot;
			values = values .. &quot;,&quot; .. dbBool(v.allowBase)
		end	

		if v.accessLevel ~= nil then
			fields = fields .. &quot;, accessLevel&quot;
			values = values .. &quot;,&quot; .. dbBool(v.accessLevel)
		end	

		if v.owner ~= nil then
			fields = fields .. &quot;, owner&quot;
			values = values .. &quot;,&quot; .. v.owner
		end	

		if v.mayor ~= nil then
			fields = fields .. &quot;, mayor&quot;
			values = values .. &quot;,&quot; .. v.mayor
		end	

		if v.protectSize ~= nil then
			fields = fields .. &quot;, protectSize&quot;
			values = values .. &quot;,&quot; .. v.protectSize
		end	

		if v.killZombies ~= nil then
			fields = fields .. &quot;, killZombies&quot;
			values = values .. &quot;,&quot; .. dbBool(v.killZombies)
		end	
	
		sql = &quot;INSERT INTO locations (&quot; .. fields .. &quot;) VALUES (&quot; .. values .. &quot;)&quot;

		conn:execute(sql)
	end

	dbug(&quot;Locations Imported&quot;)
end


function importFriends()
	local friendlist, i

	dbug(&quot;Importing Friends&quot;)
	message(&quot;say [&quot; .. server.chatColour .. &quot;]Importing friends[-]&quot;)

	for k,v in pairs(friends) do
		friendlist = string.split(v.friends, &quot;,&quot;)

		for i=1,table.maxn(friendlist),1 do
			if friendlist[i] ~= &quot;&quot; then
				conn:execute(&quot;INSERT INTO friends (steam, friend) VALUES (&quot; .. k .. &quot;,&quot; .. friendlist[i] .. &quot;)&quot;)
			end
		end
	end

	dbug(&quot;Friends Imported&quot;)
end


function importVillagers()
	dbug(&quot;Importing Villagers&quot;)
	message(&quot;say [&quot; .. server.chatColour .. &quot;]Importing villagers[-]&quot;)

	for k,v in pairs(villagers) do
		conn:execute(&quot;INSERT INTO villagers (steam, village) VALUES (&quot; .. k .. &quot;,'&quot; .. escape(v.village) .. &quot;')&quot;)
	end

	dbug(&quot;Villagers Imported&quot;)
end


function importHotspots()
	dbug(&quot;Importing Hotspots&quot;)
	message(&quot;say [&quot; .. server.chatColour .. &quot;]Importing hotspots[-]&quot;)

	for k,v in pairs(hotspots) do
		if v.radius then
			conn:execute(&quot;INSERT INTO hotspots (hotspot, x, y, z, owner, size) VALUES ('&quot; .. escape(v.message) .. &quot;',&quot; .. v.x .. &quot;,&quot; .. v.y .. &quot;,&quot; .. v.z .. &quot;,&quot; .. v.owner .. &quot;,&quot; .. v.radius .. &quot;)&quot;)
		else
			conn:execute(&quot;INSERT INTO hotspots (hotspot, x, y, z, owner) VALUES ('&quot; .. escape(v.message) .. &quot;',&quot; .. v.x .. &quot;,&quot; .. v.y .. &quot;,&quot; .. v.z .. &quot;,&quot; .. v.owner .. &quot;)&quot;)
		end
	end

	dbug(&quot;Hotspots Imported&quot;)
end


function importResets()
	dbug(&quot;Importing Reset Zones&quot;)
	message(&quot;say [&quot; .. server.chatColour .. &quot;]Importing reset zones[-]&quot;)

	for k,v in pairs(resetRegions) do
		conn:execute(&quot;INSERT INTO resetZones (region) VALUES ('&quot; .. escape(k) .. &quot;')&quot;)
	end

	dbug(&quot;Resets Imported&quot;)
end


function importBaditems()
	dbug(&quot;Importing Bad Items&quot;)
	message(&quot;say [&quot; .. server.chatColour .. &quot;]Importing bad items list[-]&quot;)

	for k,v in pairs(badItems) do
		conn:execute(&quot;INSERT INTO badItems (item) VALUES ('&quot; .. escape(k) .. &quot;')&quot;)
	end

	dbug(&quot;Bad Items Imported&quot;)
end


function importLuaData()
	dbug(&quot;Importing Lua Tables&quot;)
	message(&quot;say [&quot; .. server.chatColour .. &quot;]Importing data from Lua tables..[-]&quot;)

--[[
	server = {}
	players = {}
	teleports = {}
	friends = {}
	locations = {}
	hotspots = {}
	villagers = {}
	shopCategories = {}
	languages = {}
	resetRegions = {}
--]]

dbug(&quot;import 1&quot;)
	dbug(&quot;Loading server&quot;)
	table.load(homedir .. &quot;/server.lua&quot;, server)
dbug(&quot;import 2&quot;)
	dbug(&quot;Loading players&quot;)
	table.load(homedir .. &quot;/players.lua&quot;, players)
dbug(&quot;import 3&quot;)
	dbug(&quot;Loading teleports&quot;)
	table.load(homedir .. &quot;/teleports.lua&quot;, teleports)
dbug(&quot;import 4&quot;)
	dbug(&quot;Loading friends&quot;)
	table.load(homedir .. &quot;/friends.lua&quot;, friends)
dbug(&quot;import 5&quot;)
	dbug(&quot;Loading locations&quot;)
	table.load(homedir .. &quot;/locations.lua&quot;, locations)
dbug(&quot;import 6&quot;)
	dbug(&quot;Loading hotspots&quot;)
	table.load(homedir .. &quot;/hotspots.lua&quot;, hotspots)
dbug(&quot;import 7&quot;)
	dbug(&quot;Loading villagers&quot;)
	table.load(homedir .. &quot;/villagers.lua&quot;, villagers)
dbug(&quot;import 9&quot;)
	dbug(&quot;Loading shop categories&quot;)
	table.load(homedir .. &quot;/shopCategories.lua&quot;, shopCategories)
dbug(&quot;import 11&quot;)
	dbug(&quot;Loading reset zones&quot;)
	table.load(homedir .. &quot;/resetRegions.lua&quot;, resetRegions)
dbug(&quot;import 12&quot;)
	dbug(&quot;Loading bad items&quot;)
	table.load(homedir .. &quot;/badItems.lua&quot;, badItems)
dbug(&quot;import 13&quot;)
	conn:execute(&quot;DELETE FROM badItems&quot;)
	conn:execute(&quot;DELETE FROM friends&quot;)
	conn:execute(&quot;DELETE FROM hotspots&quot;)
	conn:execute(&quot;DELETE FROM locations&quot;)
	conn:execute(&quot;DELETE FROM players&quot;)
	conn:execute(&quot;DELETE FROM resetZones&quot;)
	conn:execute(&quot;DELETE FROM shopCategories&quot;)
	conn:execute(&quot;DELETE FROM teleports&quot;)
	conn:execute(&quot;DELETE FROM villagers&quot;)

dbug(&quot;import 4&quot;)
	importPlayers()
dbug(&quot;import 5&quot;)
	importBaditems()
dbug(&quot;import 6&quot;)
	importHotspots()
dbug(&quot;import 8&quot;)
	importLocations()
dbug(&quot;import 9&quot;)
	importResets()
dbug(&quot;import 12&quot;)
	importTeleports()
dbug(&quot;import 13&quot;)
	importVillagers()
dbug(&quot;import 14&quot;)
	importFriends()
dbug(&quot;import 15&quot;)
	importShopCategories()


	dbug(&quot;Import of Lua tables Complete&quot;)
	message(&quot;say [&quot; .. server.chatColour .. &quot;]Import complete.[-]&quot;)
end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_bookmarks</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
bookmark commands
=============
list bookmarks
bookmark
bk
--]]


function gmsg_bookmarks()
	calledFunction = &quot;gmsg_bookmark&quot;

	local note, pid, debug

	debug = false

if debug then display (&quot;debug bookmarks 1\n&quot;) end

	if gmsgvars.words[1] == &quot;list&quot; and gmsgvars.words[2] == &quot;bookmarks&quot; then
		pid = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;bookmarks &quot;) + 10)
		pid = string.trim(pid)
		pid = LookupPlayer(pid)

		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			pid = gmsgvars.playerid
		end

		if (pid == nil) then 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No player found with that name.[-]&quot;)
			faultyGMSG = false
			return true
		else
			cursor,errorString = conn:execute(&quot;select * from bookmarks where steam = &quot; .. pid)
			row = cursor:fetch({}, &quot;a&quot;)

			while row do
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]#&quot; .. row.id .. &quot; &quot; .. row.x .. &quot; &quot; .. row.y .. &quot; &quot; .. row.z .. &quot; &quot; .. row.note .. &quot;[-]&quot;)
				row = cursor:fetch(row, &quot;a&quot;)
			end
		end

		faultyGMSG = false
		return true
	end

	-- ###################  do not allow remote commands beyond this point ################
	if (gmsgvars.playerid == nil) then
		faultyGMSG = false
		return false
	end
	-- ####################################################################################

if debug then display (&quot;debug bookmarks 2\n&quot;) end

	if (gmsgvars.words[1] == &quot;bookmark&quot; and gmsgvars.words[2] ~= nil) then

		note = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;bookmark &quot;) + 9)
		
		if note == nil then note = &quot;&quot; end

		conn:execute(&quot;INSERT INTO bookmarks (steam, x, y, z, note) VALUES (&quot; .. gmsgvars.playerid .. &quot;,&quot; .. math.floor(igplayers[gmsgvars.playerid].xPos) .. &quot;,&quot; .. math.ceil(igplayers[gmsgvars.playerid].yPos) .. &quot;,&quot; .. math.floor(igplayers[gmsgvars.playerid].zPos) .. &quot;,'&quot; .. escape(note) .. &quot;')&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Position added to bookmarks.[-]&quot;)	

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug bookmarks 3\n&quot;) end

	if gmsgvars.words[1] == &quot;bk&quot; then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyGMSG = false
			return true
		end

		if (gmsgvars.number == nil) then 
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The bookmark number is required eg. /goto bookmark 5[-]&quot;)
			faultyGMSG = false
			return true
		else
			cursor,errorString = conn:execute(&quot;select * from bookmarks where id = &quot; .. gmsgvars.number)
			rows = cursor:numrows()

			if rows &gt; 0 then
				row = cursor:fetch({}, &quot;a&quot;)

				-- first record their current x y z
				savePosition(gmsgvars.playerid)

				cmd = &quot;tele &quot; .. gmsgvars.playerid .. &quot; &quot; .. row.x .. &quot; &quot; .. row.y .. &quot; &quot; .. row.z
				prepareTeleport(gmsgvars.playerid, cmd)
				teleport(cmd, true)
			end
		end

		faultyGMSG = false
		return true
	end

if debug then display (&quot;debug bookmarks end\n&quot;) end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_pms</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
private message commands
=============
These are stored in the table customMessages.  Currently they are limited to simple private text responses.
add command
remove command
custom commands
--]]

function gmsg_pms()
	calledFunction = &quot;gmsg_pms&quot;

	local access, msg, cmd

	-- don't proceed if there is no leading slash
	if (string.sub(gmsgvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyGMSG = false
		return false
	end

	cmd = string.sub(gmsgvars.command, 2)

	if (gmsgvars.words[1] == &quot;add&quot; and gmsgvars.words[2] == &quot;command&quot;) then
		if (accessLevel(gmsgvars.playerid) &gt; 1) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is a restricted command[-]&quot;)
			faultyGMSG = false
			return true
		end

		access = 99
		cmd = nil

		if string.find(gmsgvars.command, &quot;message&quot;) then
			msg = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;message&quot;) + 8)

			if string.find(gmsgvars.command, &quot;level&quot;) then
				cmd = string.sub(gmsgvars.oldLine, string.find(gmsgvars.oldLine, &quot;command&quot;) + 8, string.find(gmsgvars.oldLine, &quot;level&quot;) - 2)
				access = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;level&quot;) + 6, string.find(gmsgvars.command, &quot;message&quot;) - 2)
			else
				cmd = string.sub(gmsgvars.oldLine, string.find(gmsgvars.oldLine, &quot;command&quot;) + 8, string.find(gmsgvars.oldLine, &quot;message&quot;) - 2)
			end
		else
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Message required.[-]&quot;)
			faultyGMSG = false
			return true
		end

		if cmd == nil then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Command required.[-]&quot;)
			faultyGMSG = false
			return true
		end

		-- strip leading /
		if (string.sub(cmd, 1, 1) == &quot;/&quot;) then
			cmd = string.sub(cmd, 2)
		end
	
		customCommands[cmd] = {}
		conn:execute(&quot;INSERT INTO customMessages (command, message, accessLevel) Values ('&quot; .. escape(cmd) .. &quot;','&quot; .. escape(msg) .. &quot;',&quot; .. access .. &quot;) ON DUPLICATE KEY UPDATE accessLevel = &quot; .. access.. &quot;, message = '&quot; .. escape(msg) .. &quot;'&quot;)
		message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You added the command: /&quot; .. cmd  .. &quot;[-]&quot;)

		faultyGMSG = false
		return true
	end


	if (gmsgvars.words[1] == &quot;remove&quot; and gmsgvars.words[2] == &quot;command&quot;) then
		if (accessLevel(gmsgvars.playerid) &gt; 1) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is a restricted command[-]&quot;)
			faultyGMSG = false
			return true
		end

		cmd = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;command&quot;) + 9)

		if cmd ~= nil then
			conn:execute(&quot;DELETE FROM customMessages WHERE command = '&quot; .. escape(cmd) .. &quot;'&quot;)
			customCommand[cmd] = nil
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You removed the command /&quot; .. cmd .. &quot;[-]&quot;)
		else
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Command required.[-]&quot;)
		end

		faultyGMSG = false
		return true
	end


	if (gmsgvars.words[1] == &quot;custom&quot; and gmsgvars.words[2] == &quot;commands&quot;) then
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is a restricted command[-]&quot;)
			faultyGMSG = false
			return true
		end

		cursor,errorString = conn:execute(&quot;SELECT * FROM customMessages&quot;)
		row = cursor:fetch({}, &quot;a&quot;)

		if not row then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]There are no custom commands.[-]&quot;)
		else
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Custom commands:[-]&quot;)
		end

		while row do
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/&quot; .. row.command .. &quot;[-]&quot;)
			row = cursor:fetch(row, &quot;a&quot;)	
		end

		faultyGMSG = false
		return true
	end


	-- ###################  do not allow remote commands beyond this point ################
	if (gmsgvars.playerid == nil) then
		faultyGMSG = false
		return false
	end
	-- ####################################################################################


	if customCommands[cmd] then

		cursor,errorString = conn:execute(&quot;select * from customMessages where command = '&quot; .. escape(cmd) .. &quot;'&quot;)
		rows = cursor:numrows()

		if rows &gt; 0 then
			row = cursor:fetch({}, &quot;a&quot;)

			if (accessLevel(gmsgvars.playerid) &lt;= tonumber(row.accessLevel)) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. row.message .. &quot;[-]&quot;)
				faultyGMSG = false
				return true
			end

			faultyGMSG = false
			return true
		end
	end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_custom</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
custom commands in an external script
=============
This is called ahead of most other gmsg code modules.  You can use this module to override commands in other modules so long as both commands
are trying to match the same strings.

--]]


dofile(homedir .. &quot;/scripts/gmsg_custom.lua&quot;)</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>NewServer</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function gatherServerData()
	-- read a bunch of info from the server.  The bot will capture it elsewhere.

	send(&quot;lkp&quot;)
	tempTimer( 4, [[send(&quot;pm IPCHECK&quot;)]] )
	tempTimer( 5, [[send(&quot;admin list&quot;)]] )
	tempTimer( 7, [[send(&quot;ban list&quot;)]] )
	tempTimer( 9, [[send(&quot;gg&quot;)]] )
	tempTimer( 11, [[send(&quot;llp&quot;)]] )
end


function initServer()
	server.windowGMSG = &quot;GMSG&quot;
	server.windowDebug = &quot;Debug&quot;
	server.windowAlerts = &quot;Alerts&quot;
	server.windowLists = &quot;Lists&quot;
	server.windowPlayers = &quot;Players&quot;
	server.botName = &quot;Bot&quot;
	server.prisonSize = 30
	server.mapSize = 30000
	server.chatColour = &quot;D4FFD4&quot;
	server.baseSize = 32
	server.ServerPort = &quot;0&quot;
	server.MOTD = &quot;We have a new server bot!&quot;
	server.IP = &quot;0.0.0.0&quot;
	server.ircAlerts = &quot;#bot_alerts&quot;
	server.ircMain = &quot;#bot&quot;
	server.ircWatch = &quot;#bot_watch&quot;
	server.allowGimme = false
	server.lottery = 0
	server.allowShop = false
	server.allowWaypoints = false
	server.maxPlayers = 24
	server.maxServerUptime = 12
	server.baseSize = 32
	server.baseCooldown = 2400
	server.protectionMaxDays = 31
	server.ircBotName = &quot;Bot&quot;
	server.ServerName = &quot;New Server&quot;
	server.rules = &quot;No rules yet!&quot;
	server.shopCountdown = 3
	server.gimmePeace = false

	conn:execute(&quot;DELETE FROM server&quot;)
	cursor,errorString = conn:execute(&quot;INSERT INTO server (botName, windowGMSG, windowAlerts, windowDebug, windowLists, windowPlayers) values ('Bot', 'GMSG', 'Alerts', 'Debug', 'Lists', 'Players')&quot;)

	botStarted = nil
	login()
end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>Modded Allocs</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
Commands for Coppi's modded Alloc's mod
=============

--]]

function mutePlayer(steam)
	send(&quot;mpc &quot; .. steam .. &quot; true&quot;)
	irc_QueueMsg(server.ircMain, players[steam].name .. &quot;'s chat has been muted :D&quot;)
	message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Your chat is no longer muted.[-]&quot;)
end


function unmutePlayer(steam)
	send(&quot;mpc &quot; .. steam .. &quot; false&quot;)
	irc_QueueMsg(server.ircMain, players[steam].name .. &quot;'s chat is no longer muted D:&quot;)
	message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Your chat is no longer muted.[-]&quot;)
end


function gmsg_coppi()
	calledFunction = &quot;gmsg_coppi&quot;

	local debug

	debug = false

if debug then dbug(&quot;debug coppi start&quot;) end

	-- ###################  Staff only beyond this point ################
	-- Don't proceed if this is a player.  Server and staff only here.
	if (gmsgvars.playername ~= &quot;Server&quot;) then 
		if (accessLevel(gmsgvars.playerid) &gt; 2) then
			faultyGMSG = false
			return false
		end
	end
	-- ##################################################################

if debug then dbug(&quot;debug coppi 1&quot;) end

	if gmsgvars.words[1] == &quot;mute&quot; and gmsgvars.words[2] ~= nil then
		pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;mute &quot;) + 6)
		pname = string.trim(pname)
		pid = LookupPlayer(pname)

		if pid == nil then
			if (gmsgvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No player found called &quot; .. pname .. &quot;[-]&quot;)
			else
				irc_QueueMsg(server.ircMain, &quot;No player found called &quot; .. pname)
			end

			faultyGMSG = false
			return true
		end

		mutePlayer(pid)

		if (gmsgvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Chat from player &quot; .. players[pid].name .. &quot; is blocked :D[-]&quot;)
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug coppi 2&quot;) end

	if gmsgvars.words[1] == &quot;unmute&quot; and gmsgvars.words[2] ~= nil then
		pname = string.sub(gmsgvars.command, string.find(gmsgvars.command, &quot;mute &quot;) + 6)
		pname = string.trim(pname)
		pid = LookupPlayer(pname)

		if pid == nil then
			if (gmsgvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No player found called &quot; .. pname .. &quot;[-]&quot;)
			else
				irc_QueueMsg(server.ircMain, &quot;No player found called &quot; .. pname)
			end

			faultyGMSG = false
			return true
		end

		unmutePlayer(pid)

		if (gmsgvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[pid].name .. &quot; can chat again D:[-]&quot;)
		end


		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug coppi 3&quot;) end

	if gmsgvars.words[1] == &quot;spawn&quot; and (gmsgvars.words[2] == &quot;horde&quot;) then
		if gmsgvars.words[3] ~= nil then
			pid = LookupPlayer(gmsgvars.words[3])
			if pid ~= nil then
				if igplayers[pid] then
					send(&quot;sh &quot; .. math.floor(igplayers[pid].xPos) .. &quot; &quot; .. math.floor(igplayers[pid].yPos) .. &quot; &quot; .. math.floor(igplayers[pid].zPos))
					irc_QueueMsg(server.ircMain, &quot;Horde spawned by bot at &quot; .. igplayers[pid].name .. &quot;'s position at &quot; .. math.floor(igplayers[pid].xPos) .. &quot; &quot; .. math.floor(igplayers[pid].yPos) .. &quot; &quot; .. math.floor(igplayers[pid].zPos))
				end
			else
				loc = LookupLocation(gmsgvars.words[3])
				if loc ~= nil then
					send(&quot;sh &quot; .. locations[loc].x .. &quot; &quot; .. locations[loc].y .. &quot; &quot; .. locations[loc].z)	
					irc_QueueMsg(server.ircMain, &quot;Horde spawned by bot at &quot; .. locations[loc].x .. &quot; &quot; .. locations[loc].y .. &quot; &quot; .. locations[loc].z)
				end
			end
		else
			if (gmsgvars.playername ~= &quot;Server&quot;) then
				if igplayers[gmsgvars.playerid].horde ~= nil then
					send(&quot;sh &quot; .. igplayers[gmsgvars.playerid].horde)
				else
					send(&quot;sh &quot; .. gmsgvars.intX .. &quot; &quot; .. gmsgvars.intY .. &quot; &quot; .. gmsgvars.intZ)
				end
			end
		end

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug coppi 4&quot;) end

	if (gmsgvars.words[1] == &quot;hide&quot; and gmsgvars.words[2] == &quot;commands&quot; and gmsgvars.words[3] == nil) then
		server.hideCommands = true
		send(&quot;tcch /&quot;)
		conn:execute(&quot;UPDATE server SET hideCommands = 1&quot;)

		if (gmsgvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Bot commands are now hidden from global chat.[-]&quot;)	
		else
			irc_QueueMsg(server.ircMain, &quot;Bot commands are now hidden from global chat.&quot;)
		end
		
		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug coppi 5&quot;) end

	if (gmsgvars.words[1] == &quot;show&quot; and gmsgvars.words[2] == &quot;commands&quot; and gmsgvars.words[3] == nil) then
		server.hideCommands = true
		send(&quot;tcch&quot;)
		conn:execute(&quot;UPDATE server SET hideCommands = 0&quot;)

		if (gmsgvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. gmsgvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Bot commands are now visible in global chat.[-]&quot;)	
		else
			irc_QueueMsg(server.ircMain, &quot;Bot commands are now visible in global chat.&quot;)
		end
		
		faultyGMSG = false
		return true
	end

	-- ###################  do not allow remote commands beyond this point ################
	if (gmsgvars.playerid == nil) then
		faultyGMSG = false
		return false
	end
	-- ####################################################################################

if debug then dbug(&quot;debug coppi 4&quot;) end

	if gmsgvars.words[1] == &quot;set&quot; and (gmsgvars.words[2] == &quot;horde&quot;) then
		-- mark the player's current position for spawning a horde with /spawn horde
		igplayers[gmsgvars.playerid].horde = gmsgvars.intX .. &quot; &quot; .. gmsgvars.intY .. &quot; &quot; .. gmsgvars.intZ

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug coppi 5&quot;) end

	if gmsgvars.words[1] == &quot;clear&quot; and (gmsgvars.words[2] == &quot;horde&quot;) then
		-- forget the pre-recorded coords of the horde spawn point
		igplayers[gmsgvars.playerid].horde = nil

		faultyGMSG = false
		return true
	end

if debug then dbug(&quot;debug coppi end&quot;) end

end</script>
            <eventHandlerList/>
        </Script>
    </ScriptPackage>
    <KeyPackage/>
</MudletPackage>
