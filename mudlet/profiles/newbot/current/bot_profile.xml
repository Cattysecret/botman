<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.0">
    <HostPackage>
        <Host autoClearCommandLineAfterSend="no" disableAutoCompletion="no" printCommand="yes" USE_IRE_DRIVER_BUGFIX="yes" mUSE_FORCE_LF_AFTER_PROMPT="no" mUSE_UNIX_EOL="no" mNoAntiAlias="no" mRawStreamDump="no" mAlertOnNewData="yes" mFORCE_NO_COMPRESSION="no" mFORCE_GA_OFF="no" mFORCE_SAVE_ON_EXIT="yes" mEnableGMCP="no" mMapStrongHighlight="no" mLogStatus="no" mEnableSpellCheck="no" mShowInfo="no" mAcceptServerGUI="yes" mMapperUseAntiAlias="no" mFORCE_MXP_NEGOTIATION_OFF="no" mRoomSize="0.5" mLineSize="5" mBubbleMode="no" mShowRoomIDs="no" mShowPanel="no" mHaveMapperScript="no">
            <name>7days Server</name>
            <mInstalledPackages/>
            <url>127.0.0.1</url>
            <serverPackageName>nothing</serverPackageName>
            <serverPackageVersion>-1</serverPackageVersion>
            <port>26900</port>
            <borderTopHeight>0</borderTopHeight>
            <borderBottomHeight>0</borderBottomHeight>
            <borderLeftWidth>0</borderLeftWidth>
            <borderRightWidth>0</borderRightWidth>
            <wrapAt>100</wrapAt>
            <wrapIndentCount>0</wrapIndentCount>
            <commandSeperator>;</commandSeperator>
            <mFgColor>#c0c0c0</mFgColor>
            <mBgColor>#000000</mBgColor>
            <mCommandFgColor>#717100</mCommandFgColor>
            <mCommandBgColor>#000000</mCommandBgColor>
            <mCommandLineFgColor>#808080</mCommandLineFgColor>
            <mCommandLineBgColor>#000000</mCommandLineBgColor>
            <mBlack>#000000</mBlack>
            <mLightBlack>#808080</mLightBlack>
            <mRed>#800000</mRed>
            <mLightRed>#ff0000</mLightRed>
            <mBlue>#000080</mBlue>
            <mLightBlue>#0000ff</mLightBlue>
            <mGreen>#00b300</mGreen>
            <mLightGreen>#00ff00</mLightGreen>
            <mYellow>#808000</mYellow>
            <mLightYellow>#ffff00</mLightYellow>
            <mCyan>#008080</mCyan>
            <mLightCyan>#00ffff</mLightCyan>
            <mMagenta>#800080</mMagenta>
            <mLightMagenta>#ff00ff</mLightMagenta>
            <mWhite>#c0c0c0</mWhite>
            <mLightWhite>#ffffff</mLightWhite>
            <mDisplayFont>DejaVu Sans Mono,10,-1,5,2,0,0,0,1,0</mDisplayFont>
            <mCommandLineFont>Bitstream Vera Sans Mono,10,-1,5,2,0,0,0,0,0</mCommandLineFont>
            <mCommandSeparator>;</mCommandSeparator>
            <commandLineMinimumHeight>30</commandLineMinimumHeight>
            <mFgColor2>#c0c0c0</mFgColor2>
            <mBgColor2>#000000</mBgColor2>
            <mBlack2>#242424</mBlack2>
            <mLightBlack2>#808080</mLightBlack2>
            <mRed2>#800000</mRed2>
            <mLightRed2>#ff0000</mLightRed2>
            <mBlue2>#000080</mBlue2>
            <mLightBlue2>#0000ff</mLightBlue2>
            <mGreen2>#00b300</mGreen2>
            <mLightGreen2>#00ff00</mLightGreen2>
            <mYellow2>#808000</mYellow2>
            <mLightYellow2>#ffff00</mLightYellow2>
            <mCyan2>#008080</mCyan2>
            <mLightCyan2>#00ffff</mLightCyan2>
            <mMagenta2>#800080</mMagenta2>
            <mLightMagenta2>#ff00ff</mLightMagenta2>
            <mWhite2>#c0c0c0</mWhite2>
            <mLightWhite2>#ffffff</mLightWhite2>
            <mSpellDic>en_US</mSpellDic>
            <mLineSize>5</mLineSize>
            <mRoomSize>0.5</mRoomSize>
        </Host>
    </HostPackage>
    <TriggerPackage>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Login</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers 
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see http://www.gnu.org/licenses
--]]

lastAction = &quot;Login&quot;
botOffline = 2

-- add your telnet password below.  Telnet fails to login on the first try and this will resend the pass.
if string.find(line, &quot;Password incorrect&quot;) then
-- EDIT ME!
	send(&quot;insert telnet password here&quot;)
end

-- enable triggers and timers.  No ability to enable scripts in code yet.
enableTrigger(&quot;End list players&quot;)
enableTrigger(&quot;PVP Police&quot;)
enableTrigger(&quot;MatchAll&quot;)
enableTrigger(&quot;InventorySlot&quot;)
enableTrigger(&quot;Player connected&quot;)
enableTrigger(&quot;playerinfo&quot;)
enableTrigger(&quot;Player disconnected&quot;)
enableTrigger(&quot;Inventory&quot;)
enableTrigger(&quot;lkp&quot;)
enableTrigger(&quot;Zombie scouts&quot;)
enableTrigger(&quot;InventoryOwner&quot;)
enableTrigger(&quot;AirDrop alert&quot;)
enableTrigger(&quot;Spam&quot;)
enableTrigger(&quot;Game Time&quot;)
enableTrigger(&quot;GameTickCount&quot;)
enableTrigger(&quot;Logon Successful&quot;)
enableTrigger(&quot;Collect Ban&quot;)
enableTrigger(&quot;Unban player&quot;)
enableTrigger(&quot;Overstack&quot;)
enableTrigger(&quot;Open Reserved Slot&quot;)
enableTrigger(&quot;mem&quot;)
enableTrigger(&quot;lp&quot;)
enableTrigger(&quot;Tele&quot;)
enableTrigger(&quot;llp&quot;)
enableTrigger(&quot;Chat&quot;)
enableTrigger(&quot;log chat&quot;)

enableTimer(&quot;EveryHalfMinute&quot;)
enableTimer(&quot;OneMinuteTimer&quot;)
enableTimer(&quot;listPlayers&quot;)
enableTimer(&quot;OneHourTimer&quot;)
enableTimer(&quot;Reconnect&quot;)
enableTimer(&quot;GimmeReset&quot;)
enableTimer(&quot;TimedCommands&quot;)
enableTimer(&quot;ThirtyMinuteTimer&quot;)
enableTimer(&quot;PlayerQueuedCommands&quot;)
enableTimer(&quot;GimmeQueuedCommands&quot;)
enableTimer(&quot;ircQueue&quot;)
enableTimer(&quot;Every45Seconds&quot;)
enableTimer(&quot;TrackPlayer&quot;)
enableTimer(&quot;messageQueue&quot;)
</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>lease enter password:</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>End list players</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

showPlayers = false
playersOnline = tonumber(string.match(line, &quot;%d+&quot;))
deleteLine()

if (playersOnline == 0) then
	-- we could schedule something to happen when no players are online
end

-- reset relogCount as we have established that the server is talking to us
relogCount = 0



</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>Total of </string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>2</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>PVP Police</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

function pvpPolice()
	local killerScore = 0
	local victimScore = 0
	local killerid
	local victimid
	local arenaID
	local score
	local eventID

	if (not string.find(line, &quot;INF Chat&quot;)) then
		-- prevent players from tricking the bot into banning players
		return
	end 

	r = rand(15)
	score = string.format(&quot;%.1f&quot;, math.random() * 10)

	nameStart = string.find(line, &quot;INF Chat&quot;) + 10
	nameEnd = string.find(line, &quot; eliminated&quot;) - 1

	killerName = string.sub(line, nameStart, nameEnd)
	killerid = LookupPlayer(killerName)

	nameStart = string.find(line, &quot;eliminated&quot;) + 11

	victimName = string.sub(line, nameStart)
	victimid = LookupPlayer(victimName)

	igplayers[victimid].deadX = igplayers[victimid].xPos
	igplayers[victimid].deadY = igplayers[victimid].yPos
	igplayers[victimid].deadZ = igplayers[victimid].zPos

	if (killerName == victimName) then
		if (r == 1) then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; removed themselves from the gene pool.[-]&quot;) end
		if (r == 2) then message(&quot;say [&quot; .. server.chatColour .. &quot;]LOL!  Didn't run far away enough did you &quot; .. killerName .. &quot;?[-]&quot;) end
		if (r == 3) then message(&quot;say [&quot; .. server.chatColour .. &quot;]And the prize for most creative way to end themselves goes to.. &quot; .. killerName .. &quot;[-]&quot;) end
		if (r == 4) then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; really shouldn't handle explosives.[-]&quot;) end
		if (r == 5) then message(&quot;say Oh no! &quot; .. killerName .. &quot; died.  What a shame.[-]&quot;) end
		if (r == 6) then message(&quot;say [&quot; .. server.chatColour .. &quot;]Great effort there &quot; .. killerName .. &quot;. I'm awarding &quot; .. score .. &quot; points.[-]&quot;) end
		if (r == 7) then message(&quot;say [&quot; .. server.chatColour .. &quot;]LOL! REKT[-]&quot;) end

		if (r == 8) then 
			message(&quot;say [&quot; .. server.chatColour .. &quot;]We are gathered here today to remember with sadness the passing of &quot; .. killerName .. &quot;. Rest in pieces. Amen.[-]&quot;)
		end

		if (r == 9) then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; cut the wrong wire.[-]&quot;) end
		if (r == 10) then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; really showed that explosive who's boss![-]&quot;) end
		if (r == 11) then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; shouldn't play Russian Roulette with a fully loaded gun.[-]&quot;) end
		if (r == 12) then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; added a new stain to the floor.[-]&quot;) end
		if (r == 13) then message(&quot;say [&quot; .. server.chatColour .. &quot;]ISIS got nothing on &quot; .. killerName .. &quot;'s suicide bomber skillz.[-]&quot;) end
		if (r == 14) then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; reached a new low with that death. Six feet under.[-]&quot;) end
		if (r == 15) then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; needs clean undies after that one.[-]&quot;) end

		return
	else
		if (pvpZone(igplayers[killerid].xPos, igplayers[killerid].zPos) ~= false) or (server.gameType == &quot;pvp&quot;) then
			if tonumber(players[killerid].playerKills) == 0 then
				r = rand(4)
				if r == 1 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; makes their first kill and is now a hit.. sorry has a hit on themselves.[-]&quot;) end
				if r == 2 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; finally scores their first kill! Woo Hoo![-]&quot;) end
				if r == 3 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; finally scores their first kill! About time you showed up kid.[-]&quot;) end
				if r == 4 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; makes their first kill!  It was just a prank bro![-]&quot;) end

				players[killerid].pvpBounty = 200
			else
				r = rand(29)
				if r == 1 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; once again asserts their dominance in the world.[-]&quot;) end
				if r == 2 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; strikes a mighty blow against &quot; .. victimName .. &quot;![-]&quot;) end
				if r == 3 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; fluked that one! &quot; .. victimName .. &quot; will be pissed.[-]&quot;) end
				if r == 4 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; dispatched &quot; .. victimName .. &quot; with a little too much enthusiasm. Medics have been called to consume the body.[-]&quot;) end
				if r == 5 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; ripped &quot; .. victimName .. &quot; a new asshole.[-]&quot;) end
				if r == 6 then message(&quot;say [&quot; .. server.chatColour .. &quot;]Player &quot; .. killerName .. &quot; is on fire metaphorically speaking. &quot; .. victimName .. &quot; is too.. for real.[-]&quot;) end
				if r == 7 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; is really asking for it with another spectacular kill.[-]&quot;) end
				if r == 8 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; sent &quot; .. victimName .. &quot; a heart stopping, high velocity gift.  Right between the eyes.[-]&quot;) end
				if r == 9 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. victimName .. &quot; walked right into that one![-]&quot;) end
				if r == 10 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. victimName .. &quot; forgot their flame proof underwear, or infact any underwear.[-]&quot;) end
				if r == 11 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. victimName .. &quot; spread themselves too thin in that fight.  Anyone got a broom and shovel?[-]&quot;) end
				if r == 12 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. victimName .. &quot; impaled themselves on &quot; .. killerName .. &quot;'s mighty sword! .. I said mighty not erect![-]&quot;) end
				if r == 13 then message(&quot;say [&quot; .. server.chatColour .. &quot;]Sadly &quot; .. victimName .. &quot; lost that fight.  Well I'm sad, I had &quot; .. t .. &quot; zennies riding on him. :([-]&quot;) end
				if r == 14 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. victimName .. &quot; enters the space program with a bang.. and a thud.. and another.  Oh and there's a leg.[-]&quot;) end
				if r == 15 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; cut &quot; .. victimName .. &quot; a new asshole!  I guess that makes &quot; .. victimName .. &quot; their own twin?[-]&quot;) end
				if r == 16 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; cut &quot; .. victimName .. &quot; a new asshole!  &quot; .. victimName .. &quot; is an even bigger asshole now! ^^[-]&quot;) end
				if r == 17 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; is slicing and dicing up the competition![-]&quot;) end
				if r == 18 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; makes mince meat of &quot; .. victimName .. &quot;! Gather round boys!  We're havin a BBQ with a side of WTF covered in OMG sauce![-]&quot;) end
				if r == 19 then message(&quot;say [&quot; .. server.chatColour .. &quot;]Gordon Bennet! &quot; .. killerName .. &quot; is racing towards the lead with another masterfull kill.[-]&quot;) end
				if r == 20 then message(&quot;say [&quot; .. server.chatColour .. &quot;]That was a feeble effort by &quot; .. victimName .. &quot;.[-]&quot;) end
				if r == 21 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. victimName .. &quot; will need to move faster next time.. because they just lost both legs below the knee![-]&quot;) end
				if r == 22 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; made new garden furnature from &quot; .. victimName .. &quot;'s corpse.[-]&quot;) end
				if r == 23 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; has a new trophy head! &quot; .. victimName .. &quot;'s head is pretty ugly but it'll do.[-]&quot;) end
				if r == 24 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; has meat on the menu again with a slice of &quot; .. victimName .. &quot; and a few unrecognisable gibblets.[-]&quot;) end
				if r == 25 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. victimName .. &quot; should have taken up knitting, its safer.[-]&quot;) end
				if r == 26 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. victimName .. &quot; is in pieces over that one!  Caution: choking hazard.  Keep away from children under 3.[-]&quot;) end
				if r == 27 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. victimName .. &quot; proves once again that you shouldn't borrow sugar from &quot; .. killerName .. &quot;.[-]&quot;) end
				if r == 28 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. victimName .. &quot; needs a new hobby. &quot; .. killerName .. &quot; needs a dry clean.[-]&quot;) end
				if r == 29 then message(&quot;say [&quot; .. server.chatColour .. &quot;]Oops &quot; .. killerName .. &quot; did it again.[-]&quot;) end

				if server.allowBank then
					message(&quot;pm &quot; .. killerid .. &quot; [&quot; .. server.chatColour .. &quot;]You won the bounty on &quot; .. victimName .. &quot;![-]&quot;)
				end
			end

			if server.allowBank then
				if players[victimid].pvpBounty &gt; 0 then
					players[killerid].cash = players[killerid].cash + players[victimid].pvpBounty
					players[victimid].pvpBounty = 0
					message(&quot;pm &quot; .. killerid .. &quot; [&quot; .. server.chatColour .. &quot;]You got the bounty on &quot; .. victimName .. &quot;![-]&quot;)
				else
					message(&quot;say [&quot; .. server.chatColour .. &quot;]A bounty of &quot; .. players[killerid].pvpBounty .. &quot; is on &quot; .. killerName .. &quot;'s head. Bring it home![-]&quot;)
				end
			end

			-- record the pvp in the events table
			conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. math.floor(igplayers[killerid].xPos) .. &quot;,&quot; .. math.ceil(igplayers[killerid].yPos) .. &quot;,&quot; .. math.floor(igplayers[killerid].zPos) .. &quot;,'&quot; .. serverTime .. &quot;','pvp','Player &quot; .. escape(killerName) .. &quot; killed &quot; .. escape(victimName) .. &quot; in a pvp zone',&quot; .. killerid .. &quot;)&quot;)

			if db2Connected then
				-- copy in bots db
				connBots:execute(&quot;INSERT INTO events (server, serverTime, type, event, steam) VALUES ('&quot; .. escape(server.ServerName) .. &quot;','&quot; .. serverTime .. &quot;','pvp','Player &quot; .. escape(killerName) .. &quot; killed &quot; .. escape(victimName) .. &quot; in a pvp zone',&quot; .. killerid .. &quot;)&quot;)
			end

			return
		end

		-- arena pvp zone
		if locations[&quot;arena&quot;] ~= nil then
			if distancexz(igplayers[killerid].xPos, igplayers[killerid].zPos, locations[&quot;arena&quot;].x, locations[&quot;arena&quot;].z ) &lt; 31 then
				return
			end
		end

		-- don't react if player is inside the prison
		if locations[&quot;prison&quot;] ~= nil then
			if ((math.abs(math.abs(igplayers[killerid].xPos) - math.abs(locations[&quot;prison&quot;].x)) &lt; server.prisonSize) or (math.abs(math.abs(igplayers[killerid].zPos) - math.abs(locations[&quot;prison&quot;].z)) &lt; server.prisonSize)) then
				return
			end
		end

		if (accessLevel(killerid) &lt; 3 and server.ignoreAdmins == true) then 
			cecho(server.windowAlerts, &quot;admin pvp: &quot; .. line .. &quot;\n&quot;)
			message(&quot;say [&quot; .. server.chatColour .. &quot;]PvP is not allowed outside of PVP zones! However &quot; .. killerName .. &quot; is authorised to PVP[-]&quot;)	
			message(&quot;pm &quot; .. killerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are allowed to pvp to defend yourself and others. Don't abuse this privilege.[-]&quot;)
			table.save(homedir .. &quot;/server.lua&quot;, server)
			conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. math.floor(igplayers[victimid].xPos) .. &quot;,&quot; .. math.ceil(igplayers[victimid].yPos) .. &quot;,&quot; .. math.floor(igplayers[victimid].zPos) .. &quot;,'&quot; .. serverTime .. &quot;','pvp','Admin &quot; .. escape(killerName) .. &quot; killed &quot; .. escape(victimName) .. &quot; at &quot; .. igplayers[killerid].xPos .. &quot; &quot; .. igplayers[killerid].yPos .. &quot; &quot; .. igplayers[killerid].zPos .. &quot;',&quot; .. killerid .. &quot;)&quot;)

			if db2Connected then
				-- copy in bots db
				connBots:execute(&quot;INSERT INTO events (server, serverTime, type, event, steam) VALUES ('&quot; .. escape(server.ServerName) .. &quot;','&quot; .. serverTime .. &quot;','pvp','Admin &quot; .. escape(killerName) .. &quot; killed &quot; .. escape(victimName) .. &quot; at &quot; .. igplayers[killerid].xPos .. &quot; &quot; .. igplayers[killerid].yPos .. &quot; &quot; .. igplayers[killerid].zPos .. &quot;',&quot; .. killerid .. &quot;)&quot;)
			end

			return
		end

		cecho(server.windowAlerts, line .. &quot;\n&quot;)
		message(&quot;say [&quot; .. server.chatColour .. &quot;]PvP is not allowed outside of PVP zones!  Read /help pvp[-]&quot;)

		if (isNewPlayer(victimid) and not isNewPlayer(killerid)) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Killing in self-defense is allowed.  No arrest made. Admins will review this killing and may decide to punish for it later.[-]&quot;)	
			irc_QueueMsg(server.ircAlerts, killerName .. &quot; killed new player &quot; .. victimName .. &quot;.  No arrest made. Killer's location was &quot; .. math.floor(igplayers[killerid].xPos) .. &quot; &quot; .. math.floor(igplayers[killerid].yPos) .. &quot; &quot; .. math.floor(igplayers[killerid].zPos))
			conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. math.floor(igplayers[victimid].xPos) .. &quot;,&quot; .. math.ceil(igplayers[victimid].yPos) .. &quot;,&quot; .. math.floor(igplayers[victimid].zPos) .. &quot;,'&quot; .. serverTime .. &quot;','pvp','&quot; .. escape(killerName) .. &quot; killed new player &quot; .. escape(victimName) .. &quot;.  No arrest made. Killer's location was &quot; .. math.floor(igplayers[victimid].xPos) .. &quot; &quot; .. math.floor(igplayers[victimid].yPos) .. &quot; &quot; .. math.floor(igplayers[victimid].zPos) .. &quot;',&quot; .. killerid .. &quot;)&quot;)

			if db2Connected then
				-- copy in bots db
				connBots:execute(&quot;INSERT INTO events (server, serverTime, type, event, steam) VALUES ('&quot; .. escape(server.ServerName) .. &quot;','&quot; .. serverTime .. &quot;','pvp','&quot; .. escape(killerName) .. &quot; killed new player &quot; .. escape(victimName) .. &quot;.  No arrest made. Killer's location was &quot; .. math.floor(igplayers[victimid].xPos) .. &quot; &quot; .. math.floor(igplayers[victimid].yPos) .. &quot; &quot; .. math.floor(igplayers[victimid].zPos) .. &quot;',&quot; .. killerid .. &quot;)&quot;)
			end

			return
		end

		if locations[&quot;prison&quot;] ~= nil then
			igplayers[killerid].xPosOld = math.floor(igplayers[killerid].xPos)
			igplayers[killerid].yPosOld = math.floor(igplayers[killerid].yPos)
			igplayers[killerid].zPosOld = math.floor(igplayers[killerid].zPos)
			
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; has been sent to prison, charged with PVP in a restricted zone.[-]&quot;)
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Admins or the victim can release them by typing /release &quot; .. killerName .. &quot;[-]&quot;)
			message(&quot;pm &quot; .. killerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can not return until released from prison.[-]&quot;)
			irc_QueueMsg(server.ircAlerts, killerName .. &quot; has been sent to prison, charged with PVP at &quot; .. igplayers[killerid].xPosOld .. &quot; &quot; .. igplayers[killerid].yPosOld .. &quot; &quot; .. igplayers[killerid].zPosOld)
			cmd = &quot;tele &quot; .. killerid .. &quot; &quot; .. locations[&quot;prison&quot;].x .. &quot; &quot; .. locations[&quot;prison&quot;].y .. &quot; &quot; .. locations[&quot;prison&quot;].z

			if players[killerid].watchPlayer then
				irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. killerid .. &quot; &quot; .. igplayers[killerid].name .. &quot; arrested for PVP by bot&quot;)
			end

			prepareTeleport(killerid, cmd)
			teleport(cmd, true)
				
			players[killerid].prisoner = true
			players[killerid].pvpVictim = victimid
			players[killerid].prisonReason = &quot;PVP against &quot; .. players[victimid].name
			players[killerid].prisonxPosOld = igplayers[killerid].xPosOld
			players[killerid].prisonyPosOld = igplayers[killerid].yPosOld
			players[killerid].prisonzPosOld = igplayers[killerid].zPosOld		

			igplayers[killerid].xPosLastOK = locations[&quot;prison&quot;].x
			igplayers[killerid].yPosLastOK = locations[&quot;prison&quot;].y
			igplayers[killerid].zPosLastOK = locations[&quot;prison&quot;].z
				
			message(&quot;pm &quot; .. victimid  .. &quot; [&quot; .. server.chatColour .. &quot;]You may release &quot; .. killerName .. &quot;. Do so at your own risk by typing[-]&quot;)
			message(&quot;pm &quot; .. victimid  .. &quot; /release &quot; .. players[killerid].id .. &quot; or /release &quot; .. killerName .. &quot;[-]&quot;)
						
			conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. math.floor(igplayers[killerid].xPos) .. &quot;,&quot; .. math.ceil(igplayers[killerid].yPos) .. &quot;,&quot; .. math.floor(igplayers[killerid].zPos) .. &quot;,'&quot; .. serverTime .. &quot;','pvp','Player &quot; .. escape(killerName) .. &quot; sent to prison for killing &quot; .. escape(victimName) .. &quot; at &quot; .. igplayers[killerid].xPos .. &quot; &quot; .. igplayers[killerid].yPos .. &quot; &quot; .. igplayers[killerid].zPos .. &quot;',&quot; .. killerid .. &quot;)&quot;)

			if db2Connected then
				-- copy in bots db
				connBots:execute(&quot;INSERT INTO events (server, serverTime, type, event, steam) VALUES ('&quot; .. escape(server.ServerName) .. &quot;','&quot; .. serverTime .. &quot;','pvp','Player &quot; .. escape(killerName) .. &quot; sent to prison for killing &quot; .. escape(victimName) .. &quot; at &quot; .. igplayers[killerid].xPos .. &quot; &quot; .. igplayers[killerid].yPos .. &quot; &quot; .. igplayers[killerid].zPos .. &quot;',&quot; .. killerid .. &quot;)&quot;)
			end
		else
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. killerName .. &quot; has been banned for 1 day, charged with PVP.  Contact an admin to get them unbanned any sooner.[-]&quot;)
			irc_QueueMsg(server.ircAlerts, killerName .. &quot; has been banned for 1 day, charged with PVP at &quot; .. igplayers[killerid].xPos .. &quot; &quot; .. igplayers[killerid].yPos .. &quot; &quot; .. igplayers[killerid].zPos)
			kick(killerid, &quot;This is a PVE server.  PVP somewhere else.  An admin may unban you pending the circumstances of the pvp.&quot;)
			banPlayer(killerID, &quot;1 day&quot;, &quot;PVP&quot;, &quot;&quot;)
			
			conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. math.floor(igplayers[killerid].xPos) .. &quot;,&quot; .. math.ceil(igplayers[killerid].yPos) .. &quot;,&quot; .. math.floor(igplayers[killerid].zPos) .. &quot;,'&quot; .. serverTime .. &quot;','pvp','Player &quot; .. escape(killerName) .. &quot; banned 1 day for killing &quot; .. escape(victimName) .. &quot; at &quot; .. igplayers[killerid].xPos .. &quot; &quot; .. igplayers[killerid].yPos .. &quot; &quot; .. igplayers[killerid].zPos .. &quot;',&quot; .. killerid .. &quot;)&quot;)

			if db2Connected then
				-- copy in bots db
				connBots:execute(&quot;INSERT INTO events (server, serverTime, type, event, steam) VALUES ('&quot; .. escape(server.ServerName) .. &quot;','&quot; .. serverTime .. &quot;','pvp','Player &quot; .. escape(killerName) .. &quot; banned 1 day for killing &quot; .. escape(victimName) .. &quot; at &quot; .. igplayers[killerid].xPos .. &quot; &quot; .. igplayers[killerid].yPos .. &quot; &quot; .. igplayers[killerid].zPos .. &quot;',&quot; .. killerid .. &quot;)&quot;)
			end
		end
	end
end


if string.find(line, &quot;eliminated&quot;) then
	pvpPolice()
end</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>eliminated</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>MatchAll</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

if string.find(line, &quot;-&gt;&quot;) or string.find(line, &quot;NullReferenceException:&quot;)  then -- what is this shit?  ignore it.
	return
end

local pname, pid, number, died, coords, words, temp
local dy, mth, yr, hr, min, sec, pm, reason, timestamp, banDate
local fields, values, x, z, id, loc, reset, steam

-- set counter to help detect the bot going offline
botOffline = 2

if string.find(line, &quot;INF Server shutting down!&quot;) then
	saveLuaTables()
end

if string.find(line, &quot;type=EntityZombie&quot;) then
	temp = string.split(line, &quot; &quot;)
	id = string.match(temp[7], &quot;(-?%d+)&quot;)
	x = string.match(temp[9], &quot;(-?%d+)&quot;)
	z = string.match(temp[11], &quot;(-?%d+)&quot;)

	loc = inLocation(x, z)

	if not loc and server.gameType == &quot;con&quot; then
		send(&quot;kill &quot; .. id)
	end

	if loc ~= false then
		if locations[loc].killZombies then
			send(&quot;kill &quot; .. id)
		end
	end
end

if server.coppi then
	if string.find(line, &quot;friends:&quot;) then
		collectFriends = string.sub(line, 1, string.find(line, &quot;friends:&quot;) - 2)
		collectFriends = LookupPlayer(collectFriends)
	end
end

-- look for general stuff
died = false
if (string.find(line, &quot;INF Chat&quot;) and string.find(line, &quot;eliminated&quot;)) then
	nameStart = string.find(line, &quot;eliminated &quot;) + 12
	pname = string.trim(string.sub(line, nameStart))
	died = true
end

if (string.find(line, &quot;INF Chat&quot;) and string.find(line, &quot; died&quot;)) then
	pname = string.sub(line, string.find(line, &quot;Chat&quot;) + 6, string.len(line) - 5)
	pname = string.trim(pname)
	died = true
end


if died then
	pid = LookupPlayer(pname)

	if (pid ~= nil) then
		conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. math.floor(igplayers[pid].xPos) .. &quot;,&quot; .. math.ceil(igplayers[pid].yPos) .. &quot;,&quot; .. math.floor(igplayers[pid].zPos) .. &quot;,'&quot; .. serverTime .. &quot;','death','&quot; .. escape(pname) .. &quot; died',&quot; .. pid .. &quot;)&quot;)

		players[pid].tp = 1
		players[pid].hackerScore = 0
		igplayers[pid].deadX = math.floor(igplayers[pid].xPos)
		igplayers[pid].deadY = math.ceil(igplayers[pid].yPos)
		igplayers[pid].deadZ = math.floor(igplayers[pid].zPos)

		players[pid].deathX = igplayers[pid].xPos
		players[pid].deathY = igplayers[pid].yPos
		players[pid].deathZ = igplayers[pid].zPos

		if inLocation(players[pid].deathX, players[pid].deathZ) == &quot;deadzone&quot; then
			players[pid].baseCooldown = 0
			conn:execute(&quot;UPDATE players SET baseCooldown = 0 WHERE steam = &quot; .. pid)
		end

		irc_QueueMsg(server.ircMain, &quot;Player &quot; .. pid .. &quot; name: &quot; .. pname .. &quot;'s death recorded at &quot; .. igplayers[pid].deadX .. &quot; &quot; .. igplayers[pid].deadY .. &quot; &quot; .. igplayers[pid].deadZ)

		if tonumber(server.packCooldown) &gt; 0 then
			players[pid].packCooldown = os.time() + server.packCooldown
		end

		if players[pid].watchPlayer then
			irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. pid .. &quot; &quot; .. players[pid].name .. &quot; died at &quot; .. igplayers[pid].deadX .. &quot; &quot; .. igplayers[pid].deadY .. &quot; &quot; .. igplayers[pid].deadZ)
		end
	end

	-- nuke their gimme queue of zeds
	for k, v in pairs(gimmeQueuedCommands) do
		if (v.steam == pid) and (string.find(v.cmd, &quot;se &quot; .. pid)) then
			gimmeQueuedCommands[k] = nil
		end
	end
end

number = tonumber(string.match(line, &quot; (%d+)&quot;))

if (string.find(line, &quot;ServerMaxPlayerCount set to&quot;)) then
	server.ServerMaxPlayerCount = number
end

if (string.find(line, &quot;MaxSpawnedZombies set to&quot;)) then
	server.MaxSpawnedZombies = number
end

if (string.find(line, &quot;MaxSpawnedAnimals set to&quot;)) then
	server.MaxSpawnedAnimals = number
end

if (string.find(line, &quot;LootRespawnDays =&quot;)) then
	server.LootRespawnDays = number
end

if (string.find(line, &quot;BlockDurabilityModifier =&quot;)) then
	server.BlockDurabilityModifier = number
end

if (string.find(line, &quot;DayNightLength =&quot;)) then
	server.DayNightLength = number
end

if (string.find(line, &quot;DropOnDeath =&quot;)) then
	server.DropOnDeath = number
end

if (string.find(line, &quot;DropOnQuit =&quot;)) then
	server.DropOnQuit = number
end

if (string.find(line, &quot;EnemyDifficulty =&quot;)) then
	server.EnemyDifficulty = number
end

if (string.find(line, &quot;EnemySenseMemory =&quot;)) then
	server.EnemySenseMemory = number
end

if (string.find(line, &quot;LandClaimSize =&quot;)) then
	server.LandClaimSize = number
end

if (string.find(line, &quot;LootAbundance =&quot;)) then
	server.LootAbundance = number
end

if (string.find(line, &quot;LootRespawnDays =&quot;)) then
	server.LootRespawnDays = number
end

if (string.find(line, &quot;ServerPort =&quot;)) then
	server.ServerPort = number
end

if (string.find(line, &quot;ZombiesRun =&quot;)) then
	server.ZombiesRun = number
end

if (string.find(line, &quot;ServerName =&quot;)) then
	server.ServerName = string.trim(string.sub(line, 22))
end

if (string.find(line, &quot;GameName =&quot;)) then
	server.GameName = string.trim(string.sub(line, 20))
end

if (string.find(line, &quot;ServerMaxPlayerCount =&quot;)) then
	server.ServerMaxPlayerCount = number
end

if (string.find(line, &quot;MaxSpawnedZombies =&quot;)) then
	server.MaxSpawnedZombies = number
	-- If we detect this line it means we are receiving data from the server so we set a flag to let us know elsewhere that we got server data ok.
	serverDataLoaded = true
end

conn:execute(&quot;UPDATE server SET serverName = '&quot; .. escape(server.ServerName) .. &quot;', ServerPort = &quot; .. server.ServerPort)

if getAdminList ~= nil then
	if string.sub(line, 1, 4) ~= &quot;    &quot; then
		getAdminList = nil
	end
end

if getAdminList ~= nil then
	temp = string.split(line, &quot;:&quot;)
	temp[1] = string.trim(temp[1])
	temp[2] = string.trim(string.sub(temp[2], 1, 18))

	number = tonumber(temp[1])
	pid = temp[2]

	if players[pid] then
		if number == 0 then
			owners[pid] = {}
		end

		if number == 1 then
			admins[pid] = {}
		end

		if number == 2 then
			mods[pid] = {}
		end

		players[pid].accessLevel = tonumber(number)
		players[pid].newPlayer = false
		players[pid].silentBob = false
		players[pid].walkies = false
		players[pid].timeout = false
		players[pid].botTimeout = false
		players[pid].prisoner = false
		players[pid].exiled = 2
		players[pid].canTeleport = true
		players[pid].enableTP = true
		players[pid].botHelp = true
		conn:execute(&quot;UPDATE players SET newPlayer = 0, silentBob = 0, walkies = 0, exiled = 2, canTeleport = 1, enableTP = 1, botHelp = 1, accessLevel = &quot; .. number .. &quot; WHERE steam = &quot; .. pid)		
	end
end

-- update owners, admins and mods
if (line == &quot;  Level: SteamID (Player name if online)&quot;) then
	owners = {}
	admins = {}
	mods = {}
	getAdminList = true
end


if string.sub(line, 1, 4) == &quot;   (&quot; then
	coords = string.split(string.sub(line, 5, string.len(line) - 1), &quot;,&quot;)

	if players[llpid].removedClaims == nil then
		players[llpid].removedClaims = 0
	end

	conn:execute(&quot;UPDATE keystones SET remove = 1 WHERE steam = &quot; .. llpid .. &quot; AND x = &quot; .. coords[1] .. &quot; AND y = &quot; .. coords[2] .. &quot; AND z = &quot; .. coords[3] .. &quot; AND remove &gt; 1&quot;)
	conn:execute(&quot;UPDATE keystones SET removed = 0 WHERE steam = &quot; .. llpid .. &quot; AND x = &quot; .. coords[1] .. &quot; AND y = &quot; .. coords[2] .. &quot; AND z = &quot; .. coords[3])

	if accessLevel(llpid) &gt; 3 then
		region = getRegion(coords[1], coords[3])

		loc, reset = inLocation(coords[1], coords[3])

		if (resetRegions[region]) or reset or players[llpid].removeClaims == true then
			conn:execute(&quot;INSERT INTO keystones (steam, x, y, z, remove) VALUES (&quot; .. llpid .. &quot;,&quot; .. coords[1] .. &quot;,&quot; .. coords[2] .. &quot;,&quot; .. coords[3] .. &quot;,1) ON DUPLICATE KEY UPDATE remove = 1&quot;)
		else
			conn:execute(&quot;INSERT INTO keystones (steam, x, y, z) VALUES (&quot; .. llpid .. &quot;,&quot; .. coords[1] .. &quot;,&quot; .. coords[2] .. &quot;,&quot; .. coords[3] .. &quot;)&quot;)
		end		
	else
		conn:execute(&quot;INSERT INTO keystones (steam, x, y, z) VALUES (&quot; .. llpid .. &quot;,&quot; .. coords[1] .. &quot;,&quot; .. coords[2] .. &quot;,&quot; .. coords[3] .. &quot;)&quot;)
	end
end


if ircListItems ~= nil and string.sub(string.trim(line), 1, 5) == &quot;Slot &quot; then
	ircListItems = nil
end


if ircListItems ~= nil then
	if string.sub(line,1,4) == &quot;    &quot; and string.sub(line,5,5) ~= &quot; &quot; then
		irc_QueueMsg(players[ircListItems].ircAlias, string.trim(line))
	end
end


-- collect the ban list
if collectBans ~= nil then
	if (string.find(line, &quot; AM &quot;)) or (string.find(line, &quot; PM &quot;)) and not string.find(line, &quot;banned until&quot;) then
		temp = string.split(line, &quot;-&quot;)
		steam = string.trim(temp[2])

		conn:execute(&quot;INSERT INTO bans (BannedTo, steam, reason) VALUES ('&quot; .. string.trim(temp[1]) .. &quot;',&quot; .. steam .. &quot;,'&quot; .. string.trim(temp[3]) .. &quot;')&quot;)

		-- also insert the steam owner (will only work if the steam id is different)
		conn:execute(&quot;INSERT INTO bans (BannedTo, steam, reason) VALUES ('&quot; .. string.trim(temp[1]) .. &quot;',&quot; .. players[steam].steamOwner .. &quot;,'&quot; .. string.trim(temp[3]) .. &quot;')&quot;)
	end
end


if (string.find(line, &quot;Banned until&quot;)) then
	collectBans = true
end


if echoConsoleTo ~= nil then
	if string.find(line, &quot;Executing command 'help&quot;) then
		echoConsole = true
		return
	end

	if string.find(line, &quot;Executing command 'se'&quot;) then
		echoConsole = true
		return
	end

	if string.find(line, &quot;Executing command 'si &quot;) and string.find(line, echoConsoleTrigger) then
		echoConsole = true
		return
	end

	if string.find(line, &quot;Executing command 'gg'&quot;) then
		echoConsole = true
		return
	end

	if string.find(line, &quot;Executing command 'llp&quot;) then
		echoConsole = true
		return
	end

	if string.find(line, &quot;Executing command 'ban list'&quot;) then
		echoConsole = true
		return
	end

	if (echoConsole ~= nil) and (string.sub(line, 1, 4) == os.date(&quot;%Y&quot;)) then
		echoConsole = nil
		echoConsoleTo = l
	end

	if echoConsole == true then
		line = line:gsub(&quot;,&quot;, &quot;&quot;) -- strip out commas
		irc_QueueMsg(echoConsoleTo, line)
	end
end


if (string.sub(line, 1, 4) == os.date(&quot;%Y&quot;)) then
	collectBans = nil
	collectFriends = nil
end


-- collect the friend list
if collectFriends ~= nil then
--	if not string.find(line, &quot;friends:&quot;) then
--		temp = string.split(line, &quot; &quot;)
--		pid = LookupPlayer(temp[4])		

--		if (not string.find(friends[collectFriends].friends, pid)) then
--			friends[collectFriends].friends = friends[collectFriends].friends .. pid .. &quot;,&quot;
--			irc_QueueMsg(server.ircMain, players[collectFriends].name .. &quot; is now friends with &quot; .. players[pid].name)

--			if igplayers[collectFriends] then
--				message(&quot;pm &quot; .. collectFriends .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[pid].name .. &quot; is now recognised as a friend[-]&quot;)	
--			end

--			conn:execute(&quot;INSERT INTO friends (steam, friend) VALUES (&quot; .. collectFriends .. &quot;,&quot; .. pid .. &quot;)&quot;)
--		end

--	end
end


--2015-08-23T15:08:25 87646.450 INF Executing command 'pm IPCHECK' by Telnet from 127.0.0.1:59765
if string.find(line, &quot;IPCHECK&quot;) then
	temp = string.sub(line, string.find(line, &quot;from &quot;) + 5)
	server.botsIP = string.sub(temp, 1, string.find(temp, &quot;:&quot;) - 1)
end

--2016-03-13T00:18:24 14931.344 INF Executing command 'py' by Telnet from 203.86.204.248:55524


if string.find(line, &quot;Physics enabled: False&quot;) then
	if server.allowPhysics then
		send(&quot;py&quot;)
	end
end


if string.find(line, &quot;Physics enabled: True&quot;) then
	if not server.allowPhysics then
		send(&quot;py&quot;)
	end
end


-- detect Coppi's modded Alloc's Mod
if not server.coppi then
	if string.find(line, &quot;Usage: teleportplayerhome&quot;) then
		server.coppi = true

		if server.hideCommands then
			send(&quot;tcch /&quot;)
		end
	end
end

</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>^(.*)$</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>1</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>InventorySlot</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

if (string.find(line, &quot;Chat:&quot;)) then
	-- do not process the line because Slot was mentioned in chat not output from doing si
else
	readInventorySlot()
end


</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>Slot</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Player connected</name>
            <script>--[[ 
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

function playerDenied()
	local steam

	steam = string.trim(string.sub(line, string.find(line, &quot;INF Player&quot;) + 12, string.find(line, &quot;denied&quot;) - 3))
	steam = LookupPlayer(steam)

	if steam ~= nil then
		if (accessLevel(steam) &lt; 5) then
			reserveSlot(steam)
		end
	end
end

function playerConnected()
	local entityid, player, steam, steamOwner, IP, temp_table, temp, debug
	local timestamp = os.time()

	debug = false

	if debug then dbug(&quot;playerConnected 1&quot;) end

	temp_table = string.split(line, &quot;,&quot;)
	timeConnected = string.sub(line, 1, 19)

	if string.find(line, &quot;steamid=&quot;) then 
		player = string.trim(string.sub(temp_table[3], string.find(temp_table[3], &quot;name=&quot;) + 5, string.find(temp_table[3], &quot;,&quot;)))
		steam = string.sub(temp_table[4], string.find(temp_table[4], &quot;steamid=&quot;) + 8, string.find(temp_table[4], &quot;,&quot;))
		entityid = string.sub(temp_table[2], string.find(temp_table[2], &quot;entityid=&quot;) + 9, string.find(temp_table[2], &quot;,&quot;))
		if string.find(line, &quot;steamOwner&quot;) then
			steamOwner = string.sub(temp_table[5], string.find(temp_table[5], &quot;steamOwner=&quot;) + 11)
			IP = string.sub(temp_table[6], string.find(temp_table[6], &quot;ip=&quot;) + 3)
		else
			steamOwner = steam
			IP = string.sub(temp_table[5], string.find(temp_table[5], &quot;ip=&quot;) + 3)
		end
	end

	if IP == nil then IP = &quot;&quot; end

	if debug then dbug(&quot;playerConnected 2&quot;) end

	if string.find(line, &quot;OwnerID=&quot;) and not string.find(line, &quot;OwnerID=''&quot;) then
		steam = string.sub(line, string.find(line, &quot;OwnerID=&quot;) + 9, string.find(line, &quot;PlayerName=&quot;) - 4)
		player = string.trim(string.sub(line, string.find(line, &quot;PlayerName=&quot;) + 12, string.len(line) - 1))
		entityid = string.sub(line, string.find(line, &quot;EntityID=&quot;) + 9, string.find(line, &quot;PlayerID=&quot;) - 3)
	end

	if debug then dbug(&quot;playerConnected 3&quot;) end

	-- log the player connection in events table
	conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (0,0,0,'&quot; .. serverTime .. &quot;','player joined','Player joined &quot; .. escape(player) .. &quot; &quot; .. steam .. &quot; Owner &quot; .. steamOwner .. &quot; &quot; .. entityid .. &quot; &quot; .. IP .. &quot;',&quot; .. steamOwner .. &quot;)&quot;)

	if debug then dbug(&quot;playerConnected 4&quot;) end

	if	db2Connected then
		-- copy in bots db
		connBots:execute(&quot;INSERT INTO events (server, serverTime, type, event, steam) VALUES ('&quot; .. escape(server.ServerName) .. &quot;','&quot; .. serverTime .. &quot;','player joined','Player joined &quot; .. escape(player) .. &quot; &quot; .. steam .. &quot; Owner &quot; .. steamOwner .. &quot; &quot; .. entityid .. &quot; &quot; .. IP .. &quot;',&quot; .. steamOwner .. &quot;)&quot;)
	end

	if debug then dbug(&quot;playerConnected 5&quot;) end

	lastPlayerConnected = player
	lastSteamConnected = steam

	-- add to players table
	if (not players[steam]) then
		initNewPlayer(steam, player, entityid, steamOwner)
		fixMissingPlayer(steam, steamOwner)

		irc_QueueMsg(server.ircMain, &quot;###  New player joined &quot; .. player .. &quot; steam: &quot; .. steam.. &quot; owner: &quot; .. steamOwner .. &quot; id: &quot; .. entityid .. &quot; ###&quot;)
		irc_QueueMsg(server.ircAlerts, &quot;New player joined&quot;)
		irc_QueueMsg(server.ircAlerts, line:gsub(&quot;%,&quot;, &quot;&quot;))
		irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. steam .. &quot; &quot; .. player .. &quot; new player connected&quot;)

		for k, v in pairs(igplayers) do
			if accessLevel(k) &lt; 3 then
				message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]New player joined &quot; .. entityid .. &quot; &quot; .. player .. &quot;[-]&quot;)
			end
		end

		conn:execute(&quot;INSERT INTO players (steam, steamOwner, id, name, protectSize, protect2Size, firstSeen) VALUES (&quot; .. steam .. &quot;,&quot; .. steamOwner .. &quot;,&quot; .. entityid .. &quot;,'&quot; .. escape(player) .. &quot;',&quot; .. server.baseSize .. &quot;,&quot; .. server.baseSize .. &quot;,&quot; .. os.time() .. &quot;)&quot;)		

		if debug then dbug(&quot;playerConnected 6&quot;) end

		conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (0,0,0,'&quot; .. serverTime .. &quot;','new player','New player joined &quot; .. escape(player) .. &quot; steam: &quot; .. steam .. &quot; owner: &quot; .. steamOwner .. &quot; id: &quot; .. entityid .. &quot;',&quot; .. steam .. &quot;)&quot;)

		if debug then dbug(&quot;playerConnected 7&quot;) end

		if	db2Connected then
			-- also update the bots db
			insertBotsPlayer(steam)
		end

		if debug then dbug(&quot;playerConnected 8&quot;) end

		if	db2Connected then
			-- copy in bots db 
			connBots:execute(&quot;INSERT INTO events (server, serverTime, type, event, steam) VALUES ('&quot; .. escape(server.ServerName) .. &quot;','&quot; .. serverTime .. &quot;','new player','New player joined &quot; .. escape(player) .. &quot; steam: &quot; .. steam .. &quot; owner: &quot; .. steamOwner .. &quot; id: &quot; .. entityid .. &quot;',&quot; .. steam .. &quot;)&quot;)
		end

		if debug then dbug(&quot;playerConnected 9&quot;) end
	else
		if players[steam].watchPlayer then
			irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. steam .. &quot; &quot; .. player .. &quot; connected&quot;)
		end

		-- add to in-game players table
		if (not igplayers[steam]) then
			initNewIGPlayer(steam, player, entityid, steamOwner)
			fixMissingIGPlayer(steam, steamOwner)
		end

		players[steam].IP = IP

		if debug then dbug(&quot;playerConnected 10&quot;) end

		if	db2Connected then
			-- update player in bots db
			updateBotsPlayer(steam)
		end
		cmd = &quot;llp &quot; .. steam
		tempTimer( 5, [[send(&quot;]] .. cmd .. [[&quot;)]] )
	end

	if inWhitelist(steam) then
		players[steam].whitelisted = true
	end

	if server.coppi and players[steam].mute then
		send(&quot;mpc &quot; .. steam .. &quot; true&quot;)
	end

	if debug then dbug(&quot;playerConnected 11&quot;) end

	if IP ~= &quot;&quot; then
		CheckBlacklist(steam, IP)
	end

	if debug then dbug(&quot;playerConnected 12&quot;) end

	if (not lastHotspots[steam]) then
		lastHotspots[steam] = {}
	end

	if (players[steam].sessionCount ~= nil) then
		players[steam].sessionCount = players[steam].sessionCount + 1
	else
		players[steam].sessionCount = 1
	end

	if (friends[steam] == nil) then
		friends[steam] = {}
		friends[steam].friends = &quot;&quot;
	end

	players[steam].autoKicked = nil

	invTemp[steam] = {}

	if not string.find(players[steam].names, player, nil, true) then -- the last argument disables pattern matching.  We need to do this for player names with () in them.
		players[steam].names = players[steam].names .. &quot;,&quot; .. player
	end

	if debug then dbug(&quot;playerConnected 13&quot;) end

	conn:execute(&quot;UPDATE players SET aliases = '&quot; .. players[steam].names .. &quot;', sessionCount = &quot; .. players[steam].sessionCount .. &quot; WHERE steam = &quot; .. steam)

	if debug then dbug(&quot;playerConnected 14&quot;) end

	-- kick player if currently banned or permabanned
	cursor,errorString = conn:execute(&quot;SELECT * FROM bans WHERE Steam = &quot; .. steam .. &quot; or Steam = &quot; .. steamOwner .. &quot; and expiryDate &gt; '&quot; .. os.date(&quot;%Y-%m-%d %H:%M:%S&quot;) .. &quot;'&quot;)
	if cursor:numrows() &gt; 0 then
		kick(steam, &quot;You are currently banned. Contact us if this is in error.&quot;)
		return
	end

	-- kick for bad player name
	if	not server.allowNumericNames and not server.allowGarbageNames and not players[steam].whitelisted then
		temp = countAlphaNumeric(player)

		if tonumber(player) ~= nil or tonumber(temp) == 0 then
			kick(steam, &quot;Names without letters are not allowed here. You need to change your name to play on this server.&quot;)
			return
		end
	end

	-- kick player if only 1 slot left and it is reserved for someone else
	if tonumber(playersOnline) == tonumber(server.ServerMaxPlayerCount) - 1 and tonumber(table.maxn(reservedSlots)) &gt; 0 and not reservedSlots[steam] then
		kick(steam, &quot;Sorry the last slot is temporarily reserved. Please try again in a minute.&quot;)
		return
	end	

	-- timeout the player if they are relogging too many times in quick succession
--	if tonumber(players[steam].relogCount) &gt; 4 and players[steam].newPlayer then
--		timeoutPlayer(steam, &quot;relogging many times in a short space of time.&quot;, false)
--		players[steam].relogCount = 0
--	end

	-- delete read mail that isn't flagged as saved (status = 2).
	conn:execute(&quot;DELETE FROM mail WHERE id = &quot; .. steam .. &quot; and status = 1&quot;)

	if server.coppi then
		send(&quot;pcml &quot; .. steam .. &quot; 255&quot;)
	end

	cecho(server.windowDebug, &quot;Finished Player Connected\n&quot;)

	if debug then dbug(&quot;playerConnected end&quot;) end
end

if string.find(line, &quot;denied: Too many players on the server!&quot;) then
	playerDenied()
end

if string.find(line, &quot;Player connected&quot;) then
	playerConnected()
end</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>INF Player connected</string>
                <string>denied: Too many players on the server</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>playerinfo</name>
            <script>--[[ 
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


if botDisabled then
	return
end

function playerInfo()
	-- EDIT THIS FUNCTION WITH CARE.  This function is central to player management.  Some lines need to be run before others.
	-- Lua will stop execution wherever it strikes a fault (usually trying to use a non-existing variable)
	-- enable debugging to see roughly where the bot gets to.  It should reach 'end playerinfo'.
	-- Good luck :)

	faultyPlayerinfo = true
	faultyPlayerinfoID = 0
	faultyPlayerinfoLine = line

	local debugSteam, debug, id, name, posX, posY, posZ, lastX, lastY, lastZ, lastDist, mapCenterDistance
	local deaths, zombies, kills, score, level, steam, steamtest, admin, lastGimme, lastLogin
	local xPosOld, yPosOld, zPosOld, rawPosition, outsideMap, outsideMapDonor, fields, values
	local isAdmin = &quot;No&quot;
	local isPrisoner = &quot;No&quot;
	local timestamp = os.time()
	local region = &quot;&quot;
	local resetZone = false
	local ping, dist, IP, hotspot, currentLocation
	local skipTPtest = false
	local badData = false

	-- Set debugSteam to the steam id or player name that you want to monitor.  The player must be on the server.
	debugSteam = 0
	--debugSteam = &quot;copy steam id here&quot;

	if (debugSteam ~= 0) then 
		dbug(&quot;debug playerinfo&quot;) 
	end	

	-- sanity check debugSteam
	if tonumber(debugSteam) == nil then
		debugSteam = LookupPlayer(debugSteam)
		if debugSteam == nil then debugSteam = 0 end
	end

	name_table = string.split(line, &quot;, &quot;)

	if string.find(name_table[3], &quot;pos&quot;) then 
		name = string.trim(name_table[2])
	else
		temp = name_table[1] .. &quot;, name&quot; .. string.sub(line, string.find(line, &quot;, pos=&quot;), string.len(line))
		name_table = string.split(temp, &quot;, &quot;)
		name = string.trim(string.sub(line, string.find(line, &quot;,&quot;) + 2, string.find(line, &quot;, pos=&quot;) - 1))
	end

	-- stop processing this player if we don't have 18 parts to the line after splitting on comma
	-- it is probably a read error
	if (table.maxn(name_table) &lt; 18) then
		faultyPlayerinfoID = 0
		return
	end

	temp = string.split(name_table[1], &quot;=&quot;)
	id = temp[2]

	num = tonumber(string.sub(name_table[3], 6))
	if (num == nil) then badData = true end
	posX = num

	num = tonumber(name_table[4])
	if (num == nil) then badData = true end
	posY = num

	temp = string.split(name_table[5], &quot;)&quot;)
	num = tonumber(temp[1])
	if (num == nil) then badData = true end
	posZ = num

	temp = string.split(name_table[11], &quot;=&quot;)
	num = tonumber(temp[2])
	if (num == nil) then badData = true end
	deaths = num

	temp = string.split(name_table[12], &quot;=&quot;)
	num = tonumber(temp[2])
	if (num == nil) then badData = true end
	zombies = num

	temp = string.split(name_table[13], &quot;=&quot;)
	num = tonumber(temp[2])
	if (num == nil) then badData = true end
	kills = num

	temp = string.split(name_table[14], &quot;=&quot;)
	num = tonumber(temp[2])
	if (num == nil) then badData = true end
	score = num

	temp = string.split(name_table[15], &quot;=&quot;)
	num = tonumber(temp[2])
	if (num == nil) then badData = true end
	level = num

	temp = string.split(name_table[16], &quot;=&quot;)
	if (num == nil) then badData = true end
	steam = temp[2]

	faultyPlayerinfoID = steam

	temp = string.split(name_table[17], &quot;=&quot;)
	IP = temp[2]

	temp = string.split(name_table[18], &quot;=&quot;)
	ping = temp[2]

	if badData then
		cecho(server.windowDebug, &quot;Bad lp line: &quot; .. line .. &quot;\n&quot;)
		return
	end

	rawPosition = posX .. posY .. posZ


	intX = math.floor(posX)
	intY = math.ceil(posY)
	intZ = math.floor(posZ)

	region = getRegion(intX, intZ)
	if (resetRegions[region]) then 
		resetZone = true 
	else
		resetZone = false
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 1&quot;) 
	end	

	-- check for crazy server crash
	if (string.find(line, &quot;type=EntityZombie&quot;)) then
		if nextRebootTest == nil or (nextRebootTest ~= nil and os.time() &gt; nextRebootTest) then
			if (server.scheduledRestart == true) and scheduledRestartForced == false then
				gmsg(&quot;/cancel reboot&quot;)
			end

			if scheduledRestartForced == false then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]Zombies have been detected in the player data and an urgent reboot has been initiated to fix it.[-]&quot;)
				message(&quot;say [&quot; .. server.chatColour .. &quot;]You have 2 minutes to stop what you are doing and clear your crafting, forges and campfires.[-]&quot;)
				gmsg(&quot;/reboot server 2 minutes forced&quot;)
			end
		end

		return
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 2&quot;) 
	end	

	--display (&quot;temp[2] = -&quot; .. temp[2] .. &quot;-\n&quot;)

	-- check for invalid or missing steamid.  kick if not passed
	steamtest = 0
	steamtest = tonumber(steam)
	if (steamtest == nil) and (steam ~= &quot;&quot;) then --  or (string.len(steam) &lt; 17)
		cecho (server.windowAlerts, &quot;Kicking player &quot; .. name .. &quot; for invalid Steam ID &quot; .. steam .. &quot;\n&quot;)
		cecho (server.windowAlerts,  line .. &quot;\n&quot;)
		message(&quot;say [&quot; .. server.chatColour .. &quot;]Kicking player &quot; .. name .. &quot; for bad steam ID: &quot; .. steam .. &quot;[-]&quot;)
		send (&quot;kick &quot; .. id)

		faultyPlayerinfo = false
		return
	end

	-- add to in-game players table
	if (igplayers[steam] == nil) then
		igplayers[steam] = {}
		igplayers[steam].id = id
		igplayers[steam].name = name
		igplayers[steam].steam = steam
		igplayers[steam].steamOwner = steam

		fixMissingIGPlayer(steam)
	end

	-- add to players table
	if (players[steam] == nil) then
		players[steam] = {}
		players[steam].id = id
		players[steam].name = name
		players[steam].steam = steam

		if tonumber(score) == 0 and tonumber(zombies) == 0 and tonumber(deaths) == 0 then
			players[steam].newPlayer = true
		else
			players[steam].newPlayer = false
		end

		players[steam].watchPlayer = true
		players[steam].IP = IP
		players[steam].exiled = 0

		irc_QueueMsg(server.ircMain, &quot;###  New player joined &quot; .. player .. &quot; steam: &quot; .. steam.. &quot; id: &quot; .. id .. &quot; ###&quot;)
		irc_QueueMsg(server.ircAlerts, &quot;New player joined&quot;)
		irc_QueueMsg(server.ircAlerts, line)

		conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. math.floor(posX) .. &quot;,&quot; .. math.floor(posY) .. &quot;,&quot; .. math.floor(posZ) .. &quot;,'&quot; .. serverTime .. &quot;','new player','New player joined &quot; .. name .. &quot; steam: &quot; .. steam.. &quot; id: &quot; .. id .. &quot;',&quot; .. steam .. &quot;)&quot;)
		conn:execute(&quot;INSERT INTO players (steam, name, id, IP, newPlayer, watchPlayer) VALUES (&quot; .. steam .. &quot;,'&quot; .. escape(name) .. &quot;',&quot; .. id .. &quot;,&quot; .. IP .. &quot;,1,1)&quot;)

		fixMissingPlayer(steam)
		CheckBlacklist(steam, IP)
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 4&quot;) 
	end	

	if (players[steam].prisoner == true) then
		isPrisoner = &quot;Yes&quot;
	end

	if accessLevel(steam) &lt; 3 then
		isAdmin = &quot;Yes&quot;
	end

	if IP ~= &quot;&quot; and players[steam].IP == &quot;&quot; then
		players[steam].IP = IP
		CheckBlacklist(steam, IP)
	end

	-- ping kick
	if players[steam].whitelisted == false and players[steam].newPlayer then
		if tonumber(ping) &lt; tonumber(server.pingKick) and tonumber(server.pingKick) &gt; 0 then
			igplayers[steam].highPingCount = tonumber(igplayers[steam].highPingCount) - 1
			if tonumber(igplayers[steam].highPingCount) &lt; 0 then igplayers[steam].highPingCount = 0 end
		end 

		if tonumber(ping) &gt; tonumber(server.pingKick) and tonumber(server.pingKick) &gt; 0 then
			igplayers[steam].highPingCount = tonumber(igplayers[steam].highPingCount) + 1

			if tonumber(igplayers[steam].highPingCount) &gt; 5 then
				irc_QueueMsg(server.ircMain, &quot;Kicked &quot; .. name .. &quot; steam: &quot; .. steam.. &quot; for high ping &quot; .. ping)
				kick(steam, &quot;High ping. Contact an admin and ask to be whitelisted.&quot;)
				return
			end
		end
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 9&quot;) 
	end	

	if tonumber(intY) &gt; 0 and tonumber(intY) &lt; 500 then
		igplayers[steam].lastTP = nil
		forgetLastTP(steam)
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 10&quot;) 
	end	

	if (players[steam].location ~= &quot;&quot;) then
		-- spawn the player at location
		if (locations[players[steam].location]) then
			cursor,errorString = conn:execute(&quot;select * from locationSpawns where location='&quot; .. players[steam].location .. &quot;'&quot;)
			if cursor:numrows() &gt; 0 then
				randomPVPTP(steam, players[steam].location, true)
			else
				cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. locations[players[steam].location].x .. &quot; &quot; .. locations[players[steam].location].y .. &quot; &quot; .. locations[players[steam].location].z
				igplayers[steam].lastTP = cmd
				teleport(cmd, true)
			end

			players[steam].location = &quot;&quot;
			conn:execute(&quot;UPDATE players SET location = '' WHERE steam = &quot; .. steam)
		end

		if (players[steam].location == &quot;return player&quot;) then		

			if players[steam].xPosTimeout ~= 0 and players[steam].zPosTimeout ~= 0 then
				cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. players[steam].xPosTimeout .. &quot; &quot; .. players[steam].yPosTimeout .. &quot; &quot; .. players[steam].zPosTimeout
				players[steam].xPosTimeout = 0
				players[steam].yPosTimeout = 0
				players[steam].zPosTimeout = 0
			else
				cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. players[steam].xPosOld .. &quot; &quot; .. players[steam].yPosOld .. &quot; &quot; .. players[steam].zPosOld
			end

			igplayers[steam].lastTP = cmd
			teleport(cmd, true)
			players[steam].location = &quot;&quot;
			conn:execute(&quot;UPDATE players SET location = '' WHERE steam = &quot; .. steam)
		end
	end

	-- test for hackers teleporting
	-- This feature has been partially disabled for now. There are too many false flags since 14.6
	if not server.playersCanFly then
		if tonumber(intY) &gt; -5000 and tonumber(intX) ~= 0 and tonumber(intZ) ~= 0 and tonumber(igplayers[steam].xPos) ~= 0 and tonumber(igplayers[steam].zPos) ~= 0 and tonumber(os.time() - igplayers[steam].lastLP) &lt; 4 then
			dist = 0

			if igplayers[steam].deadX == nil then
				dist = distancexz(posX, posZ, igplayers[steam].xPos, igplayers[steam].zPos)
			end

			if (dist &gt;= 300) then
				if tonumber(players[steam].tp) &lt; 1 then
					if players[steam].newPlayer == true then
						new = &quot; [FF8C40]NEW player &quot;
					else
						new = &quot; [FF8C40]Player &quot;
					end

					if accessLevel(steam) &gt; 2 then
						irc_QueueMsg(server.ircMain, serverTime .. &quot; Player &quot; .. id .. &quot; name: &quot; .. name .. &quot; detected teleporting to &quot; .. intX .. &quot; &quot; .. intY .. &quot; &quot; .. intZ .. &quot; distance &quot; .. dist)
						irc_QueueMsg(server.ircAlerts, serverTime .. &quot; Player &quot; .. id .. &quot; name: &quot; .. name .. &quot; detected teleporting to &quot; .. intX .. &quot; &quot; .. intY .. &quot; &quot; .. intZ .. &quot; distance &quot; .. dist)
						irc_QueueMsg(server.ircTracker, serverTime .. &quot; Player &quot; .. id .. &quot; name: &quot; .. name .. &quot; detected teleporting from &quot; .. math.floor(igplayers[steam].xPos) .. &quot; &quot; .. math.ceil(igplayers[steam].yPos) .. &quot; &quot; .. math.floor(igplayers[steam].zPos) .. &quot; to &quot; .. intX .. &quot; &quot; .. intY .. &quot; &quot; .. intZ .. &quot; distance &quot; .. dist)

						players[steam].hackerScore = tonumber(players[steam].hackerScore) + 1
						players[steam].watchPlayer = true
						conn:execute(&quot;UPDATE players SET watchPlayer = 1 WHERE steam = &quot; .. steam)

						if tonumber(players[steam].hackerScore) &gt; 1 then
							players[steam].hackerScore = 0
							players[steam].tp = 0
--							message(&quot;say [&quot; .. server.chatColour .. &quot;]Temp-banning &quot; .. players[steam].name .. &quot; 1 day for unexplained teleporting. An admin will investigate the circumstances.[-]&quot;)
--							banPlayer(steam, &quot;1 day&quot;, &quot;We detected unusual teleporting from you and are investigating the circumstances.&quot;, &quot;&quot;)
						end

						for k, v in pairs(igplayers) do
							if (accessLevel(k) &lt; 3) then
--								message(&quot;pm &quot; .. k .. new .. id .. &quot; name: &quot; .. name .. &quot; detected teleporting (possible hacker). The detection is real but I could be wrong.  Watch the player.[-]&quot;)
							end
						end
					end
				end

				players[steam].tp = 0

				-- just in case this is an admin we don't know about, run admin list
				send(&quot;admin list&quot;)
			end
		end
	end

	igplayers[steam].lastLP = os.time()

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 11&quot;) 
	end	

	players[steam].name = name
	players[steam].steamOwner = igplayers[steam].steamOwner
	igplayers[steam].name = name
	igplayers[steam].steam = steam
	igplayers[steam].xPos = posX
	igplayers[steam].yPos = posY
	igplayers[steam].zPos = posZ
	igplayers[steam].playerKills = kills
	igplayers[steam].deaths = deaths
	igplayers[steam].zombies = zombies
	igplayers[steam].score = score
	igplayers[steam].level = level
	players[steam].level = level
	igplayers[steam].killTimer = 0 -- to help us detect a player that has disconnected unnoticed
	igplayers[steam].raiding = false

	if tonumber(ping) &gt; 0 then
		igplayers[steam].ping = ping
		players[steam].ping = ping
	end

	if igplayers[steam].rawPosition == nil then
		igplayers[steam].rawPosition = rawPosition
	end

	if (igplayers[steam].xPosLast == nil) then
		igplayers[steam].xPosLast = posX
		igplayers[steam].yPosLast = posY
		igplayers[steam].zPosLast = posZ
		igplayers[steam].xPosLastOK = intX
		igplayers[steam].yPosLastOK = intY
		igplayers[steam].zPosLastOK = intZ
	end

	atHome(steam)

	currentLocation = inLocation(intX, intZ)

	if currentLocation ~= false then
		resetZone = locations[currentLocation].resetZone

		if locations[currentLocation].killZombies then 
			scanZombies = true
		end
	end

	if players[steam].showLocationMessages then
		if igplayers[steam].alertLocation ~= currentLocation and currentLocation ~= false then
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Welcome to &quot; .. currentLocation .. &quot;[-]&quot;)
		end
	end

	if currentLocation == false then --  or igplayers[steam].alertLocation ~= currentLocation
		if players[steam].showLocationMessages then
			if igplayers[steam].alertLocation ~= &quot;&quot; then
				message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You have left &quot; .. igplayers[steam].alertLocation .. &quot;[-]&quot;)
			end
		end

		igplayers[steam].alertLocation = &quot;&quot;
		players[steam].inLocation = &quot;&quot;
	else
		igplayers[steam].alertLocation = currentLocation
		players[steam].inLocation = currentLocation
	end

	if igplayers[steam].checkNewPlayer == true then
		igplayers[steam].checkNewPlayer = false

		if tonumber(level) &gt; 1 then
			players[steam].newPlayer = false
			conn:execute(&quot;UPDATE players SET newPlayer = 0 WHERE steam = &quot; .. steam)
			irc_QueueMsg(server.ircMain, &quot;Player &quot; .. player .. &quot;'s new player status has been removed because their level is &quot; .. level)
		end
	end

	-- convert zombie kills to cash
	if (tonumber(igplayers[steam].zombies) &gt; tonumber(players[steam].zombies)) and (math.abs(igplayers[steam].zombies - players[steam].zombies) &lt; 20) then
		if server.allowBank then
			players[steam].cash = tonumber(players[steam].cash) + math.abs(igplayers[steam].zombies - players[steam].zombies) * server.zombieKillReward

			if (players[steam].watchCash == true) then
				message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]+&quot; .. math.abs(igplayers[steam].zombies - players[steam].zombies) * server.zombieKillReward .. &quot; Zennies. $&quot; .. players[steam].cash .. &quot; in the bank[-]&quot;)
			end
		end

		if igplayers[steam].doge then
			r = rand(70)
			if r == 1 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]MUCH KILL[-]&quot;)	end
			if r == 2 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]GREAT PAIN[-]&quot;)	end
			if r == 3 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]WOW[-]&quot;)	end
			if r == 4 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]VERY DEATH[-]&quot;)	end
			if r == 5 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]AMAZING[-]&quot;)	end
			if r == 6 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]CALL 911[-]&quot;)	end
			if r == 7 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]BIG HIT[-]&quot;)	end
			if r == 8 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]EXTREME GORE[-]&quot;)	end
			if r == 9 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]EXTREME POWER SHOT[-]&quot;)	end
			if r == 10 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]EPIC BLOOD LOSS[-]&quot;)	end
			if r == 11 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]OMG[-]&quot;)	end
			if r == 12 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]OVERKILL[-]&quot;)	end
			if r == 13 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]EXTREME OVERKILL[-]&quot;)	end
			if r == 14 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]VERY OP[-]&quot;)	end
			if r == 15 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]DISMEMBERMENT[-]&quot;)	end
			if r == 16 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]HEAD SHOT[-]&quot;)	end
			if r == 17 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]PSYCHO[-]&quot;)	end
			if r == 18 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]HAX[-]&quot;)	end
			if r == 19 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]GAME OVER[-]&quot;)	end
			if r == 20 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]OWNED[-]&quot;)	end
			if r == 21 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]DUDE[-]&quot;)	end
			if r == 22 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]SICK[-]&quot;)	end
			if r == 23 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]INCREDIBLE[-]&quot;)	end
			if r == 24 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]BODY PARTS[-]&quot;)	end
			if r == 25 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]WTF[-]&quot;)	end
			if r == 26 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]EPIC[-]&quot;)	end
			if r == 27 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]AIMBOT[-]&quot;)	end
			if r == 28 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]EXPLOSIVE[-]&quot;)	end
			if r == 29 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]IMPOSSIBLE[-]&quot;)	end
			if r == 30 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]MASSIVE HURT[-]&quot;)	end
			if r == 31 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]C-C-C-COMBO BREAKER[-]&quot;)	end
			if r == 32 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]ULTRA KILL[-]&quot;)	end
			if r == 33 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]SUPPRESSED[-]&quot;)	end
			if r == 34 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]IMPRESSIVE[-]&quot;)	end
			if r == 35 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]ONE UP[-]&quot;)	end
			if r == 36 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]MEGA KILL[-]&quot;)	end
			if r == 37 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]SUPER KILL[-]&quot;)	end
			if r == 38 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]SKILL SHOT[-]&quot;)	end
			if r == 39 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]VERY AMAZING[-]&quot;)	end
			if r == 40 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]EPIC OWNAGE[-]&quot;)	end
			if r == 41 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]OMG WTF HAX[-]&quot;)	end
			if r == 42 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]HOW[-]&quot;)	end
			if r == 43 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]IMPOSSIBLE[-]&quot;)	end
			if r == 44 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]CRAZY KILL[-]&quot;)	end
			if r == 45 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]LEGENDARY KILL[-]&quot;)	end
			if r == 46 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]GUTSY[-]&quot;)	end
			if r == 47 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]SMOOTH[-]&quot;)	end
			if r == 48 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]PRO[-]&quot;)	end
			if r == 49 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]NUKED[-]&quot;)	end
			if r == 50 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]STOLEN KILL[-]&quot;)	end
			if r == 51 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]LEEEEEEEEEEEEEROY JENKINS!!!!!![-]&quot;)	end
			if r == 52 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]THANKS OBAMA[-]&quot;)	end
			if r == 53 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]WE GOT A BADDASS OVER HERE[-]&quot;)	end
			if r == 54 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]WTF BBQ[-]&quot;)	end
			if r == 55 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]JUST A FLESH WOUND[-]&quot;)	end
			if r == 56 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]WALK IT OFF[-]&quot;)	end
			if r == 57 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]THAT'S GOTTA HURT[-]&quot;)	end
			if r == 58 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]OOPS[-]&quot;)	end
			if r == 59 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]DAMN[-]&quot;)	end
			if r == 60 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]THUD[-]&quot;)	end
			if r == 61 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]FLUKE[-]&quot;)	end
			if r == 62 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]SORRY![-]&quot;)	end
			if r == 63 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]CHEAP[-]&quot;)	end
			if r == 64 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]BEGINNERS LUCK[-]&quot;)	end
			if r == 65 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]I'LL BE BACK[-]&quot;)	end
			if r == 66 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]HASTA LA VISTA BABY[-]&quot;)	end
			if r == 67 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]NOT THE KNEE![-]&quot;)	end
			if r == 68 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]KILLED DEAD[-]&quot;)	end
			if r == 69 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]LUCKY SHOT[-]&quot;)	end
			if r == 70 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]HE'S DEAD JIM[-]&quot;)	end
		end

		if server.allowBank then
			-- update the lottery prize pool
			server.lottery = server.lottery + (math.abs(igplayers[steam].zombies - players[steam].zombies) * server.lotteryMultiplier)
		end
	end

	-- update player record of zombies
	players[steam].zombies = igplayers[steam].zombies

	if tonumber(players[steam].playerKills) &lt; tonumber(kills) then
		players[steam].playerKills = kills
	end

	if tonumber(players[steam].deaths) &lt; tonumber(deaths) then
		players[steam].deaths = deaths
	end

	if tonumber(players[steam].score) &lt; tonumber(score) then
		players[steam].score = score
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 12&quot;) 
	end	

	--players[steam].level = level
	players[steam].xPos = posX
	players[steam].yPos = posY
	players[steam].zPos = posZ

	mapCenterDistance = distancexz(intX,intZ,0,0)
	outsideMap = squareDistance(intX, intZ, server.mapSize)
	outsideMapDonor = squareDistance(intX, intZ, server.mapSize + 5000)

	if (players[steam].alertReset == nil) then
		players[steam].alertReset = true
	end

	if (igplayers[steam].greet == true) and (igplayers[steam].greetdelay == 0) then
		igplayers[steam].greet = false

		if server.welcome ~= nil then
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. server.welcome .. &quot;[-]&quot;)
		else
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Welcome to &quot; .. server.ServerName .. &quot;!  Type /info, /rules or /help for answers to common questions.[-]&quot;)
		end

		if (tonumber(igplayers[steam].zombies) ~= 0) then
			if (players[steam].donor == true) then
				welcome = &quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Welcome back &quot; .. name .. &quot;! Thanks for supporting us. =D[-]&quot;
			else
				welcome = &quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Welcome back &quot; .. name .. &quot;![-]&quot;
			end

			if (string.find(serverTime, &quot;02-14&quot;, 5, 10)) then welcome = &quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Happy Valentines Day &quot; .. name .. &quot;![-]&quot; end

			message(welcome)
		else
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Welcome &quot; .. name .. &quot;![-]&quot;)
		end

		if (players[steam].timeout == true) then
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You are in timeout, not glitched or lagged.  You will stay here until released by an admin.[-]&quot;)
		end

		if (server.scheduledRestart == true or rebootTimerID ~= nil) then
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]&lt;!&gt; SERVER WILL REBOOT SHORTLY &lt;!&gt;[-]&quot;)
		end

		if server.MOTD ~= &quot;&quot; then
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,&quot; .. steam .. &quot;,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]&quot; .. server.MOTD .. &quot;[-]&quot;) .. &quot;')&quot;)
		end

		if tonumber(players[steam].removedClaims) &gt; 0 then
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,&quot; .. steam .. &quot;,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]I am holding &quot; .. players[steam].removedClaims .. &quot; land claim blocks for you. Type /give claims to receive them.[-]&quot;) .. &quot;')&quot;)
		end

		cursor,errorString = conn:execute(&quot;SELECT * FROM mail WHERE recipient = &quot; .. steam .. &quot; and status = 0&quot;)
		if cursor:numrows() &gt; 0 then
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,&quot; .. steam .. &quot;,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]You have unread mail.  Type /read mail to read it now or /help mail for more options.[-]&quot;) .. &quot;')&quot;)
		end

		if players[steam].newPlayer == true and server.rules ~= &quot;&quot; then
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,&quot; .. steam .. &quot;,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]&quot; .. server.rules ..&quot;[-]&quot;) .. &quot;')&quot;)
		end

		if server.warnBotReset == true and accessLevel(steam) == 0 then
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,&quot; .. steam .. &quot;,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]ALERT!  It appears that the server has been reset.[-]&quot;) .. &quot;')&quot;)
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,&quot; .. steam .. &quot;,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]To reset me type /reset bot.[-]&quot;) .. &quot;')&quot;)
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,&quot; .. steam .. &quot;,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]To dismiss this alert type /no reset.[-]&quot;) .. &quot;')&quot;)
		end

		if (not players[steam].santa) and specialDay == &quot;christmas&quot; then
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,&quot; .. steam .. &quot;,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]HO HO HO! Merry Christmas!  Type /santa to open your Christmas stocking![-]&quot;) .. &quot;')&quot;)
		end
	end


	if igplayers[steam].alertLocation == &quot;&quot; and currentLocation ~= false then
		conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,&quot; .. steam .. &quot;,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]Welcome to &quot; .. currentLocation .. &quot;[-]&quot;) .. &quot;')&quot;)
		igplayers[steam].alertLocation = currentLocation
	end


	if (igplayers[steam].greetdelay &gt; 0) then
		igplayers[steam].greetdelay = igplayers[steam].greetdelay - 1
	end


	if (igplayers[steam].teleCooldown &gt; 0) then
		igplayers[steam].teleCooldown = igplayers[steam].teleCooldown - 1
	end

	igplayers[steam].sessionPlaytime = os.time() - igplayers[steam].sessionStart

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 13&quot;) 
	end	

	if (players[steam].newPlayer == true and (igplayers[steam].sessionPlaytime + players[steam].timeOnServer &gt; (server.newPlayerTimer * 60))) then
		players[steam].newPlayer = false
		players[steam].watchPlayer = false
		message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Your new player status has been lifted.  You may now use the base command to teleport home.[-]&quot;)
		conn:execute(&quot;UPDATE players SET newPlayer = 0, watchPlayer = 0 WHERE steam = &quot; .. steam)
	end

	if tonumber(players[steam].donorExpiry) &lt; os.time() and players[steam].donor == true then
--		players[steam].donor = false
--		players[steam].donorLevel = 0
--		conn:execute(&quot;UPDATE players SET donor = 0, donorLevel = 0 WHERE steam = &quot; .. steam)

--		message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Your donor status has expired :(  Contact an admin if you need help accessing your second base. Your 2nd base's protection will be disabled one week from when your donor status expired.[-]&quot;)

		if os.time() - tonumber(players[steam].donorExpiry) &gt; (60 * 60 * 24 * 7) then
--			players[steam].protect2 = fase
--			conn:execute(&quot;UPDATE players SET protect2 = 0 WHERE steam = &quot; .. steam)
--			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]ALERT! Your second base is no longer bot protected![-]&quot;)
		end
	end

	if (showPlayers == true) then
		if players[steam].prisoner then 
			isPrisoner = &quot;yes&quot;
		else
			isPrisoner = &quot;no&quot;
		end

		if accessLevel(steam) &lt; 3 then 
			isAdmin = &quot;yes&quot;
		else
			isAdmin = &quot;no&quot;
		end

		cecho(server.windowLists, &quot;id:&quot; .. id .. &quot; name:&quot; .. igplayers[steam].name .. &quot; steam:&quot; .. steam .. &quot; admin:&quot; .. isAdmin .. &quot; xyz:&quot; .. math.floor(igplayers[steam].xPos) .. &quot; &quot; .. math.ceil(igplayers[steam].yPos) .. &quot; &quot; .. math.floor(igplayers[steam].zPos) .. &quot; prisoner:&quot; .. isPrisoner .. &quot; score:&quot; .. igplayers[steam].score .. &quot;\n&quot;)
		
		cecho(server.windowPlayers, &quot;id: &quot; .. id .. &quot;\n&quot;)
		cecho(server.windowPlayers, &quot;playerName: &quot; .. igplayers[steam].name .. &quot;\n&quot;)
		cecho(server.windowPlayers, &quot;current X Y Z: &quot; .. math.floor(igplayers[steam].xPos) .. &quot; &quot; .. math.ceil(igplayers[steam].yPos) .. &quot; &quot; .. math.floor(igplayers[steam].zPos) .. &quot;\n&quot;)	
		cecho(server.windowPlayers, &quot;steamID: &quot; .. steam .. &quot;\n&quot;)
		cecho(server.windowPlayers, &quot;playerKills: &quot; .. igplayers[steam].playerKills .. &quot;\n&quot;)
		cecho(server.windowPlayers, &quot;zombies: &quot; .. igplayers[steam].zombies .. &quot;\n&quot;)
		cecho(server.windowPlayers, &quot;score: &quot; .. igplayers[steam].score .. &quot;\n&quot;)
		cecho(server.windowPlayers, &quot;admin: &quot; .. isAdmin .. &quot;\n&quot;)
		cecho(server.windowPlayers, &quot;prisoner: &quot; .. isPrisoner .. &quot;\n&quot;)	
		cecho(server.windowPlayers, &quot;home XYZ: &quot; .. players[steam].homeX .. &quot; &quot; .. players[steam].homeY .. &quot; &quot; .. players[steam].homeZ .. &quot;\n&quot;)	
		cecho(server.windowPlayers, &quot;home2 XYZ: &quot; .. players[steam].homeX .. &quot; &quot; .. players[steam].home2Y .. &quot; &quot; .. players[steam].home2Z .. &quot;\n&quot;)	
		cecho(server.windowPlayers, &quot;session time: &quot; .. os.date(&quot;!%X&quot;,igplayers[steam].sessionPlaytime) .. &quot; seconds\n&quot;)	
		cecho(server.windowPlayers, &quot; \n&quot;)
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 14&quot;) 
	end	

	-- if we are following a player and they move more than 50 meters away, teleport us close to them.
	if igplayers[steam].following ~= nil then
		if igplayers[igplayers[steam].following] and players[igplayers[steam].following].timeout == false and players[igplayers[steam].following].botTimeout == false then
			followDistance = 50
			if igplayers[steam].followDistance ~= nil then followDistance = tonumber(igplayers[steam].followDistance) end

			dist = distancexz(igplayers[steam].xPos, igplayers[steam].zPos, igplayers[igplayers[steam].following].xPos, igplayers[igplayers[steam].following].zPos)	
			if dist &gt; followDistance and igplayers[igplayers[steam].following].yPos &gt; 0 then
				-- teleport close to the player
				players[steam].tp = 1
				players[steam].hackerScore = 0
				send(&quot;tele &quot; .. steam .. &quot; &quot; .. math.floor(igplayers[igplayers[steam].following].xPos) .. &quot; &quot; .. math.ceil(igplayers[igplayers[steam].following].yPos - 30) .. &quot; &quot; .. math.floor(igplayers[igplayers[steam].following].zPos))
			end
		end
	end


	if (igplayers[steam].alertLocationExit ~= nil) then
		dist = distancexz(igplayers[steam].xPos, igplayers[steam].zPos, locations[igplayers[steam].alertLocationExit].x, locations[igplayers[steam].alertLocationExit].z)
		size = tonumber(locations[igplayers[steam].alertLocationExit].size)

		if (dist &gt; tonumber(locations[igplayers[steam].alertLocationExit].size) + 100) then
			igplayers[steam].alertLocationExit = nil

			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Your have moved too far away from the location. If you still wish to do /protect location, please start again.[-]&quot;)
			faultyPlayerinfo = false
			return
		end

		if (dist &gt; tonumber(locations[igplayers[steam].alertLocationExit].size) + 10) and (dist &lt;  tonumber(locations[igplayers[steam].alertLocationExit].size) + 30) then
			locations[igplayers[steam].alertLocationExit].exitX = intX
			locations[igplayers[steam].alertLocationExit].exitY = intY
			locations[igplayers[steam].alertLocationExit].exitZ = intZ
			locations[igplayers[steam].alertLocationExit].protected = true

			conn:execute(&quot;UPDATE locations SET exitX = &quot; .. intX .. &quot;, exitY = &quot; .. intY .. &quot;, exitZ = &quot; .. intZ .. &quot;, protected = 1 WHERE name = '&quot; .. igplayers[steam].alertLocationExit .. &quot;'&quot;)
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You have enabled protection for &quot; .. igplayers[steam].alertLocationExit .. &quot;.[-]&quot;)

			igplayers[steam].alertLocationExit = nil

			faultyPlayerinfo = false
			return
		end
	end


	if (igplayers[steam].alertVillageExit ~= nil) then
		dist = distancexz(igplayers[steam].xPos, igplayers[steam].zPos, locations[igplayers[steam].alertVillageExit].x, locations[igplayers[steam].alertVillageExit].z)
		size = tonumber(locations[igplayers[steam].alertVillageExit].size)

		if (dist &gt; tonumber(locations[igplayers[steam].alertVillageExit].size) + 100) then
			igplayers[steam].alertVillageExit = nil

			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Your have moved too far away from &quot; .. igplayers[steam].alertVillageExit .. &quot;. Return to &quot; .. igplayers[steam].alertVillageExit .. &quot; and type /protect village &quot; .. igplayers[steam].alertVillageExit .. &quot; again.[-]&quot;)
			faultyPlayerinfo = false
			return
		end

		if (dist &gt;  tonumber(locations[igplayers[steam].alertVillageExit].size) + 10) and (dist &lt;  tonumber(locations[igplayers[steam].alertVillageExit].size) + 100) then
			locations[igplayers[steam].alertVillageExit].exitX = intX
			locations[igplayers[steam].alertVillageExit].exitY = intY
			locations[igplayers[steam].alertVillageExit].exitZ = intZ
			locations[igplayers[steam].alertVillageExit].protect = true

			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You have enabled protection for &quot; .. igplayers[steam].alertVillageExit .. &quot;[-]&quot;)

			igplayers[steam].alertVillageExit = nil

			faultyPlayerinfo = false
			return
		end
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 15&quot;) 
	end	

	if (igplayers[steam].alertBaseExit == true) then
		if igplayers[steam].alertBase == 1 then
			dist = distancexz(igplayers[steam].xPos, igplayers[steam].zPos, players[igplayers[steam].alertBaseID].homeX, players[igplayers[steam].alertBaseID].homeZ)
			size = tonumber(players[igplayers[steam].alertBaseID].protectSize)
		else
			dist = distancexz(igplayers[steam].xPos, igplayers[steam].zPos, players[igplayers[steam].alertBaseID].home2X, players[igplayers[steam].alertBaseID].home2Z)
			size = tonumber(players[igplayers[steam].alertBaseID].protect2Size)
		end

		if (dist &gt; 200) then
			igplayers[steam].alertBaseExit = nil
			igplayers[steam].alertBaseID = nil
			igplayers[steam].alertBase = nil

			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Your have moved too far away from the base. If you still wish to do setexitbase, please start again.[-]&quot;)
			faultyPlayerinfo = false
			return
		end

		if igplayers[steam].alertBase == 1 then
			if (dist &gt;  tonumber(players[igplayers[steam].alertBaseID].protectSize) + 10) and (dist &lt;  tonumber(players[igplayers[steam].alertBaseID].protectSize) + 40) then
				players[igplayers[steam].alertBaseID].exitX = intX
				players[igplayers[steam].alertBaseID].exitY = intY
				players[igplayers[steam].alertBaseID].exitZ = intZ

				if (accessLevel(steam) &lt; 3) then
					message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You have set an exit teleport for &quot; .. players[igplayers[steam].alertBaseID].name .. &quot;'s base.[-]&quot;)
				else
					message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You have set an exit teleport for your base.  You can test it with /test base.[-]&quot;)
				end

				-- check for nearby bases
				failProtect = false
				for k, v in pairs(players) do
					if (v.homeX ~= 0) and k ~= igplayers[steam].alertBaseID then
							if (v.homeX ~= 0 and v.homeZ ~= 0) then
							dist = distancexz(players[igplayers[steam].alertBaseID].homeX, players[igplayers[steam].alertBaseID].homeZ, v.homeX, v.homeZ)

							if (tonumber(dist) &lt; tonumber(players[igplayers[steam].alertBaseID].protectSize)) then
								if friends[k] == nil or not string.find(friends[k].friends, igplayers[steam].alertBaseID) then
									failProtect = true
								end
							end
						end
					end			

					if (v.home2X ~= 0) and k ~= igplayers[steam].alertBaseID then
						if (v.home2X ~= 0 and v.home2Z ~= 0) then
							dist = distancexz(players[igplayers[steam].alertBaseID].homeX, players[igplayers[steam].alertBaseID].homeZ, v.home2X, v.home2Z)

							if (dist &lt; players[igplayers[steam].alertBaseID].protectSize + 10) then
								if not string.find(friends[k].friends, igplayers[steam].alertBaseID) then
									failProtect = true
								end
							end
						end
					end						
				end
			
				if failProtect == false then
					players[igplayers[steam].alertBaseID].protect = true
					message(&quot;pm &quot; .. igplayers[steam].alertBaseID .. &quot; [&quot; .. server.chatColour .. &quot;]Base protection for your base is active.[-]&quot;)
				else
					message(&quot;pm &quot; .. igplayers[steam].alertBaseID .. &quot; [&quot; .. server.chatColour .. &quot;]Your base is too close to another player base who is not on your friends list.  Protection cannot be enabled.[-]&quot;)
				end			

				igplayers[steam].alertBaseExit = nil
				igplayers[steam].alertBaseID = nil
				igplayers[steam].alertBase = nil

				faultyPlayerinfo = false
				return
			end
		else
			if (dist &gt;  tonumber(players[igplayers[steam].alertBaseID].protect2Size) + 10) and (dist &lt;  tonumber(players[igplayers[steam].alertBaseID].protect2Size) + 40) then
				players[igplayers[steam].alertBaseID].exit2X = intX
				players[igplayers[steam].alertBaseID].exit2Y = intY
				players[igplayers[steam].alertBaseID].exit2Z = intZ

				if (accessLevel(steam) &lt; 3) then
					message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You have set an exit teleport for &quot; .. players[igplayers[steam].alertBaseID].name .. &quot;'s 2nd base.[-]&quot;)
				else
					message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You have set an exit teleport for your 2nd base.  You can test it with /test base.[-]&quot;)
				end

				-- check for nearby bases
				failProtect = false
				for k, v in pairs(players) do
					if (v.homeX ~= 0) and k ~= igplayers[steam].alertBaseID then
							if (v.homeX ~= 0 and v.homeZ ~= 0) then
							dist = distancexz(players[igplayers[steam].alertBaseID].home2X, players[igplayers[steam].alertBaseID].home2Z, v.homeX, v.homeZ)

							if (tonumber(dist) &lt; tonumber(players[igplayers[steam].alertBaseID].protect2Size)) then
								if friends[k] == nil or not string.find(friends[k].friends, igplayers[steam].alertBaseID) then
									failProtect = true
								end
							end
						end
					end			

					if (v.home2X ~= 0) and k ~= igplayers[steam].alertBaseID then
						if (v.home2X ~= 0 and v.home2Z ~= 0) then
							dist = distancexz(players[igplayers[steam].alertBaseID].home2X, players[igplayers[steam].alertBaseID].home2Z, v.home2X, v.home2Z)

							if (dist &lt; players[igplayers[steam].alertBaseID].protect2Size + 10) then
								if not string.find(friends[k].friends, igplayers[steam].alertBaseID) then
									failProtect = true
								end
							end
						end
					end						
				end
			
				if failProtect == false then
					players[igplayers[steam].alertBaseID].protect2 = true
					message(&quot;pm &quot; .. igplayers[steam].alertBaseID .. &quot; [&quot; .. server.chatColour .. &quot;]Base protection for your second base is active.[-]&quot;)
				else
					message(&quot;pm &quot; .. igplayers[steam].alertBaseID .. &quot; [&quot; .. server.chatColour .. &quot;]Your second base is too close to another player base who is not on your friends list.  Protection cannot be enabled.[-]&quot;)
				end			

				igplayers[steam].alertBaseExit = nil
				igplayers[steam].alertBaseID = nil
				igplayers[steam].alertBase = nil

				faultyPlayerinfo = false
				return
			end
		end
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 16&quot;) 
	end	

	x = math.floor(igplayers[steam].xPos / 512)
	z = math.floor(igplayers[steam].zPos / 512)

	if (accessLevel(steam) &lt; 4) and server.enableRegionPM then
		if (igplayers[steam].region ~= &quot;r.&quot; .. x .. &quot;.&quot; .. z .. &quot;.7rg&quot;) then
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Region r.&quot; .. x .. &quot;.&quot; .. z .. &quot;.7rg[-]&quot;)
		end	
	end

	igplayers[steam].region = &quot;r.&quot; .. x .. &quot;.&quot; .. z .. &quot;.7rg&quot;
	igplayers[steam].regionX = x
	igplayers[steam].regionZ = z

	-- timeout
	if (players[steam].timeout == true or players[steam].botTimeout == true) then
		if (intY &lt; 20000) then
			players[steam].tp = 1
			players[steam].hackerScore = 0
			send(&quot;tele &quot; .. steam .. &quot; &quot; .. intX .. &quot; &quot; .. 50000 .. &quot; &quot; .. intZ)
		end	

		faultyPlayerinfo = false
		return
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 17&quot;) 
	end	

	-- world fall catcher
	fallCatcher(steam, intX, intY, intZ)

	-- prevent player exceeding the map limit unless an admin and ignoreadmins is false
	if outsideMap and players[steam].donor == false and (accessLevel(steam) &gt; 3) then
		if not inLocation(intX, intZ) then
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]This map is restricted to &quot; .. (server.mapSize / 1000) .. &quot; km from the center.[-]&quot;)
			players[steam].tp = 1
			players[steam].hackerScore = 0

			if players[steam].watchPlayer then
				irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. steam .. &quot; &quot; .. name .. &quot; teleported by bot for exceeding map limit&quot;)
			end

			send (&quot;tele &quot; .. steam .. &quot; &quot; .. igplayers[steam].xPosLastOK .. &quot; &quot; .. igplayers[steam].yPosLastOK .. &quot; &quot; .. igplayers[steam].zPosLastOK)	
			faultyPlayerinfo = false
			return
		end
	end

	if outsideMapDonor and players[steam].donor == true and (accessLevel(steam) &gt; 3 or server.ignoreAdmins == false) then
		if not inLocation(intX, intZ) then
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]This map is restricted to &quot; .. ((server.mapSize + 5000) / 1000) .. &quot; km from the center.[-]&quot;)
			players[steam].tp = 1
			players[steam].hackerScore = 0

			if players[steam].watchPlayer then
				irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. steam .. &quot; &quot; .. name .. &quot; teleported by bot for exceeding map limit&quot;)
			end

			send (&quot;tele &quot; .. steam .. &quot; &quot; .. igplayers[steam].xPosLastOK .. &quot; &quot; .. igplayers[steam].yPosLastOK .. &quot; &quot; .. igplayers[steam].zPosLastOK)	
			faultyPlayerinfo = false
			return
		end
	end

	if tonumber(players[steam].exiled) == 1 and locations[&quot;exile&quot;] and not players[steam].prisoner then
		if (distancexz( intX, intZ, locations[&quot;exile&quot;].x, locations[&quot;exile&quot;].z ) &gt; tonumber(locations[&quot;exile&quot;].size)) then

			if players[steam].watchPlayer then
				irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. steam .. &quot; &quot; .. name .. &quot; teleported by bot to exile&quot;)
			end

			randomPVPTP(steam, &quot;exile&quot;, true)
			faultyPlayerinfo = false
			return
		end

		if players[steam].inLocation ~= &quot;exile&quot; then
			-- fix an occasional issue with unset coords
			if tonumber(igplayers[steam].xPosLastOK) == 0 and tonumber(igplayers[steam].yPosLastOK) == 0 and tonumber(igplayers[steam].zPosLastOK) == 0 then
				cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. locations[&quot;exile&quot;].x .. &quot; &quot; .. locations[&quot;exile&quot;].y .. &quot; &quot; .. locations[&quot;exile&quot;].z
			else
				cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. igplayers[steam].xPosLastOK .. &quot; &quot; .. igplayers[steam].yPosLastOK .. &quot; &quot; .. igplayers[steam].zPosLastOK
			end

			igplayers[steam].lastTP = cmd

			if players[steam].watchPlayer then
				irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. steam .. &quot; &quot; .. name .. &quot; teleported by bot to exile&quot;)
			end

			teleport(cmd, true)	
			faultyPlayerinfo = false
			return
		end
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 18&quot;) 
	end	

	-- left prison zone warning 
	if (locations[&quot;prison&quot;]) then
		if (distancexz( intX, intZ, locations[&quot;prison&quot;].x, locations[&quot;prison&quot;].z ) &gt; tonumber(locations[&quot;prison&quot;].size)) then
			if (players[steam].alertPrison == false) then
				if (not players[steam].prisoner) and 	players[steam].showLocationMessages then
					message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You have left the prison.[-]&quot;)
				end

				players[steam].alertPrison = true
			end
		end

		if (players[steam].prisoner) then
			if (locations[&quot;prison&quot;]) then
				if (squareDistanceXZXZ(locations[&quot;prison&quot;].x, locations[&quot;prison&quot;].z, intX, intZ, locations[&quot;prison&quot;].size)) then
					players[steam].alertPrison = false

					if (squareDistanceXZXZ(locations[&quot;prison&quot;].x, locations[&quot;prison&quot;].z, igplayers[steam].xPosLastOK, igplayers[steam].zPosLastOK, locations[&quot;prison&quot;].size)) then
						cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. locations[&quot;prison&quot;].x .. &quot; &quot; .. locations[&quot;prison&quot;].y .. &quot; &quot; .. locations[&quot;prison&quot;].z
					else
						cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. igplayers[steam].xPosLastOK .. &quot; &quot; .. igplayers[steam].yPosLastOK .. &quot; &quot; .. igplayers[steam].zPosLastOK
					end

					if players[steam].watchPlayer then
						irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. steam .. &quot; &quot; .. name .. &quot; teleported by bot to prison&quot;)
					end

					prepareTeleport(steam, cmd)
					teleport(cmd, true)
				end
			end

			faultyPlayerinfo = false
			return
		end

		-- entered prison zone warning 
		if (distancexz( intX, intZ, locations[&quot;prison&quot;].x, locations[&quot;prison&quot;].z ) &lt; tonumber(locations[&quot;prison&quot;].size)) then
			if (players[steam].alertPrison == true) then
				if (not players[steam].prisoner) and players[steam].showLocationMessages then
					message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You have entered the prison.  Continue at your own risk.[-]&quot;)
				end
				players[steam].alertPrison = false
			end
		end
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 19&quot;) 
	end	

	-- freeze!
	if (players[steam].freeze == true) then
		players[steam].tp = 1
		players[steam].hackerScore = 0
		send(&quot;tele &quot; .. steam .. &quot; &quot; .. igplayers[steam].xPosLastOK .. &quot; &quot; .. igplayers[steam].yPosLastOK .. &quot; &quot; .. igplayers[steam].zPosLastOK)	
		faultyPlayerinfo = false
		return
	end


	-- teleport lookup
	if (igplayers[steam].teleCooldown &lt; 1) and (players[steam].prisoner == false) then
		tp = &quot;&quot;
		tp = LookupTeleport(posX, posY, posZ)
		if (tp ~= nil and teleports[tp].active == true) then
			ownerid = LookupOfflinePlayer(teleports[tp].owner)
			if (players[steam].walkies ~= true) then
				if (accessLevel(steam) &lt; 3) or (teleports[tp].owner == igplayers[steam].steam or teleports[tp].public == true or isFriend(ownerid, steam)) then
					if match == 1 then
						igplayers[steam].teleCooldown = 1
						cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. math.floor(teleports[tp].dx) .. &quot; &quot; .. math.ceil(teleports[tp].dy) + 1 .. &quot; &quot; .. math.floor(teleports[tp].dz)
						igplayers[steam].lastTP = cmd

						if players[steam].watchPlayer then
							irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. steam .. &quot; &quot; .. name .. &quot; teleported by bot (triggered &quot; .. tp .. &quot; teleport)&quot;)
						end

						teleport(cmd, true)

						faultyPlayerinfo = false
						return
					end

					if match == 2 and teleports[tp].oneway == false then
						igplayers[steam].teleCooldown = 1
						cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. math.floor(teleports[tp].x) .. &quot; &quot; .. math.ceil(teleports[tp].y) + 1 .. &quot; &quot; .. math.floor(teleports[tp].z)
						igplayers[steam].lastTP = cmd

						if players[steam].watchPlayer then
							irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. steam .. &quot; &quot; .. name .. &quot; teleported by bot (triggered &quot; .. tp .. &quot; teleport)&quot;)
						end

						teleport(cmd, true)

						faultyPlayerinfo = false
						return
					end
				end
			end
		end
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 20&quot;) 
	end	


	-- left reset zone warning
	if (not resetZone) then
		if (players[steam].alertReset == false) and players[steam].showLocationMessages then
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You are out of the reset zone.[-]&quot;)
			players[steam].alertReset = true
			faultyPlayerinfo = false
		end
	end


	-- entered reset zone warning 
	if (resetZone) then
		if (players[steam].alertReset == true) and players[steam].showLocationMessages then
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You are in a reset zone. Don't build here.[-]&quot;)
			players[steam].alertReset = false
			faultyPlayerinfo = false

			-- check for claims in the reset zone not owned by staff and remove them
			checkRegionClaims(x, z)
		end
	end


	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 21&quot;) 
	end	

	if	baseProtection(steam, posX, posY, posZ) and not resetZone then
		faultyPlayerinfo = false
		return
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 21a&quot;) 
	end	

	-- add to tracker table
	dist = distancexyz(intX, intY, intZ, igplayers[steam].xPosLast, igplayers[steam].yPosLast, igplayers[steam].zPosLast)

	if (dist &gt; 2) and tonumber(intY) &gt; 0 and tonumber(intY) &lt; 255 then
		-- record the players position
		conn:execute(&quot;INSERT INTO tracker (steam, x, y, z, session) VALUES (&quot; .. steam .. &quot;,&quot; .. intX .. &quot;,&quot; .. intY .. &quot;,&quot; .. intZ .. &quot;,&quot; .. players[steam].sessionCount .. &quot;)&quot;)

		if igplayers[steam].location ~= nil then
			conn:execute(&quot;INSERT INTO locationSpawns (location, x, y, z) VALUES ('&quot; .. igplayers[steam].location .. &quot;',&quot; .. intX .. &quot;,&quot; .. intY .. &quot;,&quot; .. intZ .. &quot;)&quot;)
		end
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 22&quot;) 
	end	

	if (igplayers[steam].deadX ~= nil) then
		dist = math.abs(distancexz(igplayers[steam].deadX, igplayers[steam].deadZ, posX, posZ))
		if (dist &gt; 2) then
			igplayers[steam].deadX = nil
			igplayers[steam].deadY = nil
			igplayers[steam].deadZ = nil
			
			if players[steam].bed ~= &quot;&quot; then
				if players[steam].bed == &quot;base1&quot; then
					cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. players[steam].homeX .. &quot; &quot; .. players[steam].homeY .. &quot; &quot; .. players[steam].homeZ
					igplayers[steam].lastTP = cmd

					if players[steam].watchPlayer then
						irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. steam .. &quot; &quot; .. name .. &quot; teleported by bot&quot;)
					end

					teleport(cmd, true)	
				end	
				
				if players[steam].bed == &quot;base2&quot; then
					cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. players[steam].home2X .. &quot; &quot; .. players[steam].home2Y .. &quot; &quot; .. players[steam].home2Z
					igplayers[steam].lastTP = cmd

					if players[steam].watchPlayer then
						irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. steam .. &quot; &quot; .. name .. &quot; teleported by bot&quot;)
					end

					teleport(cmd, true)	
				end				
			end
		end
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 23&quot;) 
	end	

	-- hotspot lookup
	hotspot = LookupHotspot(posX, posY, posZ)

	if (hotspot ~= nil) then
		if (igplayers[steam].lastHotspot ~= hotspot) then
			for k, v in pairs(lastHotspots[steam]) do
				-- todo finish this off.  look for presence of hotspot
				if v == hotspot then -- don't add or display this hotspot yet.  we've seen it recently
					faultyPlayerinfo = false
					return
				end
			end

			igplayers[steam].lastHotspot = hotspot
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. hotspots[hotspot].hotspot .. &quot;[-]&quot;)

			if (lastHotspots[steam] == nil) then lastHotspots[steam] = {} end
			if (table.maxn(lastHotspots[steam]) &gt; 10) then
				table.remove(lastHotspots[steam], 1)
			end	

			table.insert(lastHotspots[steam],  hotspot)
			faultyPlayerinfo = false
		end
	end


	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 24&quot;) 
	end	

	if igplayers[steam].rawPosition ~= rawPosition then
		igplayers[steam].afk = os.time() + 900
		igplayers[steam].rawPosition = rawPosition
	end

	--if (playersOnline &gt;= server.ServerMaxPlayerCount) and (accessLevel(steam) &gt; 3) then
	--	if (igplayers[steam].afk - os.time() &lt; 0) then
	--		send (&quot;kick &quot; .. steam .. &quot; Server is full.  You were kicked because you were idle too long.  You can rejoin any time.&quot;)
	--	end
	--end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 25&quot;) 
	end	


	if (pvpZone(posX, posZ) ~= false) then
		if players[steam].alertPVP == true then
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You have entered a PVP zone!  Proceed with caution.[-]&quot;)
			players[steam].alertPVP = false
			faultyPlayerinfo = false
		end
	else
		if players[steam].alertPVP == false then
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You have left a PVP zone.  Do not kill other players here![-]&quot;)
			players[steam].alertPVP = true
			faultyPlayerinfo = false
		end
	end

	if (steam == debugSteam) then 
		dbug(&quot;debug playerinfo 26&quot;) 
	end	

	-- report players movement to irc in _tracker channel
	if players[steam].watchPlayer then
		if math.abs(igplayers[steam].xPosLastOK) &gt; 0 and math.abs(igplayers[steam].yPosLastOK) &gt; 0 and math.abs(igplayers[steam].zPosLastOK) &gt; 0 then
			dist = math.abs(distancexyz(igplayers[steam].xPosLastOK, igplayers[steam].yPosLastOK, igplayers[steam].zPosLastOK, posX, posY, posZ))

			if dist &gt; 40 then
				irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. steam .. &quot; &quot; .. name .. &quot; old [ &quot; .. igplayers[steam].xPosLastOK .. &quot; &quot; .. igplayers[steam].yPosLastOK .. &quot; &quot; .. igplayers[steam].zPosLastOK .. &quot; ] new [ &quot; .. intX .. &quot; &quot; .. intY .. &quot; &quot; .. intZ .. &quot; ] dist &quot; .. string.format(&quot;%.1f&quot;, dist) )
			end
		end
	end

	-- stuff to do after everything else
	igplayers[steam].xPosLast = posX
	igplayers[steam].yPosLast = posY
	igplayers[steam].zPosLast = posZ

	-- record this coord as the last one that the player was allowed to be at.  if their next step is not allowed, they get returned to this one.
	igplayers[steam].xPosLastOK = intX
	igplayers[steam].yPosLastOK = intY
	igplayers[steam].zPosLastOK = intZ

	faultyPlayerinfo = false

	if (steam == debugSteam) then 
		dbug(&quot;end playerinfo&quot;) 
	end	
end


if string.find(line, &quot;, health=&quot;) then
	if faultyPlayerinfo == true and tonumber(faultyPlayerinfoID) &gt; -1 then
		cecho(server.windowDebug, &quot;!! Fault detected in playerinfo trigger\n&quot;)
		cecho(server.windowDebug, faultyPlayerinfoLine .. &quot;\n&quot;)

		cecho(server.windowAlerts, &quot;!! Fault detected in playerinfo trigger\n&quot;)
		cecho(server.windowAlerts, faultyPlayerinfoLine .. &quot;\n&quot;)

		if tonumber(	faultyPlayerinfoID) &gt; 0 and players[faultyPlayerinfoID] then
			fixMissingPlayer(faultyPlayerinfoID)

			if igplayers[faultyPlayerinfoID] then
				fixMissingIGPlayer(faultyPlayerinfoID)	
			end
		end
	end

	playerInfo()
	deleteLine()
end</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>, ip=</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Player disconnected</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

local steam, pos

if botDisabled then
	return
end

if string.find(line, &quot;Player disconnected:&quot;) then
	pos = string.find(line, &quot;PlayerID='&quot;) + 10
	steam = string.sub(line, pos, pos + 16)

	serverTime = string.sub(line, 1, 19)
	newDay()

	dbug(&quot;Saving disconnected player &quot; .. igplayers[steam].name)

	playerDisconnected(steam)

	if players[steam].watchPlayer then
		irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. steam .. &quot; &quot; .. players[steam].name .. &quot; disconnected&quot;)
	end

	-- check how many claims they have placed
	send(&quot;llp &quot; .. steam)
end</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>Player disconnected:</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Inventory</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

if not string.find(line, server.botsIP) then
	return
end

serverTime = string.sub(line, 1, 19)
invCheckID = string.sub(line, string.find(line, &quot;si &quot;) + 3, string.find(line, &quot;by &quot;) - 2)

deleteLine()</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>Executing command 'si</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>lkp</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

local name, id, steam, playtime, seen, result

data = string.split(line, &quot;,&quot;)

name = string.sub(data[1], string.find(data[1], &quot;. &quot;) + 2)
id = string.sub(data[2], string.find(data[2], &quot;id=&quot;) + 3)
steam = string.sub(data[3], string.find(data[3], &quot;steamid=&quot;) + 8)
playtime = string.sub(data[6], string.find(data[6], &quot;playtime=&quot;) + 9, string.len(data[6]) - 2)
seen = string.sub(data[7], string.find(data[7], &quot;seen=&quot;) + 5)

local pattern = &quot;(%d+)-(%d+)-(%d+) (%d+):(%d+)&quot;
local runyear, runmonth, runday, runhour, runminute, runseconds = seen:match(pattern)
local seenTimestamp = os.time({year = runyear, month = runmonth, day = runday, hour = runhour, min = runminute, sec = runseconds})

if (not players[steam] and (playtime ~= &quot;0&quot;)) then
	cecho(server.windowDebug, &quot;add player &quot; .. name .. &quot;\n&quot;)
	players[steam] = {}
	players[steam].id = id
	players[steam].name = name
	players[steam].steam = steam
	players[steam].playtime = playtime
	players[steam].seen = seen

	conn:execute(&quot;INSERT INTO players (steam, id, name, playtime, seen) VALUES (&quot; .. steam .. &quot;,&quot; .. id .. &quot;,'&quot; .. escape(name) .. &quot;',&quot; .. playtime .. &quot;,'&quot; .. seen .. &quot;') ON DUPLICATE KEY UPDATE playtime = &quot; .. playtime .. &quot;, seen = '&quot; .. seen .. &quot;'&quot;)
else
	if (playtime ~= &quot;0&quot;) then
		cecho(server.windowDebug, &quot;update player &quot; .. name .. &quot;\n&quot;)
		players[steam].id = id
		players[steam].name = name
		players[steam].playtime = playtime
		players[steam].seen = seen

		conn:execute(&quot;INSERT INTO players (steam, id, name, playtime, seen) VALUES (&quot; .. steam .. &quot;,&quot; .. id .. &quot;,'&quot; .. escape(name) .. &quot;',&quot; .. playtime .. &quot;,'&quot; .. seen .. &quot;') ON DUPLICATE KEY UPDATE playtime = &quot; .. playtime .. &quot;, seen = '&quot; .. seen .. &quot;'&quot;)
	end
end

-- add missing fields and give them default values
fixMissingPlayer(steam)</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>online=</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Zombie Scouts</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


-- 014-12-29T18:36:42 13941.838 INF AIDirector: Spawning scouts @ ((-4791.0, 64.0, -5491.0)) heading towards ((-4740.0, 64.0, -5588.0))

if botDisabled then
	return
end

local test, dist, xStart, zStart, xEnd, zEnd, direction

if string.find(line, &quot;towards&quot;) then
	-- get the origin coords
	test = string.sub(line, string.find(line, &quot;scouts&quot;) + 11, string.find(line, &quot;heading&quot;) - 4)
	split = string.split(test, &quot;,&quot;)
	xStart = string.match(split[1], &quot;-?%d+&quot;)
	zStart = string.match(split[3], &quot;-?%d+&quot;)

	-- get the destination coords
	test = string.sub(line, string.find(line, &quot;towards&quot;) + 7)
	split = string.split(test, &quot;,&quot;)
	xEnd = string.match(split[1], &quot;-?%d+&quot;)
	zEnd = string.match(split[3], &quot;-?%d+&quot;)

	if (string.find(line, &quot;heading towards&quot;)) then
		for k, v in pairs(igplayers) do
			direction = getCompass(v.xPos, v.zPos, xStart, zStart)
			dist = distancexz(v.xPos, v.zPos, xEnd, zEnd)

			if (dist &lt; 50) then
				message(&quot;pm &quot; .. k .. &quot; &quot; ..  &quot; [&quot; .. server.chatColour .. &quot;]Screamers have been detected heading your way from the &quot; .. direction .. &quot;.[-]&quot;)
			end
		end
	end
end</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>AIDirector: Spawning scouts</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>InventoryOwner</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

local pname

pname = string.sub(line, string.find(line, &quot;player &quot;) + 7)
pname = string.sub(pname, 1, string.len(pname) - 1)

invCheckID = LookupPlayer(pname, &quot;all&quot;) 

if (string.find(line, &quot;Belt of player&quot;)) then
	if (igplayers[invCheckID].inventoryLast ~= igplayers[invCheckID].inventory) then
		igplayers[invCheckID].inventoryLast = igplayers[invCheckID].inventory
	end

	igplayers[invCheckID].inventory = &quot;&quot;
	igplayers[invCheckID].oldBelt = igplayers[invCheckID].belt
	igplayers[invCheckID].belt = &quot;&quot;
	igplayers[invCheckID].pack = &quot;&quot;
	igplayers[invCheckID].equipment = &quot;&quot;
	invScan = &quot;belt&quot;
end

if (string.find(line, &quot;Bagpack of player&quot;)) then
	invScan = &quot;bagpack&quot;
end

if (string.find(line, &quot;Equipment of player&quot;)) then
	invScan = &quot;equipment&quot;
end

deleteLine()
</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>Belt of player</string>
                <string>Bagpack of player</string>
                <string>Equipment of player</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
                <integer>0</integer>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>AirDrop alert</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--651 INF AIAirDrop: Spawned supply crate @ ((2114.4, 244.0, -2210.6))&quot;

if botDisabled then
	return
end

local test, dist, direction, coord, k, v

test = string.sub(line, string.find(line, &quot;@&quot;) + 4)
test = string.sub(test, 1, string.len(test) - 2)
coord = string.split(test, &quot;,&quot;)

for k, v in pairs(igplayers) do
	dist = distancexz(v.xPos, v.zPos, coord[1], coord[3])
	if (tonumber(dist) &lt; 500) then
		direction = getCompass(v.xPos, v.zPos, coord[1], coord[3])
		message(&quot;pm &quot; .. k .. &quot; &quot; ..  &quot; [&quot; .. server.chatColour .. &quot;]Supplies have been dropped &quot; .. math.floor(dist) .. &quot; meters to the &quot; .. direction ..&quot;![-]&quot;)
	end
end</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>AIAirDrop: Spawned supply crate</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Spam</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


deleteLine()
ExceptionCount = 0

-- |Spawned
-- |Player</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>^.*(NullReferenceException|Block on position|-&gt;|lifetime=|\'gt|\'mem|\'lp|command \'si|STATS|Time|Token|Started thread|RequestTo|Adding|Removing|Created player|Allowing|Authenticating|Player set to online|OnPlayer|NET: Received package|Infinity|Exited|Couldn\'t send RPC|Disconnected player|Error in|Exception in|INF VOICE|'GameManager| at AllocsFixes.|Freeing).*$</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>1</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Game Time</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

local words = {}

for word in line:gmatch(&quot;%w+&quot;) do table.insert(words, word) end

gameDate = string.trim(line)
gameDay = words[2]
gameHour = tonumber(words[3])
gameMinute = words[4]
gameDate = &quot;Day &quot; .. gameDay .. &quot;, &quot; ..string.format(&quot;%02d&quot;, gameHour) .. &quot;:&quot; .. gameMinute

--if (gameDay % 7 == 0) then
--	if (tonumber(gameHour) == 17) then
--		if (feralWarning == false) then
--			message(&quot;say [&quot; .. server.chatColour .. &quot;]Feral hordes will run tonight![-]&quot;)
--			feralWarning = true
--		end
--	else
--		feralWarning = false
--	end


if (tonumber(gameHour) == 0 and server.allowShop == true and server.allowLottery == true) then
	if 	dailyDraw == false then
		drawLottery()
		dailyDraw = true
	end
else
	dailyDraw = false
end

if tonumber(gameDay) &lt; tonumber(server.gameDay) and tonumber(server.gameDay) &gt; 0 and server.warnBotReset ~= true then
	if tonumber(server.gameDay) &lt; 10 then
		-- the server date has rolled back.  try to alert any level 0 admin that the bot may need a reset too.
		server.warnBotReset = true

		for k,v in pairs(igplayers) do
			if accessLevel(k) == 0 then
				message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]ALERT!  It appears that the server has been reset.[-]&quot;)
				message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]To reset me type /reset bot.[-]&quot;)
				message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]To dismiss this alert type /no reset.[-]&quot;)
			end
		end
	end
end

server.gameDay = gameDay
conn:execute(&quot;UPDATE server SET gameDay = &quot; .. gameDay)
</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>Day </string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>2</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>GameTickCount</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

local diff, days, hours

-- grab the tick counter
test = string.sub(line, string.find(line, &quot;:&quot;) + 7, string.find(line, &quot; INF&quot;))
gameTick = tonumber(test)

if nextRebootTest ~= nil and os.time() &lt; nextRebootTest then
	return
end

if gameTick &gt; 0 then
	server.uptime = gameTick
else
	server.uptime = os.time() - botStarted
end

if gameTick &lt; 0 and server.scheduledRestart == false and server.allowReboot == true then
	gmsg(&quot;/reboot server in 5 minutes&quot;, 0)
	message(&quot;say [&quot; .. server.chatColour .. &quot;]A fault has been detected. A reboot should fix it.[-]&quot;)
end

diff = gameTick
days = math.floor(diff / 86400)

if (days &gt; 0) then
	diff = diff - (days * 86400)
end

hours = math.floor(diff / 3600)

if tonumber(hours) &gt;= tonumber(server.maxServerUptime) and server.scheduledRestart == false and server.allowReboot == true then
	message(&quot;say [&quot; .. server.chatColour .. &quot;]The server will reboot soon to keep it running well.[-]&quot;)
	gmsg(&quot;/reboot in 15 minutes&quot;, 0)
end
</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>'gt'</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Logon Successful</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

-- relogCount is used to detect excessive relogging which is indicative of a server crash.
if relogCount == nil then relogCount = 0 end

if string.find(line, &quot;Logon successful.&quot;) then
	botOffline = 2
	relogCount = relogCount + 1

	if not serverDataLoaded then
		-- The bot hasn't yet managed to get data from gg and other server info commands so run gg etc now.
		getServerData()
	end

	if relogCount &gt; 6 then
		irc_QueueMsg(server.ircMain, &quot;Server has crashed.  Please manually restart it.&quot;)
	else
		irc_QueueMsg(server.ircMain, &quot;Successfully logged in and monitoring server traffic.&quot;)
	end

	if not server.allowPhysics then
		send(&quot;py&quot;)
	end

	if server.tempMaxPlayers ~= nil then
		send(&quot;sg ServerMaxPlayerCount &quot; .. server.tempMaxPlayers)
	end
end
</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>Logon successful.</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>2</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Collect Ban</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

local temp, reason, yr, mth, dy, hr, min, sec, tdate, steam, expiryDate, bannedTo

temp = string.split(line, &quot; &quot;)

tdate = string.split(temp[4], &quot;/&quot;)
yr = tdate[3]
mth = tdate[1]
dy = tdate[2]

tdate = string.split(temp[5], &quot;:&quot;)
hr = tonumber(tdate[1])
min = tdate[2]
sec = tdate[3]

if temp[6] == &quot;PM,&quot; then
	hr = hr + 12
end

bannedTo = temp[4] .. &quot; &quot; .. escape(temp[5]) .. &quot; &quot; .. escape(string.sub(temp[6], 1, 2))
expiryDate = yr .. &quot;-&quot; .. mth .. &quot;-&quot; .. dy .. &quot; &quot; .. hr .. &quot;:&quot; .. min .. &quot;:&quot; .. sec
steam = temp[1]
reason = string.sub(line, string.find(line, &quot;reason:&quot;) + 8)

if reason ~= nil then
	conn:execute(&quot;INSERT INTO bans (BannedTo, steam, reason, expiryDate) VALUES ('&quot; .. bannedTo .. &quot;',&quot; .. steam .. &quot;,'&quot; .. escape(reason) .. &quot;','&quot; .. expiryDate .. &quot;'&quot;)
else
	conn:execute(&quot;INSERT INTO bans (BannedTo, steam, expiryDate) VALUES ('&quot; .. bannedTo .. &quot;',&quot; .. steam .. &quot;,'&quot; .. expiryDate .. &quot;'&quot;)
end

if db2Connected then
	-- update the ban on bots db to fill in the missing bannedTo field since we didn't calculate it earlier
	connBots:execute(&quot;UPDATE bans set bannedTo = '&quot; .. bannedTo .. &quot;' WHERE bannedTo = 'MISSING' AND botID = '&quot; .. server.botID .. &quot;'&quot;)
end
</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>banned until</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Unban player</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

local temp, steam

temp = string.split(line, &quot; &quot;)
steam = string.sub(temp[8], 1, string.len(temp[8]) - 1)

-- also remove the steam owner from the bans table
conn:execute(&quot;DELETE FROM bans WHERE steam = &quot; .. steam .. &quot; or steam = &quot; .. players[steam].steamOwner)
</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>Executing command 'ban remove</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Overstack</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--INF Player with ID 2101092 has stack for &quot;weaponRepairKit&quot; greater than allowed (24 &gt; 12)

if botDisabled then
	return
end

local item, limit, id

id = string.sub(line, string.find(line, &quot; ID &quot;) + 4, string.find(line, &quot; has&quot;) - 1)
item = string.sub(line, string.find(line, &quot;stack for &quot;) + 11, string.find(line, &quot;greater&quot;) - 3)
limit = string.sub(line, string.find(line, &quot; &gt; &quot;) + 3, string.len(line) - 1)

stackLimits[item] = {}
stackLimits[item].limit = tonumber(limit)

id = LookupPlayer(id)
if id ~= nil then
	players[id].overstack = true

	if not string.find(item, players[id].overstackItems) then
		players[id].overstackItems = players[id].overstackItems .. item .. &quot;|&quot;
	end
end</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>INF Player with ID</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Open Reserved Slot</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
local steamid
steamid = string.sub(line, string.find(line, &quot;from:&quot;) + 6)
if (steamid == &quot;yourname&quot;) then
	display(&quot;opening reserved slot\n&quot;)
	send(&quot;sg ServerMaxPlayerCount &quot; .. tonumber(server.ServerMaxPlayerCount) + 1)
	server.ServerMaxPlayerCount = server.ServerMaxPlayerCount + 1
end
--]]</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>NET: P2PSessionRequest</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>mem</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

--Time: 16.80m FPS: 96.70 Heap: 548.2MB Max: 731.3MB Chunks: 1232 CGO: 118 Ply: 3 Zom: 10 Ent: 16 (44) Items: 20 CO: 3


if botDisabled then
	return
end

local time, fps, heap, heapMax, chunks, cgo, ply, zom, ent, items

if (string.find(line, &quot;Heap:&quot;)) then
	time = string.sub(line, string.find(line, &quot;Time:&quot;) + 6, string.find(line, &quot;FPS:&quot;) - 3)
	fps = tonumber(string.sub(line, string.find(line, &quot;FPS:&quot;) + 5, string.find(line, &quot;Heap:&quot;) - 2))
	heap = string.sub(line, string.find(line, &quot;Heap:&quot;) + 6, string.find(line, &quot;Max:&quot;) - 4)
	heapMax = string.sub(line, string.find(line, &quot;Max:&quot;) + 5, string.find(line, &quot;Chunks:&quot;) - 4)
	chunks = string.sub(line, string.find(line, &quot;Chunks:&quot;) + 8, string.find(line, &quot;CGO:&quot;) - 2)
	cgo = string.sub(line, string.find(line, &quot;CGO:&quot;) + 5, string.find(line, &quot;Ply:&quot;) - 2)
	ply = string.sub(line, string.find(line, &quot;Ply:&quot;) + 5, string.find(line, &quot;Zom:&quot;) - 2)
	zom = string.sub(line, string.find(line, &quot;Zom:&quot;) + 5, string.find(line, &quot;Ent:&quot;) - 2)
	ent = string.sub(line, string.find(line, &quot;Ent:&quot;) + 5, string.find(line, &quot;Items:&quot;) - 2)
	items = string.sub(line, string.find(line, &quot;Items:&quot;) + 7, string.find(line, &quot;CO:&quot;) - 2)

	server.fps = fps
	conn:execute(&quot;INSERT INTO performance (serverdate, gametime, fps, heap, heapMax, chunks, cgo, players, zombies, entities, items) VALUES ('&quot; .. serverTime .. &quot;',&quot; .. time .. &quot;,&quot; .. fps .. &quot;,&quot; .. heap .. &quot;,&quot; .. heapMax .. &quot;,&quot; .. chunks .. &quot;,&quot; .. cgo .. &quot;,&quot; .. ply .. &quot;,&quot; .. zom .. &quot;,'&quot; .. ent .. &quot;',&quot; .. items .. &quot;)&quot;)
end</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>Heap:</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>lp</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

if string.find(string.sub(line, 1, 19), os.date(&quot;%Y&quot;)) then
	serverTime = string.sub(line, 1, 19)
	specialDay = &quot;&quot;

	if (string.find(serverTime, &quot;02-14&quot;, 5, 10)) then specialDay = &quot;valentine&quot; end
	if (string.find(serverTime, &quot;12-25&quot;, 5, 10)) then specialDay = &quot;christmas&quot; end
end</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>Executing command 'lp</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Tele</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

local player, id, cmd

if string.find(line, &quot;from &quot;) then
	cmd = string.sub(line, string.find(line, &quot;tele &quot;), string.find(line, &quot;from&quot;) - 3)
	cmd = string.split(cmd, &quot; &quot;)

	i = table.maxn(cmd)
	id = LookupPlayer(cmd[2])
	players[id].tp = 1
	players[id].hackerScore = 0
end


if string.find(line, server.botsIP) then
	cmd = string.sub(line, string.find(line, &quot;tele &quot;), string.find(line, &quot;by Telnet&quot;) - 3)
	cmd = string.split(cmd, &quot; &quot;)

	id = cmd[2]
	players[id].tp = 1
	players[id].hackerScore = 0
end

</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>Telnet executed 'tele</string>
                <string>Executing command 'tele</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>llp</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end


function llp()
	local pos, temp, x, y, z

	if string.find(line, &quot;Executing command 'llp&quot;) then
		pos = string.find(line, &quot;llp&quot;) + 4
		llpid = string.sub(line, pos, pos + 16)
		players[llpid].keystones = 0
		return
	end

	-- depreciated in latest Allocs. Here for backwards compatibility
	if string.find(line, &quot;keystones (protected:&quot;) then
		pos = string.find(line, &quot; owns&quot;) - 3
		llpid = string.sub(line, pos - 16, pos)
		players[llpid].keystones = string.sub(line, string.find(line, &quot;owns &quot;) + 5, string.find(line, &quot; keyst&quot;) - 1)
		conn:execute(&quot;UPDATE players SET keystones = &quot; .. players[llpid].keystones .. &quot; WHERE steam = &quot; .. llpid)
	end

	-- New format of output
	if string.find(line, &quot;LandProtectionOf:&quot;) then
		--LandProtectionOf: id=76561197983251951,  location=-99, 128, 192
		temp = string.split(line, &quot;,&quot;)		

		pos = string.find(temp[1], &quot;=&quot;) + 1
		llpid = string.sub(temp[1], pos)

		x = string.sub(temp[2], string.find(temp[2], &quot;=&quot;) + 1)
		y = temp[3]
		z = temp[4]

		if players[llpid].removedClaims == nil then
			players[llpid].removedClaims = 0
		end

		conn:execute(&quot;UPDATE keystones SET remove = 1 WHERE steam = &quot; .. llpid .. &quot; AND x = &quot; .. x .. &quot; AND y = &quot; .. y .. &quot; AND z = &quot; .. z .. &quot; AND remove &gt; 1&quot;)
		conn:execute(&quot;UPDATE keystones SET removed = 0 WHERE steam = &quot; .. llpid .. &quot; AND x = &quot; .. x .. &quot; AND y = &quot; .. y .. &quot; AND z = &quot; .. z)

		if accessLevel(llpid) &gt; 3 then
			region = getRegion(x, z)
			loc, reset = inLocation(x, z)

			if (resetRegions[region]) or reset or players[llpid].removeClaims == true then
				conn:execute(&quot;INSERT INTO keystones (steam, x, y, z, remove) VALUES (&quot; .. llpid .. &quot;,&quot; .. x .. &quot;,&quot; .. y .. &quot;,&quot; .. z .. &quot;,1) ON DUPLICATE KEY UPDATE remove = 1&quot;)
			else
				conn:execute(&quot;INSERT INTO keystones (steam, x, y, z) VALUES (&quot; .. llpid .. &quot;,&quot; .. x .. &quot;,&quot; .. y .. &quot;,&quot; .. z .. &quot;)&quot;)
			end		
		else
			conn:execute(&quot;INSERT INTO keystones (steam, x, y, z) VALUES (&quot; .. llpid .. &quot;,&quot; .. x .. &quot;,&quot; .. y .. &quot;,&quot; .. z .. &quot;)&quot;)
		end


	end
end

if string.find(line, &quot;LandProtectionOf:&quot;) or string.find(line, &quot;Executing command 'llp&quot;) or string.find(line, &quot;keystones (protected:&quot;) then
	llp()
end

</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>LandProtectionOf:</string>
                <string>Executing command 'llp</string>
                <string>keystones (protected:</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
                <integer>0</integer>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Chat</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

gmsg(line)</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>Chat:</string>
                <string>INF Executing command 'pm </string>
                <string>INF Denying command 'pm</string>
                <string>GMSG:</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
                <integer>0</integer>
                <integer>0</integer>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>log chat</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

if not (string.find(line, &quot; command 'pm&quot;) and string.find(line, &quot;' from client&quot;)) then
	-- log the chat
-- EDIT ME!
	file = io.open(&quot;/var/www/webdav/chatlogs/7Days/&quot; .. os.date(&quot;%Y%m%d&quot;) .. &quot;_chatlog.txt&quot;, &quot;a&quot;)
	file:write(line .. &quot;\n&quot;)
	file:close()
end</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>Chat:</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>le</name>
            <script>-- 13. id=2647, [type=EntityZombie, name=zombieBoe, id=2647], pos=(-97.3, 128.0, 195.5), rot=(0.0, 2.3, 0.0), lifetime=float.Max, remleote=False, dead=False, health=200

local temp, zedID, zedX, zedY, zedZ, zedDead, loc

temp = string.split(line, &quot;,&quot;)

if temp[13] == &quot; dead=False&quot; then
	zedID = string.sub(temp[1], string.find(temp[1], &quot;id=&quot;) + 3)
	zedX = string.sub(temp[5], string.find(temp[5], &quot;pos&quot;) + 5)
	zedY = temp[6]
	zedZ = string.sub(temp[7], 1, string.len(temp[7]) - 1)



	loc = inLocation(zedX, zedZ)

	if locations[loc].killZombies then
		send(&quot;kill &quot; .. zedID)
	end

end</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>type=EntityZombie</string>
                <string>type=EntityHornet</string>
                <string>type=EntityAnimalBear</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
                <integer>0</integer>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
        <Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
            <name>Reload admins</name>
            <script>send(&quot;admin list&quot;)</script>
            <triggerType>0</triggerType>
            <conditonLineDelta>0</conditonLineDelta>
            <mStayOpen>0</mStayOpen>
            <mCommand></mCommand>
            <packageName></packageName>
            <mFgColor>#ff0000</mFgColor>
            <mBgColor>#ffff00</mBgColor>
            <mSoundFile></mSoundFile>
            <colorTriggerFgColor>#000000</colorTriggerFgColor>
            <colorTriggerBgColor>#000000</colorTriggerBgColor>
            <regexCodeList>
                <string>INF Loading permissions file done.</string>
            </regexCodeList>
            <regexCodePropertyList>
                <integer>0</integer>
            </regexCodePropertyList>
        </Trigger>
    </TriggerPackage>
    <TimerPackage>
        <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
            <name>EveryHalfMinute</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see http://www.gnu.org/licenses
--]]

cecho (server.windowDebug, &quot;30 second timer\n&quot;)

if dbConnected ~= true then
	openDB()
	dbConnected = isDBConnected()
end

-- are we still connected to botsDB?
db2Connected = isDBBotsConnected()

if botDisabled then
	return
end

if (AnnounceBot == true) then
	message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. server.botName .. &quot; is online. Command me. :3[-]&quot;)
	AnnounceBot = false
end

math.randomseed( os.time() )

if (initError == true) then
	message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. server.botName .. &quot; encountered a problem starting up.  Attempting automatic fix..[-]&quot;)
	gatherServerData()
	initError = false
	AnnounceBot = true
end

send(&quot;gt&quot;)

newDay()

-- scan player inventories
for k, v in pairs(igplayers) do
	if (igplayers[k].killTimer == nil) then igplayers[k].killTimer = 9 end

	if tonumber(igplayers[k].killTimer) &lt; 2 then
		cmd = &quot;si &quot; .. k
		conn:execute(&quot;INSERT into commandQueue (command, steam) VALUES ('&quot; .. cmd .. &quot;',&quot; .. k .. &quot;)&quot;)					
	end

	-- kick player if currently banned or permabanned
--	if players[k].permanentBan == true then
--		send(&quot;kick &quot; .. k)
--	end

--	cursor,errorString = conn:execute(&quot;SELECT * FROM bans WHERE steam = &quot; .. k .. &quot; and expirydate &gt; &quot; .. os.date(&quot;%Y-%m-%d %H:%M:%S&quot;))
--	if cursor:numrows() &gt; 0 then
--		send(&quot;kick &quot; .. k)
--	end
end

cmd = &quot;DoneInventory&quot;
conn:execute(&quot;INSERT into commandQueue (command) VALUES ('&quot; .. cmd .. &quot;')&quot;)					

-- logout anyone on irc who hasn't typed anything and their session has expired
for k,v in pairs(players) do
	if v.ircAuthenticated == true then
		if v.ircSessionExpiry == nil then 
			v.ircAuthenticated = false
		else
			if (v.ircSessionExpiry - os.time()) &lt; 0 then
				v.ircAuthenticated = false
			end	
		end
	end
end

-- update the shared database (bots) server table (mainly for players online and a timestamp so others can see we're still online
updateBotsServerTable()

if tonumber(playersOnline) &gt; 0 and tonumber(playersOnline) &lt; 10 then
	if scanZombies then send(&quot;le&quot;) end
end</script>
            <command></command>
            <packageName></packageName>
            <time>00:00:40.000</time>
        </Timer>
        <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
            <name>OneMinuteTimer</name>
            <script>-- run a quick test to prove or disprove that we are still connected to the database.
-- there is a rare instance where we lose the connection for unknown reasons.
dbConnected = isDBConnected()


if botDisabled then
	return
end

OneMinuteTimer()

if tablelength(players) == 0 then
	gatherServerData()
	return
end

if server.coppi then
	for k, v in pairs(igplayers) do
--		if players[k].autoFriend ~= &quot;NA&quot; then
--			send(&quot;lpf &quot; .. k)
--		end
	end
end

if not botDisabled then
	writeBotTick()
end

if tonumber(playersOnline) &gt; 9 then
	if scanZombies then send(&quot;le&quot;) end
end

</script>
            <command></command>
            <packageName></packageName>
            <time>00:01:00.000</time>
        </Timer>
        <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
            <name>listPlayers</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end


function listPlayers()
	if finalCountdown == nil then
		finalCountdown = false
	end

	scanZombies = false
	send(&quot;lp&quot;)

	if (server.scheduledRestart == true and scheduledRestartPaused == false) and server.allowReboot == true then
		if (server.scheduledRestartTimestamp - os.time() &lt; 0) then
			startReboot()
		else
			if (server.scheduledRestartTimestamp - os.time() &gt; 11) and (server.scheduledRestartTimestamp - os.time() &lt; 61) then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]REBOOTING IN &quot; .. server.scheduledRestartTimestamp - os.time() .. &quot; SECONDS[-]&quot;)
				finalCountdown = false
			end

			if (server.scheduledRestartTimestamp - os.time() &lt; 12) and not finalCountdown then
				finalCountdown = true

				tempTimer( 1, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]10[-]&quot;)]] )
				tempTimer( 2, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]9[-]&quot;)]] )
				tempTimer( 3, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]8[-]&quot;)]] )
				tempTimer( 4, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]7[-]&quot;)]] )
				tempTimer( 5, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]6[-]&quot;)]] )
				tempTimer( 6, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]5[-]&quot;)]] )
				tempTimer( 7, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]4[-]&quot;)]] )
				tempTimer( 8, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]3[-]&quot;)]] )
				tempTimer( 9, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]2[-]&quot;)]] )
				tempTimer( 10, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]1[-]&quot;)]] )
				tempTimer( 11, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]Rebooting..[-]&quot;)]] )
			end
		end
	end
end

listPlayers()</script>
            <command></command>
            <packageName></packageName>
            <time>00:00:03.500</time>
        </Timer>
        <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
            <name>OneHourTimer</name>
            <script>if botDisabled then
	return
end

OneHourTimer()
dailyMaintenance()

-- fix any problems with player records
for k,v in pairs(players) do
	fixMissingPlayer(k)
end
</script>
            <command></command>
            <packageName></packageName>
            <time>01:00:00.000</time>
        </Timer>
        <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
            <name>Reconnect</name>
            <script>if botDisabled then
	return
end

botOffline = tonumber(botOffline) - 1

if tonumber(botOffline) &lt; 1 then
	dbug(&quot;Bot is offline - attempting reconnection.&quot;)
	botOffline = 2
	reconnect()
end

</script>
            <command></command>
            <packageName></packageName>
            <time>00:00:20.000</time>
        </Timer>
        <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
            <name>GimmeReset</name>
            <script>if botDisabled then
	return
end

gimmeReset()

-- while we're here refresh the ban list
send(&quot;ban list&quot;)</script>
            <command></command>
            <packageName></packageName>
            <time>02:00:00.000</time>
        </Timer>
        <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
            <name>TimedCommands</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

cursor,errorString = conn:execute(&quot;select * from commandQueue order by id limit 0,1&quot;)
row = cursor:fetch({}, &quot;a&quot;)

if row then
	cecho(server.windowDebug, &quot;running timed command (&quot; .. row.id .. &quot;) &quot; .. row.command .. &quot;\n&quot;)

	if (row.command ~= &quot;DoneInventory&quot;) then

		if igplayers[row.steam] == nil then
			conn:execute(&quot;delete from commandQueue where steam = &quot; .. row.steam)
			return
		end

		send(row.command)	
		conn:execute(&quot;delete from commandQueue where id = &quot; .. row.id)
	else
		conn:execute(&quot;delete from commandQueue where id = &quot; .. row.id)
		CheckInventory()
		tempTimer( 2, [[CheckClaimsRemoved()]] )
	end
end</script>
            <command></command>
            <packageName></packageName>
            <time>00:00:02.000</time>
        </Timer>
        <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
            <name>ThirtyMinuteTimer</name>
            <script>if botDisabled then
	return
end

ThirtyMinuteTimer()</script>
            <command></command>
            <packageName></packageName>
            <time>00:30:00.000</time>
        </Timer>
        <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
            <name>PlayerQueuedCommands</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

cursor,errorString = conn:execute(&quot;select * from playerQueue order by id limit 0,1&quot;)
row = cursor:fetch({}, &quot;a&quot;)

if row then
	if row.boss == true then
		for k, v in pairs(igplayers) do
			if distancexz(igplayers[k].xPos, igplayers[k].zPos, locations[&quot;arena&quot;].x, locations[&quot;arena&quot;].z) then
				for a, b in pairs(arenaPlayers) do
					message(&quot;pm &quot; .. players[b.id].id .. &quot; [&quot; .. server.chatColour .. &quot;]Here comes the BOSS!&quot;)
				end

				cecho(server.windowDebug, &quot;running player queued command &quot; .. row.command .. &quot;\n&quot;)
				send(row.command)	
				conn:execute(&quot;delete from playerQueue where id = &quot; .. row.id)
				return
			end
		end

		return	
	end

	if tonumber(row.steam) &gt; 0 and (not igplayers[row.steam]) then
		-- destroy the command without sending it
		cecho(server.windowDebug, &quot;destroying player queued command &quot; .. row.command .. &quot;\n&quot;)
		conn:execute(&quot;delete from playerQueue where id = &quot; .. row.id)
		return
	end

	if tonumber(row.steam) == 0 then
		if (string.sub(row.command, 1, 2) ~= &quot;se&quot;) and (string.sub(row.command, 1, 3) ~= &quot;say&quot;) and (string.sub(row.command, 1, 2) ~= &quot;pm&quot;) and (row.command ~= &quot;reset&quot;) then
			send(row.command)	
		else
			if row.command == &quot;reset&quot; then
				resetGimmeHell()
			else
			 	message(row.command)
			end
		end

		conn:execute(&quot;delete from playerQueue where id = &quot; .. row.id)
		return
	end

	if (distancexz(igplayers[row.steam].xPos, igplayers[row.steam].zPos, locations[&quot;arena&quot;].x, locations[&quot;arena&quot;].z ) &gt; locations[&quot;arena&quot;].size + 1 or igplayers[row.steam].deadX ~= nil) then
		-- destroy the command without sending it
		cecho(server.windowDebug, &quot;destroying player queued command &quot; .. row.command .. &quot;\n&quot;)
		conn:execute(&quot;delete from playerQueue where id = &quot; .. row.id)
		return
	else
		if (tonumber(row.steam) &gt; 0) then
			if (igplayers[row.steam].deadX == nil) then
				cecho(server.windowDebug, &quot;running player queued command &quot; .. row.command .. &quot;\n&quot;)

				if string.sub(row.command, 1, 2) == &quot;se&quot; then
					send(row.command)	
				else
					 message(row.command)	
				end

				conn:execute(&quot;delete from playerQueue where id = &quot; .. row.id)
				return
			end
		else
			cecho(server.windowDebug, &quot;running player queued command &quot; .. row.command .. &quot;\n&quot;)

			if string.sub(row.command, 1, 2) == &quot;se&quot; then
				send(row.command)	
			else
				 message(row.command)	
			end

			conn:execute(&quot;delete from playerQueue where id = &quot; .. row.id)
			return
		end
	end

	conn:execute(&quot;delete from playerQueue where id = &quot; .. row.id)
end</script>
            <command></command>
            <packageName></packageName>
            <time>00:00:04.000</time>
        </Timer>
        <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
            <name>GimmeQueuedCommands</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

local pid, dist1, dist2

cursor1,errorString = conn:execute(&quot;select distinct steam from gimmeQueue&quot;)
row1 = cursor1:fetch({}, &quot;a&quot;)

while row1 do
	cursor2,errorString = conn:execute(&quot;select * from gimmeQueue where steam = &quot; .. row1.steam .. &quot; order by id limit 0,1&quot;)
	row2 = cursor2:fetch({}, &quot;a&quot;)

	if row2 then
		send(row2.command)
		conn:execute(&quot;delete from gimmeQueue where id = &quot; .. row2.id)
	end

	row1 = cursor1:fetch(row1, &quot;a&quot;)
end</script>
            <command></command>
            <packageName></packageName>
            <time>00:00:00.500</time>
        </Timer>
        <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
            <name>ircQueue</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

cursor1,errorString = conn:execute(&quot;select distinct name from ircQueue&quot;)
row1 = cursor1:fetch({}, &quot;a&quot;)

while row1 do
	cursor2,errorString = conn:execute(&quot;select * from ircQueue where name = '&quot; .. escape(row1.name) .. &quot;' order by id limit 0,1&quot;)
	row2 = cursor2:fetch({}, &quot;a&quot;)

	if row2 then
		sendIrc(row2.name, row2.command)
		conn:execute(&quot;delete from ircQueue where id = &quot; .. row2.id)
	end

	row1 = cursor1:fetch(row1, &quot;a&quot;)
end</script>
            <command></command>
            <packageName></packageName>
            <time>00:00:00.450</time>
        </Timer>
        <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
            <name>Every45Seconds</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

local k, v, x, z, row, cursor, errorString

conn:execute(&quot;UPDATE keystones SET removed = 1&quot;)

for k, v in pairs(igplayers) do
	if v.claimPass == nil then v.claimPass = 1 end

	if accessLevel(k) &gt; 2 then
		cursor,errorString = conn:execute(&quot;SELECT count(remove) as deleted FROM keystones WHERE steam = &quot; .. k .. &quot; AND remove = 2&quot;)
		row = cursor:fetch({}, &quot;a&quot;)

		if tonumber(row.deleted) &gt; 0 then
			players[k].removedClaims = players[k].removedClaims + tonumber(row.deleted)
			players[k].alertRemovedClaims = true
			conn:execute(&quot;DELETE FROM keystones WHERE steam = &quot; .. k .. &quot; AND remove = 2&quot;)
		end

		if v.claimPass == 1 then
			x = math.floor(v.xPos / 512)
			z = math.floor(v.zPos / 512)
			checkRegionClaims(x, z)

			v.claimPass = 2
		else
			send(&quot;llp &quot; .. k)
			v.claimPass = 1
		end
	end
end</script>
            <command></command>
            <packageName></packageName>
            <time>00:01:00.000</time>
        </Timer>
        <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
            <name>TrackPlayer</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

local lastSession, rows

for k, v in pairs(igplayers) do	
	lastSession = false

	if v.trackerCount ~= nil then
		if v.trackerStopped == false then
			v.trackerCountdown = tonumber(v.trackerCountdown) - 1

			if (v.trackerCountdown &lt; 1) then
				v.trackerCountdown = v.trackerSpeed

				if v.trackerReversed then
					cursor,errorString = conn:execute(&quot;select * from memTracker where admin = &quot; .. k .. &quot; and trackerID &lt; &quot; .. v.trackerCount .. &quot; order by trackerID desc limit 0,&quot; .. v.trackerSkip + 1)
				else
					cursor,errorString = conn:execute(&quot;select * from memTracker where admin = &quot; .. k .. &quot; and trackerID &gt; &quot; .. v.trackerCount .. &quot; order by trackerID limit 0,&quot; .. v.trackerSkip + 1)
				end

				rows = cursor:numrows()

				if rows &gt; 0 then
					row = cursor:fetch({}, &quot;a&quot;)

					if tonumber(row.session) == tonumber(players[row.steam].sessionCount) then lastSession = true end

					send(&quot;tele &quot; .. k .. &quot; &quot; .. row.x .. &quot; &quot; .. row.y .. &quot; &quot; .. row.z)

					if rows == 1 then
						v.trackerStopped = true

						if lastSession then
							message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]Tracking complete. You have reached the players current position.[-]&quot;)
						else
							message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]Tracking complete. Type /next track or /last track to continue from the next session.[-]&quot;)
						end
					end

					while row do
						row = cursor:fetch(row, &quot;a&quot;)	

						if row.trackerID == nil then
							v.trackerStopped = true

							if lastSession then
								message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]Tracking complete. You have reached the players current position.[-]&quot;)
							else
								message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]Tracking complete. Type /next track or /last track to continue from the next session.[-]&quot;)
							end
						end

						v.trackerCount = row.trackerID
					end

					if v.trackerStop ~= nil then
						v.trackerStopped = true
						v.trackerStop = nil
					end
				else
					v.trackerStopped = true

					if lastSession then
						message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]Tracking complete. You have reached the players current position.[-]&quot;)
					else
						message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]Tracking complete. Type /next track or /last track to continue from the next session.[-]&quot;)
					end
				end
			end
		end
	end
end</script>
            <command></command>
            <packageName></packageName>
            <time>00:00:01.000</time>
        </Timer>
        <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
            <name>messageQueue</name>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

if botDisabled then
	return
end

cursor,errorString = conn:execute(&quot;select * from messageQueue where recipient = 0 order by id limit 0,1&quot;)
row = cursor:fetch({}, &quot;a&quot;)

if row then
	message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. row.message .. &quot;[-]&quot;)
	conn:execute(&quot;delete from messageQueue where id = &quot; .. row.id)
end


for k,v in pairs(igplayers) do
	cursor,errorString = conn:execute(&quot;select * from messageQueue where recipient = &quot; .. k .. &quot; order by id limit 0,1&quot;)
	row = cursor:fetch({}, &quot;a&quot;)

	if row then
		if tonumber(row.recipient) ~= 0 then
			if tonumber(row.sender) ~= 0 then
				message(&quot;pm &quot; .. row.recipient .. &quot; [&quot; .. server.chatColour .. &quot;]Message from &quot; .. players[row.sender].name .. &quot; &quot; .. row.message .. &quot;[-]&quot;)
			else
				message(&quot;pm &quot; .. row.recipient .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. row.message .. &quot;[-]&quot;)
			end
		else
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. row.message .. &quot;[-]&quot;)
		end

		conn:execute(&quot;delete from messageQueue where id = &quot; .. row.id)
	end
end</script>
            <command></command>
            <packageName></packageName>
            <time>00:00:02.000</time>
        </Timer>
        <Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
            <name>TwoMinuteTimer</name>
            <script></script>
            <command></command>
            <packageName></packageName>
            <time>00:02:00.000</time>
        </Timer>
    </TimerPackage>
    <AliasPackage/>
    <ActionPackage>
        <ActionGroup isActive="yes" isFolder="yes" isPushButton="no" isFlatButton="yes" useCustomLayout="no">
            <name>menu</name>
            <packageName></packageName>
            <script></script>
            <css></css>
            <commandButtonUp></commandButtonUp>
            <commandButtonDown></commandButtonDown>
            <icon></icon>
            <orientation>1</orientation>
            <location>3</location>
            <posX>0</posX>
            <posY>0</posY>
            <mButtonState>1</mButtonState>
            <sizeX>79508376</sizeX>
            <sizeY>0</sizeY>
            <buttonColumn>1</buttonColumn>
            <buttonRotation>1</buttonRotation>
            <buttonColor>#ffffff</buttonColor>
            <Action isActive="yes" isFolder="no" isPushButton="no" isFlatButton="no" useCustomLayout="no">
                <name>Show Players</name>
                <packageName></packageName>
                <script>clearUserWindow(server.windowPlayers)
--clearUserWindow(server.windowLists)
showPlayers = true

--for k, v in pairs(igplayers) do
--	cecho(server.windowLists, k .. &quot;   &quot; .. v.name .. &quot;        &quot; .. v.id .. &quot;\n&quot;)
--end</script>
                <css></css>
                <commandButtonUp></commandButtonUp>
                <commandButtonDown></commandButtonDown>
                <icon></icon>
                <orientation>1</orientation>
                <location>0</location>
                <posX>0</posX>
                <posY>0</posY>
                <mButtonState>1</mButtonState>
                <sizeX>0</sizeX>
                <sizeY>0</sizeY>
                <buttonColumn>1</buttonColumn>
                <buttonRotation>0</buttonRotation>
                <buttonColor>#ffffff</buttonColor>
            </Action>
            <Action isActive="yes" isFolder="no" isPushButton="no" isFlatButton="yes" useCustomLayout="no">
                <name>CLR Debug</name>
                <packageName></packageName>
                <script>clearUserWindow(server.windowDebug)</script>
                <css></css>
                <commandButtonUp></commandButtonUp>
                <commandButtonDown></commandButtonDown>
                <icon></icon>
                <orientation>1</orientation>
                <location>0</location>
                <posX>0</posX>
                <posY>0</posY>
                <mButtonState>1</mButtonState>
                <sizeX>3145776</sizeX>
                <sizeY>3145776</sizeY>
                <buttonColumn>1</buttonColumn>
                <buttonRotation>-1</buttonRotation>
                <buttonColor>#ffffff</buttonColor>
            </Action>
            <Action isActive="yes" isFolder="no" isPushButton="no" isFlatButton="yes" useCustomLayout="no">
                <name>CLR Lists</name>
                <packageName></packageName>
                <script>clearUserWindow(server.windowLists)</script>
                <css></css>
                <commandButtonUp></commandButtonUp>
                <commandButtonDown></commandButtonDown>
                <icon></icon>
                <orientation>1</orientation>
                <location>0</location>
                <posX>0</posX>
                <posY>0</posY>
                <mButtonState>1</mButtonState>
                <sizeX>75</sizeX>
                <sizeY>41</sizeY>
                <buttonColumn>1</buttonColumn>
                <buttonRotation>0</buttonRotation>
                <buttonColor>#ffffff</buttonColor>
            </Action>
            <Action isActive="yes" isFolder="no" isPushButton="no" isFlatButton="yes" useCustomLayout="no">
                <name>Show Tables</name>
                <packageName></packageName>
                <script>--display(serverFields)
--display(playerFields)

--echo(&quot;Players table\n&quot;)
--display( players )
--display( players[&quot;76561197983251951&quot;] )

--echo(&quot;In-game Players table\n&quot;)
--display( igplayers )



--echo(&quot;Admins table\n&quot;)
--display( admins )

--echo(&quot;Friends table\n&quot;)
--display( friends )

--echo(&quot;Teleports table\n&quot;)
--display( teleports )

--echo(&quot;Locations table\n&quot;)
--display( locations )

--echo(&quot;Server table\n&quot;)
--display( server )

--echo(&quot;chatvars table\n&quot;)
--display( chatvars )

--echo(&quot;Timed Commands table\n&quot;)
--display( timedCommands )

--hotspots={}
--echo(&quot;Hotspots table\n&quot;)
--display( hotspots )

--echo(&quot;badItems table\n&quot;)
--display( badItems )

--echo(&quot;playerQueuedCommands table\n&quot;)
--display( playerQueuedCommands )

--echo(&quot;ArenaPlayers table\n&quot;)
--display( arenaPlayers )

--echo(&quot;Inventory table\n&quot;)
--display( inventory[&quot;76561197983251951&quot;] )
--display( inventory )
--display( invTemp )

--echo(&quot;resetRegions table\n&quot;)
--display( resetRegions )

--echo(&quot;gimmeQueuedCommands table\n&quot;)
--display( gimmeQueuedCommands )

--echo(&quot;lastHotspots table\n&quot;)
--display( lastHotspots )

--echo(&quot;Owners table\n&quot;)
--display( owners )

--echo(&quot;Villagers table\n&quot;)
--display( villagers )

--echo(&quot;restrictedItems table\n&quot;)
--display( restrictedItems )

--stackLimits={}
--display(stackLimits)

--echo(&quot;shop categories table\n&quot;)
--display( shopCategories )

--echo(&quot;proxies table\n&quot;)
--display( proxies )

--display(customCommands)</script>
                <css></css>
                <commandButtonUp></commandButtonUp>
                <commandButtonDown></commandButtonDown>
                <icon></icon>
                <orientation>1</orientation>
                <location>0</location>
                <posX>0</posX>
                <posY>0</posY>
                <mButtonState>1</mButtonState>
                <sizeX>1756547332</sizeX>
                <sizeY>59476856</sizeY>
                <buttonColumn>1</buttonColumn>
                <buttonRotation>0</buttonRotation>
                <buttonColor>#ffffff</buttonColor>
            </Action>
            <Action isActive="yes" isFolder="no" isPushButton="no" isFlatButton="yes" useCustomLayout="no">
                <name>Test Code</name>
                <packageName></packageName>
                <script></script>
                <css></css>
                <commandButtonUp></commandButtonUp>
                <commandButtonDown></commandButtonDown>
                <icon></icon>
                <orientation>1</orientation>
                <location>0</location>
                <posX>0</posX>
                <posY>0</posY>
                <mButtonState>2</mButtonState>
                <sizeX>1631854633</sizeX>
                <sizeY>808533369</sizeY>
                <buttonColumn>1</buttonColumn>
                <buttonRotation>-1</buttonRotation>
                <buttonColor>#ffffff</buttonColor>
            </Action>
            <Action isActive="yes" isFolder="no" isPushButton="no" isFlatButton="yes" useCustomLayout="no">
                <name>temp test</name>
                <packageName></packageName>
                <script></script>
                <css></css>
                <commandButtonUp></commandButtonUp>
                <commandButtonDown></commandButtonDown>
                <icon></icon>
                <orientation>1</orientation>
                <location>0</location>
                <posX>0</posX>
                <posY>0</posY>
                <mButtonState>1</mButtonState>
                <sizeX>2097272</sizeX>
                <sizeY>6881382</sizeY>
                <buttonColumn>1</buttonColumn>
                <buttonRotation>-1</buttonRotation>
                <buttonColor>#ffffff</buttonColor>
            </Action>
            <Action isActive="yes" isFolder="no" isPushButton="no" isFlatButton="yes" useCustomLayout="no">
                <name>CLR Alerts</name>
                <packageName></packageName>
                <script>clearUserWindow(server.windowAlerts)</script>
                <css></css>
                <commandButtonUp></commandButtonUp>
                <commandButtonDown></commandButtonDown>
                <icon></icon>
                <orientation>1</orientation>
                <location>0</location>
                <posX>0</posX>
                <posY>0</posY>
                <mButtonState>2</mButtonState>
                <sizeX>7340147</sizeX>
                <sizeY>352329872</sizeY>
                <buttonColumn>1</buttonColumn>
                <buttonRotation>-1</buttonRotation>
                <buttonColor>#ffffff</buttonColor>
            </Action>
            <Action isActive="no" isFolder="no" isPushButton="no" isFlatButton="yes" useCustomLayout="no">
                <name>Load IP Blacklist</name>
                <packageName></packageName>
                <script>--readIPBlacklist()</script>
                <css></css>
                <commandButtonUp></commandButtonUp>
                <commandButtonDown></commandButtonDown>
                <icon></icon>
                <orientation>1</orientation>
                <location>0</location>
                <posX>0</posX>
                <posY>0</posY>
                <mButtonState>1</mButtonState>
                <sizeX>295772544</sizeX>
                <sizeY>0</sizeY>
                <buttonColumn>1</buttonColumn>
                <buttonRotation>0</buttonRotation>
                <buttonColor>#ffffff</buttonColor>
            </Action>
        </ActionGroup>
    </ActionPackage>
    <ScriptPackage>
        <Script isActive="yes" isFolder="no">
            <name>Functions</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see http://www.gnu.org/licenses
--]]

function inWhitelist(steam)
	-- is the player in the whitelist?
	cursor,errorString = conn:execute(&quot;SELECT * FROM whitelist WHERE steam = &quot; .. steam)
	row = cursor:fetch({}, &quot;a&quot;)

	if row then
		return true
	else
		return false
	end
end


function getWhitelistedServers()
	whitelistedServers = {}
	whitelistedServers[server.IP] = {}
	whitelistedServers[server.botsIP] = {}	

	cursor,errorString = connBots:execute(&quot;select IP from servers&quot;)
	row = cursor:fetch({}, &quot;a&quot;)

	while row do
		whitelistedServers[row.IP] = {}	
		row = cursor:fetch(row, &quot;a&quot;)	
	end
end


function atHome(steam)
	local dist, size, greet, home, time

	greet = false
	home = false

	if players[steam].lastAtHome == nil then
		players[steam].lastAtHome = os.time()
	end

	-- base 1
	if math.abs(players[steam].homeX) &gt; 0 and math.abs(players[steam].homeZ) &gt; 0 then
		dist = distancexz(math.floor(players[steam].xPos), math.floor(players[steam].zPos), players[steam].homeX, players[steam].homeZ)
		size = tonumber(players[steam].protectSize)

		if (dist &lt;= size) then
			home = true

			if not players[steam].atHome then
				greet = true
			end
		end
	end

	-- base 2
	if math.abs(players[steam].home2X) &gt; 0 and math.abs(players[steam].home2Z) &gt; 0 then
		dist = distancexz(math.floor(players[steam].xPos), math.floor(players[steam].zPos), players[steam].home2X, players[steam].home2Z)
		size = tonumber(players[steam].protect2Size)

		if (dist &lt;= size) then
			home = true

			if not players[steam].atHome then
				greet = true
			end
		end
	end

	if greet then
		time = os.time() - players[steam].lastAtHome

		if time &gt; 300 and time &lt;= 900 then
			r = rand(5)
			if r == 1 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Welcome home &quot; .. players[steam].name .. &quot;[-]&quot;) end
			if r == 2 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Back so soon &quot; .. players[steam].name .. &quot;?[-]&quot;) end
			if r == 3 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You're back![-]&quot;) end
			if r == 4 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Home sweet home :)[-]&quot;) end
			if r == 5 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Home again[-]&quot;) end
		end

		if time &gt; 900 and time &lt;= 1800 then
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You're back &quot; .. players[steam].name .. &quot;! Welcome home :)[-]&quot;)
		end

		if time &gt; 1800 and time &lt;= 3600 then
			r = rand(5)
			if r == 1 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Home at last &quot; .. players[steam].name .. &quot;![-]&quot;) end
			if r == 2 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Home again, home again. Ziggity zig.[-]&quot;) end
			if r == 3 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Look what the cat dragged in.  Hello &quot; .. players[steam].name .. &quot;[-]&quot;) end
			if r == 4 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Home at last &quot; .. players[steam].name .. &quot;![-]&quot;) end
			if r == 5 then message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You're back! So nice of you to drop by.[-]&quot;) end
		end

		if time &gt; 3600 then
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]So you decided to come home &quot; .. players[steam].name .. &quot;?[-]&quot;)
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Dinner's on the floor.[-]&quot;)
			r = rand(5)
			if r == 1 then send(&quot;give &quot; .. steam .. &quot; canDogfood 1&quot;) end
			if r == 2 then send(&quot;give &quot; .. steam .. &quot; canCatfood 1&quot;) end
			if r == 3 then send(&quot;give &quot; .. steam .. &quot; femur 1&quot;) end
			if r == 4 then send(&quot;give &quot; .. steam .. &quot; vegetableStew 1&quot;) end
			if r == 5 then send(&quot;give &quot; .. steam .. &quot; meatStew 1&quot;) end
		end
	end

	if home then
		players[steam].atHome = true
		players[steam].lastAtHome = os.time()
	else
		players[steam].atHome = false
	end
end


function reserveSlot(steam)
	dbug(&quot;Reserving slot for &quot; .. steam)
	send(&quot;sg ServerMaxPlayerCount &quot; .. server.ServerMaxPlayerCount + 1)
	reservedSlots[steam] = steam
	tempTimer( 60, [[removeReservedSlot(&quot;]] .. steam .. [[&quot;)]] )
end


function removeReservedSlot(steam)
	if reservedSlots[steam] then
		dbug(&quot;Removing reserved slot for &quot; .. steam)
		reservedSlots[steam] = nil
		send(&quot;sg ServerMaxPlayerCount &quot; .. server.ServerMaxPlayerCount - 1)
	end
end


function calcTimestamp(str)
	-- takes input like 1 week, 1 month, 1 year and outputs a timestamp that much in the future
	local number, period

	str = string.lower(str)
	number = math.abs(math.floor(tonumber(string.match(str, &quot;(-?%d+)&quot;))))

	if string.find(str, &quot;day&quot;) then
		period = 60 * 60 * 24
	end

	if string.find(str, &quot;week&quot;) then
		period = 60 * 60 * 24 * 7
	end

	if string.find(str, &quot;month&quot;) then
		period = 60 * 60 * 24 * 30
	end

	if string.find(str, &quot;year&quot;) then
		period = 60 * 60 * 24 * 365
	end

	if number == nil or period == nil then 
		return os.time()
	else
		return os.time() + period * number
	end
end


function dbug(text)
	-- send text to the debug window we created in Mudlet.
	cecho(server.windowLists, text .. &quot;\n&quot;)
end


function countAlphaNumeric(test)
	-- return the number of alphanumeric characters in test

	local _, count = string.gsub(test, &quot;%w&quot;, &quot;&quot;)
	return count
end


function isFile(name)
    if type(name)~=&quot;string&quot; then return false end
    if not isDir(name) then
        return os.rename(name,name) and true or false
        -- note that the short evaluation is to
        -- return false instead of a possible nil
    end
    return false
end


function isFileOrDir(name)
    if type(name)~=&quot;string&quot; then return false end
    return os.rename(name, name) and true or false
end


function isDir(name)
    if type(name)~=&quot;string&quot; then return false end
    local cd = lfs.currentdir()
    local is = lfs.chdir(name) and true or false
    lfs.chdir(cd)
    return is
end


function pmsg(msg, all)
	-- queue msg for output by a timer
	for k,v in pairs(igplayers) do
		if all ~= nil or players[k].noSpam == false then
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,&quot; .. k .. &quot;,'&quot; .. escape(msg) .. &quot;)&quot;)
		end
	end
end


function strDateToTimestamp(strdate)
	-- Unix timestamps end in 2038.  To prevent invalid dates, we will force year to 2030 if it is later.
	local sday, smonth, syear, shour, sminute, sseconds = strdate:match(&quot;(%d+)/(%d+)/(%d+) (%d+):(%d+):(%d+)&quot;)

	-- don't allow dates over 2030.  timestamps stop at 2038
	if tonumber(syear) &gt; 2030 then syear = 2030 end

	return os.time({year = syear, month = smonth, day = sday, hour = shour, min = sminute, sec = sseconds})
end


function getEquipment(equipment, item)
	-- search the most recent inventory recording for an item and if found return how much there is and best quality if applicable
	local tbl, test, i, found, quantity, quality

	found = false
	quality = 0
	quantity = 0
	tbl = string.split(equipment, &quot;|&quot;)

	for i=1, table.maxn(tbl) - 1, 1 do
		test = string.split(tbl[i], &quot;,&quot;)

		if test[2] == item then
			found = true

			if tonumber(test[3]) &gt; tonumber(quality) then
				quality = tonumber(test[3])
			end
		end
	end

	if found then
		return true, quality
	else
		return false, 0
	end
end


function getInventory(inventory, item)
	-- search the most recent inventory recording for an item and if found return how much there is and best quality if applicable
	local tbl, test, i, found, quantity, quality

	found = false
	quality = 0
	quantity = 0
	tbl = string.split(inventory, &quot;|&quot;)

	for i=1, table.maxn(tbl) - 1, 1 do
		test = string.split(tbl[i], &quot;,&quot;)
		if test[3] == item then
			found = true
			quantity = quantity + tonumber(test[2])

			if tonumber(test[4]) &gt; tonumber(quality) then
				quality = tonumber(test[4])
			end
		end
	end

	if found then
		return true, quantity, quality
	else
		return false, 0 , 0
	end
end


function inInventory(steam, item, quantity, slot)
	-- search the most recent inventory recording for an item
	local tbl, test, i

	cursor,errorString = conn:execute(&quot;SELECT * FROM inventoryTracker WHERE steam = &quot; .. steam ..&quot;  ORDER BY inventoryTrackerID DESC Limit 0, 1&quot;)
	row = cursor:fetch({}, &quot;a&quot;)

	tbl = string.split(row.belt .. row.pack .. row.equipment, &quot;|&quot;)

	for i=1, table.maxn(tbl) - 1, 1 do
		test = string.split(tbl[i], &quot;,&quot;)
		if slot ~= nil then
			if tonumber(test[2]) &gt;= tonumber(quantity) and test[3] == item and tonumber(test[1]) == slot then
				return true
			end
		else
			if tonumber(test[2]) &gt;= tonumber(quantity) and test[3] == item then
				return true
			end
		end
	end

	return false
end


function inBelt(steam, item, quantity, slot)
	-- search the most recent inventory recording for an item in the belt
	local tbl, test, i

	cursor,errorString = conn:execute(&quot;SELECT * FROM inventoryTracker WHERE steam = &quot; .. steam ..&quot;  ORDER BY inventoryTrackerID DESC Limit 0, 1&quot;)
	row = cursor:fetch({}, &quot;a&quot;)

	tbl = string.split(row.belt, &quot;|&quot;)

	for i=1, table.maxn(tbl) - 1, 1 do
		test = string.split(tbl[i], &quot;,&quot;)
		if slot ~= nil then
			if tonumber(test[2]) &gt;= tonumber(quantity) and test[3] == item and tonumber(test[1]) == slot then
				return true
			end
		else
			if tonumber(test[2]) &gt;= tonumber(quantity) and test[3] == item then
				return true
			end
		end
	end

	return false
end


function mapPosition(steam)
	-- express the player's coordinates as a compass bearing
	local ns, ew

	if tonumber(players[steam].xPos) &lt; 0 then
		ew = math.abs(math.floor(players[steam].xPos)).. &quot; W&quot;
	else
		ew = math.floor(players[steam].xPos) .. &quot; E&quot;
	end

	if tonumber(players[steam].zPos) &lt; 0 then
		ns = math.abs(math.floor(players[steam].zPos)) .. &quot; S&quot;
	else
		ns = math.floor(players[steam].zPos) .. &quot; N&quot;
	end

	return ns .. &quot; &quot; .. ew
end


function validPosition(steam, alert)
	-- check that y position is between bedrock and the max build height
	if tonumber(players[steam].yPos) &gt; -1 and tonumber(players[steam].yPos) &lt; 256 then
		return true
	else
		if alert ~= nil then
			message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You cannot do that here. If you recently teleported, wait a bit then try again.[-]&quot;)
		end

		return false
	end
end


function savePosition(steam, temp)
	-- helper function to save the players position
	if tonumber(players[steam].yPos) &gt; -1 and tonumber(players[steam].yPos) &lt; 256 then
		-- store the player's current x y z
		if temp == nil then
			players[steam].xPosOld = math.floor(players[steam].xPos)
			players[steam].yPosOld = math.ceil(players[steam].yPos)
			players[steam].zPosOld = math.floor(players[steam].zPos)

			conn:execute(&quot;UPDATE players SET xPosOld = &quot; .. players[steam].xPosOld .. &quot;, yPosOld = &quot; .. players[steam].yPosOld .. &quot;, zPosOld = &quot; .. players[steam].zPosOld .. &quot; WHERE steam = &quot; .. steam)
		else
			players[steam].xPosOld2 = math.floor(players[steam].xPos)
			players[steam].yPosOld2 = math.ceil(players[steam].yPos)
			players[steam].zPosOld2 = math.floor(players[steam].zPos)

			conn:execute(&quot;UPDATE players SET xPosOld2 = &quot; .. players[steam].xPosOld2 .. &quot;, yPosOld2 = &quot; .. players[steam].yPosOld2 .. &quot;, zPosOld2 = &quot; .. players[steam].zPosOld2 .. &quot; WHERE steam = &quot; .. steam)
		end
	end
end


function seen(steam)
	-- when was a player last seen ingame?
	local words, word, diff, ryear, rmonth, rday, rhour, rmin, rsec
	local dateNow, Now, dateSeen, Seen, days, hours, minutes

	if players[steam].seen == &quot;&quot; then
		return &quot;A new player on for the first time now.&quot;
	end

	words = {}
	for word in serverTime:gmatch(&quot;%w+&quot;) do table.insert(words, word) end

	ryear = words[1]
	rmonth = words[2]
	rday = string.sub(words[3], 1, 2)
	rhour = string.sub(words[3], 4, 5)
	rmin = words[4]
	rsec = words[5]

	dateNow = {year=ryear, month=rmonth, day=rday, hour=rhour, min=rmin, sec=rsec}
	Now = os.time(dateNow)

	words = {}
	for word in players[steam].seen:gmatch(&quot;%w+&quot;) do table.insert(words, word) end

	ryear = words[1]
	rmonth = words[2]
	rday = string.sub(words[3], 1, 2)
	rhour = string.sub(words[3], 4, 5)
	rmin = words[4]
	rsec = words[5]

	dateSeen = {year=ryear, month=rmonth, day=rday, hour=rhour, min=rmin, sec=rsec}
	Seen = os.time(dateSeen)

	diff = os.difftime(Now, Seen)
	days = math.floor(diff / 86400)

	if (days &gt; 0) then
		diff = diff - (days * 86400)
	end

	hours = math.floor(diff / 3600)

	if (hours &gt; 0) then
		diff = diff - (hours * 3600)
	end

	minutes = math.floor(diff / 60)

	return players[steam].name .. &quot; was last seen &quot; .. days .. &quot; days &quot; .. hours .. &quot; hours &quot; .. minutes ..&quot; minutes ago&quot;
end


function LookupHotspot(x,y,z)
	-- return the closest hotspot that these coords are inside
	local size, k, v

	for k, v in pairs(hotspots) do
		if (v.radius ~= nil) then 
			size = v.radius 
		else
			size = 3 
		end

		if distancexyz(x, y, z, v.x, v.y, v.z) &lt;= tonumber(size) then
			return k
		end
	end
end


function messageAdmins(message)
	-- helper function to send a message to all staff
	local k,v

	for k, v in pairs(players) do
		if (accessLevel(k) &lt; 3) then
			if igplayers[k] then
				message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. message .. &quot;[-]&quot;)
			else
				conn:execute(&quot;INSERT INTO mail (sender, recipient, message) VALUES (0,&quot; .. k .. &quot;, '&quot; .. escape(message) .. &quot;')&quot;)
			end
		end
	end
end


function kick(steam, reason)
	local tmp

	tmp = steam
	-- if there is no player with steamid steam, try looking it up incase we got their name instead of their steam
	if not players[steam] then
		steam = LookupPlayer(string.trim(steam))
		-- restore the original steam value if nothing matched as we may be banning someone who's never played here.
		if steam == nil then steam = tmp end
	end

	if igplayers[steam] then
		conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. math.floor(players[steam].xPos) .. &quot;,&quot; .. math.ceil(players[steam].yPos) .. &quot;,&quot; .. math.floor(players[steam].zPos) .. &quot;,'&quot; .. serverTime .. &quot;','kick','Player &quot; .. steam .. &quot; &quot; .. escape(players[steam].name) .. &quot; kicked for &quot; .. escape(reason) .. &quot;',&quot; .. steam .. &quot;)&quot;)
		send(&quot;kick &quot; .. steam .. &quot; &quot; .. &quot; \&quot;&quot; .. reason .. &quot;\&quot;&quot;)
	end
end


function banPlayer(steam, duration, reason, issuer)
	local tmp, admin, belt, pack, equipment

	belt = &quot;&quot;
	pack = &quot;&quot;
	equipment = &quot;&quot;

	if string.len(issuer) &gt; 10 then
		admin = issuer
	else
		admin = 0
	end

	tmp = steam
	-- if there is no player with steamid steam, try looking it up incase we got their name instead of their steam
	if not players[steam] then
		steam = LookupPlayer(string.trim(steam))
		-- restore the original steam value if nothing matched as we may be banning someone who's never played here.
		if steam == nil then steam = tmp end
	end

	-- grab their belt, pack and equipment
	if players[steam] then
		cursor,errorString = conn:execute(&quot;SELECT * FROM inventoryTracker WHERE steam = &quot; .. steam ..&quot; ORDER BY inventoryTrackerid DESC Limit 1&quot;)
		row = cursor:fetch({}, &quot;a&quot;)
		if row then
			belt = row.belt
			pack = row.pack
			equipment = row.equipment
		end
	end

	if players[steam] then
		conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. math.floor(players[steam].xPos) .. &quot;,&quot; .. math.ceil(players[steam].yPos) .. &quot;,&quot; .. math.floor(players[steam].zPos) .. &quot;,'&quot; .. serverTime .. &quot;','ban','Player &quot; .. steam .. &quot; &quot; .. escape(players[steam].name) .. &quot; has has been banned for &quot; .. duration .. &quot; for &quot; .. escape(reason) .. &quot;',&quot; .. steam .. &quot;)&quot;)
		irc_QueueMsg(server.ircMain, &quot;[BANNED] Player &quot; .. steam .. &quot; &quot; .. players[steam].name .. &quot; has been banned for &quot; .. duration .. &quot; &quot; .. reason)
		irc_QueueMsg(server.ircAlerts, &quot;[BANNED] Player &quot; .. steam .. &quot; &quot; .. players[steam].name .. &quot; has been banned for &quot; .. duration .. &quot; &quot; .. reason)
	else
		-- handle unknown steam id
		conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (0,0,0,'&quot; .. serverTime .. &quot;','ban','Player &quot; .. steam .. &quot; &quot; .. steam .. &quot; has has been banned for &quot; .. duration .. &quot; for &quot; .. escape(reason) .. &quot;',&quot; .. steam .. &quot;)&quot;)
		irc_QueueMsg(server.ircMain, &quot;[BANNED] Unknown player &quot; .. steam .. &quot; has been banned for &quot; .. duration .. &quot; &quot; .. reason)
		irc_QueueMsg(server.ircAlerts, &quot;[BANNED] Unknown player &quot; .. steam .. &quot; has been banned for &quot; .. duration .. &quot; &quot; .. reason)
	end

	-- add to bots db
	if reason == &quot;blacklisted&quot; then
		if db2Connected then
			connBots:execute(&quot;INSERT INTO bans (bannedTo, steam, reason, permanent, playTime, score, playerKills, zombies, country, belt, pack, equipment, botID, admin) VALUES ('&quot; .. escape(&quot;MISSING&quot;) .. &quot;',&quot; .. steam .. &quot;,'&quot; .. escape(reason) .. &quot;',&quot; .. dbBool(players[steam].permanentBan) .. &quot;,&quot; .. tonumber(players[steam].timeOnServer) + tonumber(players[steam].playtime) .. &quot;,&quot; .. players[steam].score .. &quot;,&quot; .. players[steam].playerKills .. &quot;,&quot; .. players[steam].zombies .. &quot;,'&quot; .. players[steam].country .. &quot;','&quot; .. escape(belt) .. &quot;','&quot; .. escape(pack) .. &quot;','&quot; .. escape(equipment) .. &quot;','&quot; .. server.botID .. &quot;','&quot; .. admin .. &quot;')&quot;)
		end
	end

	send(&quot;ban add &quot; .. steam .. &quot; &quot; .. duration .. &quot; \&quot;&quot; .. reason .. &quot;\&quot;&quot;)
	send(&quot;llp &quot; .. steam)
end


function timeoutPlayer(steam, reason, bot)
	-- if the player is not already in timeout, send them there.
	if players[steam].timeout == false and players[steam].botTimeout == false then
		players[steam].timeout = true
		if accessLevel(steam) &gt; 2 then players[steam].silentBob = true end
		if bot then players[steam].botTimeout = true end -- the bot initiated this timeout
		-- record their position for return
		players[steam].xPosTimeout = math.floor(players[steam].xPos)
		players[steam].yPosTimeout = math.ceil(players[steam].yPos) + 1
		players[steam].zPosTimeout = math.floor(players[steam].zPos)

		conn:execute(&quot;UPDATE players SET timeout = 1, botTimeout = &quot; .. dbBool(bot) .. &quot;, xPosTimeout = &quot; .. players[steam].xPosTimeout .. &quot;, yPosTimeout = &quot; .. players[steam].yPosTimeout .. &quot;, zPosTimeout = &quot; .. players[steam].zPosTimeout .. &quot; WHERE steam = &quot; .. steam)		
		conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. math.floor(players[steam].xPos) .. &quot;,&quot; .. math.ceil(players[steam].yPos) .. &quot;,&quot; .. math.floor(players[steam].zPos) .. &quot;,'&quot; .. serverTime .. &quot;','timeout','Player &quot; .. steam .. &quot; &quot; .. escape(players[steam].name) .. &quot; has has been sent to timeout for &quot; .. escape(reason) .. &quot;',&quot; .. steam .. &quot;)&quot;)
		
		-- then teleport the player to timeout
		players[steam].tp = 1
		players[steam].hackerScore = 0

		if players[steam].watchPlayer then
			irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. steam .. &quot; &quot; .. players[steam].name .. &quot; sent to timeout&quot;)
		end

		send(&quot;tele &quot; .. steam .. &quot; &quot; .. players[steam].xPosTimeout .. &quot; 50000 &quot; .. players[steam].zPosTimeout)

		message(&quot;say [&quot; .. server.chatColour .. &quot;]Sending player &quot; .. players[steam].name .. &quot; to timeout for &quot; .. reason .. &quot;[-]&quot;)
		irc_QueueMsg(server.ircMain, &quot;[TIMEOUT] Player &quot; .. steam .. &quot; &quot; .. players[steam].name .. &quot; has been sent to timeout for &quot; .. reason)
		irc_QueueMsg(server.ircAlerts, &quot;[TIMEOUT] Player &quot; .. steam .. &quot; &quot; .. players[steam].name .. &quot; has been sent to timeout for &quot; .. reason)
	end
end


function checkRegionClaims(x, z)
	cursor,errorString = conn:execute(&quot;SELECT * FROM keystones WHERE floor(x / 512) =  &quot; .. x .. &quot; AND floor(z / 512) = &quot; .. z)
	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		if row.remove == &quot;1&quot; then
			send(&quot;rlp &quot; .. row.x .. &quot; &quot; .. row.y .. &quot; &quot; .. row.z)
			conn:execute(&quot;UPDATE keystones SET remove = 2 WHERE steam = &quot; .. row.steam .. &quot; AND x = &quot; .. row.x .. &quot; AND y = &quot; .. row.y .. &quot; AND z = &quot; .. row.z )
		end

		row = cursor:fetch(row, &quot;a&quot;)	
	end
end


function dbWho(ownerid, x, y, z, dist, days, hours, height)
	local cursor, errorString,row, counter

	if days == nil then days = 1 end
	if height == nil then height = 4 end

	conn:execute(&quot;DELETE FROM searchResults WHERE owner = &quot; .. ownerid)

	if hours &gt; 0 then
		cursor,errorString = conn:execute(&quot;select distinct steam, session from tracker where abs(x - &quot; .. x .. &quot;) &lt; &quot; .. dist .. &quot; and abs(z - &quot; .. z .. &quot;) &lt; &quot; .. dist .. &quot; and abs(y - &quot; .. y .. &quot;) &lt; &quot; .. height .. &quot; and timestamp &gt;= '&quot; .. os.date(&quot;%Y-%m-%d %H:%M:%S&quot;, os.time() - (tonumber(hours) * 3600)) .. &quot;'&quot;)
	else
		cursor,errorString = conn:execute(&quot;select distinct steam, session from tracker where abs(x - &quot; .. x .. &quot;) &lt; &quot; .. dist .. &quot; and abs(z - &quot; .. z .. &quot;) &lt; &quot; .. dist .. &quot; and abs(y - &quot; .. y .. &quot;) &lt; &quot; .. height .. &quot; and timestamp &gt;= '&quot; .. os.date(&quot;%Y-%m-%d %H:%M:%S&quot;, os.time() - (tonumber(days) * 86400)) .. &quot;'&quot;)
	end

	row = cursor:fetch({}, &quot;a&quot;)
	counter = 1
	rows = cursor:numrows()

	if igplayers[ownerid] == nil then
		if rows &gt; 50 then
			irc_QueueMsg(ownerid, &quot;****** Report length &quot; .. rows .. &quot; rows.  Cancel it with: nuke irc ******&quot;)
		end
	end

	while row do
		conn:execute(&quot;INSERT INTO searchResults (owner, steam, session, counter) VALUES (&quot; .. ownerid .. &quot;,&quot; .. row.steam .. &quot;,&quot; .. row.session .. &quot;,&quot; .. counter .. &quot;)&quot;)

		if igplayers[ownerid] then
			message(&quot;pm &quot; .. ownerid .. &quot; [&quot; .. server.chatColour .. &quot;] #&quot; .. counter ..&quot; &quot; .. row.steam .. &quot; &quot; .. players[row.steam].id .. &quot; &quot; .. players[row.steam].name .. &quot; sess: &quot; .. row.session .. &quot;[-]&quot;)
		else
			irc_QueueMsg(ownerid, &quot;#&quot; .. counter ..&quot; &quot; .. row.steam .. &quot; &quot; .. players[row.steam].name .. &quot; sess: &quot; .. row.session)
		end

		counter = counter + 1
		row = cursor:fetch(row, &quot;a&quot;)	
	end
end


function dailyMaintenance()
	-- put something here to be run when the server date hits midnight
	if db2Connected then
		getWhitelistedServers()
	end

	return true
end


function startReboot()
	send(&quot;sa&quot;)
	rebootTimerID = tempTimer( 5, [[finishReboot()]] )
end


function clearRebootFlags()
	nextRebootTest = os.time() + 60
	scheduledReboot = false 
	server.scheduledRestart = false
	server.scheduledRestartTimestamp = os.time()
	scheduledRestartPaused = nil
	scheduledRestartForced = false
end


function finishReboot()
	tempTimer( 30, [[clearRebootFlags()]] )

	if (rebootTimerID ~= nil) then 
		killTimer(rebootTimerID)
		rebootTimerID = nil 
	end

	if (rebootTimerDelayID ~= nil) then 
		killTimer(rebootTimerDelayID)
		rebootTimerDelayID = nil 
	end

	if not server.allowPhysics then
		server.tempMaxPlayers = server.maxPlayers
		send(&quot;sg ServerMaxPlayerCount 0&quot;)
	end

	send(&quot;shutdown&quot;)
end


function newDay()
	if (string.sub(serverTime, 1, 10) ~= server.date) then
		server.date = string.sub(serverTime, 1, 10)
		resetShop()

		if tonumber(playersOnline) == 0 then
			saveLuaTables()
		end
	end
end


function IPToInt(ip)
	local o1,o2,o3,o4

	o1,o2,o3,o4 = ip:match(&quot;(%d%d?%d?)%.(%d%d?%d?)%.(%d%d?%d?)%.(%d%d?%d?)&quot; )
	return 2^24*o1 + 2^16*o2 + 2^8*o3 + o4
end


function readIPBlacklist()
	-- very slow.  don't run with a full server
	local ln
	local iprange

	local o1,o2,o3,o4
	local num1,num2

	for ln in io.lines(homedir .. &quot;/cn.csv&quot;) do
		iprange = string.split(ln, &quot;,&quot;)

		o1,o2,o3,o4 = iprange[1]:match(&quot;(%d%d?%d?)%.(%d%d?%d?)%.(%d%d?%d?)%.(%d%d?%d?)&quot; )
		num1 = 2^24*o1 + 2^16*o2 + 2^8*o3 + o4

		o1,o2,o3,o4 = iprange[2]:match(&quot;(%d%d?%d?)%.(%d%d?%d?)%.(%d%d?%d?)%.(%d%d?%d?)&quot; )
		num2 = 2^24*o1 + 2^16*o2 + 2^8*o3 + o4

		connBots:execute(&quot;INSERT INTO IPBlacklist (StartIP, EndIP) VALUES (&quot; .. num1 .. &quot;,&quot; .. num2 .. &quot;)&quot;)
	end
end


function Translate(playerid, command, lang, override)
	local words, word, oldCount, matches

	os.execute(userHome .. &quot;/&quot; .. server.botID .. &quot;trans.txt&quot;)

	words = {}
	for word in command:gmatch(&quot;%S+&quot;) do table.insert(words, word) end
	oldCount = table.maxn(words)

	if lang == &quot;&quot; then
		os.execute(&quot;trans -b -no-ansi \&quot;&quot; .. command .. &quot;\&quot; &gt; &quot; .. userHome .. &quot;/&quot; .. server.botID .. &quot;trans.txt&quot;)
	else
		os.execute(&quot;trans -b -no-ansi {en=&quot; .. lang ..&quot;}  \&quot;&quot; .. command .. &quot;\&quot; &gt; &quot; .. userHome .. &quot;/&quot; .. server.botID .. &quot;trans.txt&quot;)
	end                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         

	for ln in io.lines(userHome .. &quot;/&quot; .. server.botID .. &quot;trans.txt&quot;) do
		matches = 0
		for word in ln:gmatch(&quot;%S+&quot;) do
			if string.find(command, word, nil, true) then
				matches = matches + 1
			end
		end

		if matches &lt; 2 then
			if ln ~= command and string.trim(ln) ~= &quot;&quot; then
				if players[playerid].translate == true or override ~= nil then
					message(&quot;say [BDFFFF]&quot; .. players[playerid].name .. &quot; [-]&quot; .. ln)
				end

				if players[playerid].translate == false then
					irc_QueueMsg(server.ircMain, players[playerid].name .. &quot; &quot; .. ln)
				end
			end
		end
	end

	io.close()
end


function CheckClaimsRemoved()
	for k,v in pairs(igplayers) do
		if players[k].alertRemovedClaims == true then
			message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]You placed claims in a restricted area and they have been automatically removed.  You can get them back by typing /give lcb.[-]&quot;)
			players[k].alertRemovedClaims = false
		end
	end
end


function CheckBlacklist(steam, ip)
	local o1,o2,o3,o4 = ip:match(&quot;(%d%d?%d?)%.(%d%d?%d?)%.(%d%d?%d?)%.(%d%d?%d?)&quot; )
	local ipint = 2^24*o1 + 2^16*o2 + 2^8*o3 + o4

	if not db2Connected then
		return
	end

	if players[steam].whitelisted == false then
		-- test for China IP
		ipint = tonumber(ipint)

		cursor,errorString = connBots:execute(&quot;SELECT * FROM IPBlacklist WHERE StartIP &lt;=  &quot; .. ipint .. &quot; AND EndIP &gt;= &quot; .. ipint)
		if cursor:numrows() &gt; 0 then

			irc_QueueMsg(server.ircMain, &quot;Chinese IP detected. &quot; .. players[steam].name)
			irc_QueueMsg(server.ircAlerts, &quot;Chinese IP detected. &quot; .. players[steam].name)
			players[steam].china = true
			players[steam].country = &quot;CN&quot;
			players[steam].ircTranslate = true

			if server.blacklistResponse == 'exile' then
				if tonumber(players[steam].exiled) == 0 then
					players[steam].exiled = 1
					conn:execute(&quot;UPDATE players SET country = 'CN', exiled = 1, ircTranslate = 1 WHERE steam = &quot; .. steam)
				end

				-- alert players
				for k, v in pairs(igplayers) do
					if players[k].exiled~=1 and not players[k].prisoner then
						message(&quot;pm &quot; .. k .. &quot; Chinese player &quot; .. players[steam].name .. &quot; detected and sent to exile.[-]&quot;)
					end
				end
			end

			if server.blacklistResponse == 'ban' then
				irc_QueueMsg(server.ircMain, &quot;Chinese player &quot; .. players[steam].name .. &quot; banned.&quot;)
				irc_QueueMsg(server.ircAlerts, &quot;Chinese player &quot; .. players[steam].name .. &quot; banned.&quot;)
				banPlayer(steam, &quot;10 years&quot;, &quot;blacklisted&quot;, &quot;&quot;)
			end

			connBots:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event,steam) VALUES (&quot; .. math.floor(players[steam].xPos) .. &quot;,&quot; .. math.ceil(players[steam].yPos) .. &quot;,&quot; .. math.floor(players[steam].zPos) .. &quot;,'&quot; .. serverTime .. &quot;','info','Chinese player joined. Name: &quot; .. escape(player) .. &quot; SteamID: &quot; .. steam .. &quot; IP: &quot; .. ip  .. &quot;',&quot; .. steam .. &quot;)&quot;)
		else
			reverseDNS(steam, ip)
		end
	end
end


function reverseDNS(steam, ip)
	os.rename(homedir .. &quot;/dns/&quot; .. steam .. &quot;.txt&quot;, homedir .. &quot;/dns/&quot; .. steam .. &quot;_old.txt&quot;)
	os.execute(&quot;whois &quot; .. ip .. &quot; &gt; \&quot;&quot; .. homedir .. &quot;/dns/&quot; .. steam .. &quot;.txt\&quot;&quot;)
	tempTimer( 60, [[readDNS(&quot;]] .. steam .. [[&quot;)]] )
end


function readDNS(steam)
	local file, ln, split, ip1, ip2, exiled, country, proxy

	file = io.open(homedir .. &quot;/dns/&quot; .. steam .. &quot;.txt&quot;, &quot;r&quot;)	
	exiled = false
	proxy = false
	country = &quot;&quot;
	for ln in file:lines() do
		ln = string.upper(ln)

		if string.find(ln, &quot;%s(%d+)%.(%d+)%.(%d+)%.(%d+)%s&quot;) then
			a,b = string.find(ln, &quot;%s(%d+)%.(%d+)%.(%d+)%.(%d+)%s&quot;)
			iprange = string.sub(ln, a, a+b)
		end

		if not players[steam].whitelisted and isNewPlayer(steam) then
			for k,v in pairs(proxies) do
				if string.find(ln, string.upper(v.scanString), nil, true) then
					v.hits = tonumber(v.hits) + 1

					if db2Connected then
						connBots:execute(&quot;UPDATE proxies SET hits = hits + 1 WHERE scanString = '&quot; .. escape(k) .. &quot;'&quot;)
					end

					if v.action == &quot;ban&quot; or v.action == &quot;&quot; then
						irc_QueueMsg(server.ircMain, &quot;Player &quot; .. players[steam].name .. &quot; banned. Detected proxy &quot; .. v.scanString)
						irc_QueueMsg(server.ircAlerts, &quot;Player &quot; .. players[steam].name .. &quot; banned. Detected proxy &quot; .. v.scanString)
						banPlayer(steam, &quot;10 years&quot;, &quot;blacklisted&quot;, &quot;&quot;)
						proxy = true
					else
						if players[steam].exiled == 0 then
							players[steam].exiled = 1
							irc_QueueMsg(server.ircMain, &quot;Player &quot; .. players[steam].name .. &quot; exiled. Detected proxy &quot; .. v.scanString)
							irc_QueueMsg(server.ircAlerts, &quot;Player &quot; .. players[steam].name .. &quot; exiled. Detected proxy &quot; .. v.scanString)
							exiled = true
							proxy = true
						end
					end
				end
			end
		end

		if proxy then break end

		if string.find(ln, &quot;OUNTRY:&quot;) then
			-- only report country change if CN or HK are involved. For once, don't blame Canada.
			a,b = string.find(ln, &quot;%s(%w+)&quot;)
			country = string.sub(ln, a + 1)
			if players[steam].country ~= &quot;&quot; and players[steam].country ~= country and (players[steam].country == &quot;CN&quot; or players[steam].country == &quot;HK&quot; or country == &quot;CN&quot; or country == &quot;HK&quot;) and players[steam].whitelisted == false then
				irc_QueueMsg(server.ircAlerts, &quot;Possible proxy detected! Country changed! &quot; .. steam .. &quot; &quot; .. players[steam].name .. &quot; &quot; .. players[steam].IP .. &quot; old country &quot; .. players[steam].country .. &quot; new &quot; .. country)
				conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event,steam) VALUES (0,0,0'&quot; .. serverTime .. &quot;','proxy','Suspected proxy used by &quot; .. escape(players[steam].name) .. &quot; &quot; .. players[steam].IP .. &quot; old country &quot; .. players[steam].country .. &quot; new &quot; .. country .. &quot;,&quot; .. steam .. &quot;)&quot;)	
				proxy = true
			else
				 players[steam].country = country
			end
		end

		-- We consider HongKong to be China since Chinese players connect from there too.
		if (country == &quot;CN&quot; or country == &quot;HK&quot;) and players[steam].whitelisted == false then
			-- China detected. Add ip range to IPBlacklist table
			split = string.split(iprange, &quot;-&quot;)

			ip1 = IPToInt(string.trim(split[1]))
			ip2 = IPToInt(string.trim(split[2]))
			
			irc_QueueMsg(server.ircMain, &quot;Chinese IP detected. &quot; .. players[steam].name .. &quot; &quot; .. players[steam].IP)
			irc_QueueMsg(server.ircAlerts, &quot;Chinese IP detected. &quot; .. players[steam].name .. &quot; &quot; .. players[steam].IP)
			players[steam].china = true
			players[steam].ircTranslate = true

			if server.blacklistResponse == 'exile' then
				if players[steam].exiled == 0 then
					players[steam].exiled = 1
					irc_QueueMsg(server.ircMain, &quot;Chinese player &quot; .. players[steam].name .. &quot; exiled.&quot;)
					irc_QueueMsg(server.ircAlerts, &quot;Chinese player &quot; .. players[steam].name .. &quot; exiled.&quot;)
					exiled = true
				end
			end

			if server.blacklistResponse == 'ban' then
				irc_QueueMsg(server.ircMain, &quot;Chinese player &quot; .. players[steam].name .. &quot; banned.&quot;)
				irc_QueueMsg(server.ircAlerts, &quot;Chinese player &quot; .. players[steam].name .. &quot; banned.&quot;)
				banPlayer(steam, &quot;10 years&quot;, &quot;blacklisted&quot;, &quot;&quot;)
			end

			if db2Connected then
				irc_QueueMsg(server.ircMain, &quot;Added new Chinese IP range &quot; .. iprange .. &quot; to blacklist&quot;)			
				connBots:execute(&quot;INSERT INTO IPBlacklist (StartIP, EndIP) VALUES (&quot; .. ip1 .. &quot;,&quot; .. ip2 .. &quot;)&quot;)
			end

			-- alert players
			for k, v in pairs(igplayers) do
				if players[k].exiled~=1 and not players[k].prisoner then
					if exiled then
						message(&quot;pm &quot; .. k .. &quot; Chinese player &quot; .. players[steam].name .. &quot; detected and sent to exile.[-]&quot;)
					else
						message(&quot;pm &quot; .. k .. &quot; Chinese player &quot; .. players[steam].name .. &quot; detected.[-]&quot;)
					end
				end
			end

			conn:execute(&quot;UPDATE players SET country = '&quot; .. escape(country) .. &quot;', exiled = 1, ircTranslate = 1 WHERE steam = &quot; .. steam)
			conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event,steam) VALUES (&quot; .. math.floor(players[steam].xPos) .. &quot;,&quot; .. math.ceil(players[steam].yPos) .. &quot;,&quot; .. math.floor(players[steam].zPos) .. &quot;,'&quot; .. serverTime .. &quot;','info','Chinese player joined. Name: &quot; .. escape(player) .. &quot; SteamID: &quot; .. steam .. &quot; IP: &quot; .. players[steam].IP  .. &quot;',&quot; .. steam .. &quot;)&quot;)	
			file:close()

			-- got country so stop processing the dns record
			break
		end
	end

	if proxy then
		os.rename(homedir .. &quot;/dns/&quot; .. steam .. &quot;_old.txt&quot;, homedir .. &quot;/proxies/&quot; .. steam .. &quot;_&quot; .. country .. &quot;.txt&quot;)
		os.rename(homedir .. &quot;/dns/&quot; .. steam .. &quot;.txt&quot;, homedir .. &quot;/proxies/&quot; .. steam .. &quot;_&quot; .. country .. &quot;.txt&quot;)
	else
		os.rename(homedir .. &quot;/dns/&quot; .. steam .. &quot;.txt&quot;, homedir .. &quot;/dns/&quot; .. steam .. &quot;_old.txt&quot;)
	end

	conn:execute(&quot;UPDATE players SET country = '&quot; .. country .. &quot;' WHERE steam = &quot; .. steam)

	file:close()

	if not proxy then
		os.rename(homedir .. &quot;/dns/&quot; .. steam .. &quot;.txt&quot;, homedir .. &quot;/dns/&quot; .. steam .. &quot;_old.txt&quot;)
	end
end


function initNewPlayer(steam, player, entityid, steamOwner)
	conn:execute(&quot;INSERT INTO players (steam, id, name, steamOwner) VALUES (&quot; .. steam .. &quot;,&quot; .. entityid .. &quot;,'&quot; .. escape(player) .. &quot;',&quot; .. steamOwner .. &quot;)&quot;)

	players[steam] = {}
	players[steam].id = entityid
	players[steam].name = player
	players[steam].names = player .. &quot;,&quot;
	players[steam].steam = steam
	players[steam].steamOwner = steamOwner
	players[steam].xPos = 0
	players[steam].yPos = 0
	players[steam].zPos = 0
	players[steam].xPosOld = 0
	players[steam].yPosOld = 0
	players[steam].zPosOld = 0
	players[steam].xPosOld2 = 0
	players[steam].yPosOld2 = 0
	players[steam].zPosOld2 = 0
	players[steam].homeX = 0
	players[steam].homeY = 0
	players[steam].homeZ = 0
	players[steam].home2X = 0
	players[steam].home2Y = 0
	players[steam].home2Z = 0
	players[steam].gimmeCount = 0
	players[steam].baseCooldown = 0
	players[steam].teleCooldown = 0
	players[steam].walkies = false
	players[steam].silentBob = false
	players[steam].donor = false
	players[steam].donorLevel = 0
	players[steam].donorExpiry = os.time()
	players[steam].protect = false
	players[steam].protectSize = server.baseSize
	players[steam].protect2 = false
	players[steam].protect2Size = server.baseSize
	players[steam].firstSeen = os.time()
	players[steam].timeOnServer = 0
	players[steam].alertPrison = true
	players[steam].alertPVP = true
	players[steam].alertReset = true
	players[steam].alertMapLimit = false
	players[steam].timeout = false
	players[steam].newPlayer = true
	players[steam].watchPlayer = true
	players[steam].sessionCount = 1
	players[steam].lastBaseRaid = 0
	players[steam].raiding = false
	players[steam].botTimeout = false
	players[steam].playtime = 0
	players[steam].cash = 0
	players[steam].overstack = false
	players[steam].overstackScore = 0
	players[steam].overstackTimeout = false
	players[steam].overstackItems = &quot;&quot;
	players[steam].removeClaims = false
	players[steam].tokens = 0
	players[steam].prisoner = false
	players[steam].whitelisted = false
	players[steam].permanentBan = false
	players[steam].prisonxPosOld = 0
	players[steam].prisonyPosOld = 0
	players[steam].prisonzPosOld = 0
	players[steam].prisonReason = &quot;&quot;
	players[steam].pvpVictim = 0
	players[steam].country = &quot;&quot;
	players[steam].ping = 0
	players[steam].lastLogout = os.time()
	players[steam].relogCount = 0
	players[steam].atHome = false
	players[steam].location = &quot;lobby&quot;
	players[steam].autoFriend = &quot;&quot;
	players[steam].hackerScore = 0
	players[steam].tp = 0
	players[steam].bedX = 0
	players[steam].bedY = 0
	players[steam].bedZ = 0
	players[steam].packCooldown = 0
	players[steam].ircPass = &quot;&quot;
	return true
end


function initNewIGPlayer(steam, player, entityid, steamOwner)
	igplayers[steam] = {}
	igplayers[steam].id = entityid
	igplayers[steam].name = player
	igplayers[steam].steam = steam
	igplayers[steam].steamOwner = steamOwner
	igplayers[steam].greet = true
	igplayers[steam].connected = true
	igplayers[steam].greetdelay = 4
	igplayers[steam].xPos = 0
	igplayers[steam].yPos = 0
	igplayers[steam].zPos = 0
	igplayers[steam].xPosLast = 0
	igplayers[steam].yPosLast = 0
	igplayers[steam].zPosLast = 0
	igplayers[steam].xPosLastOK = 0
	igplayers[steam].yPosLastOK = 0
	igplayers[steam].zPosLastOK = 0
	igplayers[steam].firstSeen = os.time()
	igplayers[steam].sessionStart = os.time()
	igplayers[steam].sessionPlaytime = 0
	igplayers[steam].timeOnServer = 0
	igplayers[steam].lastHotspot = 0
	igplayers[steam].inventory = &quot;&quot;
	igplayers[steam].inventoryLast = &quot;&quot;
	igplayers[steam].illegalInventory = false
	igplayers[steam].botQuestion = &quot;&quot; -- used for storing the last question the bot asked the player.
	igplayers[steam].killTimer = 0
	igplayers[steam].xPosLastAlert = 0
	igplayers[steam].yPosLastAlert = 0
	igplayers[steam].zPosLastAlert = 0
	igplayers[steam].ping = 0
	igplayers[steam].highPingCount = 0
	igplayers[steam].afk = os.time() + 180
	igplayers[steam].checkNewPlayer = true
	igplayers[steam].lastLP = os.time()
	return true
end


function fixMissingStuff()
	lfs.mkdir(homedir .. &quot;/daily&quot;)
	lfs.mkdir(homedir .. &quot;/dns&quot;)
	lfs.mkdir(homedir .. &quot;/proxies&quot;)
	lfs.mkdir(homedir .. &quot;/temp&quot;)
	lfs.mkdir(homedir .. &quot;/scripts&quot;)

	if not isFile(homedir .. &quot;/scripts/gmsg_custom.lua&quot;) then
		file = io.open(homedir .. &quot;/scripts/gmsg_custom.lua&quot;, &quot;a&quot;)
		file:write(&quot;function gmsg_custom()\n&quot;)
		file:write(&quot;	calledFunction = \&quot;gmsg_custom\&quot;\n&quot;)
		file:write(&quot;	\-\- ###################  do not allow remote commands beyond this point ################\n&quot;)
		file:write(&quot;	if (chatvars.playerid == nil) then\n&quot;)
		file:write(&quot;		faultyChat = false\n&quot;)
		file:write(&quot;		return false\n&quot;)
		file:write(&quot;	end\n&quot;)
		file:write(&quot;	\-\- ####################################################################################\n&quot;)
		file:write(&quot;	if (chatvars.words[1] == \&quot;test\&quot; and chatvars.words[2] == \&quot;command\&quot;) then\n&quot;)
		file:write(&quot;		message(\&quot;pm \&quot; .. chatvars.playerid .. \&quot; [\&quot; .. server.chatColour .. \&quot;]This is a sample command in gmsg_custom.lua in the scripts folder.[-]\&quot;)\n&quot;)
		file:write(&quot;		faultyChat = false\n&quot;)
		file:write(&quot;		return true\n&quot;)
		file:write(&quot;	end\n&quot;)
		file:write(&quot;end\n&quot;)
		file:close()
	end
end


function playerDisconnected(steam)
	-- this function has been moved from the player disconnected trigger so we can call it in a bot shutting down command to ensure
	-- all player data is saved to the database.

	fixMissingPlayer(steam)

	-- update players table with x y z
	players[steam].lastAtHome = nil
	players[steam].protectPaused = nil
	players[steam].protect2Paused = nil

	if igplayers[steam] then
		-- only process the igplayer record if the player is actually online otherwise assume these are already done
		players[steam].xPos = igplayers[steam].xPos
		players[steam].yPos = igplayers[steam].yPos
		players[steam].zPos = igplayers[steam].zPos
		players[steam].playerKills = igplayers[steam].playerKills
		players[steam].deaths = igplayers[steam].deaths
		players[steam].zombies = igplayers[steam].zombies
		players[steam].score = igplayers[steam].score
		players[steam].ping = igplayers[steam].ping
		players[steam].timeOnServer = players[steam].timeOnServer + igplayers[steam].sessionPlaytime

		if (igplayers[steam].sessionPlaytime) &gt; 300 then
			players[steam].relogCount = 0
		end

		if (igplayers[steam].sessionPlaytime) &lt; 60 then
			if not players[steam].timeout and not players[steam].botTimeout and not players[steam].prisoner then
				players[steam].relogCount = tonumber(players[steam].relogCount) + 1
			end
		else
			players[steam].relogCount = tonumber(players[steam].relogCount) - 1
			if tonumber(players[steam].relogCount) &lt; 0 then players[steam].relogCount = 0 end
		end

		players[steam].lastLogout = os.time()
		players[steam].seen = serverTime
	end

	if accessLevel(steam) &lt; 3 then
		conn:execute(&quot;DELETE FROM memTracker WHERE admin = &quot; .. steam)
	end

	conn:execute(&quot;DELETE FROM messageQueue WHERE recipient = &quot; .. steam)
	conn:execute(&quot;DELETE FROM gimmeQueue WHERE steam = &quot; .. steam)
	conn:execute(&quot;DELETE FROM commandQueue WHERE steam = &quot; .. steam)
	conn:execute(&quot;DELETE FROM playerQueue WHERE steam = &quot; .. steam)

	-- delete player from igplayers table
	igplayers[steam] = nil
	lastHotspots[steam] = nil
	invTemp[steam] = nil

	-- update the player record in the database
	updatePlayer(steam)

	if	db2Connected then
		-- insert or update player in bots db
		connBots:execute(&quot;INSERT INTO players (server, steam, ip, name, online) VALUES ('&quot; .. escape(server.ServerName) .. &quot;',&quot; .. steam .. &quot;,'&quot; .. players[steam].IP .. &quot;','&quot; .. escape(players[steam].name) .. &quot;',0) ON DUPLICATE KEY UPDATE ip = '&quot; .. players[steam].IP .. &quot;', name = '&quot; .. escape(players[steam].name) .. &quot;', online = 0&quot;)		
	end
end


function shutdownBot()
	botDisabled = true

	for k,v in pairs(igplayers) do
		playerDisconnected(k)
	end

	message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. server.botName .. &quot; is now offline.[-]&quot;)
	sendIrc(server.ircMain, server.botName .. &quot; is now offline.[-]&quot;)	
	closeDB()
end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>irc code</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function irc_QueueMsg(name, msg)
	-- Don't allow the bot to command itself
	if name == server.botName then
		return
	end

	conn:execute(&quot;INSERT INTO ircQueue (name, command) VALUES ('&quot; .. name .. &quot;','&quot; .. escape(msg) .. &quot;')&quot;)
end


function irc_NewInventory(steam, trackerID)
	local tbl, slot, rows, i

	if trackerID ~= nil then
		cursor,errorString = conn:execute(&quot;SELECT * FROM inventoryTracker WHERE steam = &quot; .. steam ..&quot; AND inventoryTrackerID = &quot; .. trackerID)
	else
		cursor,errorString = conn:execute(&quot;SELECT * FROM inventoryTracker WHERE steam = &quot; .. steam ..&quot; ORDER BY inventoryTrackerid DESC Limit 1&quot;)
	end

	row = cursor:fetch({}, &quot;a&quot;)
	if row then
		irc_QueueMsg(irc_params[1], &quot;&quot;)
		irc_QueueMsg(irc_params[1], &quot;Belt of &quot; .. irc_params[3])
		irc_QueueMsg(irc_params[1], &quot;&quot;)

		tbl = string.split(row.belt, &quot;|&quot;)
		for i=1, table.maxn(tbl) - 1, 1 do
			slot = string.split(tbl[i], &quot;,&quot;)
			if tonumber(slot[4]) &gt; 0 then
				irc_QueueMsg(irc_params[1], &quot;Slot &quot; .. slot[1] .. &quot; qty &quot; .. slot[2] .. &quot; &quot; .. slot[3] .. &quot; &quot; .. slot[4])
			else
				irc_QueueMsg(irc_params[1], &quot;Slot &quot; .. slot[1] .. &quot; qty &quot; .. slot[2] .. &quot; &quot; .. slot[3])
			end
		end

		irc_QueueMsg(irc_params[1], &quot;&quot;)
		irc_QueueMsg(irc_params[1], &quot;Backpack of &quot; .. irc_params[3])
		irc_QueueMsg(irc_params[1], &quot;&quot;)

		tbl = string.split(row.pack, &quot;|&quot;)
		for i=1, table.maxn(tbl) - 1, 1 do
			slot = string.split(tbl[i], &quot;,&quot;)
			if tonumber(slot[4]) &gt; 0 then
				irc_QueueMsg(irc_params[1], &quot;Slot &quot; .. slot[1] .. &quot; qty &quot; .. slot[2] .. &quot; &quot; .. slot[3] .. &quot; &quot; .. slot[4])
			else
				irc_QueueMsg(irc_params[1], &quot;Slot &quot; .. slot[1] .. &quot; qty &quot; .. slot[2] .. &quot; &quot; .. slot[3])
			end
		end

		irc_QueueMsg(irc_params[1], &quot;&quot;)
		irc_QueueMsg(irc_params[1], &quot;Equipment of &quot; .. irc_params[3])
		irc_QueueMsg(irc_params[1], &quot;&quot;)

		tbl = string.split(row.equipment, &quot;|&quot;)
		for i=1, table.maxn(tbl) - 1, 1 do
			slot = string.split(tbl[i], &quot;,&quot;)
			irc_QueueMsg(irc_params[1], &quot;Slot &quot; .. slot[1] .. &quot; qty &quot; .. slot[2] .. &quot; &quot; .. slot[3])
		end
	else
		irc_QueueMsg(irc_params[1], &quot;&quot;)
		irc_QueueMsg(irc_params[1], &quot;I do not have an inventory recorded for &quot; .. players[steam].name)
	end

	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_Request_Inventory()
	irc_NewInventory(irc_params[2])
end


function irc_message()
	irc_QueueMsg(irc_params[1], irc_params[2])
end


function irc_ListTables()
	irc_QueueMsg(irc_params[1], &quot;These are the bot tables that you can view and edit:&quot;)
	irc_QueueMsg(irc_params[1], &quot;server&quot;)
	irc_QueueMsg(irc_params[1], &quot;rollingMessages&quot;)
	irc_QueueMsg(irc_params[1], &quot;whitelist&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_List_Villages()
	local id

	irc_QueueMsg(irc_params[1], &quot;List of villages on the server:&quot;)
	for k, v in pairs(locations) do
		if v.village == true then
			id = LookupOfflinePlayer(v.mayor)
			if id ~= nil then
				irc_QueueMsg(irc_params[1], v.name .. &quot; the Mayor is &quot; .. players[id].name)
			else
				irc_QueueMsg(irc_params[1], v.name)
			end
		end
	end

	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_List_Villagers()
	local text

	irc_QueueMsg(irc_params[1], &quot;The following players are villagers:&quot;)
	for k, v in pairs(villagers) do
		text = v.village .. &quot; &quot; .. players[k].name

		if locations[v.village].mayor == k then
			text = text .. &quot; (the mayor of &quot; .. v.village .. &quot;)&quot;
		end

		irc_QueueMsg(irc_params[1], text)
	end

	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_ListBases(steam)
	local prot1
	local prot2
	local msg

	if steam ~= nil then
		cursor,errorString = conn:execute(&quot;SELECT steam, name, homeX, homeY, homeZ, home2X, home2Y, home2Z, protect, protect2, protectSize, protect2Size from players where steam = &quot; .. steam .. &quot; order by name&quot;)
	else
		cursor,errorString = conn:execute(&quot;SELECT steam, name, homeX, homeY, homeZ, home2X, home2Y, home2Z, protect, protect2, protectSize, protect2Size from players order by name&quot;)
	end

	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		prot1 = &quot;OFF&quot;
		prot2 = &quot;OFF&quot;

		if row.protect == true then prot1 = &quot;ON&quot; end
		if row.protect2 == true then prot2 = &quot;ON&quot; end
		msg = row.steam .. &quot; &quot; .. row.name .. &quot; &quot;

		if tonumber(row.homeX) == 0 and tonumber(row.homeY) == 0 and tonumber(row.homeZ) == 0 and tonumber(row.home2X) == 0 and tonumber(row.home2Y) == 0 and tonumber(row.home2Z) == 0 then
			if steam ~= nil then
				msg = msg .. &quot;has no base set&quot;
			else
				msg = nil
			end
		else
			msg = msg .. row.homeX .. &quot; &quot; .. row.homeY .. &quot; &quot; .. row.homeZ .. &quot; &quot; .. prot1 .. &quot; (&quot; .. row.protectSize .. &quot;) &quot;
			msg = msg .. row.home2X .. &quot; &quot; .. row.home2Y .. &quot; &quot; .. row.home2Z .. &quot; &quot; .. prot2 .. &quot; (&quot; .. row.protect2Size .. &quot;) &quot;
		end

		if irc_params[2] == &quot;protected&quot; and (row.protect == true or row.protect2 == true) then
			if msg ~= nil then
				irc_QueueMsg(irc_params[1], msg)
			end
		end

		if irc_params[2] ~= &quot;protected&quot; then	
			if msg ~= nil then
				irc_QueueMsg(irc_params[1], msg)
			end
		end

		row = cursor:fetch(row, &quot;a&quot;)	
	end

	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_PlayersNearPlayer(name, name1, range, xPos, zPos, offline)
	local alone, dist, number, flag

	alone = true

	if offline == false then
		if name1 ~= &quot;&quot; then
			irc_QueueMsg(name, &quot;Players within &quot; .. range .. &quot; meters of &quot; .. players[name1].name .. &quot; are:&quot;) 	
		else
			irc_QueueMsg(name, &quot;Players within &quot; .. range .. &quot; meters of x &quot; .. xPos .. &quot; z &quot; .. zPos .. &quot; are:&quot;) 	
		end

		for k, v in pairs(igplayers) do
			if k ~= name1 then
				if name1 ~= &quot;&quot; then
					dist = distancexz(players[name1].xPos, players[name1].zPos, v.xPos, v.zPos)
				else
					dist = distancexz(xPos, zPos, v.xPos, v.zPos)
				end

				if dist &lt;= range then
					irc_QueueMsg(name, v.name .. &quot; distance: &quot; .. string.format(&quot;%-4.2d&quot;, dist) .. &quot; meters&quot;)
					alone = false
				end
			end
		end
	else
		if name1 ~= &quot;&quot; then
			irc_QueueMsg(name, &quot;Players within &quot; .. range .. &quot; meters of &quot; .. players[name1].name .. &quot; including offline are:&quot;) 	
		else
			irc_QueueMsg(name, &quot;Players within &quot; .. range .. &quot; meters of x &quot; .. xPos .. &quot; z &quot; .. zPos .. &quot; including offline are:&quot;) 	
		end

		for k, v in pairs(players) do
			if k ~= name1 then
				if name1 ~= &quot;&quot; then
					dist = distancexz(players[name1].xPos, players[name1].zPos, v.xPos, v.zPos)
				else
					dist = distancexz(xPos, zPos, v.xPos, v.zPos)
				end

				if dist &lt;= range then
					if igplayers[k] then 
						flag = &quot; PLAYING&quot;
					else
						flag = &quot; OFFLINE&quot;
					end

					irc_QueueMsg(name, v.name .. &quot; distance: &quot; .. string.format(&quot;%-4.2d&quot;, dist) .. &quot; meters&quot; .. flag)
					alone = false
				end
			end
		end
	end

	if (alone == true) then
		if name1 ~= &quot;&quot; then
			irc_QueueMsg(name, &quot;There is nobody within &quot; .. range .. &quot; meters of &quot; .. players[name1].name)
		else
			irc_QueueMsg(name, &quot;There is nobody within &quot; .. range .. &quot; meters of x &quot; .. xPos .. &quot; z &quot; .. zPos)
		end
	end

	irc_QueueMsg(name, &quot;&quot;)
end


function irc_BasesNearPlayer(name, name1, range, xPos, zPos)
	local alone, dist, protected

	alone = true

	irc_QueueMsg(name, &quot;Bases within &quot; .. range .. &quot; meters of &quot; .. players[name1].name .. &quot; are:&quot;) 	

	for k, v in pairs(players) do
		if (v.homeX ~= 0 and v.homeZ ~= 0) then
			if name1 ~= &quot;&quot; then
				dist = distancexz(players[name1].xPos, players[name1].zPos, v.homeX, v.homeZ)
			else
				dist = distancexz(xPos, zPos, v.homeX, v.homeZ)			
			end

			if dist &lt;= range then
				if players[k].protect == true then
					protected = &quot; bot protected&quot;
				else
					protected = &quot; unprotected&quot;
				end

				irc_QueueMsg(name, v.name .. &quot; distance: &quot; .. string.format(&quot;%-.2d&quot;, dist) .. &quot; meters&quot; .. protected)
				alone = false
			end
		end
		
		if (v.home2X ~= 0 and v.home2Z ~= 0) then
			if name1 ~= &quot;&quot; then		
				dist = distancexz(players[name1].xPos, players[name1].zPos, v.home2X, v.home2Z)
			else
				dist = distancexz(xPos, zPos, v.home2X, v.home2Z)			
			end

			if dist &lt;= range then
				if players[k].protect2 == true then
					protected = &quot; bot protected&quot;
				else
					protected = &quot; unprotected&quot;
				end

				irc_QueueMsg(name, v.name .. &quot; (base 2) distance: &quot; .. string.format(&quot;%-.2d&quot;, dist) .. &quot; meters&quot; .. protected)
				alone = false
			end
		end		
	end

	if (alone == true) then
		irc_QueueMsg(name, &quot;There are none within &quot; .. range .. &quot; meters of &quot; .. players[name1].name)
	end

	irc_QueueMsg(name, &quot;&quot;)
end


function irc_LocationsNearPlayer(name, name1, range, xPos, zPos)
	local alone, dist

	alone = true

	irc_QueueMsg(name, &quot;Locations within &quot; .. range .. &quot; meters of &quot; .. players[name1].name .. &quot; are:&quot;) 	

	for k, v in pairs(locations) do
		if name1 ~= &quot;&quot; then
			dist = distancexz(players[name1].xPos, players[name1].zPos, v.x, v.z)
		else
			dist = distancexz(xPos, zPos, v.x, v.z)			
		end

		if dist &lt;= range then
			irc_QueueMsg(name, v.name .. &quot; distance: &quot; .. string.format(&quot;%-.2d&quot;, dist) .. &quot; meters&quot;)
			alone = false
		end
	end

	if (alone == true) then
		irc_QueueMsg(name, &quot;There are none within &quot; .. range .. &quot; meters of &quot; .. players[name1].name)
	end

	irc_QueueMsg(name, &quot;&quot;)
end


function irc_PlayerShortInfo()
	local time
	local days
	local hours
	local minutes

	if (igplayers[irc_params[2]]) then
		time = tonumber(players[irc_params[2]].timeOnServer) + tonumber(igplayers[irc_params[2]].sessionPlaytime)
	else
		time = tonumber(players[irc_params[2]].timeOnServer)
	end

	days = math.floor(time / 86400)

	if (days &gt; 0) then
		time = time - (days * 86400)
	end

	hours = math.floor(time / 3600)

	if (hours &gt; 0) then
		time = time - (hours * 3600)
	end

	minutes = math.floor(time / 60)
	time = time - (minutes * 60)

	irc_QueueMsg(irc_params[1], &quot;Info for player &quot; .. irc_params[3])
	if players[irc_params[2]].newPlayer == true then irc_QueueMsg(irc_params[1], &quot;A new player&quot;) end
	irc_QueueMsg(irc_params[1], &quot;SteamID &quot; .. players[irc_params[2]].steam)
	irc_QueueMsg(irc_params[1], &quot;Steam Rep http://steamrep.com/search?q=&quot; .. players[irc_params[2]].steam)
	irc_QueueMsg(irc_params[1], &quot;Player ID &quot; .. players[irc_params[2]].id)
	if players[irc_params[2]].firstSeen ~= nil then irc_QueueMsg(irc_params[1], &quot;First seen: &quot; .. os.date(&quot;%Y-%m-%d %H:%M:%S&quot;, players[irc_params[2]].firstSeen) ) end
	irc_QueueMsg(irc_params[1], seen(irc_params[2]))
	irc_QueueMsg(irc_params[1], &quot;Total time played: &quot; .. days .. &quot; days &quot; .. hours .. &quot; hours &quot; .. minutes .. &quot; minutes &quot; .. time .. &quot; seconds&quot;)
	if players[irc_params[2]].names ~= nil then irc_QueueMsg(irc_params[1], &quot;Has played as &quot; .. players[irc_params[2]].names) end
	if players[irc_params[2]].timeout == true then irc_QueueMsg(irc_params[1], &quot;Is in timeout&quot;) end
	if players[irc_params[2]].prisoner then 
		irc_QueueMsg(irc_params[1], &quot;Is a prisoner&quot;) 
		if players[irc_params[2]].prisonReason ~= nil then irc_QueueMsg(irc_params[1], &quot;Reason Arrested: &quot; .. players[irc_params[2]].prisonReason) end
	end
	irc_QueueMsg(irc_params[1], &quot;Keystones placed &quot; .. players[irc_params[2]].keystones)
	irc_QueueMsg(irc_params[1], &quot;Zombies &quot; .. players[irc_params[2]].zombies)
	irc_QueueMsg(irc_params[1], &quot;Score &quot; .. players[irc_params[2]].score)
	irc_QueueMsg(irc_params[1], &quot;Deaths &quot; .. players[irc_params[2]].deaths)
	irc_QueueMsg(irc_params[1], &quot;Current Session &quot; .. players[irc_params[2]].sessionCount)
	irc_QueueMsg(irc_params[1], &quot;IP http://who.is/whois-ip/ip-address/&quot; .. players[irc_params[2]].IP)
	irc_QueueMsg(irc_params[1], &quot;Ping &quot; .. players[irc_params[2]].ping .. &quot; Country: &quot; .. players[irc_params[2]].country)

	if players[irc_params[2]].china then
		irc_QueueMsg(irc_params[1], &quot;China IP detected&quot;)
	end

	if players[irc_params[2]].exiled == 1 then
		irc_QueueMsg(irc_params[1], &quot;Is exiled&quot;)
	else
		irc_QueueMsg(irc_params[1], &quot;Not exiled&quot;)
	end

	if players[irc_params[2]].inLocation ~= &quot;&quot; then
		irc_QueueMsg(irc_params[1], &quot;In location &quot; .. players[irc_params[2]].inLocation)
	else
		irc_QueueMsg(irc_params[1], &quot;Not in a named location&quot;)
	end

	irc_QueueMsg(irc_params[1], &quot;Current position &quot; .. math.floor(players[irc_params[2]].xPos) .. &quot; &quot; .. math.ceil(players[irc_params[2]].yPos) .. &quot; &quot; .. math.floor(players[irc_params[2]].zPos))

	if players[irc_params[2]].donor then
		irc_QueueMsg(irc_params[1], &quot;Is a donor&quot;)
	else
		irc_QueueMsg(irc_params[1], &quot;Not a donor&quot;)
	end

	cursor,errorString = conn:execute(&quot;SELECT * FROM bans WHERE steam =  &quot; .. irc_params[2])
	if cursor:numrows() &gt; 0 then
		row = cursor:fetch({}, &quot;a&quot;)
		irc_QueueMsg(irc_params[1], &quot;BANNED until &quot; .. row.BannedTo .. &quot; &quot; .. row.Reason)
	end

	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_List_Owners()
	irc_QueueMsg(irc_params[1], &quot;The server owners are..&quot;)
	for k, v in pairs(owners) do
		irc_QueueMsg(irc_params[1], players[k].name)
	end

	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_List_Admins()
	irc_QueueMsg(irc_params[1], &quot;The server admins are..&quot;)
	for k, v in pairs(admins) do
		irc_QueueMsg(irc_params[1], players[k].name)
	end

	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_List_Mods()
	irc_QueueMsg(irc_params[1], &quot;The server mods are..&quot;)
	for k, v in pairs(mods) do
		irc_QueueMsg(irc_params[1], players[k].name)
	end

	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_friend()
	-- add to friends table
	if (friends[irc_params[2]] == nil) then
		friends[irc_params[2]] = {}
		friends[irc_params[2]].friends = &quot;&quot;
	end

	if (not string.find(friends[irc_params[2]].friends, irc_params[3])) then
		friends[irc_params[2]].friends = friends[irc_params[2]].friends .. irc_params[3] .. &quot;,&quot;
		irc_QueueMsg(irc_params[1], players[irc_params[2]].name .. &quot; is now friends with &quot; .. players[irc_params[3]].name) 
	else
		irc_QueueMsg(irc_params[1], players[irc_params[2]].name .. &quot; is already friends with &quot; .. players[irc_params[3]].name) 
	end

	conn:execute(&quot;INSERT INTO friends (steam, friend) VALUES (&quot; .. irc_params[3] .. &quot;,&quot; .. irc_params[2] .. &quot;)&quot;)

	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_unfriend()
	local friendlist

	-- add to friends table
	if (friends[irc_params[2]] == nil) then
		friends[irc_params[2]] = {}
		friends[irc_params[2]].friends = &quot;&quot;
	end

	friendlist = string.split(friends[irc_params[2]].friends, &quot;,&quot;)

	-- now simply rebuild friend skipping over the one we are removing
	friends[irc_params[2]].friends = &quot;&quot;
	for i=1,table.maxn(friendlist) - 1,1 do
		if (friendlist[i] ~= irc_params[3]) then
			friends[irc_params[2]].friends = friends[irc_params[2]].friends .. friendlist[i] .. &quot;,&quot;
		end
	end
	
	irc_QueueMsg(irc_params[1], players[irc_params[2]].name .. &quot; is no longer friends with &quot; .. players[irc_params[3]].name) 

	conn:execute(&quot;DELETE FROM friends WHERE steam = &quot; .. irc_params[3] .. &quot; AND friend = &quot; .. irc_params[2])	

	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_friends()
	local friendlist

	friendlist = string.split(friends[irc_params[2]].friends, &quot;,&quot;)

	irc_QueueMsg(irc_params[1], irc_params[3] .. &quot; is friends with..&quot;)
	for i=1,table.maxn(friendlist)-1,1 do
		if (friendlist[i] ~= &quot;&quot;) then
			id = LookupPlayer(friendlist[i])
			irc_QueueMsg(irc_params[1], players[id].name)
		end
	end	

	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_new_players(name)
	local id
	local x
	local z

	id = LookupOfflinePlayer(name, &quot;all&quot;)

	irc_QueueMsg(name, &quot;New players in the last 2 days:&quot;)

	for k, v in pairs(players) do
		if v.firstSeen ~= nil then
			if ((os.time() - tonumber(v.firstSeen)) &lt; 86401) then
				if accessLevel(id) &gt; 3 then
					irc_QueueMsg(name, v.name) 
				else
					irc_QueueMsg(name, &quot;steam: &quot; .. k .. &quot; id: &quot; .. string.format(&quot;%8d&quot;, v.id) .. &quot; name: &quot; .. v.name .. &quot; at &quot; .. math.floor(v.xPos) .. &quot; &quot; .. math.ceil(v.yPos) .. &quot; &quot; .. math.floor(v.zPos))
				end					
			end
		end
	end
	
	irc_QueueMsg(name, &quot;&quot;)
end


function irc_server_status(name, days)
	irc_QueueMsg(name, &quot;The server date is &quot; .. serverTime)

	if days == nil then
		irc_QueueMsg(name, &quot;24 hour stats to now:&quot;)
		days = 1
	else
		irc_QueueMsg(name, &quot;Last &quot; .. days .. &quot; days stats to now:&quot;)
	end

	cursor,errorString = conn:execute(&quot;SELECT COUNT(id) as number FROM events WHERE type LIKE '%pvp%' AND timestamp &gt; DATE_SUB(now(), INTERVAL &quot;.. days .. &quot; DAY)&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	irc_QueueMsg(name, &quot;PVPs: &quot; .. row.number)

	cursor,errorString = conn:execute(&quot;SELECT COUNT(id) as number FROM events WHERE type LIKE '%timeout%' AND timestamp &gt; DATE_SUB(now(), INTERVAL &quot;.. days .. &quot; DAY)&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	irc_QueueMsg(name, &quot;Timeouts: &quot; .. row.number)

	cursor,errorString = conn:execute(&quot;SELECT COUNT(id) as number FROM events WHERE type LIKE '%arrest%' AND timestamp &gt; DATE_SUB(now(), INTERVAL &quot;.. days .. &quot; DAY)&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	irc_QueueMsg(name, &quot;Arrests: &quot; .. row.number)

	cursor,errorString = conn:execute(&quot;SELECT COUNT(id) as number FROM events WHERE type LIKE '%new%' AND timestamp &gt; DATE_SUB(now(), INTERVAL &quot;.. days .. &quot; DAY)&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	irc_QueueMsg(name, &quot;New players: &quot; .. row.number)

	cursor,errorString = conn:execute(&quot;SELECT COUNT(id) as number FROM events WHERE type LIKE '%ban%' AND timestamp &gt; DATE_SUB(now(), INTERVAL &quot;.. days .. &quot; DAY)&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	irc_QueueMsg(name, &quot;Bans: &quot; .. row.number)

	cursor,errorString = conn:execute(&quot;SELECT MAX(players) as number FROM performance WHERE timestamp &gt; DATE_SUB(now(), INTERVAL &quot;.. days .. &quot; DAY)&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	irc_QueueMsg(name, &quot;Most players online: &quot; .. row.number)
	irc_QueueMsg(name, &quot;&quot;)
end


function irc_server_event(name)
	local event, days, steam
	event = irc_params[2]
	days = irc_params[3]
	steam = irc_params[4]

	if days == '' then
		irc_QueueMsg(name, event .. &quot;s in the last 24 hours:&quot;)
		days = 1
	else
		irc_QueueMsg(name, event .. &quot;s in the last &quot; .. days .. &quot; days:&quot;)
	end

	if steam ~= &quot;&quot; then
		cursor,errorString = conn:execute(&quot;SELECT * FROM events WHERE steam = &quot; .. steam .. &quot; AND type LIKE '%&quot; .. event .. &quot;%' AND timestamp &gt; DATE_SUB(now(), INTERVAL &quot;.. days .. &quot; DAY)&quot;)
	else
		cursor,errorString = conn:execute(&quot;SELECT * FROM events WHERE type LIKE '%&quot; .. event .. &quot;%' AND timestamp &gt; DATE_SUB(now(), INTERVAL &quot;.. days .. &quot; DAY)&quot;)
	end

	row = cursor:fetch({}, &quot;a&quot;)

	while row do
		irc_QueueMsg(name, row.serverTime .. &quot; &quot; .. row.event .. &quot; at &quot; .. row.x .. &quot; &quot; .. row.y .. &quot; &quot; .. row.z)
		row = cursor:fetch(row, &quot;a&quot;)
	end

	irc_QueueMsg(name, &quot;&quot;)
end


function irc_players(name)
	local id
	local x
	local z
	local flags

	id = LookupPlayer(name, &quot;all&quot;)

	irc_QueueMsg(name, &quot;The following users are in-game right now:&quot;)

	for k, v in pairs(igplayers) do
		x = math.floor(v.xPos / 512)
		z = math.floor(v.zPos / 512)

		flags = &quot; &quot;
		if players[k].newPlayer == true then flags = flags .. &quot;[NEW]&quot; end
		if players[k].timeout == true then flags = flags .. &quot;[TIMEOUT]&quot; end

		if (accessLevel(id) &gt; 3) then
			irc_QueueMsg(name, v.name .. &quot; score: &quot; .. string.format(&quot;%-6d&quot;, v.score) .. &quot; PVP: &quot; .. string.format(&quot;%-2d&quot;, v.playerKills) .. &quot; zeds: &quot; .. string.format(&quot;%-6d&quot;, v.zombies) .. &quot; &quot; .. flags)
		else
			if players[id].ircAuthenticated == true then
				irc_QueueMsg(name, &quot;steam: &quot; .. k .. &quot; id: &quot; .. string.format(&quot;%-7d&quot;, v.id) .. &quot; score: &quot; .. string.format(&quot;%-6d&quot;, v.score) .. &quot; PVP: &quot; .. string.format(&quot;%-2d&quot;, v.playerKills) .. &quot; zeds: &quot; .. string.format(&quot;%-6d&quot;, v.zombies) .. &quot; region r.&quot; .. x .. &quot;.&quot; .. z .. &quot;.7rg   name: &quot; .. v.name  .. flags .. &quot; [ &quot; .. math.floor(v.xPos) .. &quot; &quot; .. math.ceil(v.yPos) .. &quot; &quot; .. math.floor(v.zPos) .. &quot; ] &quot; .. players[k].country .. &quot; &quot; .. v.ping)
			else
				irc_QueueMsg(name, v.name .. &quot; score: &quot; .. string.format(&quot;%-6d&quot;, v.score) .. &quot; PVP: &quot; .. string.format(&quot;%-2d&quot;, v.playerKills) .. &quot; zeds: &quot; .. string.format(&quot;%-6d&quot;, v.zombies) .. &quot; &quot; .. flags)
			end
		end
	end

	irc_QueueMsg(irc_params[1], &quot;There are &quot; .. playersOnline .. &quot; players online.&quot;)
	irc_QueueMsg(name, &quot;&quot;)
end


function irc_listResetZones(name)
   local a = {}
	local n
	local sid
	local pid

	irc_QueueMsg(name, &quot;The following regions are designated reset zones:&quot;)

   for n in pairs(resetRegions) do
		table.insert(a, n)
	end  

	table.sort(a)

   for k, v in ipairs(a) do
		irc_QueueMsg(name, &quot;region: &quot; .. v)
	end

	irc_QueueMsg(name, &quot;&quot;)
end


function irc_gameTime(name)
	irc_QueueMsg(name, &quot;The game date is: &quot; .. gameDate)
end


function irc_uptime(name)
	diff = os.difftime(os.time(), botStarted)
	days = math.floor(diff / 86400)

	if (days &gt; 0) then
		diff = diff - (days * 86400)
	end

	hours = math.floor(diff / 3600)

	if (hours &gt; 0) then
		diff = diff - (hours * 3600)
	end

	minutes = math.floor(diff / 60)

	irc_QueueMsg(name, server.botName .. &quot; has been online &quot; .. days .. &quot; days &quot; .. hours .. &quot; hours &quot; .. minutes ..&quot; minutes&quot;)

	if gameTick &lt; 0 then
		irc_QueueMsg(name, &quot;Server uptime is uncertain&quot;)
	else
		diff = gameTick
		--diff = os.difftime(os.time(), serverStarted)
		days = math.floor(diff / 86400)

		if (days &gt; 0) then
			diff = diff - (days * 86400)
		end

		hours = math.floor(diff / 3600)

		if (hours &gt; 0) then
			diff = diff - (hours * 3600)
		end

		minutes = math.floor(diff / 60)

		irc_QueueMsg(name, &quot;Server uptime is &quot; .. days .. &quot; days &quot; .. hours .. &quot; hours &quot; .. minutes ..&quot; minutes&quot;)
	end
	
	irc_QueueMsg(name, &quot;&quot;)
end


function irc_listAllPlayers(name)
    local a = {}
	local n
	local sid
	local pid

	irc_QueueMsg(name, &quot;These are all the players on record:&quot;)

    for n in pairs(players) do
		table.insert(a, players[n].name)
	end  

	table.sort(a)

    for k, v in ipairs(a) do
		sid = LookupOfflinePlayer(v, &quot;all&quot;)
		pid = players[sid].id

		cmd = &quot;steam: &quot; .. sid .. &quot; id: &quot; .. string.format(&quot;%-8d&quot;, pid) .. &quot; name: &quot; .. v
		irc_QueueMsg(irc_params[1], cmd)
	end

	irc_QueueMsg(name, &quot;&quot;)
end


function irc_IGPlayerInfo()
	if (players[irc_params[2]] ~= nil) then
		irc_QueueMsg(irc_params[1], &quot;In-Game Player record of: &quot; .. players[irc_params[2]].name)
		for k, v in pairs(igplayers[irc_params[2]]) do
			if k ~= &quot;inventory&quot; and k ~= &quot;inventoryLast&quot; then
				cmd = k .. &quot;,&quot; .. tostring(v)
				irc_QueueMsg(irc_params[1], cmd)
			end
		end
	else
		irc_QueueMsg(irc_params[1], &quot;&quot;)
		irc_QueueMsg(irc_params[1], &quot;I do not know a player called &quot; .. irc_params[3])
	end
	
	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_PlayerInfo()
	if (players[irc_params[2]] ~= nil) then
		irc_QueueMsg(irc_params[1], &quot;Player record of: &quot; .. players[irc_params[2]].name)
		for k, v in pairs(players[irc_params[2]]) do
			if k ~= &quot;ircPass&quot; then
				cmd = k .. &quot;,&quot; .. tostring(v)
				irc_QueueMsg(irc_params[1], cmd)
			end
		end
	else
		irc_QueueMsg(irc_params[1], &quot;&quot;)
		irc_QueueMsg(irc_params[1], &quot;I do not know a player called &quot; .. irc_params[3])
	end
	
	irc_QueueMsg(irc_params[1], &quot;&quot;)	
end


function irc_ShowTable()
	irc_QueueMsg(irc_params[1], &quot;The &quot; .. irc_params[2] ..&quot; table: &quot;)

	if string.lower(irc_params[2]) == &quot;server&quot; then
		for k, v in pairs(server) do
			cmd = k .. &quot;,&quot; .. tostring(v)
			irc_QueueMsg(irc_params[1], cmd)
		end
	
		irc_QueueMsg(irc_params[1], &quot;&quot;)	
	end
end


function irc_listDonors(name)
   local a = {}
	local n
	local sid
	local pid

	irc_QueueMsg(name, &quot;These are all the donors on record:&quot;)

   for n in pairs(players) do
		if (players[n].donor == true) then
			table.insert(a, players[n].name)
		end
	end  

	table.sort(a)

   for k, v in ipairs(a) do
		sid = LookupOfflinePlayer(v, &quot;all&quot;)
		pid = players[sid].id

		irc_QueueMsg(name, &quot;steam: &quot; .. sid .. &quot; id: &quot; .. string.format(&quot;%-8d&quot;, pid) .. &quot; name: &quot; .. v)
	end

	irc_QueueMsg(name, &quot;&quot;)
end


function irc_uncraftables(name)
	irc_QueueMsg(name, &quot;I scan for these uncraftable items in inventories:&quot;)

	for k, v in pairs(badItems) do
		irc_QueueMsg(name, k)
	end

	irc_QueueMsg(name, &quot;&quot;)
end


function irc_restricted(name)
	irc_QueueMsg(name, &quot;I scan for these restricted items in inventories:&quot;)

	for k, v in pairs(restrictedItems) do
		irc_QueueMsg(name, k)
	end

	irc_QueueMsg(name, &quot;&quot;)
end


function irc_teleports(name)
	irc_QueueMsg(name, &quot;List of teleports:&quot;)

	for k, v in pairs(teleports) do
		if (v.public == true) then
			public = &quot;public&quot;
		else
			public = &quot;private&quot;
		end

		irc_QueueMsg(name, v.name .. &quot; &quot; .. public)
	end

	irc_QueueMsg(name, &quot;&quot;)
end


function irc_locations(name)
	local id

	id = LookupOfflinePlayer(name, &quot;all&quot;)

	irc_QueueMsg(name, &quot;List of locations:&quot;)

	for k, v in pairs(locations) do
		if (v.public == true) then
			public = &quot;public&quot;
		else
			public = &quot;private&quot;
		end

		if (v.active == true) then
			active = &quot;enabled&quot;
		else
			active = &quot;disabled&quot;
		end

		if not admins[id] and public == &quot;private&quot; then
			irc_QueueMsg(name, v.name .. &quot; &quot; .. public .. &quot; &quot; .. active .. &quot; xyz &quot; .. v.x .. &quot;,&quot; .. v.y .. &quot;,&quot; .. v.z)
		else
			irc_QueueMsg(name, v.name .. &quot; &quot; .. public .. &quot; &quot; .. active .. &quot; xyz &quot; .. v.x .. &quot;,&quot; .. v.y .. &quot;,&quot; .. v.z)
		end
	end

	irc_QueueMsg(name, &quot;&quot;)
end


function irc_prisoners(name)
	irc_QueueMsg(name, &quot;List of prisoners:&quot;)

	-- pm a list of all the prisoners
	if (prisoners == {}) then
		irc_QueueMsg(name, v.name .. &quot;Nobody is in prison&quot;)
		return
	end

	for k, v in pairs(prisoners) do
		irc_QueueMsg(name, k .. &quot; &quot; .. players[k].name)
	end

	irc_QueueMsg(name, &quot;&quot;)
end


function irc_playerStatus()
	local protected
	local base

	if (players[irc_params[2]].protect == true) then
		protected = &quot;protected&quot;
	else
		protected = &quot;not protected (unless you have LCB's down)&quot;
	end
	
	if (players[irc_params[2]].homeX == 0 and players[irc_params[2]].homeY == 0 and players[irc_params[2]].homeZ == 0) then
		base = &quot;Has not done /setbase&quot;	
	else
		base = &quot;Has set a base&quot;
	end
	irc_QueueMsg(irc_params[1], irc_params[3] .. &quot; has &quot; .. players[irc_params[2]].cash .. &quot; zennies&quot;)

	irc_QueueMsg(irc_params[1], &quot;Base status for &quot; .. irc_params[3] .. &quot; is..&quot;)
	irc_QueueMsg(irc_params[1], base)
	irc_QueueMsg(irc_params[1], &quot;The base is &quot; .. protected)
	irc_QueueMsg(irc_params[1], &quot;Protection size is &quot; .. players[irc_params[2]].protectSize .. &quot; meters&quot;)

	if (players[irc_params[2]].protectPaused ~= nil) then
		irc_QueueMsg(irc_params[1], &quot;Protection is paused&quot;)
	end


	if (players[irc_params[2]].protect2 == true) then
		protected = &quot;protected&quot;
	else
		protected = &quot;not protected (unless you have LCB's down)&quot;
	end
	
	if (players[irc_params[2]].home2X == 0 and players[irc_params[2]].home2Y == 0 and players[irc_params[2]].home2Z == 0) then
		base = &quot;Has not done /setbase&quot;	
	else
		base = &quot;Has set a base&quot;
	end

	irc_QueueMsg(irc_params[1], &quot;Second Base status for &quot; .. irc_params[3] .. &quot; is..&quot;)
	irc_QueueMsg(irc_params[1], base)
	irc_QueueMsg(irc_params[1], &quot;Base2 is &quot; .. protected)
	irc_QueueMsg(irc_params[1], &quot;Protection size is &quot; .. players[irc_params[2]].protect2Size .. &quot; meters&quot;)

	if (players[irc_params[2]].protect2Paused ~= nil) then
		irc_QueueMsg(irc_params[1], &quot;Protection is paused&quot;)
	end

	irc_QueueMsg(irc_params[1], &quot;&quot;)
end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>Gimme</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

function arenaPicknMix(wave)
	local r

	r = rand(17)
	if wave &lt; 4 then
		if (r == 2) or (r == 7) then r = areanPicknMix() end -- don't allow feral zombie before round 4
	end

	return r
end

function PicknMix(mode)
	local r

	r = rand(30)
	if (r == 19) or (r == 7) then r = PicknMix() end
	if (r &gt; 19 and r &lt; 24) then r = PicknMix() end
	return r
end

function getEntity(r)
	entity = &quot;&quot;

	if (r == 1) then entity = &quot;zombie01&quot; end
	if (r == 2) then entity = &quot;zombieferal&quot; end
	if (r == 3) then entity = &quot;zombieBoe&quot; end 
	if (r == 4) then entity = &quot;zombieJoe&quot; end	 
	if (r == 5) then entity = &quot;zombieMoe&quot; end
	if (r == 6) then entity = &quot;zombieArlene&quot; end	 
	if (r == 7) then entity = &quot;zombieScreamer&quot; end	 
	if (r == 8) then entity = &quot;zombieDarlene&quot; end	 
	if (r == 9) then entity = &quot;zombieMarlene&quot; end	 
	if (r == 10) then entity = &quot;zombieYo&quot; end	 
	if (r == 11) then entity = &quot;zombieSteve&quot; end	 
	if (r == 12) then entity = &quot;zombieSteveCrawler&quot; end	 
	if (r == 13) then entity = &quot;snowzombie&quot; end	 
	if (r == 14) then entity = &quot;spiderzombie&quot; end	 
	if (r == 15) then entity = &quot;burntzombie&quot; end	 
	if (r == 16) then entity = &quot;zombieNurse&quot; end	 
	if (r == 17) then entity = &quot;fatzombiecop&quot; end	 
	if (r == 18) then r = rand(10) + 2 end
	if (r == 19) then entity = &quot;zombiedog&quot; end	 
	if (r == 20) then r = rand(10) + 2 end
	if (r == 21) then r = rand(10) + 2 end
	if (r == 22) then r = rand(10) + 2 end
	if (r == 23) then r = rand(10) + 2 end
	if (r == 24) then entity = &quot;startled stag&quot; end	 
	if (r == 25) then entity = &quot;bear&quot; end	 
	if (r == 26) then entity = &quot;undead bear&quot; end	 
	if (r == 27) then entity = &quot;rabbit&quot; end	 
	if (r == 28) then entity = &quot;dumb chicken&quot; end	
	if (r == 29) then entity = &quot;delicious bacon&quot; end	
	return entity
end


function setupArenaPlayers(pid)
	local dist
	local pointyStick
	local r
	local t
	local i
	local cmd

	t = os.time()
	arenaPlayers = {}
	arenaCount = 0

	for k, v in pairs(igplayers) do
		if (distancexyz(v.xPos, v.yPos, v.zPos, locations[&quot;arena&quot;].x, locations[&quot;arena&quot;].y, locations[&quot;arena&quot;].z) &lt; tonumber(locations[&quot;arena&quot;].size)) then

			arenaCount = arenaCount + 1
			arenaPlayers[tostring(arenaCount)] = {}
			arenaPlayers[tostring(arenaCount)].id = k

			-- give arena players stuff
			send(&quot;give &quot; .. v.id .. &quot; firstAidBandage 5&quot;)
			send(&quot;give &quot; .. v.id .. &quot; firstAidKit 2&quot;)
			send(&quot;give &quot; .. v.id .. &quot; shotgunShell 100&quot;)
			send(&quot;give &quot; .. v.id .. &quot; antibiotics 1&quot;)
  			send(&quot;give &quot; .. v.id .. &quot; pipeBomb 5&quot;)
  			send(&quot;give &quot; .. v.id .. &quot; meatStew 1&quot;)
  			send(&quot;give &quot; .. v.id .. &quot; repairKit 1&quot;)

			r = rand(5)
			if (r == 1) then pointyStick = &quot;boneShiv&quot; end
			if (r == 2) then pointyStick = &quot;gunPumpShotGun&quot; end
			if (r == 3) then pointyStick = &quot;huntingKnife&quot; end
			if (r == 4) then pointyStick = &quot;clubSpiked&quot;	 end

			send(&quot;give &quot; .. v.id .. &quot; &quot; .. pointyStick .. &quot; 1&quot;)
			message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]Supplies for the battle have been dropped at your feet. You have 10 seconds to prepare! (4 rounds)[-]&quot;)
		end
	end

	if (arenaCount == 0) then
		message(&quot;pm &quot; .. pid .. &quot; [&quot; .. server.chatColour .. &quot;]Nobody is in the arena.  You can't play from the spectator area.  Get in the arena coward.[-]&quot;)
		gimmeHell = 0
	end
end


function announceGimmeHell(wave)
	for k, v in pairs(arenaPlayers) do
		if (wave == 1) then
			message(&quot;pm &quot; .. v.id .. &quot; [&quot; .. server.chatColour .. &quot;]Here they come![-]&quot;)
		else
			message(&quot;pm &quot; .. v.id .. &quot; [&quot; .. server.chatColour .. &quot;]Here comes round &quot; .. wave .. &quot;![-]&quot;)
		end
	end
end


function resetGimmeHell()
	if (arenaTimer1 ~= nil) then 
		killTimer(arenaTimer1)
		arenaTimer1 = nil 
	end

	if (arenaTimer2 ~= nil) then 
		killTimer(arenaTimer2)
		arenaTimer2 = nil 
	end

	if (arenaTimer3 ~= nil) then 
		killTimer(arenaTimer3)
		arenaTimer3 = nil 
	end

	if (arenaTimer4 ~= nil) then 
		killTimer(arenaTimer4)
		arenaTimer4 = nil 
	end

	if (arenaTimer5 ~= nil) then 
		killTimer(arenaTimer5)
		arenaTimer5 = nil 
	end

	if (arenaTimer6 ~= nil) then 
		killTimer(arenaTimer6)
		arenaTimer6 = nil 
	end

	gimmeHell = 0
	arenaPlayers = {}
	conn:execute(&quot;DELETE FROM playerQueue&quot;)					

	for k, v in pairs(igplayers) do
		if (distancexyz(v.xPos, v.yPos, v.zPos, locations[&quot;arena&quot;].x, locations[&quot;arena&quot;].y, locations[&quot;arena&quot;].z) &lt; tonumber(locations[&quot;arena&quot;].size) + 20) then
			message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]gimmeHell is ready to play![-]&quot;)
		end
	end

	faultyChat = false
	return true
end


function queueGimmeHell(wave)
	local multiplier
	local r
	local p
	local cmd
	local zedBoss = 0

	multiplier = rand(13, 7)

	if (wave == 4) then
		multiplier = 2
	end

	for i = 1, arenaCount * multiplier do
		if tonumber(arenaCount) &gt; 1 then
			p = rand(arenaCount + 1)
		else
			p = 1
		end

		r = arenaPicknMix(wave)

		if wave &lt; 4 then
			while (r == 2) do
				r = arenaPicknMix(wave)
			end
		end

		if (wave == 4) then
			r = rand(3)
			if (r == 1) then r = 2 end
			if (r == 2) then r = 19 end

			cmd = &quot;se &quot; .. players[arenaPlayers[&quot;1&quot;].id].id .. &quot; &quot; .. r
			conn:execute(&quot;INSERT into playerQueue (command, arena, boss, steam) VALUES ('&quot; .. cmd .. &quot;', true, true, &quot; .. arenaPlayers[&quot;1&quot;].id .. &quot;)&quot;)					
		else	
			cmd = &quot;se &quot; .. players[arenaPlayers[tostring(p)].id].id .. &quot; &quot; .. r
			conn:execute(&quot;INSERT into playerQueue (command, arena, steam) VALUES ('&quot; .. cmd .. &quot;', true, &quot; .. arenaPlayers[tostring(p)].id .. &quot;)&quot;)					
		end
	end	

	if (wave == 4) then
		for k, v in pairs(arenaPlayers) do
			cmd = &quot;pm &quot; .. v.id .. &quot; [&quot; .. server.chatColour .. &quot;]Congratulations!  You have survived to the end of the fight!  Rest now. Tend to your wounded and mourn the fallen.[-]&quot;
			conn:execute(&quot;INSERT into playerQueue (command, arena, steam) VALUES ('&quot; .. cmd .. &quot;', true, &quot; .. v.id .. &quot;)&quot;)					
		end

		conn:execute(&quot;INSERT into playerQueue (command, arena, steam) VALUES ('reset', true, 0)&quot;)					
	end
end


function gimmeReset()
	-- reset gimmeCount for everyone
	for k, v in pairs(players) do
		players[k].gimmeCount = 0
	end

	if (playersOnline &gt; 0) and server.allowGimme == true then
		message(&quot;say [&quot; .. server.chatColour .. &quot;]Gimme has been reset!  Type gimme to play (10 gimmies per player, 15 for donors) /help gimme for info.&quot;)
	end
end


function gimme(pid)

--display(pid)

local cmd, debug
local pname = players[pid].name
local specialDay = &quot;&quot;
local maxGimmies
local dist
local r, rows, row, prize, category

debug = false

if debug then dbug(&quot;debug gimme&quot;) end

if locations[players[pid].inLocation] then
	if not locations[players[pid].inLocation].pvp then
		message(&quot;pm &quot; .. pid .. &quot; [&quot; .. server.chatColour .. &quot;]Gimme cannot be played within a location unless it is pvp enabled.[-]&quot;)
		faultyGimme = false
		return
	end
end

if debug then dbug(&quot;debug gimme 1&quot;) end

if (string.find(serverTime, &quot;02-14&quot;, 5, 10)) then specialDay = &quot;valentine&quot; end

if (faultyGimme == true) then
	cecho(&quot;Debug&quot;, &quot;!! Fault detected in Gimme\n&quot;)
	cecho(&quot;Debug&quot;, &quot;!! Fault occurred in Gimme #: &quot; .. faultyGimmeNumber .. &quot;\n&quot;)
end

faultyGimme = true

local steamid = pid
local playerid = igplayers[pid].id
local zombies = tonumber(igplayers[pid].zombies)

--		maxGimmies = 11

--display(&quot;gimme here&quot;)

--if (pid ~= yourname) then
	if players[steamid].donor == true then
		maxGimmies = 16
	else
		maxGimmies = 11
	end

	if players[steamid].gimmeCount == nil then
		players[steamid].gimmeCount = 0
	end

	if (players[steamid].gimmeCount &lt; tonumber(maxGimmies)) then
		players[steamid].gimmeCount = players[steamid].gimmeCount + 1
	else
		message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]You are out of gimmies.  You have to wait until the next gimme reset.[-]&quot;)
		faultyGimme = false
		return
	end
--end

	r = math.random(1, 60)
	faultyGimmeNumber = r

if debug then dbug(&quot;debug gimme 2&quot;) end
if debug then dbug(&quot;gimme random  &quot; .. r .. &quot; player = &quot; .. pname) end

--[[
  1 - zombie01
  2 - zombie04
  3 - zombieferal
  4 - zombieBoe
  5 - zombieJoe
  6 - zombieMoe
  7 - zombieArlene
  8 - zombieScreamer
  9 - zombieDarlene
  10 - zombieMarlene
  11 - zombieYo
  12 - zombieSteve
  13 - zombieSteveCrawler
  14 - snowzombie
  15 - spiderzombie
  16 - burntzombie
  17 - zombieNurse
  18 - fatzombiecop
  19 - hornet
  20 - zombiedog
  21 - car_Blue
  22 - car_Orange
  23 - car_Red
  24 - car_White
  25 - animalStag
  26 - animalBear
  27 - zombieBear
  28 - animalRabbit
  29 - animalChicken
  30 - animalPig
  33 - zombieUMAfemale
  34 - zombieUMAmale
  35 - zombieMaleHazmat
  36 - zombieFemaleHazmat
  37 - minibike
--]]

	-- get name of entity
	if (r == 1) then entity = &quot;zombie01&quot; end
	if (r == 2) then entity = &quot;zombie04&quot; end
	if (r == 3) then entity = &quot;zombieferal&quot; end
	if (r == 4) then entity = &quot;zombieBoe&quot; end 
	if (r == 5) then entity = &quot;zombieJoe&quot; end	 
	if (r == 6) then entity = &quot;zombieMoe&quot; end
	if (r == 7) then entity = &quot;zombieArlene&quot; end	 
	if (r == 8) then entity = &quot;zombieScreamer&quot; end	 
	if (r == 9) then entity = &quot;zombieDarlene&quot; end	 
	if (r == 10) then entity = &quot;zombieMarlene&quot; end	 
	if (r == 11) then entity = &quot;zombieYo&quot; end	 
	if (r == 12) then entity = &quot;zombieSteve&quot; end	 
	if (r == 13) then entity = &quot;zombieSteveCrawler&quot; end	 
	if (r == 14) then entity = &quot;snowzombie&quot; end	 
	if (r == 15) then entity = &quot;spiderzombie&quot; end	 
	if (r == 16) then entity = &quot;burntzombie&quot; end	 
	if (r == 17) then entity = &quot;zombieNurse&quot; end	 
	if (r == 18) then entity = &quot;fatzombiecop&quot; end	 
	if (r == 19) then r = 31 end
	if (r == 20) then entity = &quot;zombiedog&quot; end	 
	if (r == 21) then r = 31 end
	if (r == 22) then r = 31 end
	if (r == 23) then r = 31 end
	if (r == 24) then r = 31 end
	if (r == 25) then entity = &quot;startled stag&quot; end	 
	if (r == 26) then entity = &quot;bear&quot; end	 
	if (r == 27) then entity = &quot;undead bear&quot; end	 
	if (r == 28) then entity = &quot;rabbit&quot; end	 
	if (r == 29) then entity = &quot;dumb chicken&quot; end	 

	spawnCount = 1

	if (r &lt; 30) then
		-- nasty zombies
		descriptor = rand(6)	
		chanceOfMultiples = rand(50)
		
		if (chanceOfMultiples &gt; 25) then
			if (zombies &gt; 99) and (zombies &lt; 300) then spawnCount = rand(3) end	
			if (zombies &gt; 299) and (zombies &lt; 500) then spawnCount = rand(4) end	
			if (zombies &gt; 499) and (zombies &lt; 800) then spawnCount = rand(5) end
			if (zombies &gt; 799) and (zombies &lt; 1000) then spawnCount = rand(6) end
			if (zombies &gt; 999) and (zombies &lt; 1500) then spawnCount = rand(7) end
			if (zombies &gt; 1499) and (zombies &lt; 2000) then spawnCount = rand(8) end
			if (zombies &gt; 1999) and (zombies &lt; 2500) then spawnCount = rand(9) end
			if (zombies &gt; 2499) and (zombies &lt; 3000) then spawnCount = rand(10) end
			if (zombies &gt; 2999) and (zombies &lt; 3500) then spawnCount = rand(11) end
			if (zombies &gt; 3499) and (zombies &lt; 4000) then spawnCount = rand(12) end
			if (zombies &gt; 3999) and (zombies &lt; 4500) then spawnCount = rand(13) end

			if (zombies &gt; 4499) and (zombies &lt; 5000) then spawnCount = rand(14) end
			if (zombies &gt; 4999) and (zombies &lt; 5500) then spawnCount = rand(15) end
			if (zombies &gt; 5499) and (zombies &lt; 6000) then spawnCount = rand(16) end
			if (zombies &gt; 5999) and (zombies &lt; 6500) then spawnCount = rand(17) end
			if (zombies &gt; 6499) and (zombies &lt; 7000) then spawnCount = rand(18) end
			if (zombies &gt; 6999) and (zombies &lt; 7500) then spawnCount = rand(19) end
			if (zombies &gt; 7499) then spawnCount = rand(50) end
		end

if entity == &quot;zombieferal&quot; then
	spawnCount = rand(3)
end

if debug then dbug(&quot;debug gimme 3&quot;) end

--cecho(&quot;Debug&quot;, &quot;spawnCount = &quot; .. spawnCount .. &quot;\n&quot;)

		coffee = &quot;&quot;
		if (tonumber(gameHour) &gt; 21 or tonumber(gameHour) &lt; 7) then coffee = &quot;caffeinated &quot; end

		-- set up critter description
		if (spawnCount == 1) then
			if (descriptor == 1) then
				description = &quot;a surprised &quot; .. coffee
			end
			
			if (descriptor == 2) then
				description = &quot;an angry &quot; .. coffee
			end	
			
			if (descriptor == 3) then
				description = &quot;a very dangerous &quot; .. coffee
			end	
			
			if (descriptor == 4) then
				description = &quot;a murderous &quot; .. coffee
			end		
			
			if (descriptor == 5) then
				description = &quot;a pissed off &quot; .. coffee
			end		
			
			if (descriptor == 6) then
				description = &quot;an adorable &quot; .. coffee
			end		
		else
			if (descriptor == 1) then
				description = &quot;surprised &quot; .. coffee
			end
			
			if (descriptor == 2) then
				description = &quot;angry &quot; .. coffee
			end	
			
			if (descriptor == 3) then
				description = &quot;very dangerous &quot; .. coffee
			end	
			
			if (descriptor == 4) then
				description = &quot;murderous &quot; .. coffee
			end		
			
			if (descriptor == 5) then
				description = &quot;pissed off &quot; .. coffee
			end		
			
			if (descriptor == 6) then
				description = &quot;adorable &quot; .. coffee
			end			
		end	

		if (specialDay == &quot;valentine&quot;) then
			if (spawnCount == 1) then
				if (descriptor == 1) then
					description = &quot;a romantic &quot; .. coffee
				end
				
				if (descriptor == 2) then
					description = &quot;an attractive &quot; .. coffee
				end	
				
				if (descriptor == 3) then
					description = &quot;a very special &quot; .. coffee
				end	
				
				if (descriptor == 4) then
					description = &quot;a besotted &quot; .. coffee
				end		
				
				if (descriptor == 5) then
					description = &quot;a single and looking &quot; .. coffee
				end		
				
				if (descriptor == 6) then
					description = &quot;an eligible &quot; .. coffee
				end		
			else
				if (descriptor == 1) then
					description = &quot;eligible &quot; .. coffee
				end
				
				if (descriptor == 2) then
					description = &quot;super sexy &quot; .. coffee
				end	
				
				if (descriptor == 3) then
					description = &quot;lusty &quot; .. coffee
				end	
				
				if (descriptor == 4) then
					description = &quot;infatuated &quot; .. coffee
				end		
				
				if (descriptor == 5) then
					description = &quot;approachable &quot; .. coffee
				end		
				
				if (descriptor == 6) then
					description = &quot;gorgeous &quot; .. coffee
				end			
			end	
		end
	end

if debug then dbug(&quot;debug gimme 4&quot;) end

	if (r == 30) then 
		cursor,errorString = conn:execute(&quot;select * from gimmePrizes&quot;)
		rows = tonumber(cursor:numrows())
		r = rand(rows + 1)

		cursor,errorString = conn:execute(&quot;select * from gimmePrizes limit &quot; .. r - 1 .. &quot;,1&quot;)
		row = cursor:fetch({}, &quot;a&quot;)

		qty = rand(tonumber(row.prizeLimit))
		category = row.category
		prize = row.name
		
		description = &quot;&quot;
		if (qty == 1) then description = &quot;a &quot; end
		
		if (category == &quot;weapon&quot;) then
			descr = rand(13)
		
			if (descr==1) then description = description .. &quot;shiny new &quot; end
			if (descr==2) then description = description .. &quot;dangerous &quot; end			
			if (descr==3) then description = description .. &quot;sharp &quot; end						
			if (descr==4) then description = description .. &quot;well crafted &quot; end						
			if (descr==5) then description = description .. &quot;knock-off &quot; end									
			if (descr==6) then description = description .. &quot;banged up &quot; end									
			if (descr==7) then description = description .. &quot;basic &quot; end									
			if (descr==8) then description = description .. &quot;barely used &quot; end									
			if (descr==9) then description = description .. &quot;blood stained &quot; end												
			if (descr==10) then description = description .. &quot;common &quot; end												
			if (descr==11) then description = description .. &quot;dull &quot; end															
			if (descr==12) then description = description .. &quot;rusty &quot; end															
		end			
		
		if (category == &quot;book&quot;) then
			descr = rand(13)
		
			if (descr==1) then description = description .. &quot;rare &quot; end
			if (descr==2) then description = description .. &quot;wordy &quot; end			
			if (descr==3) then description = description .. &quot;well written &quot; end						
			if (descr==4) then description = description .. &quot;useful &quot; end						
			if (descr==5) then description = description .. &quot;tatty old &quot; end									
			if (descr==6) then description = description .. &quot;scruffy &quot; end									
			if (descr==7) then description = description .. &quot;faded &quot; end									
			if (descr==8) then description = description .. &quot;torn &quot; end									
			if (descr==9) then description = description .. &quot;soggy &quot; end												
			if (descr==10) then description = description .. &quot;dirty &quot; end												
			if (descr==11) then description = description .. &quot;chewed &quot; end															
			if (descr==12) then description = description .. &quot;ratty &quot; end															
		end			
		
		if (category == &quot;misc&quot;) then
			descr = rand(13)
		
			if (descr==1) then description = description .. &quot;common &quot; end
			if (descr==2) then description = description .. &quot;boring &quot; end			
			if (descr==3) then description = description .. &quot;interesting &quot; end						
			if (descr==4) then description = description .. &quot;damaged &quot; end						
			if (descr==5) then description = description .. &quot;rare &quot; end									
			if (descr==6) then description = description .. &quot;stupid &quot; end									
			if (descr==7) then description = description .. &quot;stinky &quot; end									
			if (descr==8) then description = description .. &quot;useless &quot; end									
			if (descr==9) then description = description .. &quot;amazing &quot; end												
			if (descr==10) then description = description .. &quot;collectable &quot; end												
			if (descr==11) then description = description .. &quot;dull &quot; end															
			if (descr==12) then description = description .. &quot;uninteresting &quot; end															
		end				
		
		if (category == &quot;health&quot;) then
			descr = rand(11)
		
			if (descr==1) then description = description .. &quot;dodgy &quot; end
			if (descr==2) then description = description .. &quot;sterile &quot; end			
			if (descr==3) then description = description .. &quot;generic &quot; end						
			if (descr==4) then description = description .. &quot;expensive &quot; end						
			if (descr==5) then description = description .. &quot;highly saught after &quot; end									
			if (descr==6) then description = description .. &quot;common &quot; end									
			if (descr==7) then description = description .. &quot;knock-off &quot; end									
			if (descr==8) then description = description .. &quot;yucky &quot; end									
			if (descr==9) then description = description .. &quot;gross &quot; end												
			if (descr==10) then description = description .. &quot;spare &quot; end												
		end			
		
		if (category == &quot;food&quot;) then
			descr = rand(13)
		
			if (descr==1) then description = description .. &quot;delicious &quot; end
			if (descr==2) then description = description .. &quot;yummy &quot; end			
			if (descr==3) then description = description .. &quot;yucky &quot; end						
			if (descr==4) then description = description .. &quot;tasty &quot; end						
			if (descr==5) then description = description .. &quot;bland &quot; end									
			if (descr==6) then description = description .. &quot;boring &quot; end									
			if (descr==7) then description = description .. &quot;expired &quot; end									
			if (descr==8) then description = description .. &quot;chewy &quot; end									
			if (descr==9) then description = description .. &quot;crunchy &quot; end												
			if (descr==10) then description = description .. &quot;tainted &quot; end												
			if (descr==11) then description = description .. &quot;stinky &quot; end															
			if (descr==12) then description = description .. &quot;funky &quot; end															
		end	
		
		if (category == &quot;tools&quot;) then
			descr = rand(11)
		
			if (descr==1) then description = description .. &quot;handy &quot; end
			if (descr==2) then description = description .. &quot;utilitarian &quot; end			
			if (descr==3) then description = description .. &quot;dirty &quot; end						
			if (descr==4) then description = description .. &quot;rusty &quot; end						
			if (descr==5) then description = description .. &quot;sturdy &quot; end									
			if (descr==6) then description = description .. &quot;ACME &quot; end									
			if (descr==7) then description = description .. &quot;knock-off &quot; end									
			if (descr==8) then description = description .. &quot;genuine &quot; end									
			if (descr==9) then description = description .. &quot;basic &quot; end												
			if (descr==10) then description = description .. &quot;designer &quot; end												
		end		
		
		if (category == &quot;clothes&quot;) then
			descr = rand(11)
		
			if (descr==1) then description = description .. &quot;shitty &quot; end
			if (descr==2) then description = description .. &quot;sturdy &quot; end			
			if (descr==3) then description = description .. &quot;tatty &quot; end						
			if (descr==4) then description = description .. &quot;used &quot; end						
			if (descr==5) then description = description .. &quot;brand new &quot; end									
			if (descr==6) then description = description .. &quot;soiled &quot; end									
			if (descr==7) then description = description .. &quot;boring &quot; end									
			if (descr==8) then description = description .. &quot;fabulous &quot; end									
			if (descr==9) then description = description .. &quot;natty &quot; end												
			if (descr==10) then description = description .. &quot;stylish &quot; end												
		end
		
		description = description .. prize
		
		if (qty &gt; 1) then
			description = qty .. &quot; &quot; .. description .. &quot;s&quot;
		end
				
		if (not server.gimmePeace) then			
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won &quot; .. description .. &quot;[-]&quot;)
		else
			message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won &quot; .. description .. &quot;[-]&quot;)
		end	
		
		send(&quot;give &quot; .. steamid .. &quot; &quot; .. prize .. &quot; &quot; .. qty)

		faultyGimme = false
		return 
	end

	if (r == 31) then
		if (not server.gimmePeace) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; almost won a prize![-]&quot;)
		else
			message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; almost won a prize![-]&quot;)
		end

		faultyGimme = false
		return 
	end

	if (r == 32) then
		spawnCount = rand(7,2)
		if (not server.gimmePeace) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won &quot; .. spawnCount .. &quot; BUNNIES![-]&quot;)
		else
			message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won &quot; .. spawnCount .. &quot; BUNNIES![-]&quot;)
		end

		for i = 1, spawnCount do
			cmd = &quot;se &quot; .. playerid .. &quot; 28&quot;
			conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('&quot; .. cmd .. &quot;', &quot; .. steamid .. &quot;)&quot;)
		end

		faultyGimme = false
		return
	end

	if (r == 33) then
		r = rand(100)
		if (r &lt; 70) then
			if (not server.gimmePeace) then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; almost won an epic prize![-]&quot;)
			else
				message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; almost won an epic prize![-]&quot;)
			end

			faultyGimme = false
			return
		end

		if (not server.gimmePeace) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won epic litter![-]&quot;)
		else
			message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won epic litter![-]&quot;)
		end

		t = os.time()
		for i = 1, 100 do
			r = rand(8)
		
			if (r == 1) then litter = &quot;canEmpty&quot; end
			if (r == 2) then litter = &quot;candyTin&quot; end
			if (r == 3) then litter = &quot;paper&quot; end
			if (r == 4) then litter = &quot;cloth&quot; end
			if (r == 5) then litter = &quot;yuccaFibers&quot; end
			if (r == 6) then litter = &quot;dirt&quot; end
			if (r == 6) then litter = &quot;bulletCasing&quot; end
			if (r == 7) then litter = &quot;emptyJar&quot; end

			cmd = &quot;give &quot; .. playerid .. &quot; &quot; .. litter .. &quot; 1&quot;
			conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('&quot; .. cmd .. &quot;', &quot; .. steamid .. &quot;)&quot;)
		end

		faultyGimme = false
		return
	end

	if (r == 34) then
		item = rand(13)
		if (item == 1) then prize = &quot;canBeef&quot; end
		if (item == 2) then prize = &quot;canChili&quot; end
		if (item == 3) then prize = &quot;canPasta&quot; end
		if (item == 4) then prize = &quot;gasCan&quot; end
		if (item == 5) then prize = &quot;firstAidBandage&quot; end
		if (item == 6) then prize = &quot;beer&quot; end
		if (item == 7) then prize = &quot;shades&quot; end
		if (item == 8) then prize = &quot;bottledWater&quot; end
		if (item == 9) then prize = &quot;baconAndEggs&quot; end
		if (item == 10) then prize = &quot;vegetableStew&quot; end
		if (item == 11) then prize = &quot;goldenRodTea&quot; end
		if (item == 12) then prize = &quot;coffee&quot; end

		for k, v in pairs(igplayers) do
			if (k ~= steamid) then send(&quot;give &quot; .. k .. &quot; &quot; .. prize .. &quot; 1&quot;) end
		end

		message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won a &quot; .. prize .. &quot; for everyone! One for you, one for you, and you and.. oh sorry &quot; .. pname .. &quot; none left.[-]&quot;)
		message(&quot;say [&quot; .. server.chatColour .. &quot;]Everyone else collect your prize![-]&quot;)
		faultyGimme = false
		return
	end


	if (r == 35) then
		descr = rand(9)

		if (descr == 1) then cmd = &quot;Nothing!&quot; end
		if (descr == 2) then cmd = &quot;Nothing!&quot; end
		if (descr == 3) then cmd = &quot;Nothing!&quot; end

		if (descr == 4) then 
			cmd = &quot;*BZZT*  Oh no!  It's eaten another gimmie![-]&quot; 
			players[steamid].gimmeCount = players[steamid].gimmeCount + 1
		end

		if (descr == 5) then
			i = rand(4)
 
			cmd = i .. &quot; extra gimmies! =D&quot; 
			players[steamid].gimmeCount = players[steamid].gimmeCount - i
		end

		if (descr &gt; 5 and descr &lt; 9) then
			r = rand(10)
			 if (not server.gimmePeace) then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; Ruh Roh! Gimmies short circuited!  You win..[-]&quot;)
				cmd = &quot;say Every panels lit up! OMG! Zombies are coming out of the walls! RUN !![-]&quot; 
			else
				message(&quot;pm [&quot; .. server.chatColour .. &quot;]&quot; .. playerid .. &quot; Ruh Roh! Gimmies short circuited!  You win..[-]&quot;)
				cmd = &quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Every panels lit up! OMG! Zombies are coming out of the walls! RUN !![-]&quot; 
			end

			tempTimer( 1, [[message(&quot;]].. cmd .. [[&quot;)]] )

			for i = 1, r do
				z = PicknMix()
				cmd = &quot;se &quot; .. playerid .. &quot; &quot; .. z
				conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('&quot; .. cmd .. &quot;', &quot; .. steamid .. &quot;)&quot;)
			end

			faultyGimme = false
			return
		end

		if (not server.gimmePeace) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; Ruh Roh! Gimmies short circuited!  You win..[-]&quot;)
			cmd = &quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. cmd .. &quot;[-]&quot;
			tempTimer( 2, [[message(&quot;]].. cmd .. [[&quot;)]] )
		else
			cmd = &quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. cmd .. &quot;[-]&quot;
			tempTimer( 2, [[message(&quot;]].. cmd .. [[&quot;)]] )
		end	

		faultyGimme = false
		return	
	end


	if (r == 36) then
		if (not server.gimmePeace) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]HAPPY BIRTHDAY &quot; .. pname .. &quot;!  We got you a puppy![-]&quot;)
		else
			message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]HAPPY BIRTHDAY &quot; .. pname .. &quot;! We got you a puppy![-]&quot;)
		end

		cmd = &quot;se &quot; .. playerid .. &quot; 20&quot;
		conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('&quot; .. cmd .. &quot;', &quot; .. steamid .. &quot;)&quot;)

		faultyGimme = false
		return
	end


	if (r == 37) then
		if (not server.gimmePeace) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]You won a HUGE STEAK!!! &quot; .. pname .. &quot;!  But this guy ate it :(  Deal with him![-]&quot;)
		else
			message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]You won a HUGE STEAK!!! &quot; .. pname .. &quot;!  But this guy ate it :(  Deal with him![-]&quot;)
		end

		cmd = &quot;se &quot; .. playerid .. &quot; 4&quot;
		conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('&quot; .. cmd .. &quot;', &quot; .. steamid .. &quot;)&quot;)

		faultyGimme = false
		return
	end


	if (r == 38) then
		if (not server.gimmePeace) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won invisiblity!  Press Alt-F4 to claim your prize!!![-]&quot;)
		else
			message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]You won invisiblity!  Press Alt-F4 to claim your prize!!![-]&quot;)
		end

		faultyGimme = false
		return
	end


	if (r == 39) then
		spawnCount = rand(15,5)
		if (not server.gimmePeace) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; ate a bad potato and is shitting potatoes everywhere![-]&quot;)
		else
			message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; ate a bad potato and is shitting potatoes everywhere![-]&quot;)
		end

		for i = 1, spawnCount do
			cmd = &quot;give &quot; .. playerid .. &quot; potato 1&quot;
			conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('&quot; .. cmd .. &quot;', &quot; .. steamid .. &quot;)&quot;)
		end

		faultyGimme = false
		return
	end

	if (r == 40) then
		if (not server.gimmePeace) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; voted first place WINNER! Here's your trophy.[-]&quot;)
		else
			message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; voted first place WINNER! Here's your trophy.[-]&quot;)
		end

		cmd = &quot;give &quot; .. playerid .. &quot; trophy3 1&quot;
		conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('&quot; .. cmd .. &quot;', &quot; .. steamid .. &quot;)&quot;)

		faultyGimme = false
		return
	end


	if (r == 41) then
		if (not server.gimmePeace) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won a care package via air drop.  Gee I hope the pilot knows where the drop zone is![-]&quot;)
		else
			message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won a care package via air drop.  Gee I hope the pilot knows where the drop zone is![-]&quot;)
		end

		send(&quot;spawnairdrop&quot;)

		faultyGimme = false
		return
	end


	if (r == 42) then
		players[steamid].baseCooldown = 0
		conn:execute(&quot;UPDATE players SET baseCooldown = 0 WHERE steam = &quot; .. steamid)

		if (not server.gimmePeace) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won a get out of Dodge free card!  Their base cooldown has been reset.[-]&quot;)
		else
			message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won a get out of Dodge free card!  Your base cooldown has been reset.[-]&quot;)
		end

		faultyGimme = false
		return
	end	


	if (r &gt; 42) and (r &lt; 50) then
		if (not server.gimmePeace) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]You lose!  Try again &quot; .. pname .. &quot;[-]&quot;)
		else
			message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]You lose!  Try again &quot; .. pname .. &quot;[-]&quot;)
		end

		faultyGimme = false
		return
	end


	if (r &gt; 49) then
		if (not server.gimmePeace) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; did not win a prize.[-]&quot;)
		else
			message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; did not win a prize.[-]&quot;)
		end

		faultyGimme = false
		return
	end


	if (spawnCount == 1) then
		if (not server.gimmePeace) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won &quot; .. description .. entity .. &quot;[-]&quot;)
		else
			message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won &quot; .. description .. entity .. &quot;[-]&quot;)
		end
	else
		if (zombies &gt; 2499) then
			descr = &quot; won &quot; .. spawnCount .. &quot; Pick 'N Mix Zombies!&quot;

			if spawnCount == 6 then
				descr = &quot; won a 6 pack of Ready-To-Die zombies!&quot;
			end

			if spawnCount == 12 then
				descr = &quot; won a 12 pack of zombies!&quot;
			end

			if spawnCount == 13 then
				descr = &quot; won a bakers dozen of zombies!&quot;
			end

			if spawnCount == 24 then
				descr = &quot; won a hearty 24 pack of zombies!&quot;
			end

			if spawnCount == 50 then
				descr = &quot; won ALL THE ZOMBIES!&quot;
			end

			if (not server.gimmePeace) then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. descr .. &quot;[-]&quot;)
			else
				message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. descr .. &quot;[-]&quot;)
			end
		else
			if (not server.gimmePeace) then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won &quot; .. spawnCount .. &quot; &quot; .. description .. entity ..&quot;s![-]&quot;)
			else
				message(&quot;pm &quot; .. steamid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; won &quot; .. spawnCount .. &quot; &quot; .. description .. entity ..&quot;s![-]&quot;)
			end
		end
	end

	if r &gt; 30 then
		-- abort if r &gt; 30 so we don't spawn the broken zeds
		faultyGimme = false
		return
	end

	if (spawnCount == 1) then
		cmd = &quot;se &quot; .. playerid .. &quot; &quot; .. r
		conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('&quot; .. cmd .. &quot;', &quot; .. steamid .. &quot;)&quot;)

		if (specialDay == &quot;valentine&quot;) then 
			z = rand(5)
			if z == 1 then send(&quot;give &quot; .. playerid .. &quot; yellowflower 1&quot;) end
			if z == 2 then send(&quot;give &quot; .. playerid .. &quot; plantChrysanthemum 1&quot;) end
			if z == 3 then send(&quot;give &quot; .. playerid .. &quot; goldenrod 1&quot;) end
			if z == 4 then send(&quot;give &quot; .. playerid .. &quot; cotton 1&quot;) end
		end
	else
		if (zombies &gt; 2499) then
			for i = 1, spawnCount do
				cmd = &quot;se &quot; .. playerid .. &quot; &quot; .. PicknMix()
				conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('&quot; .. cmd .. &quot;', &quot; .. steamid .. &quot;)&quot;)
			end
		else
			for i = 1, spawnCount do
				cmd = &quot;se &quot; .. playerid .. &quot; &quot; .. r
				conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('&quot; .. cmd .. &quot;', &quot; .. steamid .. &quot;)&quot;)

				if (specialDay == &quot;valentine&quot;) then 
					z = rand(5)
					if z == 1 then cmd = &quot;give &quot; .. playerid .. &quot; yellowflower 1&quot; end
					if z == 2 then cmd = &quot;give &quot; .. playerid .. &quot; plantChrysanthemum 1&quot; end
					if z == 3 then cmd = &quot;give &quot; .. playerid .. &quot; goldenrod 1&quot; end
					if z == 4 then cmd = &quot;give &quot; .. playerid .. &quot; cotton 1&quot; end

					conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('&quot; .. cmd .. &quot;', &quot; .. steamid .. &quot;)&quot;)
				end
			end
		end
	end

if debug then dbug(&quot;debug gimme end&quot;) end

	faultyGimme = false
	return
end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>IRCMessage</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

--[[
IRC commands
============

no login required:
------------------
bow before me
login
hi bot
staff
owners
admins
mods
date, time or day
uptime
location &lt;name&gt;
new players
server stats/status
who
help shop
help topics/server/donors/csi/watchlist/announcements/commands/motd
help bad items
help custom commands
reset zones
locations
villages
fps
shop categories
shop &lt;category&gt;
shop &lt;item&gt;
nuke/clear irc
server
rules

login required:
---------------
check dns
say
say&lt;language code eg fr&gt;
server ip/address
view alerts
show inventory
announcements
add announcement
delete announcement
who visited
pay &lt;player&gt; &lt;amount&gt;
claims &lt;player or blank&gt;
cmd &lt;normal ingame command if supported&gt;
pm &lt;player&gt; &lt;message&gt;
con help/se/ban list/gg/si/llp
villagers
base cooldown timer
set rules
motd/set motd/clear motd
list tables
show table
reset bot
stop translating


--]]


local ircid, pid, login, name1, name2, words, wordsOld, words2, wordCount, result, msgLower, number, counter, xpos, zpos, debug, tmp

debug = false

function requireLogin(name)
	irc_QueueMsg(name, &quot;Your login has expired. Login and and repeat your command.&quot;)
end

IRCMessage = function (event, name, channel, msg)
	if lastIRC == msg then
		server.ircBotName = name
	end

	if debug then 
		dbug(&quot;debug ircmessage&quot;) 
		dbug(event .. &quot; &quot; .. name .. &quot; &quot; .. channel .. &quot; &quot; .. msg)
	end

	-- block Mudlet from messaging the official Mudlet support channel
	if (channel == &quot;#mudlet&quot;) then return end

	-- block Mudlet from reacting to its own messages
	if (name == server.botName or name == server.ircBotName or string.find(msg, &quot;&lt;&quot; .. server.ircBotName .. &quot;&gt;&quot;, nil, true)) then return end

	wordsOld = {}
	for word in msg:gmatch(&quot;%S+&quot;) do table.insert(wordsOld, word) end

	words2 = string.split(msg, &quot; &quot;)
	msgLower = string.lower(msg)

	words = {}
	irc_params = {}
	ircid = LookupOfflinePlayer(name, &quot;all&quot;)

	if ircid ~= nil and debug then
		dbug(&quot;ircid &quot; .. ircid)
	end

	if ircid ~= nil then
		if players[ircid].ircAuthenticated == true then
			-- keep login session alive
			if accessLevel(ircid) &lt; 4 then
				players[ircid].ircSessionExpiry = os.time() + 3600
			else
				players[ircid].ircSessionExpiry = os.time() + 10800
			end
		end

		dbug(&quot;IRC: &quot; .. name .. &quot; access &quot; .. accessLevel(ircid) .. &quot; said &quot; .. msg)
	end

	if debug then dbug(&quot;debug ircmessage 2&quot;) end

	table.insert(irc_params, name)
	for word in msgLower:gmatch(&quot;%w+&quot;) do table.insert(words, word) end
	wordCount = table.maxn(words)

	number = tonumber(string.match(msg, &quot; (-?\%d+)&quot;))

	if (words[1] == &quot;hi&quot; or words[1] == &quot;hello&quot;) and (string.lower(words[2]) == string.lower(server.botName) or string.lower(words[2]) == string.lower(server.ircBotName) or words[2] == &quot;bot&quot; or words[2] == &quot;server&quot;) then
		table.insert(irc_params, &quot; Hi there &quot; .. name .. &quot;!  How can I help you today?&quot;)
		irc_QueueMsg(name, irc_params[2])
		return
	end


	if (words[1] == &quot;staff&quot; and words[2] == nil) then
		irc_List_Owners(name)
		irc_List_Admins(name)
		irc_List_Mods(name)
		return
	end


	if (words[1] == &quot;owners&quot; and words[2] == nil) then
		irc_List_Owners(name)
		return
	end


	if (words[1] == &quot;admins&quot; and words[2] == nil) then
		irc_List_Admins(name)
		return
	end


	if (words[1] == &quot;mods&quot; and words[2] == nil) then
		irc_List_Mods(name)
		return
	end


	if words[1] == string.lower(server.botName) or words[1] == string.lower(server.ircBotName) and words[2] == nil then
		irc_params = {}
		table.insert(irc_params, server.ircMain)
		table.insert(irc_params, &quot; Hi &quot; .. name)
		irc_QueueMsg(irc_params[1], irc_params[2])
		return
	end


	if (words[1] == &quot;say&quot;) then
		if players[ircid].ircAuthenticated == false then
			requireLogin(name)
			return
		end

		msg = string.trim(string.sub(msg, 5))
		message(&quot;say &quot; .. name .. &quot;-irc: [i]&quot; .. msg .. &quot;[/i][-]&quot;)
		return
	end


	if (string.find(words[1], &quot;say&quot;) and (string.len(words[1]) == 5) and words[2] ~= nil) then
		if players[ircid].ircAuthenticated == false then
			requireLogin(name)
			return
		end

		msg = string.sub(msg, string.len(words[1]) + 2)
		msg = string.trim(msg)

		if (msg ~= &quot;&quot;) then
			Translate(ircid, msg, string.sub(words[1], 4), true)
		end

		return
	end


	if (words[1] == &quot;date&quot; or words[1] == &quot;time&quot; or words[1] == &quot;day&quot;) and words[2] == nil then
		irc_gameTime(channel)
		return
	end


	if (words[1] == &quot;uptime&quot;) and words[2] == nil then
		irc_uptime(channel)
		return
	end


	if (words[1] == &quot;location&quot;) then
		-- display details about the location

		locationName = words[2]
		locationName = string.trim(locationName)
		loc = LookupLocation(locationName)

		if (loc == nil) then 
			irc_QueueMsg(name, &quot;That location does not exist.&quot;)
			return
		else	
			cursor,errorString = conn:execute(&quot;SELECT * FROM locations WHERE name = '&quot; .. locationName ..&quot;'&quot;)
			row = cursor:fetch({}, &quot;a&quot;)

			irc_QueueMsg(name, &quot;Location: &quot; .. row.name)
			irc_QueueMsg(name, &quot;Active: &quot; .. dbYN(row.active))
			irc_QueueMsg(name, &quot;Reset Zone: &quot; .. dbYN(row.resetZone))
			irc_QueueMsg(name, &quot;Safe Zone: &quot; .. dbYN(row.killZombies))
			irc_QueueMsg(name, &quot;Public: &quot; .. dbYN(row.public))
			irc_QueueMsg(name, &quot;Allow Bases: &quot; .. dbYN(row.allowBase))

			if row.miniGame ~= nil then
				irc_QueueMsg(name, &quot;Mini Game: &quot; .. row.miniGame)
			end

			irc_QueueMsg(name, &quot;Village: &quot; .. dbYN(row.village))

			temp = LookupPlayer(row.mayor)
			if row.owner ~= &quot;0&quot; then 
				temp = LookupPlayer(row.mayor)
			else
				temp = &quot;&quot;
			end

			irc_QueueMsg(name, &quot;Mayor: &quot; .. temp)
			irc_QueueMsg(name, &quot;Protected: &quot; .. dbYN(row.protected))
			irc_QueueMsg(name, &quot;PVP: &quot; .. dbYN(row.pvp))
			irc_QueueMsg(name, &quot;Access Level: &quot; .. row.accessLevel)

			temp = LookupPlayer(row.owner)
			if row.owner ~= &quot;0&quot; then 
				temp = LookupPlayer(row.owner)
			else
				temp = &quot;&quot;
			end

			irc_QueueMsg(name, &quot;Owner: &quot; .. temp)
			irc_QueueMsg(name, &quot;Coords: &quot; .. row.x .. &quot; &quot; .. row.y .. &quot; &quot; .. row.z)
			irc_QueueMsg(name, &quot;Size: &quot; .. row.size * 2)
			irc_QueueMsg(name, &quot;Players in &quot; .. loc)
	
			for k,v in pairs(igplayers) do
				if players[k].inLocation == loc then
					irc_QueueMsg(name, v.name)
				end
			end

			irc_QueueMsg(name, &quot;&quot;)
		end

		return
	end


	if words[1] == &quot;new&quot; and words[2] == &quot;players&quot; then
		pid = LookupOfflinePlayer(name, &quot;all&quot;)

		if number == nil then 
			number = 86400 
		else
			number = number * 86400
		end

		irc_QueueMsg(name, &quot;New players in the last &quot; .. math.floor(number / 86400) .. &quot; days:&quot;)

		cursor,errorString = conn:execute(&quot;SELECT * FROM events where timestamp &gt;= '&quot; .. os.date('%Y-%m-%d %H:%M:%S', os.time() - number).. &quot;' and type = 'new player' order by timestamp desc&quot;)
		row = cursor:fetch({}, &quot;a&quot;)

		while row do
			if accessLevel(pid) &gt; 3 then
				irc_QueueMsg(name, v.name)
			else
				msg = &quot;steam: &quot; .. row.steam .. &quot; id: &quot; .. string.format(&quot;%8d&quot;, players[row.steam].id) .. &quot; name: &quot; .. players[row.steam].name .. &quot; at [ &quot; .. players[row.steam].xPos .. &quot; &quot; .. players[row.steam].yPos .. &quot; &quot; .. players[row.steam].zPos .. &quot; ] &quot; .. players[row.steam].country
				msg = msg .. &quot; PVP &quot; .. players[row.steam].playerKills

				if (igplayers[row.steam]) then
					time = tonumber(players[row.steam].timeOnServer) + tonumber(igplayers[row.steam].sessionPlaytime)
				else
					time = tonumber(players[row.steam].timeOnServer)
				end

				hours = math.floor(time / 3600)

				if (hours &gt; 0) then
					time = time - (hours * 3600)
				end

				minutes = math.floor(time / 60)

				msg = msg .. &quot; Playtime &quot; .. hours .. &quot;h &quot; .. minutes .. &quot;m&quot;

				cursor2,errorString = conn:execute(&quot;SELECT * FROM bans WHERE steam =  &quot; .. row.steam)
				if cursor2:numrows() &gt; 0 then
					msg = msg .. &quot; BANNED&quot;
				end

				if players[row.steam].timeout == true then
					msg = msg .. &quot; TIMEOUT&quot;
				end

				if players[row.steam].country == &quot;CN&quot; or players[row.steam].country == &quot;HK&quot; then
					msg = msg .. &quot; Chinese&quot;
				end

				irc_QueueMsg(name, msg)
			end

			row = cursor:fetch(row, &quot;a&quot;)	
		end
	
		irc_QueueMsg(name, &quot;&quot;)
		return
	end

	if words[1] == &quot;server&quot; and (words[2] == &quot;status&quot; or words[2] == &quot;stats&quot;) then
		irc_server_status(name)
		return
	end


	if (words[1] == &quot;who&quot; and words[2] == nil) then
		irc_players(name)
		return
	end


	if (words[1] == &quot;help&quot; and words[2] == &quot;shop&quot;) then
		irc_HelpShop()
		return
	end


	if (words[1] == &quot;help&quot; and words[2] == &quot;topics&quot;) then
		if words[3] ~= nil then
			table.insert(irc_params, words[3])
		end

		irc_HelpTopics()
		return
	end


	if (words[1] == &quot;help&quot; and words[2] == nil) then
		irc_commands()
		return
	end
	
	
	if (words[1] == &quot;help&quot; and words[2] == &quot;server&quot;) then
		irc_HelpServer()
		return
	end


	if (words[1] == &quot;help&quot; and words[2] == &quot;donors&quot;) then
		irc_HelpDonors()
		return
	end
	
	
	if (words[1] == &quot;help&quot; and words[2] == &quot;csi&quot;) then
		irc_HelpCSI()
		return
	end


	if (words[1] == &quot;help&quot; and words[2] == &quot;watchlist&quot;) then
		irc_HelpWatchlist()
		return
	end
	
	
	if (words[1] == &quot;help&quot; and words[2] == &quot;bad&quot; and words[3] == &quot;items&quot;) then
		irc_HelpBadItems()
		return
	end


	if (words[1] == &quot;help&quot; and words[2] == &quot;announcements&quot;) then
		irc_HelpAnnouncements()
		return
	end


	if (words[1] == &quot;help&quot; and words[2] == &quot;commands&quot;) then
		irc_HelpCommands()
		return
	end


	if (words[1] == &quot;help&quot; and words[2] == &quot;custom&quot; and words[3] == &quot;commands&quot;) then
		irc_HelpCustomCommands()
		return
	end


	if (words[1] == &quot;help&quot; and words[2] == &quot;motd&quot;) then
		irc_HelpMOTD()
		return
	end


	if (words[1] == &quot;reset&quot; and words[2] == &quot;zones&quot; and words[3] == nil) then
		irc_listResetZones(name)
		return
	end


	if (words[1] == &quot;locations&quot; and words[2] == nil) then
		irc_locations(name)	
		return
	end


	if (words[1] == &quot;villages&quot; and words[2] == nil) then
		irc_List_Villages(name)
		return
	end


	if words[1] == &quot;fps&quot; and words[2] == nil then
		cursor,errorString = conn:execute(&quot;SELECT * FROM performance  ORDER BY serverdate DESC Limit 0, 1&quot;)
		row = cursor:fetch({}, &quot;a&quot;)

		if row then
			irc_QueueMsg(channel, &quot;Server FPS: &quot; .. server.fps .. &quot; Players: &quot; .. row.players .. &quot; Zombies: &quot; .. row.zombies .. &quot; Entities: &quot; .. row.entities .. &quot; Heap: &quot; .. row.heap .. &quot; HeapMax: &quot; .. row.heapMax)
		end

		return
	end	


	if words[1] == &quot;shop&quot; and shopCategories[words[2]] then
		LookupShop(words[2], true)	

		cursor,errorString = conn:execute(&quot;SELECT * FROM memShop ORDER BY idx&quot;)
		row = cursor:fetch({}, &quot;a&quot;)

		while row do
			if tonumber(row.stock) == -1 then
				msg = &quot;Code:  &quot; .. row.code .. &quot;    item:  &quot; .. row.item .. &quot;    price:  &quot; .. row.price .. &quot; UNLIMITED&quot;
			else
				msg = &quot;Code:  &quot; .. row.code .. &quot;    item:  &quot; .. row.item .. &quot; price: &quot; .. row.price .. &quot;  (&quot; .. row.stock .. &quot;)  left&quot;
			end

			irc_QueueMsg(irc_params[1], msg)
			row = cursor:fetch(row, &quot;a&quot;)	
		end

		irc_QueueMsg(irc_params[1], &quot;&quot;)											
		return
	end	


	if (words[1] == &quot;shop&quot; and words[2] == &quot;categories&quot;) then		
		irc_QueueMsg(irc_params[1], &quot;The shop categories are:&quot;)

		for k, v in pairs(shopCategories) do
			irc_QueueMsg(irc_params[1], k)
		end

		irc_QueueMsg(irc_params[1], &quot;&quot;)				
		return
	end	


	if (words[1] == &quot;shop&quot; and words[2] ~= nil and words[3] == nil) then
		LookupShop(wordsOld[2], true)		

		cursor,errorString = conn:execute(&quot;SELECT * FROM memShop ORDER BY category, idx&quot;)
		row = cursor:fetch({}, &quot;a&quot;)

		while row do
			if tonumber(row.stock) == -1 then
				msg = &quot;Code:  &quot; .. row.code .. &quot;    item:  &quot; .. row.item .. &quot;    price:  &quot; .. row.price .. &quot; UNLIMITED&quot;
			else
				msg = &quot;Code:  &quot; .. row.code .. &quot;    item:  &quot; .. row.item .. &quot; price: &quot; .. row.price .. &quot;  (&quot; .. row.stock .. &quot;)  left&quot;
			end

			irc_QueueMsg(irc_params[1], msg)

			row = cursor:fetch(row, &quot;a&quot;)	
		end

		irc_QueueMsg(irc_params[1], &quot;&quot;)				
		return
	end	


	if words[1] == &quot;nuke&quot; or words[1] == &quot;clear&quot; and words[2] == &quot;irc&quot; then
		conn:execute(&quot;DELETE FROM ircQueue WHERE name = '&quot; .. name .. &quot;'&quot;)
		irc_QueueMsg(channel, &quot;IRC spam nuked for &quot; .. name)

		if ircListItems == ircid then ircListItems = nil end

		if echoConsoleTo == name then
			echoConsole = nil
			echoConsoleTo = nil
		end
	end
	
	
	if (words[1] == &quot;server&quot;) then
		if words[2] == &quot;ip&quot; or words[2] == &quot;address&quot; and (string.trim(words[3]) ~= &quot;&quot;) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end			
		
			server.IP = string.sub(msg, string.find(msg, words[3]), string.len(msg))
			table.insert(irc_params, &quot;The server address is now &quot; .. server.IP .. &quot;:&quot; .. server.ServerPort)
			irc_message()

			conn:execute(&quot;UPDATE server SET IP = '&quot; .. server.IP .. &quot;'&quot;)
			getWhitelistedServers()

			return
		end

		if words[2] == nil then
			irc_QueueMsg(irc_params[1], &quot;Server name is &quot; .. server.ServerName)
			irc_QueueMsg(irc_params[1], &quot;Address is &quot; .. server.IP .. &quot;:&quot; .. server.ServerPort)
			irc_QueueMsg(irc_params[1], &quot;There are  &quot; .. playersOnline .. &quot; players online.&quot;)
			return
		end
	end


	if (words[1] == &quot;rules&quot;) then
		if words[2] == nil then
			table.insert(irc_params, &quot;The server rules are &quot; .. server.rules)
			irc_message()
			return
		else
			table.insert(irc_params, &quot;To change the rules type set rules &lt;new rules&gt;&quot;)
			irc_message()
			return
		end
	end	
	
	
	if debug then dbug(&quot;debug ircmessage 3&quot;) end

	if (ircid ~= nil) and (accessLevel(ircid) &lt; 3) then
-- ########### Staff only in this section ###########

		if words[1] == &quot;check&quot; and words[2] == &quot;dns&quot; then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end

			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			pid = &quot;&quot;
			number = &quot;&quot;

			for i=2,wordCount,1 do
				if words2[i] == &quot;dns&quot; then
					name1 = words2[i+1]
					pid = LookupPlayer(name1)
				end					
			end


			if pid ~= &quot;&quot; then
				number = players[pid].IP

				irc_QueueMsg(irc_params[1], &quot;Checking DNS record for &quot; .. pid .. &quot; IP &quot; .. number)
				CheckBlacklist(pid, number)
			end

			irc_QueueMsg(irc_params[1], &quot;&quot;)											
			return
		end	

		if debug then dbug(&quot;debug ircmessage 4&quot;) end
	
		if words[1] == &quot;view&quot; and words[2] == &quot;alerts&quot; then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if number == nil then number = 20 end

			cursor,errorString = conn:execute(&quot;SELECT * FROM alerts order by alertID desc limit &quot; .. number)
			if cursor:numrows() == 0 then
				irc_QueueMsg(irc_params[1], &quot;There are no alerts recorded.&quot;)
			else
				irc_QueueMsg(irc_params[1], &quot;The most recent alerts are:&quot;)
				row = cursor:fetch({}, &quot;a&quot;)
				while row do
					msg = &quot;On &quot; .. row.timestamp .. &quot; player &quot; .. players[row.steam].name .. &quot; at &quot; .. row.x .. &quot; &quot; .. row.y .. &quot; &quot; .. row.z .. &quot; said &quot; .. row.message
					irc_QueueMsg(irc_params[1], msg)
					row = cursor:fetch(row, &quot;a&quot;)	
				end
			end

			irc_QueueMsg(irc_params[1], &quot;&quot;)											
			return
		end	

		if debug then dbug(&quot;debug ircmessage 5&quot;) end

		if words[1] == &quot;show&quot; and words[2] == &quot;inventory&quot; then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			if words[3] == nil then
				irc_QueueMsg(irc_params[1], &quot;Full example.. show inventory player Joe xpos 100 zpos 200 days 2 range 50 item tnt qty 20&quot;)
				irc_QueueMsg(irc_params[1], &quot;You can grab the coords from any player by adding, near joe&quot;)
				irc_QueueMsg(irc_params[1], &quot;Defaults: days = 1, range = 100km, xpos = 0, zpos = 0&quot;)
				irc_QueueMsg(irc_params[1], &quot;Optional: player (or near) joe, days 1, hours 1, range 50, item tin, qty 10, xpos 0, zpos 0, session 1&quot;)
				irc_QueueMsg(irc_params[1], &quot;&quot;)
				return
			end

			name1 = nil
			pid = nil
			days = 1
			hours = 0
			range = 100000
			item = nil
			xpos = 0
			zpos = 0
			qty = nil
			session = 0

			for i=3,wordCount,1 do
				if words2[i] == &quot;player&quot; then
					name1 = words2[i+1]
					pid = LookupPlayer(name1)
				end					
					
				if words2[i] == &quot;days&quot; then
					days = tonumber(words2[i+1])
				end								

				if words2[i] == &quot;hours&quot; then
					hours = tonumber(words2[i+1])
					days = 0
				end								

				if words2[i] == &quot;range&quot; then
					range = tonumber(words2[i+1])
				end	

				if words2[i] == &quot;item&quot; then
					item = words2[i+1]
				end	

				if words2[i] == &quot;qty&quot; then
					qty = words2[i+1]
				end	

				if words2[i] == &quot;xpos&quot; then
					xpos = tonumber(words2[i+1])
				end	

				if words2[i] == &quot;zpos&quot; then
					zpos = tonumber(words2[i+1])
				end	

				if words2[i] == &quot;session&quot; then
					session = words2[i+1]
				end	

				if words2[i] == &quot;near&quot; then
					name2 = words2[i+1]
					pid2 = LookupPlayer(name2)

					if pid2 ~= nil then
						xpos = players[pid2].xPos
						zpos = players[pid2].zPos
					end
				end		
			end

			if days == 0 then
				sql = &quot;SELECT * FROM inventoryChanges WHERE abs(x - &quot; .. xpos .. &quot;) &lt;= &quot; .. range .. &quot; AND abs(z - &quot; .. zpos .. &quot;) &lt;= &quot; .. range .. &quot; AND timestamp &gt;= '&quot; .. os.date(&quot;%Y-%m-%d %H:%M:%S&quot;, os.time() - (tonumber(hours) * 3600)) .. &quot;' &quot;
			else
				sql = &quot;SELECT * FROM inventoryChanges WHERE abs(x - &quot; .. xpos .. &quot;) &lt;= &quot; .. range .. &quot; AND abs(z - &quot; .. zpos .. &quot;) &lt;= &quot; .. range .. &quot; AND timestamp &gt;= '&quot; .. os.date(&quot;%Y-%m-%d %H:%M:%S&quot;, os.time() - (tonumber(days) * 86400)) .. &quot;' &quot;
			end

			if session ~= 0 then
				sql = &quot;SELECT * FROM inventoryChanges WHERE abs(x - &quot; .. xpos .. &quot;) &lt;= &quot; .. range .. &quot; AND abs(z - &quot; .. zpos .. &quot;) &lt;= &quot; .. range .. &quot; AND session = &quot; .. session .. &quot; &quot;
			end

			if pid ~= nil then
				sql = sql .. &quot;AND steam = &quot; .. pid .. &quot; &quot;
			end

			if qty ~= nil then
				if tonumber(qty) &gt; 0 then
					sql = sql .. &quot;AND delta &gt; &quot; .. qty .. &quot; &quot;
				else
					sql = sql .. &quot;AND delta &lt; &quot; .. qty .. &quot; &quot;
				end
			end

			if item ~= nil then
				sql = sql .. &quot;AND item like '%&quot; .. item .. &quot;%'&quot;
			end

			irc_QueueMsg(irc_params[1], &quot;Inventory tracking data for query:&quot;)
			irc_QueueMsg(irc_params[1], sql)

			cursor,errorString = conn:execute(sql)
			if cursor:numrows() == 0 then
				irc_QueueMsg(irc_params[1], &quot;No inventory tracking is recorded for your search parameters.&quot;)
			else
				irc_QueueMsg(irc_params[1], &quot;&quot;)
				irc_QueueMsg(irc_params[1], &quot;   id   |      steam       |      timestamp     |    item     | qty | x y z | session | name&quot;)
				row = cursor:fetch({}, &quot;a&quot;)

				rows = cursor:numrows()

				if rows &gt; 50 then
					irc_QueueMsg(name, &quot;***** Report length &quot; .. rows .. &quot; rows.  Cancel it with: nuke irc *****&quot;)
				end

				while row do
					msg = row.id .. &quot;, &quot; .. row.steam .. &quot;, &quot; .. row.timestamp .. &quot;, &quot; .. row.item .. &quot;, &quot; .. row.delta .. &quot;, &quot; .. row.x .. &quot; &quot; .. row.y .. &quot; &quot; .. row.z .. &quot;, &quot; .. row.session .. &quot;, &quot; .. players[row.steam].name
					irc_QueueMsg(irc_params[1], msg)
					row = cursor:fetch(row, &quot;a&quot;)	
				end
			end

			irc_QueueMsg(irc_params[1], &quot;&quot;)
			return
		end

		if debug then dbug(&quot;debug ircmessage 6&quot;) end

		if words[1] == &quot;announcements&quot; then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			counter = 1
			cursor,errorString = conn:execute(&quot;SELECT * FROM announcements&quot;)
			if cursor:numrows() == 0 then
				irc_QueueMsg(irc_params[1], &quot;There are no announcements recorded.&quot;)
			else
				irc_QueueMsg(irc_params[1], &quot;The server announcements are:&quot;)
				row = cursor:fetch({}, &quot;a&quot;)
				while row do
					msg = &quot;Announcement (&quot; .. counter .. &quot;) &quot; .. row.message
					counter = counter + 1
					irc_QueueMsg(irc_params[1], msg)
					row = cursor:fetch(row, &quot;a&quot;)	
				end
			end

			irc_QueueMsg(irc_params[1], &quot;&quot;)
			return
		end

		if debug then dbug(&quot;debug ircmessage 7&quot;) end

		if words[1] == &quot;add&quot; and words[2] == &quot;announcement&quot; and words[3] ~= nil then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			msg = string.sub(msg, 17, string.len(msg))

			conn:execute(&quot;INSERT INTO announcements (message, startdate, enddate) VALUES ('&quot; .. escape(msg) .. &quot;',&quot; .. os.date(&quot;%Y-%m-%d&quot;, os.time()) .. &quot;,'2020-01-01')&quot;)

			irc_QueueMsg(irc_params[1], &quot;New announcement added.&quot;)
			irc_QueueMsg(irc_params[1], &quot;&quot;)
			return
		end

		if debug then dbug(&quot;debug ircmessage 8&quot;) end

		if words[1] == &quot;delete&quot; and words[2] == &quot;announcement&quot; and words[3] ~= nil then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			counter = 1
			cursor,errorString = conn:execute(&quot;SELECT * FROM announcements&quot;)
			row = cursor:fetch({}, &quot;a&quot;)
			while row do
				if tonumber(number) == counter then
					conn:execute(&quot;DELETE FROM announcements WHERE id = &quot; .. row.id)
				end

				counter = counter + 1
				row = cursor:fetch(row, &quot;a&quot;)	
			end

			irc_QueueMsg(irc_params[1], &quot;Announcement &quot; .. number .. &quot; deleted.&quot;)
			irc_QueueMsg(irc_params[1], &quot;&quot;)
			return
		end

		if debug then dbug(&quot;debug ircmessage 9&quot;) end

		if (words[1] == &quot;who&quot; and words[2] == &quot;visited&quot;) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end
			
			if words[3] == nil then
				irc_QueueMsg(irc_params[1], &quot;See who visited a player location or base.&quot;)
				irc_QueueMsg(irc_params[1], &quot;Example with defaults:  who visited smeg days 1 range 10 height 4&quot;)
				irc_QueueMsg(irc_params[1], &quot;Example with coords:  who visited xpos 0 zpos 0 ypos 100 height 5 days 1 range 20&quot;)
				irc_QueueMsg(irc_params[1], &quot;Setting hours will reset days to zero&quot;)						
				irc_QueueMsg(irc_params[1], &quot;Defaults: days = 1 or hours = 0, range = 10&quot;)
				irc_QueueMsg(irc_params[1], &quot;To see who visited a player's bases add bases at the end.  To report at players position and bases add all.&quot;)
				irc_QueueMsg(irc_params[1], &quot;&quot;)
				return
			end			

			-- irc_params[1] == irc user
			-- irc_params[2] == target steam id
			-- irc_params[3] == distance (optional default=10
			-- irc_params[4] == days (optional default=1

			-- optional params
				-- range &lt;distance in metres&gt; Default 10
				-- days.  Default is 1 day ago from today (local time not server)

			if words[3] ~= &quot;player&quot; then
				name1 = string.trim(words[3])
			else
				name1 = string.trim(words[4])
			end

			pid = LookupPlayer(name1)
			days = 1
			hours = 0
			range = 10
			basesOnly = &quot;player&quot;

			if pid ~= nil then
				xpos = players[pid].xPos
				ypos = players[pid].yPos
				zpos = players[pid].zPos
			end

			for i=3,wordCount,1 do
				if words[i] == &quot;range&quot; then
					range = tonumber(words[i+1])
				end					
					
				if words[i] == &quot;days&quot; then
					days = tonumber(words[i+1])
					hours = 0
				end								

				if words[i] == &quot;hours&quot; then
					hours = tonumber(words[i+1])
					days = 0
				end								

				if words[i] == &quot;base&quot; then
					baseOnly = &quot;base&quot;
				end	

				if words[i] == &quot;all&quot; then
					baseOnly = &quot;all&quot;
				end	

				if words[i] == &quot;xpos&quot; then
					xpos = tonumber(words[i+1])
				end	

				if words[i] == &quot;ypos&quot; then
					ypos = tonumber(words[i+1])
				end	

				if words[i] == &quot;zpos&quot; then
					zpos = tonumber(words[i+1])
				end	

				if words[i] == &quot;height&quot; then
					height = tonumber(words[i+1])
				end	
			end

			if basesOnly == &quot;base&quot; or basesOnly == &quot;all&quot; then
				if players[pid].homeX ~= 0 and players[pid].homeZ ~= 0 then
					irc_QueueMsg(irc_params[1], &quot;Players who visited within &quot; .. range .. &quot; metres of base 1 of &quot; .. players[pid].name)
					dbWho(irc_params[1], players[pid].homeX, players[pid].homeY, players[pid].homeZ, range, days, hours, height)
				else
					irc_QueueMsg(irc_params[1], &quot;Player &quot; .. players[pid].name .. &quot; does not have a base set.&quot;)
				end

				if players[pid].home2X ~= 0 and players[pid].home2Z ~= 0 then
					irc_QueueMsg(irc_params[1], &quot;&quot;)
					irc_QueueMsg(irc_params[1], &quot;Players who visited within &quot; .. range .. &quot; metres of base 2 of &quot; .. players[pid].name)
					dbWho(irc_params[1], players[pid].home2X, players[pid].home2Y, players[pid].home2Z, range, days, hours, height)
				end
			end

			if basesOnly == &quot;player&quot; or basesOnly == &quot;all&quot; then
				irc_QueueMsg(irc_params[1], &quot;Players who visited within &quot; .. range .. &quot; metres (X) &quot; .. players[pid].xPos .. &quot; (Z) &quot; .. players[pid].zPos .. &quot; of player &quot; .. players[pid].name)
				dbWho(irc_params[1], players[pid].xPos, players[pid].yPos, players[pid].zPos, range, days, hours, height)
			end

			irc_QueueMsg(irc_params[1], &quot;&quot;)

			return
		end

		if debug then dbug(&quot;debug ircmessage 10&quot;) end

		if (words[1] == &quot;pay&quot;) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			name1 = string.sub(msg, string.find(msg, &quot; to &quot;) + 4, string.len(msg))
			name1 = string.trim(name1)
			pid = LookupPlayer(name1)

			players[pid].cash = players[pid].cash + number		
			message(&quot;pm &quot; .. pid .. &quot; &quot; .. players[ircid].name .. &quot; just paid you &quot; .. number .. &quot; zennies!  You now have &quot; .. players[pid].cash .. &quot; zennies!  KA-CHING!!&quot;)

			msg = &quot;You just paid &quot; .. number .. &quot; zennies to &quot; .. players[pid].name .. &quot; giving them a total of &quot; .. players[pid].cash .. &quot; zennies.&quot;
			irc_QueueMsg(irc_params[1], msg)
			return
		end

		if debug then dbug(&quot;debug ircmessage 11&quot;) end

		if (words[1] == &quot;claims&quot;) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			pid = nil

			if (words[2] ~= nil) then
				name1 = string.sub(msg, string.find(msgLower, &quot;claims&quot;) + 7)
				name1 = string.trim(name1)
				pid = LookupPlayer(name1)
			end

			if pid ~= nil then
				if players[pid].keystones == 0 then
					msg = players[pid].name .. &quot; has not placed any claims.&quot;
  					irc_QueueMsg(irc_params[1], msg)
					return
				end
			end


			if pid == nil then
				for k, v in pairs(players) do
					if tonumber(v.keystones) &gt; 0 then
						msg = v.keystones .. &quot;   claims belong to &quot; .. k .. &quot; &quot; .. v.name
						irc_QueueMsg(irc_params[1], msg)
					end
				end
			else
				msg = players[pid].name .. &quot; has placed &quot; .. players[pid].keystones .. &quot; at these coordinates..&quot;
				irc_QueueMsg(irc_params[1], msg)

				cursor,errorString = conn:execute(&quot;SELECT * FROM keystones WHERE steam = &quot; .. pid)
				row = cursor:fetch({}, &quot;a&quot;)
				while row do
					msg = row.x .. &quot; &quot; .. row.y .. &quot; &quot; .. row.z
					irc_QueueMsg(irc_params[1], msg)
					row = cursor:fetch(row, &quot;a&quot;)	
				end
			end

			irc_QueueMsg(irc_params[1], &quot;&quot;)
			return
		end

		if debug then dbug(&quot;debug ircmessage 12&quot;) end

		if (words[1] == &quot;cmd&quot;) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			msg = string.trim(string.sub(msg, string.find(msgLower, &quot;cmd&quot;) + 4))
			gmsg(msg, ircid)
			return
		end

		if debug then dbug(&quot;debug ircmessage 13&quot;) end

		if (words[1] == &quot;pm&quot;) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end

			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			pid = LookupPlayer(words[2])

			if pid ~= nil then
				msg = string.sub(msg, string.find(msg, words2[2], nil, true) + string.len(words2[2]) + 1)

				if igplayers[pid] then
					message(&quot;pm &quot; .. pid .. &quot; &quot; .. name .. &quot;-irc: [i]&quot; .. msg .. &quot;[-]&quot;)
					irc_QueueMsg(name, &quot;pm sent to &quot; .. players[pid].name .. &quot; you said &quot; .. msg)
				else
					conn:execute(&quot;INSERT INTO mail (sender, recipient, message) VALUES (&quot; .. ircid .. &quot;,&quot; .. pid .. &quot;, '&quot; .. escape(msg) .. &quot;')&quot;)
					irc_QueueMsg(name, &quot;Mail sent to &quot; .. players[pid].name .. &quot; you said &quot; .. msg)
					irc_QueueMsg(name, &quot;They will receive your message when they join the server.&quot;)
				end
			else
				irc_QueueMsg(name, &quot;No player called &quot; .. words[2] .. &quot; found.&quot;)
			end

			return
		end

		if debug then dbug(&quot;debug ircmessage 14&quot;) end

-- ************************************************************************************************8
		if (words[1] == &quot;con&quot;) and accessLevel(ircid) &lt; 3 then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			msg = string.lower(string.trim(string.sub(msg, string.find(msgLower, &quot;con&quot;) + 4)))
			send(msg)

			if string.sub(msg, 1, 4) == &quot;help&quot; then
				echoConsoleTo = name
				tempTimer( 2, [[ echoConsoleTo = nil ]] )
				tempTimer( 2, [[ echoConsole = nil ]] )
			end

			if msg == &quot;se&quot; or msg == &quot;ban list&quot; or msg == &quot;gg&quot; or string.sub(msg, 1, 3) == &quot;si &quot; or string.sub(msg, 1, 3) == &quot;llp&quot; then
				echoConsoleTo = name
				echoConsoleTrigger = &quot;&quot;

				if string.sub(msg, 1, 3) == &quot;si &quot; then
					echoConsoleTrigger = string.sub(msg, 4)
				end

				tempTimer( 2, [[ echoConsoleTo = nil ]] )
				tempTimer( 2, [[ echoConsole = nil ]] )
			end

			return
		end
-- ************************************************************************************************

		if debug then dbug(&quot;debug ircmessage 15&quot;) end

		if (words[1] == &quot;villagers&quot; and words[2] == nil) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_List_Villagers(name)
			return
		end

		if debug then dbug(&quot;debug ircmessage 16&quot;) end

		if (words[1] == &quot;base&quot;) and (words[2] == &quot;cooldown&quot; or words[2] == &quot;timer&quot;) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			if words[3] == nil then
				table.insert(irc_params, &quot;/base can only be used once every &quot; .. (server.baseCooldown / 60) .. &quot; minutes for players and &quot; .. math.floor((server.baseCooldown / 60) / 2) .. &quot; minutes for donors.&quot;)
				irc_message()
				return
			end

			if words[3] ~= nil then
				server.baseCooldown = tonumber(words[3])
				table.insert(irc_params, &quot; The base cooldown timer is now &quot; .. (server.baseCooldown / 60) .. &quot; minutes for players and &quot; .. math.floor((server.baseCooldown / 60) / 2) .. &quot; minutes for donors.&quot;)
				irc_message()

				conn:execute(&quot;UPDATE server SET baseCooldown = 0&quot;)
				return
			end
		end

		if debug then dbug(&quot;debug ircmessage 17&quot;) end

		if (words[1] == &quot;set&quot; and words[2] == &quot;rules&quot;) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			if words[3] ~= nil then
				server.rules = string.sub(msg, string.find(msgLower, &quot;set rules&quot;) + 9)
				table.insert(irc_params, &quot;New server rules recorded. &quot; .. server.rules)
				irc_message()

				conn:execute(&quot;UPDATE server SET rules = '&quot; .. server.rules .. &quot;'&quot;)
				return
			end
		end

		if debug then dbug(&quot;debug ircmessage 18&quot;) end

		if (words[1] == &quot;motd&quot;) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			if words[2] == nil then
				table.insert(irc_params, &quot;MOTD is &quot; .. server.MOTD)
				irc_message()
				return
			end

			if words[2] == &quot;delete&quot; or words[2] == &quot;clear&quot; then
				server.MOTD = nil
				table.insert(irc_params, &quot;Message of the day has been deleted.&quot;)
				irc_message()

				conn:execute(&quot;UPDATE server SET MOTD = ''&quot;)
				return
			end

			table.insert(irc_params, &quot;To change the MOTD type set motd &lt;new message of the day&gt;&quot;)
			irc_message()
			return
		end

		if debug then dbug(&quot;debug ircmessage 19&quot;) end

		if (words[1] == &quot;set&quot; and words[2] == &quot;motd&quot;) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			if words[3] ~= nil then
				server.MOTD = string.sub(msg, string.find(msgLower, &quot;set motd&quot;) + 9)
				table.insert(irc_params, &quot;New message of the day recorded. &quot; .. server.MOTD)
				irc_message()

				conn:execute(&quot;UPDATE server SET MOTD = '&quot; .. server.MOTD .. &quot;'&quot;)
				return
			end
		end

		if debug then dbug(&quot;debug ircmessage 20&quot;) end

		if (words[1] == &quot;list&quot;) and (words[2] == &quot;tables&quot;) and (words[3] == nil) and (accessLevel(ircid) == 0) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_ListTables()
			return
		end

		if debug then dbug(&quot;debug ircmessage 21&quot;) end

		if (words[1] == &quot;show&quot;) and (words[2] == &quot;table&quot;) and (words[3] ~= nil) and (accessLevel(ircid) == 0) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			name1 = string.trim(string.sub(msg, string.find(msgLower, &quot;table&quot;) + 6))
			table.insert(irc_params, name1)
			irc_ShowTable()
			return
		end

		if debug then dbug(&quot;debug ircmessage 22&quot;) end

		if (words[1] == &quot;reset&quot;) and (words[2] == &quot;bot&quot;) and (accessLevel(ircid) == 0) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end
			
			irc_params = {}
			table.insert(irc_params, server.ircMain)
			
			if resetbotCount == nil then resetbotCount = 0 end
			
			if tonumber(resetbotCount) &lt; 2 then
				resetbotCount = tonumber(resetbotCount) + 1
				table.insert(irc_params, &quot;ALERT! Only do this after a server wipe!  To reset me repeat the reset bot command again.&quot;)
			end

			ResetBot()
			
			resetbotCount = 0

			table.insert(irc_params, &quot;I have been reset.  All bases, inventories etc are forgotten, but not the players.&quot;)
			irc_message()
			return
		else
			resetbotCount = 0
		end

		if debug then dbug(&quot;debug ircmessage 23&quot;) end

		if words[1] == &quot;stop&quot; and words[2] == &quot;translating&quot; and words[3] ~= nil then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			name1 = string.sub(msg, string.find(msgLower, &quot;translating&quot;) + 11)
			name1 = string.trim(name1)
			pid = LookupPlayer(name1)

			if (pid ~= nil) then
				players[pid].ircTranslate = nil
				players[pid].translate = nil
				table.insert(irc_params, &quot;Chat from &quot; .. players[pid].name .. &quot; will not be translated&quot;)
				irc_message()

				conn:execute(&quot;UPDATE players SET translate = 0, ircTranslate = 0 WHERE steam = &quot; .. pid)
			else
				table.insert(irc_params, &quot;No player found matching &quot; .. name1)
				irc_message()
			end

			return
		end

		if debug then dbug(&quot;debug ircmessage 24&quot;) end

		if words[1] == &quot;translate&quot; and words[2] ~= nil then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			name1 = string.sub(msg, string.find(msgLower, &quot;translate&quot;) + 10)
			name1 = string.trim(name1)
			pid = LookupPlayer(name1)

			if (pid ~= nil) then
				players[pid].translate = true
				table.insert(irc_params, &quot;Chat from &quot; .. players[pid].name .. &quot; will be translated in-game&quot;)
				irc_message()

				conn:execute(&quot;UPDATE players SET translate = 1 WHERE steam = &quot; .. pid)
			else
				table.insert(irc_params, &quot;No player found matching &quot; .. name1)
				irc_message()
			end

			return
		end

		if debug then dbug(&quot;debug ircmessage 25&quot;) end

		if words[1] == &quot;stealth&quot; and words[2] == &quot;translate&quot; and words[3] ~= nil then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			name1 = string.sub(msg, string.find(msgLower, &quot;translate&quot;) + 10)
			name1 = string.trim(name1)
			pid = LookupPlayer(name1)

			if (pid ~= nil) then
				players[pid].ircTranslate = true
				table.insert(irc_params, &quot;Chat from &quot; .. players[pid].name .. &quot; will be translated to irc only&quot;)
				irc_message()

				conn:execute(&quot;UPDATE players SET ircTranslate = 1 WHERE steam = &quot; .. pid)
			else
				table.insert(irc_params, &quot;No player found matching &quot; .. name1)
				irc_message()
			end

			return
		end
		
		if debug then dbug(&quot;debug ircmessage 26&quot;) end
		
		if (words[1] == &quot;open&quot; and words[2] == &quot;shop&quot;) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			server.allowShop = true
			
			table.insert(irc_params, &quot;Players can use the shop and play in the lottery.&quot;)
			irc_message()

			conn:execute(&quot;UPDATE server SET allowShop = 1&quot;)
			return
		end			
		
		if debug then dbug(&quot;debug ircmessage 27&quot;) end
		
		if (words[1] == &quot;close&quot; and words[2] == &quot;shop&quot;) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			server.allowShop = false
			
			table.insert(irc_params, &quot;Only staff can use the shop.&quot;)
			irc_message()

			conn:execute(&quot;UPDATE server SET allowShop = 0&quot;)
			return
		end					

		if debug then dbug(&quot;debug ircmessage 28&quot;) end

		if (words[1] == &quot;shop&quot; and words[2] == &quot;variation&quot; and words[3] ~= nil) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			LookupShop(words[3])

			table.insert(irc_params, &quot;You have changed the price variation for &quot; .. shopItem .. &quot; to &quot; .. words2[4])
			irc_message()

			conn:execute(&quot;UPDATE shop SET variation = &quot; .. tonumber(words2[4]) .. &quot; WHERE item = '&quot; .. escape(shopItem) .. &quot;'&quot;)
			return
		end	

		if debug then dbug(&quot;debug ircmessage 29&quot;) end

		if (words[1] == &quot;shop&quot; and words[2] == &quot;special&quot; and words[3] ~= nil) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			LookupShop(words[3], true)
			
			if shopItem == &quot;&quot; then
				irc_QueueMsg(irc_params[1], &quot;The item &quot; .. words[3] .. &quot; does not exist.&quot;)			
				return
			end

			table.insert(irc_params, &quot;You have changed the special for &quot; .. shopItem .. &quot; to &quot; .. words2[4])
			irc_message()

			conn:execute(&quot;UPDATE shop SET special = &quot; .. tonumber(words2[4]) .. &quot; WHERE item = '&quot; .. escape(shopItem) .. &quot;'&quot;)
			return
		end	

		if debug then dbug(&quot;debug ircmessage 30&quot;) end

		if (words[1] == &quot;shop&quot; and words[2] == &quot;price&quot; and words[3] ~= nil) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			LookupShop(words[3], true)
			
			if shopItem == &quot;&quot; then
				irc_QueueMsg(irc_params[1], &quot;The item &quot; .. words[3] .. &quot; does not exist.&quot;)			
				return
			end			

			table.insert(irc_params, &quot;You have changed the price for &quot; .. shopItem .. &quot; to &quot; .. words2[4])
			irc_message()

			conn:execute(&quot;UPDATE shop SET price = &quot; .. tonumber(words2[4]) .. &quot; WHERE item = '&quot; .. escape(shopItem) .. &quot;'&quot;)
			return
		end	

		if debug then dbug(&quot;debug ircmessage 31&quot;) end

		if (words[1] == &quot;shop&quot; and words[2] == &quot;max&quot; and words[3] ~= nil) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			LookupShop(words[3], true)
			
			if shopItem == &quot;&quot; then
				irc_QueueMsg(irc_params[1], &quot;The item &quot; .. words[3] .. &quot; does not exist.&quot;)			
				return
			end			

			table.insert(irc_params, &quot;You have changed the max stock level for &quot; .. shopItem .. &quot; to &quot; .. words[4])
			irc_message()

			conn:execute(&quot;UPDATE shop SET maxStock = &quot; .. tonumber(words2[4]) .. &quot; WHERE item = '&quot; .. escape(shopItem) .. &quot;'&quot;)
			return
		end	

		if debug then dbug(&quot;debug ircmessage 32&quot;) end

		if (words[1] == &quot;shop&quot; and words[2] == &quot;restock&quot; and words[3] ~= nil) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			LookupShop(wordsOld[3], true)
			shopStock = tonumber(words2[4])
			
			if shopItem == &quot;&quot; then
				irc_QueueMsg(irc_params[1], &quot;The item &quot; .. wordsOld[3] .. &quot; does not exist.&quot;)			
				return
			end

			if (shopStock &lt; 0) then
				shopStock = -1
				irc_QueueMsg(irc_params[1], shopItem .. &quot; now has unlimited stock&quot;)
			else
				irc_QueueMsg(irc_params[1], &quot;There are now &quot; .. shopStock .. &quot; of &quot; .. shopItem .. &quot; for sale.&quot;)
			end

			conn:execute(&quot;UPDATE shop SET stock = &quot; .. shopStock .. &quot; WHERE item = '&quot; .. escape(shopItem) .. &quot;'&quot;)
			return
		end
		
		if debug then dbug(&quot;debug ircmessage 33&quot;) end
		
		if (words[1] == &quot;shop&quot; and words[2] == &quot;add&quot; and words[3] == &quot;category&quot;) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end		

			shopCategories[words[4]] = {}
			
			for i=2,wordCount,1 do 			
				if words[i] == &quot;code&quot; then
					shopCategories[words[4]].code  = words[i+1]
					shopCategories[words[4]].index = 1

					conn:execute(&quot;INSERT INTO shopCategories (category, idx, code) VALUES ('&quot; .. escape(words[4]) .. &quot;',1,'&quot; .. escape(words[i+1]) .. &quot;')&quot;)
				end					
			end

			if (shopCategories[words[4]].code == nil) then
				irc_QueueMsg(irc_params[1], &quot;A code is required. Do not include numbers in the code.&quot;)
				return
			end
			
			irc_QueueMsg(irc_params[1], &quot;You added or updated the category &quot; .. words[4] .. &quot;.&quot;)
			return
		end	

		if debug then dbug(&quot;debug ircmessage 34&quot;) end
		
		if (words[1] == &quot;shop&quot; and words[2] == &quot;remove&quot; and words[3] == &quot;category&quot;) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end
			
			if not shopCategories[words[4]] then
				irc_QueueMsg(irc_params[1], &quot;The category &quot; .. words[4] .. &quot; does not exist.&quot;)
				return
			end

			shopCategories[words[4]] = nil
			conn:execute(&quot;DELETE FROM shopCategories WHERE category = '&quot; .. escape(words[4]) .. &quot;')&quot;)
			conn:execute(&quot;UPDATE shop SET category = '' WHERE category = '&quot; .. escape(words[4]) .. &quot;')&quot;)
			
			irc_QueueMsg(irc_params[1], &quot;You removed the &quot; .. words[4] .. &quot; category from the shop.  Any items using it now have no category.&quot;)
			return
		end			
		
		if debug then dbug(&quot;debug ircmessage 35&quot;) end
		
		if (words[1] == &quot;shop&quot; and words[2] == &quot;change&quot; and words[3] == &quot;category&quot;) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			if words[5] == &quot;to&quot; then
				oldCategory = words[4]
				newCategory = words[6]
			else
				oldCategory = words[4]			
				newCategory = words[5]				
			end
			
			if not shopCategories[oldCategory] then
				irc_QueueMsg(irc_params[1], &quot;The category &quot; .. words[4] .. &quot; does not exist.&quot;)
				return
			end
		
			shopCategories[oldCategory] = nil
			shopCategories[newCategory] = {}

			conn:execute(&quot;UPDATE shopCategories SET category = '&quot; .. escape(newCategory) .. &quot;' WHERE category = '&quot; .. escape(oldCategory) .. &quot;')&quot;)
			conn:execute(&quot;UPDATE shop SET category = '&quot; .. escape(newCategory) .. &quot;' WHERE category = '&quot; .. escape(oldCategory) .. &quot;')&quot;)
			
			for i=2,wordCount,1 do 			
				if words[i] == &quot;code&quot; then
					shopCategories[newCategory].code  = words[i+1]
				end					
			end
			
			irc_QueueMsg(irc_params[1], &quot;You changed category &quot; .. oldCategory .. &quot; to &quot; .. newCategory .. &quot;. Any items using &quot; .. oldCategory .. &quot; have been updated.&quot;)
			return
		end		

		if debug then dbug(&quot;debug ircmessage 36&quot;) end

		if (words[1] == &quot;inv&quot;) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			name1 = string.trim(string.sub(msg, string.find(msgLower, &quot;inv&quot;) + 4))
			pid = LookupPlayer(name1)

			if (pid ~= nil) then
				table.insert(irc_params, pid)
				table.insert(irc_params, players[pid].name)
				irc_NewInventory(pid)
			end

			return
		end
		
		if debug then dbug(&quot;debug ircmessage 37&quot;) end

		if (words[1] == &quot;list&quot; and words[2] == &quot;villagers&quot; and words[3] ~= nil) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			name1 = string.sub(msg, string.find(msgLower, &quot;villagers&quot;) + 10)
			name1 = string.trim(name1)
			pid = LookupVillage(name1)

			if (pid ~= nil) then
				table.insert(irc_params, pid)
				table.insert(irc_params, players[pid].name)
				irc_ListVillagers()
			else	
				table.insert(irc_params, &quot;No village found matching &quot; .. name1)
				irc_message()
			end

			return
		end

		if debug then dbug(&quot;debug ircmessage 38&quot;) end

		if words[1] == &quot;list&quot; and (words[2] == &quot;bases&quot; or words[3] == &quot;bases&quot;) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			pid = nil
			for i=2,wordCount,1 do
				if words[i] == &quot;bases&quot; then
					pid = words[i+1]
				end	
			end

			if words[2] == &quot;protected&quot; then
				table.insert(irc_params, &quot;protected&quot;)
			else
				table.insert(irc_params, &quot;all&quot;)
			end

			if pid ~= nil then
				pid = LookupPlayer(pid)
			end

			irc_ListBases(pid)

			return
		end

		if debug then dbug(&quot;debug ircmessage 39&quot;) end

		if (words[1] == &quot;add&quot; and words[2] == &quot;bad&quot; and words[3] == &quot;item&quot; and words[4] ~= nil and accessLevel(ircid) == 0) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			name1 = wordsOld[4]

			-- add the bad item to badItems table
			badItems[name1] = {}

			conn:execute(&quot;INSERT INTO badItems (item) VALUES ('&quot; .. escape(name1) .. &quot;')&quot;)

			table.insert(irc_params, name1 .. &quot; has been added to the bad items list.&quot;)
			irc_message()

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			table.insert(irc_params, name1 .. &quot; has been added to the bad items list.&quot;)
			irc_message()

			return
		end

		if debug then dbug(&quot;debug ircmessage 40&quot;) end

		if (words[1] == &quot;remove&quot; and words[2] == &quot;bad&quot; and words[3] == &quot;item&quot; and words[4] ~= nil and accessLevel(ircid) == 0) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			name1 = wordsOld[4]

			-- remove the bad item from the badItems table
			badItems[name1] = nil

			conn:execute(&quot;DELETE FROM badItems WHERE item = '&quot; .. escape(name1) .. &quot;'&quot;)

			table.insert(irc_params, name1 .. &quot; has been removed from the bad items list.&quot;)
			irc_message()

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			table.insert(irc_params, name1 .. &quot; has been removed from the bad items list.&quot;)
			irc_message()

			return
		end

		if debug then dbug(&quot;debug ircmessage 41&quot;) end

		if (words[1] == &quot;near&quot;) then	
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end	
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			if words[2] == nil then
				irc_QueueMsg(name, &quot;Lists players, bases and locations near a player or coordinate.&quot;)
				irc_QueueMsg(name, &quot;Usage: near player &lt;name&gt;&quot;)
				irc_QueueMsg(name, &quot;optional: range &lt;number&gt;&quot;)
				irc_QueueMsg(name, &quot;optional: Instead of player use xpos &lt;number&gt; zpos &lt;number&gt;&quot;)

			end
			
			name1 = nil
			range = 200
			xPos = 0
			zPos = 0
			offline = false
			
			for i=2,wordCount,1 do
				if words[i] == &quot;player&quot; then
					name1 = words[i+1]
				end	

				if words[i] == &quot;range&quot; then
					range = tonumber(words[i+1])
				end	

				if words[i] == &quot;xpos&quot; then
					xPos = tonumber(words[i+1])
				end	

				if words[i] == &quot;zpos&quot; then
					zPos = tonumber(words[i+1])
				end	

				if words[i] == &quot;offline&quot; then
					offline = true
				end	
			end			
	
			if name1 ~= nil then
				name1 = string.trim(name1)
				name1 = LookupPlayer(name1)

				if name1 == nil then
					irc_QueueMsg(name, &quot;No player found matching &quot; .. name1)
					return
				end
			end

			if name1 == nil then
				irc_PlayersNearPlayer(name, &quot;&quot;, range, xPos, zPos, offline)
				irc_BasesNearPlayer(name, &quot;&quot;, range, xPos, zPos)
				irc_LocationsNearPlayer(name, &quot;&quot;, range, xPos, zPos)
			else
				irc_PlayersNearPlayer(name, name1, range, xPos, zPos, offline)
				irc_BasesNearPlayer(name, name1, range, xPos, zPos)
				irc_LocationsNearPlayer(name, name1, range, xPos, zPos)
			end

			return
		end

		if debug then dbug(&quot;debug ircmessage 42&quot;) end

		if (words[1] == &quot;bases&quot; or words[1] == &quot;homes&quot;) and words[2] == &quot;near&quot; and words[3] ~= nil then	
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end	
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			if string.find(msgLower, &quot;range&quot;) then
				name1 = string.sub(msg, string.find(msgLower, &quot;near&quot;) + 5, string.find(msgLower, &quot;range&quot;) - 1)
				number = string.sub(msg, string.find(msgLower, &quot;range&quot;) + 6)
			else
				name1 = string.sub(msg, string.find(msgLower, &quot;near&quot;) + 5)
			end

			name1 = string.trim(name1)
			pid = LookupPlayer(name1)

			if (pid ~= nil) then
				table.insert(irc_params, pid)
				table.insert(irc_params, players[pid].name)
				if string.find(msgLower, &quot;range&quot;) then
					table.insert(irc_params, number)
				end

				irc_BasesNearPlayer()
			else	
				table.insert(irc_params, &quot;No player found matching &quot; .. name1)
				irc_message()
			end

			return
		end

		if debug then dbug(&quot;debug ircmessage 43&quot;) end

		if (words[1] == &quot;info&quot; and words[2] ~= nil) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			name1 = string.sub(msg, string.find(msgLower, &quot;info&quot;) + 5)
			name1 = string.trim(name1)
			pid = LookupPlayer(name1)

			if (pid ~= nil) then
				table.insert(irc_params, pid)
				table.insert(irc_params, players[pid].name)
				irc_PlayerShortInfo()
				irc_friends()
			else	
				table.insert(irc_params, &quot;No player found matching &quot; .. name1)
				irc_message()
			end

			return
		end

		if debug then dbug(&quot;debug ircmessage 44&quot;) end

		if (words[1] == &quot;add&quot; and words[2] == &quot;donor&quot; and words[3] ~= nil and owners[ircid]) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			name1 = string.sub(msg, string.find(msgLower, &quot;donor&quot;) + 6)
			name1 = string.trim(name1)
			pid = LookupPlayer(name1)

			if pid ~= nil then
				-- update the player record
				players[pid].donor = true
				table.insert(irc_params, players[pid].name .. &quot; is now a donor.&quot;)
				irc_message()

				conn:execute(&quot;UPDATE players SET donor = 1 WHERE steam = &quot; .. pid)
			end

			return
		end

		if debug then dbug(&quot;debug ircmessage 45&quot;) end

		if (words[1] == &quot;remove&quot; and words[2] == &quot;donor&quot; and words[3] ~= nil and owners[ircid]) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			name1 = string.sub(msg, string.find(msgLower, &quot;donor&quot;) + 6)
			name1 = string.trim(name1)
			pid = LookupPlayer(name1)

			if pid ~= nil then
				-- update the player record
				players[pid].donor = false
				table.insert(irc_params, players[pid].name .. &quot; is no longer a donor.&quot;)
				irc_message()

				conn:execute(&quot;UPDATE players SET donor = 0 WHERE steam = &quot; .. pid)
			end

			return
		end

		if debug then dbug(&quot;debug ircmessage 46&quot;) end

		if (words[1] == &quot;add&quot; and words[2] == &quot;owner&quot; and words[3] ~= nil and owners[ircid]) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			name1 = string.sub(msg, string.find(msgLower, &quot;owner&quot;) + 6)
			name1 = string.trim(name1)
			pid = LookupPlayer(name1)

			if pid ~= nil then
				-- add the steamid to the owners table
				owners[pid] = {}
				table.insert(irc_params, players[pid].name .. &quot; has been added as a server owner.&quot;)
				irc_message()

				send(&quot;admin add &quot; .. pid .. &quot; 0&quot;)
			end

			return
		end

		if debug then dbug(&quot;debug ircmessage 47&quot;) end

		if (words[1] == &quot;remove&quot; and words[2] == &quot;owner&quot; and words[3] ~= nil and owners[ircid]) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			name1 = string.sub(msg, string.find(msgLower, &quot;owner&quot;) + 6)
			name1 = string.trim(name1)
			pid = LookupPlayer(name1)

			if pid ~= nil then
				-- remove the steamid from the owners table
				owners[pid] = nil
				table.insert(irc_params, players[pid].name .. &quot; is no longer a server owner.&quot;)
				irc_message()

				send(&quot;admin remove &quot; .. pid)
			end

			return
		end

		if debug then dbug(&quot;debug ircmessage 48&quot;) end

		if (words[1] == &quot;add&quot; and words[2] == &quot;admin&quot; and words[3] ~= nil and owners[ircid]) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			name1 = string.sub(msg, string.find(msgLower, &quot;admin&quot;) + 6)
			name1 = string.trim(name1)
			pid = LookupPlayer(name1)

			if pid ~= nil then
				-- add the steamid to the admins table
				admins[pid] = {}
				table.insert(irc_params, players[pid].name .. &quot; has been added as a server admin.&quot;)
				irc_message()

				send(&quot;admin add &quot; .. pid .. &quot; 1&quot;)
			end
		
			return
		end

		if debug then dbug(&quot;debug ircmessage 49&quot;) end

		if (words[1] == &quot;remove&quot; and words[2] == &quot;admin&quot; and words[3] ~= nil and accessLevel(ircid) == 0) then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			name1 = string.sub(msg, string.find(msgLower, &quot;admin&quot;) + 6)
			name1 = string.trim(name1)

			pid = LookupPlayer(name1)

			if pid ~= nil then
				-- remove the steamid from the admins table
				admins[pid] = nil
				table.insert(irc_params, players[pid].name .. &quot; is no longer a server admin.&quot;)
				irc_message()

				send(&quot;admin remove &quot; .. pid)
			end

			return
		end

		if debug then dbug(&quot;debug ircmessage 50&quot;) end

		if (words[1] == &quot;permaban&quot;) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			name1 = string.trim(string.sub(msg, string.find(msgLower, &quot;permaban&quot;) + 9))
			pid = LookupPlayer(name1)

			if (pid ~= nil) then
				table.insert(irc_params, pid)
				table.insert(irc_params, players[pid].name)
			else
				if (string.len(name1) == 17) then
					banPlayer(pid, &quot;10 years&quot;, &quot;Permanent ban&quot;, ircid)

					table.insert(irc_params, name1 .. &quot; banned 10 years.&quot;)
					irc_message()

					conn:execute(&quot;UPDATE players SET permanentBan = 1 WHERE steam = &quot; .. pid)
					players[pid].permanentBan = true
				else
					table.insert(irc_params, &quot;No player found matching &quot; .. name1)
					irc_message()
				end
			end
			return
		end

		if debug then dbug(&quot;debug ircmessage 51&quot;) end

		if (words[1] == &quot;remove&quot; and words[2] == &quot;permaban&quot;) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			name1 = string.trim(string.sub(msg, string.find(msgLower, &quot;permaban&quot;) + 9))
			pid = LookupPlayer(name1)

			if (pid ~= nil) then
				table.insert(irc_params, pid)
				table.insert(irc_params, players[pid].name)

				conn:execute(&quot;UPDATE players SET permanentBan = 0 WHERE steam = &quot; .. pid)
				send(&quot;ban remove &quot; .. pid)
				players[pid].permanentBan = false

				table.insert(irc_params, &quot;Ban lifted for player &quot; .. name1)
				irc_message()
			else	
				table.insert(irc_params, &quot;No player found matching &quot; .. name1)
				irc_message()
			end
			return
		end

		if debug then dbug(&quot;debug ircmessage 52&quot;) end

		if (words[1] == &quot;add&quot; and words[2] == &quot;player&quot;) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			for i=3,wordCount,1 do 					
				if words[i] == &quot;login&quot; then
					login = words[i+1]
				end					
			end

 			name1 = string.trim(string.sub(msg, string.find(msgLower, &quot;player &quot;) + 7, string.find(msgLower, &quot; login&quot;) - 1))
			result = false

			for k, v in pairs(players) do
				if (login == v.ircPass) then
					result = true
					break
				end
			end

			if (result == true) then
				table.insert(irc_params, &quot;That password is already in use.  Please choose another.&quot;)
				tempTimer( 2, [[irc_message()]] )	
				return
			end

			pid = LookupOfflinePlayer(name1, &quot;all&quot;)
			if (pid ~= nil) then
				players[pid].ircPass = login
				players[pid].ircAuthenticated = false

				table.insert(irc_params, players[pid].name .. &quot; is now authorised to talk to ingame players&quot;)
				irc_message()
				conn:execute(&quot;UPDATE players SET ircPass = '&quot; .. escape(login) .. &quot;' WHERE steam = &quot; .. pid)
			end

			return
		end

		if debug then dbug(&quot;debug ircmessage 53&quot;) end

		if (words[1] == &quot;player&quot; and string.find(msgLower, &quot;unfriend&quot;)) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			name1 = string.trim(string.sub(msg, string.find(msgLower, &quot;player&quot;) + 7, string.find(msgLower, &quot;unfriend&quot;) - 1))
			name2 = string.trim(string.sub(msg, string.find(msgLower, &quot;unfriend&quot;) + 9))

			pid = LookupPlayer(name1)
			if (pid ~= nil) then
				table.insert(irc_params, pid)
				pid = LookupPlayer(name2)
				if (pid ~= nil) then
					table.insert(irc_params, pid)
					irc_unfriend()
				else	
					table.insert(irc_params, &quot;No player found matching &quot; .. name2)
					irc_message()
				end
			else
				table.insert(irc_params, &quot;No player found matching &quot; .. name1)
				irc_message()
			end

			return
		end

		if debug then dbug(&quot;debug ircmessage 54&quot;) end

		if (words[1] == &quot;player&quot; and string.find(msgLower, &quot;friend&quot;)) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			name1 = string.trim(string.sub(msg, string.find(msgLower, &quot;player&quot;) + 7, string.find(msgLower, &quot;friend&quot;) - 1))
			name2 = string.trim(string.sub(msg, string.find(msgLower, &quot;friend&quot;) + 7))

			pid = LookupPlayer(name1)
			if (pid ~= nil) then
				table.insert(irc_params, pid)
				pid = LookupPlayer(name2)
				if (pid ~= nil) then
					table.insert(irc_params, pid)
					irc_friend()
				else	
					table.insert(irc_params, &quot;No player found matching &quot; .. name2)
					irc_message()
				end
			else
				table.insert(irc_params, &quot;No player found matching &quot; .. name1)
				irc_message()
			end

			return
		end

		if debug then dbug(&quot;debug ircmessage 55&quot;) end

		if (words[1] == &quot;friends&quot;) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			name1 = string.trim(string.sub(msg, string.find(msgLower, &quot;friends&quot;) + 8))
			pid = LookupPlayer(name1)

			if (pid ~= nil) then
				table.insert(irc_params, pid)
				table.insert(irc_params, players[pid].name)
				irc_friends()
			else	
				table.insert(irc_params, &quot;No player found matching &quot; .. name1)
				irc_message()
			end
			return
		end

		if debug then dbug(&quot;debug ircmessage 56&quot;) end

		if (words[1] == &quot;players&quot; and words[2] == nil) and accessLevel(ircid) == 0 then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_listAllPlayers(name)
			return
		end

		if debug then dbug(&quot;debug ircmessage 57&quot;) end

		if (words[1] == &quot;player&quot;) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			name1 = string.trim(string.sub(msg, string.find(msgLower, &quot;player&quot;) + 7))
			pid = LookupOfflinePlayer(name1)

			if (pid ~= nil) then
				table.insert(irc_params, pid)
				table.insert(irc_params, players[pid].name)
				irc_PlayerInfo()
			end
			return
		end

		if debug then dbug(&quot;debug ircmessage 58&quot;) end

		if (words[1] == &quot;igplayer&quot;) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			name1 = string.trim(string.sub(msg, string.find(msgLower, &quot;igplayer&quot;) + 9))
			pid = LookupPlayer(name1)

			if (pid ~= nil) then
				table.insert(irc_params, pid)
				table.insert(irc_params, players[pid].name)
				irc_IGPlayerInfo()
			end
			return
		end

		if debug then dbug(&quot;debug ircmessage 59&quot;) end

		if (words[1] == &quot;watch&quot;) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			name1 = string.trim(string.sub(msg, string.find(msgLower, &quot;watch&quot;) + 6))
			pid = LookupPlayer(name1)

			if (pid ~= nil) then
				players[pid].watchPlayer = true

				conn:execute(&quot;UPDATE players SET watchPlayer = 1 WHERE steam = &quot; .. pid)
	
				table.insert(irc_params, &quot;Now watching player &quot; .. players[pid].name)
				irc_message()
			end
			return
		end

		if debug then dbug(&quot;debug ircmessage 60&quot;) end

		if (words[1] == &quot;stop&quot; and words[2] == &quot;watching&quot;) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_params = {}
			table.insert(irc_params, server.ircMain)

			name1 = string.trim(string.sub(msg, string.find(msgLower, &quot;watching&quot;) + 9))
			pid = LookupPlayer(name1)

			if (pid ~= nil) then
				players[pid].watchPlayer = false

				conn:execute(&quot;UPDATE players SET watchPlayer = 0 WHERE steam = &quot; .. pid)
	
				table.insert(irc_params, &quot;No longer watching player &quot; .. players[pid].name)
				irc_message()
			else
				table.insert(irc_params, &quot;No player matched &quot; .. name1)
				irc_message()
			end
			return
		end

		if debug then dbug(&quot;debug ircmessage 61&quot;) end

		if (words[1] == &quot;donors&quot; and words[2] == nil) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_listDonors(name)
			return
		end

		if debug then dbug(&quot;debug ircmessage 62&quot;) end

		if (words[1] == &quot;teleports&quot; and words[2] == nil) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_teleports(name)
			return
		end

		if debug then dbug(&quot;debug ircmessage 63&quot;) end

		if (words[1] == &quot;list&quot; and words[2] == &quot;bad&quot; and words[3] == &quot;items&quot;) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_uncraftables(name)
			return
		end

		if debug then dbug(&quot;debug ircmessage 64&quot;) end

		if (words[1] == &quot;prisoners&quot; and words[2] == nil) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_prisoners(name)			
			return
		end

		if debug then dbug(&quot;debug ircmessage 65&quot;) end

		if (words[1] == &quot;li&quot; and words[2] ~= nil) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			ircListItems = ircid
			send(&quot;li &quot; .. words[2])
		end

		if debug then dbug(&quot;debug ircmessage 66&quot;) end

		if (words[1] == &quot;status&quot;) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			name1 = string.trim(string.sub(msg, string.find(msgLower, &quot;status&quot;) + 7))
			pid = LookupPlayer(name1)

			if (pid ~= nil) then
				table.insert(irc_params, pid)
				table.insert(irc_params, players[pid].name)
				irc_playerStatus()
			else	
				table.insert(irc_params, &quot;No player found matching &quot; .. name1)
				irc_message()
			end
			return
		end

		if debug then dbug(&quot;debug ircmessage 67&quot;) end
		
		if (words[1] == &quot;shop&quot; and words[2] == &quot;add&quot; and words[3] == &quot;item&quot; and words[4] ~= nil) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			LookupShop(wordsOld[4], &quot;all&quot;)

			if shopCode ~= &quot;&quot; then
				irc_QueueMsg(irc_params[1], &quot;The item &quot; .. shopCode .. &quot; already exists.&quot;)
			else		
				class = &quot;misc&quot;
				price = 10000
				stock = 0

				for i=4,wordCount,1 do 					
					if words[i] == &quot;category&quot; then
						class = words[i+1]
					end					
					
					if words[i] == &quot;price&quot; then
						price = tonumber(words[i+1])
					end					
					
					if words[i] == &quot;stock&quot; then
						stock = tonumber(words[i+1])
					end					
				end

				irc_QueueMsg(irc_params[1], &quot;You added &quot; .. wordsOld[4] .. &quot; to the shop.  You will need to add any missing info such as code, category, price and quantity.&quot;)

				conn:execute(&quot;INSERT INTO shop (item, category, stock, maxStock, price) VALUES ('&quot; .. escape(wordsOld[4]) .. &quot;','&quot; .. escape(class) .. &quot;',&quot; .. stock .. &quot;,&quot; .. stock .. &quot;,&quot; .. price .. &quot;)&quot;)
				
				reindexShop(class)				
			end

			return
		end

		if debug then dbug(&quot;debug ircmessage 68&quot;) end
		
		if (words[1] == &quot;shop&quot; and words[2] == &quot;remove&quot; and words[3] == &quot;item&quot;) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			LookupShop(wordsOld[4], &quot;all&quot;)

			if shopCode ~= &quot;&quot; then
				conn:execute(&quot;DELETE FROM shop WHERE item = '&quot; .. escape(wordsOld[4]) .. &quot;'&quot;)
				reindexShop(shopCategory)		
				irc_QueueMsg(name, &quot;You removed the item &quot; .. wordsOld[4] .. &quot; from the shop.&quot;)
			else
				irc_QueueMsg(irc_params[1], &quot;The item &quot; .. wordsOld[4] .. &quot; does not exist.&quot;)
			end			

			return
		end	

		if debug then dbug(&quot;debug ircmessage 69&quot;) end

		if (words[1] == &quot;add&quot; and words[2] == &quot;command&quot; and accessLevel(ircid) &lt; 3) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			cmd = words[3]

			if words[4] == &quot;access&quot; then
				number = tonumber(words[5])
			else
				number = 99
			end

			tmp = string.trim(string.sub(msg, string.find(msgLower, &quot;message&quot;) + 8))

			if tmp == nil then
				irc_QueueMsg(name, &quot;Bad command.  This is used to create commands that send a private message to the player. You can add an optional access level.  99 is the default.&quot;)
				irc_QueueMsg(name, &quot;Valid access levels are 99 (everyone), 90 (regulars), 4 (donors), 2 (mods), 1 (admins) 0 (owners)&quot;)
				irc_QueueMsg(name, &quot;These commands are searched after all other commands. If an identical command exists, it will be used instead. Test the commands you add.&quot;)
				irc_QueueMsg(name, &quot;Correct syntax is: add command &lt;command&gt; access &lt;99 to 0&gt; message &lt;private message&gt;&quot;)
			end

			-- add the custom message to table customMessages
			conn:execute(&quot;INSERT INTO customMessages (command, message, accessLevel) VALUES ('&quot; .. escape(cmd) .. &quot;','&quot; .. escape(tmp) .. &quot;',&quot; .. number .. &quot;) ON DUPLICATE KEY UPDATE accessLevel = &quot; .. number .. &quot;, message = '&quot; .. escape(tmp) .. &quot;'&quot;)

			-- reload from the database
			loadCustomMessages()

			table.insert(irc_params, cmd .. &quot; has been added to custom commands.&quot;)
			irc_message()
			return
		end

		if debug then dbug(&quot;debug ircmessage 70&quot;) end

		if (words[1] == &quot;remove&quot; and words[2] == &quot;command&quot; and accessLevel(ircid) &lt; 3) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			cmd = words[3]

			-- remove the custom message from table customMessages
			conn:execute(&quot;DELETE FROM customMessages WHERE command = '&quot; .. escape(cmd) .. &quot;'&quot;)

			-- remove it from the Lua table
			customMessages[cmd] = nil

			table.insert(irc_params, cmd .. &quot; has been removed from custom commands.&quot;)
			irc_message()
			return
		end

		if debug then dbug(&quot;debug ircmessage 71&quot;) end

		if (words[1] == &quot;blacklist&quot; and words[2] == &quot;add&quot; and accessLevel(ircid) &lt; 3) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			pid = LookupPlayer(words[3])

			if pid ~= nil then

				banPlayer(pid, &quot;10 years&quot;, &quot;blacklisted&quot;, ircid)
				irc_QueueMsg(name, &quot;Player &quot; .. pid  .. &quot; &quot; .. players[pid].name .. &quot; has been blacklisted 10 years.&quot;)
				return
			end
		end

		if debug then dbug(&quot;debug ircmessage 72&quot;) end

		if (words[1] == &quot;blacklist&quot; or words[1] == &quot;ban&quot; and words[2] == &quot;remove&quot; and accessLevel(ircid) &lt; 3) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			pid = LookupPlayer(words[3])
			if pid ~= nil then
				send(&quot;ban remove &quot; .. pid)
				irc_QueueMsg(name, &quot;Player &quot; .. pid  .. &quot; &quot; .. players[pid].name .. &quot; has been unbanned.&quot;)
				return
			end
		end

		if debug then dbug(&quot;debug ircmessage 73&quot;) end

		if words[1] == &quot;list&quot; and (words[2] == &quot;event&quot;) then
			for i=4,wordCount,1 do 					
				if words[i] == &quot;player&quot; then
					pid = words[i+1]
					pid = LookupPlayer(pid)
				end					
			end

			table.insert(irc_params, words[3])

			if number ~= nil then
				table.insert(irc_params, number)
			else
				table.insert(irc_params, &quot;&quot;)
			end

			if pid ~= nil then
				table.insert(irc_params, pid)
			else
				table.insert(irc_params, &quot;&quot;)
			end

			irc_server_event(name)
			return
		end

		if debug then dbug(&quot;debug ircmessage 74&quot;) end

		if words[1] == &quot;search&quot; and words[2] == &quot;player&quot; then
			irc_QueueMsg(name, &quot;Players matching &quot; .. words[3])

			cursor,errorString = conn:execute(&quot;SELECT id, steam, name FROM players where name like '%&quot; .. words[3] .. &quot;%'&quot;)
			row = cursor:fetch({}, &quot;a&quot;)
			while row do
				irc_QueueMsg(name, row.id  .. &quot; &quot; .. row.steam .. &quot; &quot; .. row.name)
				row = cursor:fetch(row, &quot;a&quot;)
			end

			irc_QueueMsg(name, &quot;&quot;)
		end

		if debug then dbug(&quot;debug ircmessage 75&quot;) end

		if (words[1] == &quot;add&quot; and words[2] == &quot;proxy&quot;) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			if words[3] == nil then
				irc_QueueMsg(name, &quot;I do a dns lookup on every player that joins. You can ban or exile players found using a known proxy.&quot;)
				irc_QueueMsg(name, &quot;Staff and whitelisted players are ignored.&quot;)
				irc_QueueMsg(name, &quot;Command example: add proxy YPSOLUTIONS action ban.  Action is optional and can be ban or exile.  Ban is the default.&quot;)
				irc_QueueMsg(name, &quot;To remove a proxy type remove proxy YPSOLUTIONS.  To list proxies type list proxies.&quot;)
				return
			end

			proxy = nil
			if string.find(msg, &quot; action&quot;) then
				proxy = string.sub(msg, string.find(msg, &quot;proxy&quot;) + 6, string.find(msg, &quot;action&quot;) - 1)
			else
				proxy = string.sub(msg, string.find(msg, &quot;proxy&quot;) + 6)
			end

			if proxy == nil then
				irc_QueueMsg(name, &quot;The proxy is required.&quot;)
				irc_QueueMsg(name, &quot;Command example: add proxy YPSOLUTIONS action ban.  Action is optional and can be ban or exile.  Ban is the default.&quot;)
				return
			end

			proxy = string.trim(string.upper(proxy))
			action = &quot;ban&quot;

			for i=4,wordCount,1 do 					
				if words[i] == &quot;action&quot; then
					action = words[i+1]
				end					
			end

			if action ~= &quot;ban&quot; and action ~= &quot;exile&quot; then
				irc_QueueMsg(name, &quot;Invalid optional action given.&quot;)
				irc_QueueMsg(name, &quot;Command example: add proxy YPSOLUTIONS action ban.  Action is optional and can be ban or exile.  Ban is the default.&quot;)
				return
			end

			-- add the proxy to table proxies
			conn:execute(&quot;INSERT INTO proxies (scanString, action, hits) VALUES ('&quot; .. escape(proxy) .. &quot;','&quot; .. escape(action) .. &quot;',0)&quot;)

			if ircid == yourname and db2Connected then
				-- also add it to bots db
				connBots:execute(&quot;INSERT INTO proxies (scanString, action, hits) VALUES ('&quot; .. escape(proxy) .. &quot;','ban',0)&quot;)
			end

			-- and add it to the Lua table proxies
			proxies[proxy] = {}
			proxies[proxy].scanString = proxy
			proxies[proxy].action = action
			proxies[proxy].hits = 0

			if action == &quot;ban&quot; then
				action = &quot;banned.&quot;
			else
				action = &quot;exiled.&quot;
			end

			irc_QueueMsg(name, &quot;Proxy &quot; .. proxy  .. &quot; has been added. New players using it will be &quot; .. action)
			return
		end

		if debug then dbug(&quot;debug ircmessage 76&quot;) end

		if (words[1] == &quot;remove&quot; and words[2] == &quot;proxy&quot;) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			proxy = string.sub(msg, string.find(msg, &quot;proxy&quot;) + 6)
			proxy = string.trim(string.upper(proxy))

			if proxy == nil then
				irc_QueueMsg(name, &quot;The proxy is required.&quot;)
				irc_QueueMsg(name, &quot;Command example: remove proxy YPSOLUTIONS.&quot;)
				return
			end

			-- remve the proxy from the proxies table
			conn:execute(&quot;DELETE FROM proxies WHERE scanString = '&quot; .. escape(proxy) .. &quot;'&quot;)

			-- and remove it from the Lua table proxies
			proxies[proxy] = nil
			irc_QueueMsg(name, &quot;You have removed the proxy &quot; .. proxy)
			return
		end

		if debug then dbug(&quot;debug ircmessage 77&quot;) end

		if words[1] == &quot;list&quot; and words[2] == &quot;proxies&quot; then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			cursor,errorString = conn:execute(&quot;SELECT * FROM proxies&quot;)
			if cursor:numrows() == 0 then
				irc_QueueMsg(irc_params[1], &quot;There are no proxies on record.&quot;)
			else
				irc_QueueMsg(irc_params[1], &quot;I am scanning for these proxies:&quot;)
				row = cursor:fetch({}, &quot;a&quot;)
				while row do
					msg = &quot;proxy: &quot; .. row.scanString .. &quot; action: &quot; .. row.action .. &quot; hits: &quot; .. row.hits
					irc_QueueMsg(name, msg)
					row = cursor:fetch(row, &quot;a&quot;)	
				end
			end

			irc_QueueMsg(name, &quot;&quot;)
			return
		end

		if debug then dbug(&quot;debug ircmessage 78&quot;) end

		if words[1] == &quot;list&quot; and words[2] == &quot;regions&quot; then
			if debug then dbug(&quot;debug ircmessage &quot; .. msg) end
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			conn:execute(&quot;DELETE FROM list&quot;)

			irc_QueueMsg(name, &quot;The following regions have player bases in them.&quot;)

			for k,v in pairs(players) do
				if math.abs(v.homeX) &gt; 0 and math.abs(v.homeZ) &gt; 0 then
					temp = getRegion(v.homeX, v.homeZ)
					conn:execute(&quot;INSERT INTO list (thing) VALUES ('&quot; .. temp .. &quot;')&quot;)
				end

				if math.abs(v.home2X) &gt; 0 and math.abs(v.home2Z) &gt; 0 then
					temp = getRegion(v.home2X, v.home2Z)
					conn:execute(&quot;INSERT INTO list (thing) VALUES ('&quot; .. temp .. &quot;')&quot;)
				end
			end

			cursor,errorString = conn:execute(&quot;SELECT * FROM list order by thing&quot;)
			row = cursor:fetch({}, &quot;a&quot;)
			while row do
				irc_QueueMsg(name, row.thing)
				row = cursor:fetch(row, &quot;a&quot;)
			end

			conn:execute(&quot;DELETE FROM list&quot;)

			irc_QueueMsg(name, &quot;&quot;)
			irc_QueueMsg(name, &quot;The following regions have locations in them.&quot;)

			for k,v in pairs(locations) do
				temp = getRegion(v.x, v.z)
					conn:execute(&quot;INSERT INTO list (thing) VALUES ('&quot; .. temp .. &quot;')&quot;)
			end

			cursor,errorString = conn:execute(&quot;SELECT * FROM list order by thing&quot;)
			row = cursor:fetch({}, &quot;a&quot;)
			while row do
				irc_QueueMsg(name, row.thing)
				row = cursor:fetch(row, &quot;a&quot;)
			end

			conn:execute(&quot;DELETE FROM list&quot;)

			irc_QueueMsg(name, &quot;&quot;)
			return
		end

		if debug then dbug(&quot;debug ircmessage 79&quot;) end

		if (words[1] == &quot;list&quot; and words[2] == &quot;restricted&quot; and words[3] == &quot;items&quot;) then
			if players[ircid].ircAuthenticated == false then
				requireLogin(name)
				return
			end

			irc_restricted(name)
			return
		end

	end

	if debug then dbug(&quot;debug ircmessage 80&quot;) end

	if (words[1] == &quot;login&quot;) then
		if words[2] ~= nil then
			ircid = LookupIRCPass(string.sub(msg, string.find(msgLower, &quot;ogin&quot;) + 5))

			if (ircid ~= nil) then
				if string.find(channel, &quot;#&quot;) then
					table.insert(irc_params, &quot;You accidentally revealed your password in a public channel.  You password has been automatically wiped and you won't be able to login until Smeg sets a new password for you.&quot;)
					irc_message()
					players[ircid].ircAuthenticated = false
					players[ircid].ircPass = nil

					conn:execute(&quot;UPDATE players SET ircPass = '' WHERE steam = &quot; .. ircid)
					return
				end

				players[ircid].ircAuthenticated = true
				players[ircid].ircAlias = name

				-- fix a weird bug where the wrong player can have the irc alias for this player and they can't get it back
				conn:execute(&quot;UPDATE players SET ircAlias = '' WHERE ircAlias = '&quot; .. escape(name) .. &quot;'&quot;)
				conn:execute(&quot;UPDATE players SET ircAlias = '&quot; .. escape(name) .. &quot;' WHERE steam = &quot; .. ircid)

				if accessLevel(ircid) &lt; 4 then
					players[ircid].ircSessionExpiry = os.time() + 3600
				else
					players[ircid].ircSessionExpiry = os.time() + 10800
				end

				table.insert(irc_params, &quot;You have logged in &quot; .. name)
				irc_message()
				return
			end

			if (players[ircid].ircPass == nil) then
				table.insert(irc_params, &quot;You don't currently have a password.  Ask us to set one for you.&quot;)
				irc_message()
			end
		else
			irc_QueueMsg(name, &quot;You didn't give me the password.  Type login &lt;password&gt; eg. login 1234&quot;)
		end

		return
	end

	if debug then dbug(&quot;debug ircmessage 81&quot;) end

	if words[1] == &quot;rescue&quot; and words[2] == &quot;me&quot; then
		for k,v in pairs(players) do
			if v.ircAlias == name then
				v.ircAlias = &quot;&quot;
				conn:execute(&quot;UPDATE players SET ircAlias = '' WHERE steam = &quot; .. k)
				irc_QueueMsg(name, &quot;Your nick has been released from a player record. Now login to claim it.&quot;)
			end
		end
	end

	if (words[1] == &quot;bow&quot; and words[2] == &quot;before&quot;) and words[3] == &quot;me&quot; then
		ircid = LookupPlayer(name, &quot;all&quot;)

		if accessLevel(ircid) &lt; 3 then
			players[ircid].ircSessionExpiry = os.time() + 3600
			players[ircid].ircAuthenticated = true
			players[ircid].ircAlias = name
			table.insert(irc_params, &quot;You have logged in &quot; .. name)
			irc_message()

			conn:execute(&quot;UPDATE players SET ircAlias = '&quot; .. escape(name) .. &quot;' WHERE steam = &quot; .. ircid)
		else
			table.insert(irc_params, &quot;Did you drop your contact lense?&quot;)
			irc_message()
		end
	end

	if debug then dbug (&quot;debug ircmessage end&quot;) end
end

</script>
            <eventHandlerList>
                <string>sysIrcMessage</string>
            </eventHandlerList>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg functions</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]

local debug


function nextReboot()
	local timeRemaining, diff, days, hours, minutes, seconds

	if not server.allowReboot then
		message(&quot;say [&quot; .. server.chatColour .. &quot;]Server reboots are not managed by me at the moment.[-]&quot;)
		return
	end

	if gameTick &lt; 0 then
		message(&quot;say [&quot; .. server.chatColour .. &quot;]The server needs a reboot now to fix a fault.[-]&quot;)
	else
		if server.scheduledRestartTimestamp &gt; os.time() or scheduledRestartPaused then
			if scheduledRestartPaused then
				timeRemaining = restartTimeRemaining
			else
				timeRemaining = server.scheduledRestartTimestamp - os.time()
			end
		else
			timeRemaining = (tonumber(server.maxServerUptime) * 3600) - gameTick + 900
		end

		diff = timeRemaining
		days = math.floor(diff / 86400)

		if (days &gt; 0) then
			diff = diff - (days * 86400)
		end

		hours = math.floor(diff / 3600)

		if (hours &gt; 0) then
			diff = diff - (hours * 3600)
		end

		minutes = math.floor(diff / 60)

		if (minutes &gt; 0) then
			seconds = diff - (minutes * 60)
		end

		if scheduledRestartPaused then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]The reboot is paused at the moment. When it is resumed, the reboot will happen in &quot; .. string.format(&quot;%02d&quot;, hours) .. &quot;:&quot; .. string.format(&quot;%02d&quot;, minutes) ..&quot;:&quot; .. string.format(&quot;%02d&quot;, seconds) .. &quot;[-]&quot;)
		else		
			message(&quot;say [&quot; .. server.chatColour .. &quot;]The next reboot is in &quot; .. days .. &quot; days &quot; .. string.format(&quot;%02d&quot;, hours) .. &quot;:&quot; .. string.format(&quot;%02d&quot;, minutes) ..&quot;:&quot; .. string.format(&quot;%02d&quot;, seconds) .. &quot;[-]&quot;)
		end
	end
end


function baseStatus(command, playerid)
	local pname
	local id
	local protected
	local base

	pname = nil
	if (accessLevel(playerid) &lt; 3 and string.find(command, &quot;status &quot;)) then
		pname = string.sub(command, string.find(command, &quot;status&quot;) + 7)
		if (pname ~= nil) then
			pname = string.trim(pname)
			id = LookupPlayer(pname)
		end
	end

	if (pname == nil) then
		id = playerid	
		pname = players[playerid].name
	else
		pname = players[id].name
	end

	message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have &quot; .. players[id].cash .. &quot; zennies in the bank.[-]&quot;)

	if (players[id].protect == true) then
		protected = &quot;protected&quot;
	else
		protected = &quot;not protected (unless you have LCB's down)&quot;
	end
	
	if (players[id].homeX == 0 and players[id].homeY == 0 and players[id].homeZ == 0) then
		if (id == playerid) then
			base = &quot;You do not have a base set yet&quot;
		else
			base = pname .. &quot; does not have a base set yet&quot;
		end
	else
		if (id == playerid) then
			base = &quot;You have set a base&quot;
		else
			base = pname .. &quot; has set a base&quot;
		end
	end

	message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. base .. &quot;[-]&quot;)	
	message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The base is &quot; .. protected .. &quot;[-]&quot;)
	message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Protection size is &quot; .. players[id].protectSize .. &quot; meters from the /base teleport[-]&quot;)

	if (players[id].protectPaused ~= nil) then
		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Base protection is temporarily paused.[-]&quot;)
	end

	if not (players[id].home2X == 0 and players[id].home2Y == 0 and players[id].home2Z == 0) then
		if (players[id].protect2 == true) then
			protected = &quot;protected&quot;
		else
			protected = &quot;not protected (unless LCB's are placed)&quot;
		end
	
		if (id == playerid) then
			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Your 2nd base status is..[-]&quot;)
		else
			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Base status for &quot; .. pname .. &quot;'s 2nd base is..[-]&quot;)	
		end

		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The base is &quot; .. protected .. &quot;[-]&quot;)
		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Protection size is &quot; .. players[id].protect2Size .. &quot; meters from the /base2 teleport[-]&quot;)

		if (players[id].protect2Paused ~= nil) then
			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Base protection is temporarily paused.[-]&quot;)
		end
	end

	if accessLevel(playerid) &lt; 3 then
		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Current session is &quot; .. players[id].sessionCount .. &quot;[-]&quot;)
		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Claims placed &quot; .. players[id].keystones .. &quot;[-]&quot;)
	end

	return false
end


function gmsg_who(playerid, number)
	local xdir, zdir, k, v, dist, alone, intX, intY, intZ, x, z

	intX = math.floor(igplayers[playerid].xPos)
	intY = math.ceil(igplayers[playerid].yPos)
	intZ = math.floor(igplayers[playerid].zPos)

	x = math.floor(intX / 512)
	z = math.floor(intZ / 512)

	if (pvpZone(igplayers[playerid].xPos, igplayers[playerid].zPos) ~= false) then
		return
	end

	alone = true

	if (number == nil) then number = 501 end

	if (accessLevel(playerid) &gt; 3) then
		number = 401
	end

	if (accessLevel(playerid) &gt; 10) then
		number = 201
	end

	if (tonumber(intX) &lt; 0) then xdir = &quot; west &quot; else xdir = &quot; east &quot; end
	if (tonumber(intZ) &lt; 0) then zdir = &quot; south&quot; else zdir = &quot; north&quot; end
	message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are at &quot; .. intX .. xdir .. intZ .. zdir .. &quot; at a height of &quot; .. intY .. &quot;[-]&quot;)
	message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are in region r.&quot; .. x .. &quot;.&quot; .. z .. &quot;.7rg[-]&quot;)

	for k, v in pairs(igplayers) do
		if (k ~= playerid) then
			dist = distancexz(intX, intZ, v.xPos, v.zPos)

			if dist &lt; tonumber(number) then
				if (v.steam ~= playerid) then
					if (alone == true) then 
						message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]players within &quot; .. number .. &quot; meters:[-]&quot;) 
						alone = false
					end

					if (accessLevel(playerid) &lt; 11) then
						x = math.floor(v.xPos / 512)
						z = math.floor(v.zPos / 512)

						message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot; distance: &quot; .. string.format(&quot;%d&quot;, dist) .. &quot; region r.&quot; .. x .. &quot;.&quot; .. z .. &quot;.7rg[-]&quot;)
					else
						if (players[playerid].watchPlayer == true) and accessLevel(v.steam) &gt; 3 then
							message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot;[-]&quot;)
						end

						if (players[playerid].watchPlayer == false) then
							message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot;[-]&quot;)
						end
					end
				end
			end
		end
	end
end


function gmsg(line, ircid)
	local result, x, z, id, pname, msg, debug, noWaypoint, temp, chatStringStart

	debug = true

	noWaypoint = false
	chatStringStart = &quot;&quot;
	chatvars = {}
	chatvars.timestamp = os.time()

	if debug then 
		dbug(line) 

		if ircid ~= nil then
			dbug(&quot;ircid &quot; .. ircid)
		end
	end

	if string.find(line, &quot;INF Chat&quot;) then
		chatStringStart = &quot;Chat:&quot;
		Chatstart = string.sub(line, 1, string.find(line, &quot;Chat:&quot;) + 5)
	end

	if string.find(line, &quot;INF GMSG&quot;) then
		chatStringStart = &quot;GMSG:&quot;
	end

	if chatStringStart == &quot;&quot; then
		chatvars.command = line
		chatvars.playername = &quot;Server&quot;
		chatvars.ircid = 0
		line = &quot;Server: &quot; .. line
	end

	if (faultyChat == nil) then faultyChat = false end
	if (faultyChat2 == nil) then faultyChat2 = false end
	if faultyChat2 then fixMissingStuff() end
	faultyChat2 = true

	if (faultyChat == true) then
		cecho(server.windowDebug, &quot;!! Fault detected in Chat\n&quot;)
		cecho(server.windowDebug, faultyLine .. &quot;\n&quot;)
		if (faultyChatCommand ~= nil) then cecho(server.windowDebug, &quot;!! Fault occurred in command: &quot; .. faultyChatCommand .. &quot;\n&quot;) end
		faultyChat = false
	end

	if debug then dbug(&quot;gmsg 1&quot;) end

	faultyLine = line
	faultyChat = true

	serverTime = string.sub(line, 1, 19)

	if debug then dbug(&quot;gmsg 2&quot;) end

	ExceptionCount = 0
	chatvars.gmsg = line
	chatvars.oldLine = line
	chatvars.playerid = 0
	chatvars.chatline = string.split(chatvars.gmsg, &quot;:&quot;)

	--2015-06-04T08:10:32 11084.343 INF Denying command 'pm /library' from client zombiehunter0502&quot;

	if string.find(line, &quot; command 'pm&quot;) and not string.find(line, &quot;' from client&quot;) then
		faultyChat = false
		return
	end

	if string.find(line, &quot; command 'pm&quot;) and string.find(line, &quot;' from client&quot;) then
		msg = string.sub(line, string.find(line, &quot;command 'pm&quot;) + 12, string.find(line, &quot;' from client&quot;) - 1)
		id = string.sub(line, string.find(line, &quot;from client &quot;) + 12) 
		id = LookupPlayer(id, &quot;all&quot;)

		cecho(server.windowGMSG, players[id].name .. &quot;: &quot; .. msg .. &quot;\n&quot;)
		irc_QueueMsg(server.ircWatch, gameDate .. &quot; &quot; .. players[id].name .. &quot;: &quot; .. msg)

		chatvars.playername = players[id].name
		chatvars.command = msg
		chatvars.accessLevel = accessLevel(id)
	else
		if 	chatStringStart == &quot;&quot; then
			msg = line
		else
			msg =  string.sub(line, string.find(line, chatStringStart) + 6)
		end

		cecho(server.windowGMSG, msg .. &quot;\n&quot;)
		lastIRC = gameDate .. &quot; &quot; .. msg
	
		if string.len(msg) &gt; 200 then
			irc_QueueMsg(server.ircMain, gameDate .. &quot; &quot; .. string.sub(msg, 1, 200))
			irc_QueueMsg(server.ircMain, gameDate .. &quot; &quot; .. string.sub(msg, 201))
		else
			irc_QueueMsg(server.ircMain, gameDate .. &quot; &quot; .. msg)
		end

		if chatStringStart == &quot;Chat:&quot; then
dbug(&quot;chat&quot;)
			chatvars.playername = string.trim(chatvars.chatline[4])
dbug(&quot;chatvars.playername ::&quot; .. chatvars.playername .. &quot;::&quot;)
			chatvars.command = string.trim(string.sub(chatvars.gmsg, string.find(chatvars.gmsg, chatvars.chatline[4], nil, true) + string.len(chatvars.chatline[4]) + 2))
		end

		if chatStringStart == &quot;GMSG:&quot; then
			chatvars.playername = string.trim(chatvars.chatline[4])
dbug(&quot;chatvars.playername :=&quot; .. chatvars.playername .. &quot;-:&quot;)
			chatvars.command = string.trim(string.sub(chatvars.gmsg, string.find(chatvars.gmsg, chatvars.chatline[4], nil, true) + string.len(chatvars.chatline[4]) + 2))
dbug(&quot;chatvars.command :=&quot; .. chatvars.command .. &quot;=:&quot;)
		end

		if (string.find(chatvars.gmsg, chatStringStart .. &quot; Server:&quot;)) then
			chatvars.playername = &quot;Server&quot;
			faultyChat = false
			
			if ircid ~= nil then
				chatvars.ircid = ircid
			end
		end

		if chatvars.playername ~= &quot;Server&quot; then
			-- strip the bloody useless quotes off the name if they are present
			if string.sub(chatvars.playername, 1, 1) == &quot;'&quot; then
				chatvars.playername = string.sub(chatvars.playername, 2, string.len(chatvars.playername) - 1)
			end

dbug(&quot;chatvars.playername ::&quot; .. chatvars.playername .. &quot;::&quot;)
			chatvars.playerid = LookupPlayer(chatvars.playername, &quot;all&quot;)
		end
	end

	if debug then dbug(&quot;gmsg 3&quot;) end

	-- don't process any chat coming from irc
	if (string.find(chatvars.gmsg, &quot;-irc:&quot;, nil, true)) then
		faultyChat = false
		return
	end

	--deleteLine()

	faultyChatCommand = chatvars.command


	if debug then
		cecho(server.windowDebug, &quot;chatvars.playername &quot; .. chatvars.playername .. &quot;\n&quot;)
		cecho(server.windowDebug, &quot;command &quot; .. chatvars.command .. &quot;\n&quot;)
	end

	-- ignore game messages
dbug(&quot;3a&quot;)
dbug(&quot;chatvars.playername &quot; .. chatvars.playername)
dbug(&quot;chatvars.playerid &quot; .. chatvars.playerid)
	if (chatvars.playername ~= &quot;Server&quot;) and chatvars.playerid == nil then
		faultyChat = false
		return
	end
dbug(&quot;3b&quot;)

	if debug then dbug(&quot;gmsg 4&quot;) end

	if (chatvars.playername ~= &quot;Server&quot;) then

		if not igplayers[chatvars.playerid] then
			faultyChat = false
			return
		end

		chatvars.intX = math.floor(igplayers[chatvars.playerid].xPos)
		chatvars.intY = math.ceil(igplayers[chatvars.playerid].yPos)
		chatvars.intZ = math.floor(igplayers[chatvars.playerid].zPos)
		chatvars.accessLevel = accessLevel(chatvars.playerid)

		x = math.floor(chatvars.intX / 512)
		z = math.floor(chatvars.intZ / 512)
		chatvars.region = &quot;r.&quot; .. x .. &quot;.&quot; .. z .. &quot;.7rg&quot;
		zombies = tonumber(igplayers[chatvars.playerid].zombies)
		chatvars.zombies = zombies

		if string.len(chatvars.command) &gt; 150 and server.coppi then
			if igplayers[chatvars.playerid].longLineCount == nil then
				igplayers[chatvars.playerid].longLineCount = 0
				igplayers[chatvars.playerid].longLineTimer = os.time()
			end

			if igplayers[chatvars.playerid].longLineCount &gt; 3 then
				igplayers[chatvars.playerid].longLineTimer = os.time() + 10
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have been muted for 1 minute for too many excessively long chat lines.[-]&quot;)
				send(&quot;mpc &quot; .. chatvars.playerid .. &quot; true&quot;)
				tempTimer( 60, [[unmutePlayer(&quot;]] .. chatvars.playerid .. [[&quot;)]] )
			end
		end
	end

	--chatvars.gmsg = string.lower(chatvars.gmsg)

	if debug then dbug(&quot;gmsg 5&quot;) end

	chatvars.words = {}
	chatvars.wordsOld = {}

	for word in chatvars.command:gmatch(&quot;%S+&quot;) do 
		table.insert(chatvars.words, string.lower(word))
		table.insert(chatvars.wordsOld, word) 
	end

	chatvars.wordCount = table.maxn(chatvars.words)
	chatvars.command = string.lower(chatvars.command)

	if (string.sub(chatvars.words[1], 1, 1) == &quot;/&quot;) then
		chatvars.words[1] = string.sub(chatvars.words[1], 2, string.len(chatvars.words[1]))
	end

	chatvars.number = tonumber(string.match(chatvars.command, &quot; (-?%d+)&quot;)) -- (-?\%d+)
	result = false

	if debug then dbug(&quot;gmsg 6&quot;) end

--	if not result then
--		if not result and debug then cecho(server.windowDebug, &quot;debug entering gmsg_custom\n&quot;) end
--		result = gmsg_custom()
--		if result and debug then cecho(server.windowDebug, &quot;debug ran command in gmsg_custom\n&quot;) end
--	end

	if debug then dbug(&quot;gmsg 7&quot;) end

	if not result then
		if not result and debug then cecho(server.windowDebug, &quot;debug entering gmsg_info\n&quot;) end
		result = gmsg_info()
		if result and debug then cecho(server.windowDebug, &quot;debug ran command in gmsg_info\n&quot;) end
	end

	if debug then dbug(&quot;gmsg 8&quot;) end

	if not result then
		if not result and debug then cecho(server.windowDebug, &quot;debug entering gmsg_unslashed\n&quot;) end
		result = gmsg_unslashed()
		if result and debug then cecho(server.windowDebug, &quot;debug ran command in gmsg_unslashed\n&quot;) end
	end

	if debug then dbug(&quot;gmsg 9&quot;) end

	if not result then
		if not result and debug then cecho(server.windowDebug, &quot;debug entering gmsg_fun\n&quot;) end
		result = gmsg_fun()
		if result and debug then cecho(server.windowDebug, &quot;debug ran command in gmsg_fun\n&quot;) end
	end

	if debug then dbug(&quot;gmsg 10&quot;) end

	if (chatvars.playername ~= &quot;Server&quot;) then
		if accessLevel(chatvars.playerid) &gt; 2 then	
			test = string.sub(line, string.find(line, chatStringStart) + 6)
			temp = test:match(&quot;(%d+.%d+.%d+.%d+)&quot;)

			if test:match(&quot;(%d%d?%d?)%.(%d%d?%d?)%.(%d%d?%d?)%.(%d%d?%d?)%:(%d+)&quot;) and not whitelistedServers[temp] then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]Do not advertise other servers! The offender has been given a temporary ban and this offense has been reported.[-]&quot;)		

				banPlayer(chatvars.playerid, &quot;1 hour&quot;, &quot;Advertising another server in public chat.&quot;, &quot;&quot;)
				messageAdmins(&quot;Banned player &quot; .. players[chatvars.playerid].name .. &quot; 1 hour for advertising another server in chat.&quot;)

				irc_QueueMsg(server.ircAlerts, gameDate .. &quot; Banned player &quot; .. chatvars.playerid .. &quot; &quot; .. players[chatvars.playerid].name .. &quot; 1 hour for advertising another server in chat.&quot;)

				faultyChat = false
				result = true
			end
		end


		if chatvars.words[1] == &quot;hardcore&quot; and chatvars.words[2] == &quot;mode&quot; and (chatvars.words[3] == &quot;off&quot; or chatvars.words[3] == &quot;disable&quot; or string.sub(chatvars.words[3], 1, 2) == &quot;de&quot;) then
			players[chatvars.playerid].silentBob = false
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The bot will help you.[-]&quot;)		
			faultyChat = false
			result = true
		end


		if chatvars.words[1] == &quot;hardcore&quot; and chatvars.words[2] == &quot;mode&quot; and (chatvars.words[3] == &quot;on&quot; or chatvars.words[3] == &quot;enable&quot; or chatvars.words[3] == &quot;activate&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The bot will not help you.[-]&quot;)		
			players[chatvars.playerid].silentBob = true
			faultyChat = false
			result = true
		end


		if players[chatvars.playerid].silentBob == true then
			result = true
			faultyChat = false
			return
		end
	end

	if debug then dbug(&quot;gmsg 11&quot;) end

	if not result then
		if not result and debug then cecho(server.windowDebug, &quot;debug entering gmsg_mail\n&quot;) end
		result = gmsg_mail()
		if result and debug then cecho(server.windowDebug, &quot;debug ran command in gmsg_mail\n&quot;) end
	end

	if not result and (chatvars.playername ~= &quot;Server&quot;) then
		if players[chatvars.playerid].lastCommand ~= nil then
			-- don't allow /stuck being spammed
			if players[chatvars.playerid].lastCommand == chatvars.command then
				if (string.sub(chatvars.command, 1, 1) == &quot;/&quot;) then
					if math.abs(players[chatvars.playerid].lastCommandTimestamp - os.time()) &lt; 3 then
						message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Please don't spam commands.[-]&quot;)
						faultyChat = false
						result = true			
						return
					end
				end
			end
		end
	end

	if debug then dbug(&quot;gmsg 12&quot;) end

	if not result then
		if not result and debug then dbug(&quot;debug entering gmsg_base&quot;) end
		result = gmsg_base()
		if result and debug then dbug(&quot;debug ran command in gmsg_base&quot;) end
	end

	if not result then
		if not result and debug then dbug(&quot;debug entering gmsg_admin&quot;) end
		result = gmsg_admin()
		if result and debug then dbug(&quot;debug ran command in gmsg_admin&quot;) end
	end

	if not result then
		if not result and debug then dbug(&quot;debug entering gmsg_friends&quot;) end
		result = gmsg_friends()
		if result and debug then dbug(&quot;debug ran command in gmsg_friends&quot;) end
	end

	if not result then
		if not result and debug then dbug(&quot;debug entering gmsg_hotspots&quot;) end
		result = gmsg_hotspots()
		if result and debug then dbug(&quot;debug ran command in gmsg_hotspots&quot;) end
	end

	if not result then
		if not result and debug then dbug(&quot;debug entering gmsg_trial_code&quot;) end
		result = gmsg_trial_code()
		if result and debug then dbug(&quot;debug ran command in gmsg_trial_code&quot;) end
	end

	if not result then
		if not result and debug then dbug(&quot;debug entering gmsg_resets&quot;) end
		result = gmsg_resets()
		if result and debug then dbug(&quot;debug ran command in gmsg_resets&quot;) end
	end

	if not result and server.allowShop then
		if not result and debug then dbug(&quot;debug entering gmsg_shop&quot;) end
		result = gmsg_shop()
		if result and debug then dbug(&quot;debug ran command in gmsg_shop&quot;) end
	end

	if not result then
		if not result and debug then dbug(&quot;debug entering gmsg_tracker&quot;) end
		result = gmsg_tracker()
		if result and debug then dbug(&quot;debug ran command in gmsg_tracker&quot;) end
	end

	if not result then
		if not result and debug then dbug(&quot;debug entering gmsg_teleports&quot;) end
		result = gmsg_teleports()
		if result and debug then dbug(&quot;debug ran command in gmsg_teleports&quot;) end
	end

	if not result then
		if not result and debug then dbug(&quot;debug enterinfg gmsg_villages&quot;) end
		result = gmsg_villages()
		if result and debug then dbug(&quot;debug ran command in gmsg_villages&quot;) end
	end

	if not result and server.allowWaypoints then
		if not result and debug then dbug(&quot;debug entering gmsg_waypoints&quot;) end
		result = gmsg_waypoints()
		if result and debug then dbug(&quot;debug ran command in gmsg_waypoints&quot;) end
	end

	if not result then
		if not result and debug then dbug(&quot;debug entering gmsg_locations&quot;) end
		result = gmsg_locations()
		if result and debug then dbug(&quot;debug ran command in gmsg_locations&quot;) end
	end

	if not result then
		if not result and debug then dbug(&quot;debug entering gmsg_server&quot;) end
		result = gmsg_server()
		if result and debug then dbug(&quot;debug ran command in gmsg_server&quot;) end
	end

	if not result then
		if not result and debug then dbug(&quot;debug entering gmsg_misc&quot;) end
		result = gmsg_misc()
		if result and debug then dbug(&quot;debug ran command in gmsg_misc&quot;) end
	end

	if not result then
		if not result and debug then dbug(&quot;debug entering gmsg_pms&quot;) end
		result = gmsg_pms()
		if result and debug then dbug(&quot;debug ran command in gmsg_pms&quot;) end
	end

	if not result and server.coppi then
		if not result and debug then dbug(&quot;debug entering gmsg_coppi&quot;) end
		result = gmsg_coppi()
		if result and debug then dbug(&quot;debug ran command in gmsg_coppi&quot;) end
	end

	if (string.sub(chatvars.command, 1, 1) == &quot;/&quot;) and (chatvars.playername ~= &quot;Server&quot;) then
		players[chatvars.playerid].lastCommand = chatvars.command
		players[chatvars.playerid].lastCommandTimestamp = os.time()
	end

	if debug then dbug(&quot;gmsg 13&quot;) end

	if (string.sub(chatvars.command, 1, 1) == &quot;/&quot;) and (chatvars.playername ~= &quot;Server&quot;) and not result then  -- THIS COMMAND MUST BE LAST OR IT STOPS SLASH COMMANDS BELOW IT WORKING.
		pname = nil
		pname = string.sub(chatvars.command, 2)
		pname = string.trim(pname)

		id = LookupPlayer(pname)

		if (players[chatvars.playerid].prisoner or not players[chatvars.playerid].canTeleport) then
			faultyChat = false
			result = true
			return
		end

		if (id ~= nil) then 
			-- reject if not an admin or a friend
			if (not isFriend(id,  chatvars.playerid)) and (accessLevel(chatvars.playerid) &gt; 2) and (id ~= chatvars.playerid) then --  and (id ~= chatvars.playerid)
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Only friends of &quot; .. players[id].name .. &quot; and staff can do this.[-]&quot;)

				faultyChat = false
				result = true
				return
			end

			if (tonumber(players[id].waypointX) ~= 0 and tonumber(players[id].waypointY) ~= 0 and tonumber(players[id].waypointZ) ~= 0) and (players[id].shareWaypoint == true or accessLevel(chatvars.playerid) &lt; 3) then
				-- first record the current x y z
				players[chatvars.playerid].xPosOld = chatvars.intX
				players[chatvars.playerid].yPosOld = chatvars.intY
				players[chatvars.playerid].zPosOld = chatvars.intZ
				igplayers[chatvars.playerid].lastLocation = &quot;&quot;

				-- then teleport to the shared waypoint
				cmd = &quot;tele &quot; .. chatvars.playerid .. &quot; &quot; .. players[id].waypointX .. &quot; &quot; .. players[id].waypointY .. &quot; &quot; .. players[id].waypointZ

				if players[chatvars.playerid].watchPlayer then
					irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. chatvars.playerid .. &quot; &quot; .. chatvars.playername .. &quot; command &quot; .. chatvars.command  )
				end

				prepareTeleport(chatvars.playerid, cmd)
				teleport(cmd)
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have teleported to &quot; .. players[id].name .. &quot;'s waypoint.[-]&quot;)

				faultyChat = false
				result = true
				return
			else
				noWaypoint = true
			end

			-- teleport to a friend if sufficient zennies
			if (players[chatvars.playerid].tokens &gt; 0) or accessLevel(chatvars.playerid) &lt; 3 then
				-- first record the current x y z
				players[chatvars.playerid].xPosOld = chatvars.intX
				players[chatvars.playerid].yPosOld = chatvars.intY
				players[chatvars.playerid].zPosOld = chatvars.intZ
				igplayers[chatvars.playerid].lastLocation = &quot;&quot;

				-- then teleport to the friend
				cmd = &quot;tele &quot; .. chatvars.playerid .. &quot; &quot; .. math.floor(players[id].xPos-1) .. &quot; &quot; .. math.ceil(players[id].yPos) .. &quot; &quot; .. math.floor(players[id].zPos)

				if players[chatvars.playerid].watchPlayer then
					irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. chatvars.playerid .. &quot; &quot; .. chatvars.playername .. &quot; command &quot; .. chatvars.command  )
				end

				prepareTeleport(chatvars.playerid, cmd)
				teleport(cmd)

				if accessLevel(chatvars.playerid) &gt; 2 then
					players[chatvars.playerid].tokens = players[chatvars.playerid].tokens - 1
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have teleported to &quot; .. players[id].name .. &quot;'s location at a cost of 1 P2P token.[-]&quot;)
				else
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have teleported to &quot; .. players[id].name .. &quot;'s location.[-]&quot;)
				end

				faultyChat = false
				result = true
				return
			end

			if noWaypoint then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; does not have an open waypoint. They need to type /open waypoint.[-]&quot;)
				faultyChat = false
				result = true
				return
			end
		end
	end

	if debug then dbug(&quot;gmsg 14&quot;) end

	if not result then
		if (string.sub(chatvars.command, 1, 1) == &quot;/&quot;) then
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Unknown command: &quot; .. chatvars.command .. &quot; Type /help or /commands for commands.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Unknown command&quot;)
			end
		else
			Translate(chatvars.playerid, chatvars.command, &quot;&quot;)
		end
	end


	faultyChat = false
	faultyChat2 = false

	if debug then dbug(&quot;gmsg end&quot;) end
end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_help</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function help(command)
	local list

	if (command == &quot;me&quot;) then
		r = rand(6)
		if (r==1) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Sorry you're beyond help I'm afraid.[-]&quot;) end
		if (r==2) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Today I did 6 impossible things, but that ain't one.[-]&quot;) end
		if (r==3) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]I can't fix that![-]&quot;) end
		if (r==4) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Ask your cat.[-]&quot;) end
		if (r==5) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You need a wash and a haircut.[-]&quot;) end
		if (r==6) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Get up and go outside.  Maybe you've heard of it?[-]&quot;) end
		return
	end


	if command == &quot;reboot&quot; then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]By default /reboot will reboot 2 minutes later. More detailed help on irc.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/reboot in n minutes/hours (restricted to server owners)[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/cancel reboot[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/pause reboot  /unpause reboot[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/enable (or /disable) reboot (toggle automated rebooting)[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A timed reboot can be delayed if anyone says wait during the countdown. This can be blocked if you add 'forced' to the reboot command.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Several automatic reboots can happen that I manage.[-]&quot;)
		return
	end


	if command == &quot;mail&quot; then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Send private messages to your friends. They have to have friended you with /friend &quot; .. players[chatvars.playerid].name .. &quot; before you can message them.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can only send mail from your console, which you access from the tild key which is above TAB and left of your 1 key.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]To send a message to your friend Dave type pm @dave Hi Dave!  If he is on, he will get it now.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can message the admins with pm @admin &lt;your message here&gt;.  Every admin will see it.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Ignore the command denied message.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot;&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/list mail (see a numbered list of all your messages)[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/read mail &lt;optional number&gt; (reads all unread by default)[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/save mail &lt;number&gt; (read mail is deleted unless saved)[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/delete mail &lt;number&gt; (delete the numbered message)[-]&quot;)
		return
	end


	if (command == &quot;bookmarks&quot;) then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This feature is just to help admins locate places of interest or so we can screenshot your base before a wipe.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]If you add too many or stupid bookmarks we will not use them.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]These are not teleports like waypoints.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;][-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/bookmark &lt;short description&gt; (add a bookmark where you are standing)[-]&quot;)

		if (accessLevel(chatvars.playerid) &lt; 3) then 
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/list bookmarks &lt;player&gt; (view a players bookmarks)[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/bk &lt;bookmark number&gt; (tp to the coords of a bookmark)[-]&quot;)
		else
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/list bookmarks (view your own bookmarks)[-]&quot;)
		end

		return
	end


	if (command == &quot;male&quot;) then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]HELLOOOOO Nurse![-]&quot;)
		return
	end


	if (command == &quot;special&quot;) then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]P2Ptokens allow you to teleport to a friend and return (once per token).[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The friend has to have friended you via the bot.  Tokens are not items so there is nothing to pick up or lose.[-]&quot;)
		return
	end


	if command == &quot;shop&quot; then
		list = &quot;&quot;
		for k, v in pairs(shopCategories) do
			if k ~= &quot;misc&quot; then
				list = list .. k .. &quot;,  &quot;
			end
		end
		list = string.sub(list, 1, string.len(list) - 3)

		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The game currency is the zenny. Each zombie killed earns you 5 zennies.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/cash (see what you have in the bank)[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]To browse type /shop followed by a category. Categories are..[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. list .. &quot;[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]For a general search type /shop &lt;item&gt; eg. /shop shirt[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/buy &lt;item number&gt; &lt;quantity&gt;  Buy all the things![-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/pay &lt;player&gt; &lt;amount&gt;  You can't put a price on love so send money instead.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/gamble (gamble in our daily lottery) 25 zennies per ticket[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Buy multiple tickets at once with /gamble 5 (or any number). The winning number is picked from ticket number 1 to 100.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The shop sells special items. Read /help special for info.[-]&quot;)
		if (accessLevel(chatvars.playerid) &lt; 3) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/open shop - allow players access to the shop.[-]&quot;) end
		if (accessLevel(chatvars.playerid) &lt; 3) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/close shop - block player access to the shop.[-]&quot;) end
		if (accessLevel(chatvars.playerid) &lt; 3) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/set shop open - set a time (0 - 23) when the shop opens.[-]&quot;) end
		if (accessLevel(chatvars.playerid) &lt; 3) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/set shop close - set a time (0 - 23) when the shop closes.[-]&quot;) end
		if (accessLevel(chatvars.playerid) &lt; 3) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/set shop location &lt;location&gt; - tie the shop to a location.[-]&quot;) end
		if (accessLevel(chatvars.playerid) &lt; 3) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/clear shop location - the shop can be used anywhere.[-]&quot;) end
		return
	end


	if command == &quot;waypoints&quot; then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Waypoints are available to donors and admins only.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/set waypoint then /waypoint or /&lt;your name&gt; to tp to it.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/open waypoint - allow your friends to tp with /&lt;your name&gt;[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/close waypoint - make it private again.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/clear waypoint - deletes the waypoint[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]An opened waypoint automatically closes when you clear it.[-]&quot;)
		return
	end


	if command == &quot;irc&quot; then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Our irc server is located at &quot; .. server.ircServer .. &quot;[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Once there type /join #&quot; .. server.ircMain .. &quot;[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Hexchat is a good free irc client which works on Windows.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Or use this link https://kiwiirc.com/client/&quot; .. server.ircServer .. &quot;/&quot; .. server.ircMain .. &quot;[-]&quot;)
		return
	end


	if command == &quot;friends&quot; then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can tell me who your friends are. This gives them access to private teleports etc.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/friend &lt;friend's name&gt; - add someone as a friend[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/unfriend &lt;friend's name&gt;[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/friends - see who you have friended[-]&quot;)
		return
	end


	if command == &quot;access&quot; and (accessLevel(chatvars.playerid) &lt; 3) then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Access levels control who can do what.  Commands that are above a players level return unknown command.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Level 0 server owners[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Level 1 admins[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Level 2 mods[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Level 3 &lt;reserved&gt;[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Level 4 Donors[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Level 90 Regular players[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Level 99 New players[-]&quot;)
		return
	end


	if command == &quot;custom commands&quot; and (accessLevel(chatvars.playerid) &lt; 3) then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can create commands that send a private message.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/custom commands (list them)[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/add command &lt;command&gt; level &lt;access level&gt; message &lt;message&gt;.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/remove command &lt;command&gt;.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Access level is optional and defaults to 99.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]See /help access for the list of access levels.[-]&quot;)
		return
	end


	if command == &quot;pve&quot; then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]PVE means player versus environment.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The objective is to live off the land, gather resources, build shelter and survive.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can always ask others for help and if it gets too tough, you can take refuge in the library.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]On this server there are a few areas where PVP is allowed. Read /help pvp for info.[-]&quot;)
		return
	end


	if command == &quot;pvp&quot; then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]We have a PVP zone called Deadzone where you may PVP other players.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Type deadzone on chat to teleport to there. All other areas are PVE ONLY.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You start off in a large city with plenty of cover.  You will be alerted when you enter or exit the pvp zone.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]If you manage to get arrested for pvp outside of a zone, your victim or an admin can release you.[-]&quot;)
		return
	end


	if (command == &quot;deadzone&quot;) then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]ALERT!  Teleporting to Deadzone is treated the same as using your base teleport. You will not be able to return to base immediately.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You start off in a large city or town in a random location.  You will be alerted when you enter or exit the pvp zone.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]If you manage to get arrested for a PVP in PVE areas, your victim or an admin can release you.[-]&quot;)
		return
	end


	if (command == &quot;gimme&quot; or command == &quot;gimmie&quot;) then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Gimme is a fun game where you can win prizes![-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]To play, place 64 casino coins in the last slot of your belt. Gimmies are played automatically once per minute until you remove the coins or run out fo gimmies to play.[-]&quot;)
		if (accessLevel(chatvars.playerid) &lt; 3) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/gimme on - enables gimme[-]&quot;) end
		if (accessLevel(chatvars.playerid) &lt; 3) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/gimme off - disables gimme[-]&quot;) end
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/gimme peace - prizes are pm'ed[-]&quot;)
		if (accessLevel(chatvars.playerid) &lt; 3) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/gimme gimme - prizes are announced publicly[-]&quot;) end
		if (accessLevel(chatvars.playerid) &lt; 3) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/gimme reset - Reset everyone's gimme count to 0 and zero the reset timer (2 hours)[-]&quot;) end
		return
	end


	if (command == &quot;hotspots&quot;) then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Hotspots are pm's that are triggered by proximity to a hotspot. They are 3 dimensional spheres and can be stacked vertically.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/hotspots &lt;optional number&gt; Lists all hotspots within 20 meters of you or type a number for a different distance[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/delete hotspot &lt;optional number&gt;. Deletes the nearest or numbered hotspot.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/hotspot &lt;private message&gt;  Adds hotspot where you are with a default radius of 3 meters[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/move hotspot &lt;numbr&gt;. The numbered hotspot will move to you.[-]&quot;)

		if (accessLevel(chatvars.playerid) &lt; 3) then 
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/resize hotspot &lt;number&gt; size 5. Change the radius of the numbered hotspot to 5 metres.[-]&quot;) 
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/delete hotspots &lt;optional player&gt;. Deletes all of a players hotspots or your own if no player given.[-]&quot;)
		else
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/resize hotspot &lt;number&gt; size 5 (max 10). Change the radius of the numbered hotspot to 5 metres.[-]&quot;) 
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/delete hotspots. Deletes all of your hotspots.[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]If you move your base, any hotspots that are outside of your base are deleted. An admin may remove hotspots deemed to be offensive.[-]&quot;)
		end

		return
	end


	if (command == &quot;setup&quot;) and (accessLevel(chatvars.playerid) &lt; 3) then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Please set the following for smooth operation of the bot..[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/reset bot (only do this after a wipe and as soon after as possible)[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/name bot &lt;short name for me&gt;[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/set map size &lt;number&gt; (how far in meters players can explore away from 0,0)[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/set base cooldown &lt;minutes&gt; (how long to wait between /base teleporting. Donors wait half as long)[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/set chat color &lt;bbcode color without the brackets&gt;[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/location add prison[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/location add exile[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/max animals &lt;number&gt;[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/max players &lt;number&gt;[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/max zombies &lt;number&gt;[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/set website &lt;url or steam group&gt;[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/set irc server &lt;ip:port&gt;[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/set (or clear) max ping &lt;100+&gt;[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/set (or clear) welcome message &lt;your welcome message&gt;[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]For prison and exile also type /set location size &lt;prison/exile&gt; &lt;distance in metres&gt;[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Also for each type /location &lt;prison/exile&gt; pvp[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/set server pvp/pve/creative (tells me what type of server this is)[-]&quot;)
		return
	end


	if 	(command == &quot;manual&quot;) and (accessLevel(chatvars.playerid) &lt; 3) then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]More detailed help is available to admins on the IRC server.[-]&quot;)
		return
	end


	if (command == &quot;tracker&quot; and accessLevel(chatvars.playerid) &lt; 3) then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can walk the path taken by a player at any point in history.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/track &lt;player&gt; session &lt;number&gt; Defaults to the most recent or current.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Once the tracker is running:[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/goto start/end[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/go or /stop[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/go back (change direction)[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/skip &lt;number&gt;.  Skips every (n) steps[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/speed &lt;number&gt;.  Default is 1. Add 1 for each second you want to wait between steps.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/forward (or /advance) &lt;number&gt; Jump forward n steps.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/back &lt;number&gt; Jump backwards n steps.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/next (track the next session)[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/last (track the previous session)[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/stop tracking[-]&quot;)
		return
	end


	if command == &quot;donors&quot; then
		if accessLevel(chatvars.playerid) &lt; 3 then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Type player status &lt;player&gt; to check their donor status[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/add donor &lt;player&gt; level &lt;level&gt; expires &lt;number&gt; &lt;week or month or year&gt;[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/remove donor &lt;player&gt;[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Later you will be able to set a time limit like you do with bans.[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Also I will add the ability to give a player a free trial for a settable time limit.[-]&quot;)
		else
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]As a thank you for supporting us donors get extra features but donating is not required and is not pay to win.[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Donors get a 2nd base teleport and base protection,[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The base cooldown timer is half the normal time,[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can set 1 waypoint and share it with friends,[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can explore an extra 5km of map,[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can own a location and even become mayor of your own village,[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You get access to anything we restrict to donors only,[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You may get experimental new features before non-donors.[-]&quot;)
		end

		return
	end


	if (command == &quot;admin&quot;) and accessLevel(chatvars.playerid) &lt; 3 then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/arrest &lt;playername / player id&gt;[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/release &lt;playername / player id&gt;[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/release here &lt;playername / player id&gt;[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/prison takes you to the prison[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/closeto &lt;playername / player id&gt; Be in god mode before using this.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/goto &lt;playername / player id&gt;[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/fetch &lt;playername / player id&gt;[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/rescue &lt;playername&gt; - like fetch but just works[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/return &lt;playername / player id&gt;[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/sendhome &lt;playername / player id&gt;[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help donors[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help tracker[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/return - to return to where you came from[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/reboot empty (or idle)[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/who visited &lt;optional player&gt; range &lt;number default is 10&gt;[-]&quot;)
		return
	end


	if command == &quot;locations&quot; then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Locations are POI's (Points of interest) that you may teleport to and from freely.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]To travel to a location, just type the name of the location eg /library  To return type /return[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Locations are for everyone so please try not to trash them and don't claim them for yourself.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Type /locations to list public locations.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/show (or hide) locations (show or hide when you enter or leave a location)[-]&quot;)

		if (accessLevel(chatvars.playerid) &lt; 3) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/prison takes you to the prison[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/location add/remove &lt;location&gt;[-]&quot;)	
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/location move &lt;location&gt; (move it to where you are standing)[-]&quot;)	
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/location private/public &lt;location&gt; (default is private)[-]&quot;)	
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/location &lt;location&gt; pvp/pve[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/location set/clear reset &lt;some name&gt; (set as reset zone or clear)[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/location &lt;some name&gt; cost &lt;number&gt; (zennies or quantity of an item)[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/location &lt;some name&gt; currency &lt;item name&gt; (require an item in inventory)[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/location &lt;location&gt; owner &lt;player&gt;[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/location allow/disallow base &lt;location&gt; (allow or block setbase)[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/location &lt;location&gt; access &lt;level&gt; (no tp for players below acccess level)[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/location &lt;location&gt; size &lt;number&gt;[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/location &lt;location&gt; ends here (where you are standing)[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/location safe/unsafe &lt;location&gt; (set safe to auto-kill zombies)[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/protect/unprotect location (like setting base protect. you must be in the location first).[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/location &lt;location&gt; random (set random spawn points by simply walking around. type /stop when finished.)[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/location &lt;location&gt; (detailed info about the location)[-]&quot;)
		end

		return
	end


	if command == &quot;villages&quot; then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Villages are special locations that act like a base but with many players as villagers and one mayor.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A player can belong to many villages and each village can have only 1 mayor.  Villagers can vote for a new mayor once per 7 game days.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The village teleport works exactly like a base teleport including the 30 minute delay.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/villages (list of villages)[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/villagers &lt;optional village&gt; (list of villagers)[-]&quot;)

		if (accessLevel(chatvars.playerid) &lt; 3) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/add village &lt;name&gt;[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/remove village &lt;name&gt;[-]&quot;)	
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/village &lt;name&gt; size &lt;size&gt; (of village protection)[-]&quot;)	
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/protect village &lt;name&gt;[-]&quot;)	
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/add member &lt;player&gt; village &lt;village&gt;[-]&quot;)	
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/remove member &lt;player&gt; village &lt;village&gt;[-]&quot;)	
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/elect &lt;player&gt; village &lt;village&gt; (assign the first mayor)[-]&quot;)	
		end
		
		return
	end


	if command == &quot;base&quot; then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]We offer base protection which is a special teleport that ejects uninvited players from your base.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You must tell the bot where your base is. Pick a central spot or right beside your storage.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Type [i]/setbase[/i].  If you have previously typed [i]enabletp[/i] you can teleport to here once every &quot; .. (server.baseCooldown / 60) .. &quot; minutes.[-]&quot;)	
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Type [i]/base[/i] (or [i]home[/i]) to fast travel to your base.[-]&quot;)	
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can activate protection on your base to teleport out unwanted players by typing [i]/protect[/i].[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]If your protection overlaps with an non-friended player, the bot will not allow you to activate your protection.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]By default only you and admins can enter your base. Read /help friends to give your friends access too.[-]&quot;)	
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can temporarily suspend base protection with [i]/pause[/i]. It will auto-resume when you are more than 100 meters from base or quit the game.[-]&quot;)	
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Type [i]/resume[/i] to re-activate it.[-]&quot;)	
		return
	end


	if command == &quot;teleport&quot; then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/enabletp (you can use teleports)[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/disabletp (walking is better)[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Read /help base and /help locations for more info.[-]&quot;)

		if (accessLevel(chatvars.playerid) &lt; 3) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/opentp tpname[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/closetp tpname (must match opentp name)[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/killtp tpname (deletes a teleport)[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/owntp tpname playername[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/privatetp tpname[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/publictp tpname[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/teleports (list them all)[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/tp tpname (tp to a teleport)[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Teleports are private by default.[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/lobby &lt;player name&gt; (send a player to the lobby if it exists)[-]&quot;)
		end

		return
	end


	if (command == &quot;reset zones&quot;) or (command == &quot;reset&quot;) then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Reset zones areas which may be deleted and reset.  You will recieve a message whenever you enter or leave a reset zone.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Do not build in a reset zone or you risk losing it all.[-]&quot;)

		if (accessLevel(chatvars.playerid) &lt; 3) then 
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Reset zones can only be managed ingame as they reference your current position.[-]&quot;) 
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]To make the region you are in a reset zone type /add reset zone (regions are large)[-]&quot;) 
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Remove it with /delete reset zone[-]&quot;) 
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/location set reset &lt;location&gt;[-]&quot;) 
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/location clear reset &lt;location&gt;[-]&quot;) 
		end

		return
	end


	if (command == &quot;commands&quot;) then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This list is just a summary.[-]&quot;)	
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/alert &lt;your message to admins&gt; Bot adds your coords too.[-]&quot;)
		if (accessLevel(chatvars.playerid) &lt; 3) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/enable gimme, /disable gimme, /gimme gimme[-]&quot;) end
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/setbase, /base, /delbase, /pause, /resume, /status[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/enabletp, /disabletp[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/friend, /unfriend, /friends[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/gimme, /gimme peace[-]&quot;)	
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/info[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/locations[-]&quot;)
		if (accessLevel(chatvars.playerid) &lt; 3) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/reboot empty (or idle)[-]&quot;) end
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/return[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/rules[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/seen[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/suicide[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/uptime[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/who[-]&quot;)

		cursor,errorString = conn:execute(&quot;select * from customMessages order by command&quot;)
		row = cursor:fetch({}, &quot;a&quot;)

		while row do
			if (accessLevel(chatvars.playerid) &lt;= tonumber(row.accessLevel)) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/&quot; .. row.command .. &quot;[-]&quot;)
			end

			row = cursor:fetch(row, &quot;a&quot;)
		end

		return
	end

	-- always have the main help last so it catches any unsupported help commands.
	if command == nil then
		if (accessLevel(chatvars.playerid) &lt; 3) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help access[-]&quot;) end
		if (accessLevel(chatvars.playerid) &lt; 3) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help admin[-]&quot;) end
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help base[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help bookmarks[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help commands or /commands[-]&quot;)
		if (accessLevel(chatvars.playerid) &lt; 3) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help custom commands[-]&quot;) end
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help friends[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help gimme[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help hotspots[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help irc[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help locations[-]&quot;)
		if (accessLevel(chatvars.playerid) &lt; 3) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help manual[-]&quot;) end
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help pve[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help pvp[-]&quot;)
		if (accessLevel(chatvars.playerid) &lt; 3) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help reboot[-]&quot;) end
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help reset[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help shop[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/alert (pass a message to the admins with your current position)[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help teleport[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help villages[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help waypoints[-]&quot;)
		if (accessLevel(chatvars.playerid) &lt; 3) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/help setup[-]&quot;) end
		return
	end
end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>Inventory</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function CheckInventory()
	local temp, newPlayer, ban, timeout, move, newItems, table1, table2, items, reason, moveTo, moveReason, banReason, timeoutReason
	local d1, delta, inventoryChanged, changes, flags, debug, badItemsFound, badItemAction, count500

	debug = false

if debug then display (&quot;check inventory 1\n&quot;) end

	-- do a quick sanity check to prevent a rare fault causing this to get stuck
	for k, v in pairs(igplayers) do
		if players[k] == nil then
			igplayers[k] = nil
		end
	end

	for k, v in pairs(igplayers) do

if debug then display (k .. &quot; &quot; .. v.name) end

		players[k].overstack = false
		players[k].overstackItems = &quot;&quot;
		ban = false
		timeout = false
		move = false
		newPlayer = false
		v.illegalInventory = false
		badItemsFound = &quot;&quot;
		count500 = 0

if debug then display (&quot;check inventory 2\n&quot;) end
	
		if igplayers[k] then
			if (tonumber(players[k].timeOnServer) + tonumber(igplayers[k].sessionPlaytime) &lt; (tonumber(server.newPlayerTimer) * 60) ) then
				newPlayer = true
			else
				newPlayer = false	
			end
		end

		temp = {}
		items = {}
		changes = {}
		newItems = &quot;&quot;
		delta = 0
		inventoryChanged = false
		flags = &quot;&quot;

		if players[k].newPlayer == true then
			flags = &quot;|NEW|&quot;
		end

		if players[k].watchPlayer == true and players[k].newPlayer == false then
			flags = &quot;|WAT|&quot;
		end

		if v.raiding == true then
			flags = flags .. &quot;RAID &quot; .. v.raidingBase .. &quot;|&quot;
		end

if debug then display (&quot;check inventory 3\n&quot;) end

		if (igplayers[k].inventory ~= &quot;&quot;) then
			table1 = string.split(igplayers[k].inventory, &quot;|&quot;)

			for i = 1, table.maxn(table1) do
				if table1[i] ~= &quot;&quot; then
					table2 = string.split(table1[i], &quot;,&quot;)

					if (badItems[table2[2]]) then
						igplayers[k].illegalInventory = true

						if badItemsFound == &quot;&quot; then
							badItemsFound = table2[2] .. &quot;(&quot; .. table2[1] .. &quot;)&quot;
						else
							badItemsFound = badItemsFound .. &quot;, &quot; .. table2[2] .. &quot;(&quot; .. table2[1] .. &quot;)&quot;
						end
					end

					if items[table2[2]] == nil then
						items[table2[2]] = {}
						items[table2[2]].item = table2[2]
						items[table2[2]].quantity = tonumber(table2[1])
						items[table2[2]].quality = tonumber(table2[3])
					else
						items[table2[2]].quantity = items[table2[2]].quantity + tonumber(table2[1])
					end

					-- stack monitoring
					if (stackLimits[table2[2]] ~= nil) and (accessLevel(k) &gt; 2 or server.ignoreAdmins == false) and (server.gameType ~= &quot;cre&quot;) then
						if tonumber(table2[1]) &gt; tonumber(stackLimits[table2[2]].limit) * 2 and tonumber(table2[1]) &gt; 1000 then
							if (players[k].overstackScore &lt; 0) then
								players[k].overstackScore = 0
							end

							if not server.allowOverstacking then
								players[k].overstack = true
								players[k].overstackItems = players[k].overstackItems .. &quot; &quot; .. table2[2] .. &quot; (&quot; .. table2[1] .. &quot;)&quot;
								players[k].overstackScore = players[k].overstackScore + 1
							end
						end

						-- instant ban for overstacking any of these if a new player
						if tonumber(table2[1]) &gt; tonumber(stackLimits[table2[2]].limit) and newPlayer == true then
							if (table2[2] == &quot;tnt&quot; or table2[2] == &quot;keystoneBlock&quot; or table2[2] == &quot;mineAirFilter&quot; or table2[2] == &quot;mineHubcap&quot; or table2[2] == &quot;rScrapIronPlateMine&quot;) then
								ban = true
								banReason = &quot;Banned for overstacking &quot; .. table2[2] .. &quot;(&quot; .. table2[1] .. &quot;).&quot;
							end
						end
					end					
				end
			end 

if debug then display (&quot;check inventory 4\n&quot;) end

			for a, b in pairs(items) do
				if (players[k].newPlayer == true and igplayers[k].skipExcessInventory ~= true) then

					cursor,errorString = conn:execute(&quot;SELECT * FROM memRestrictedItems where item = '&quot; .. escape(b.item) .. &quot;' and accessLevel &lt; &quot; .. players[k].accessLevel)				
					rows = cursor:numrows()

					if tonumber(rows) &gt; 0 then
						row = cursor:fetch({}, &quot;a&quot;)

						if tonumber(b.quantity) &gt; tonumber(row.qty) then
							if row.action == &quot;timeout&quot; then
								timeout = true
								
								if timeoutReason == nil then
									timeoutReason = &quot;excessive inventory for a new player &quot; .. b.item .. &quot;(&quot; .. b.quantity .. &quot;)&quot;
								else
									timeoutReason = timeoutReason .. &quot;, &quot; .. b.item .. &quot;(&quot; .. b.quantity .. &quot;)&quot;
								end
							end
						
							if row.action == &quot;ban&quot; then
								ban = true
							
								if banReason == nil then
									banReason = &quot;excessive inventory for a new player &quot; .. b.item .. &quot;(&quot; .. b.quantity .. &quot;)&quot;
								else
									banReason = banReason .. &quot;, &quot; .. b.item .. &quot;(&quot; .. b.quantity .. &quot;)&quot;
								end
							end
						
							if locations[row.action] then
								move = true
								moveTo = row.action
							
								if moveReason == nil then
									moveReason = &quot;excessive inventory for a new player &quot; .. b.item .. &quot;(&quot; .. b.quantity .. &quot;)&quot;
								else
									moveReason = moveReason .. &quot;, &quot; .. b.item .. &quot;(&quot; .. b.quantity .. &quot;)&quot;
								end
							end

							if row.action == &quot;watch&quot; then
								if players[k].watchPlayer == false then
									players[k].watchPlayer = true
									irc_QueueMsg(server.ircWatch, &quot;Player &quot; .. players[k].name .. &quot; has &quot; .. b.quantity .. &quot; of &quot; .. b.item .. &quot;.  They have been added to the watch list.&quot;)
								end
							end

						end
					end				
				end 
			end

if debug then display (&quot;check inventory 5\n&quot;) end

			if tablelength(invTemp[k]) == 0 then 
				invTemp[k] = items 
			end

if debug then display (&quot;check inventory 6\n&quot;) end

			for a, b in pairs(invTemp[k]) do
				if items[b.item] == nil then
					items[b.item] = {}
					items[b.item].item = b.item
					items[b.item].quantity = 0
				end

				if tonumber(b.quantity) ~= tonumber(items[a].quantity) then
					inventoryChanged = true

					table.insert(changes, { b.item, tonumber(items[a].quantity) - tonumber(b.quantity) } )	

					conn:execute(&quot;INSERT INTO inventoryChanges (steam, item, delta, x, y, z, session) VALUES (&quot; .. k .. &quot;,'&quot; .. escape(b.item) .. &quot;',&quot; .. tonumber(items[a].quantity) - tonumber(b.quantity) .. &quot;,&quot; .. math.floor(v.xPos) .. &quot;,&quot; .. math.ceil(v.yPos) .. &quot;,&quot; .. math.floor(v.zPos) .. &quot;,&quot; .. players[k].sessionCount .. &quot;)&quot;)

					if (items[a] == nil) then
						d1 = 0
					else
						d1 = tonumber(items[a].quantity)
					end

					delta = d1 - tonumber(b.quantity)
					if tonumber(delta) &gt; 0 then
						delta = &quot;+&quot; .. delta
					else
						delta = delta
					end

					if (players[k].watchPlayer == true) then
						cursor,errorString = conn:execute(&quot;SELECT * FROM memRestrictedItems where item = '&quot; .. escape(b.item) .. &quot;' and action = 'watch'&quot;)
						row = cursor:fetch({}, &quot;a&quot;)
						if row then
							if (b.item == row.item) and not string.find(newItems, b.item, nil, true) then
								newItems = newItems .. row.item .. &quot; (&quot; .. delta .. &quot;), &quot;	
							end
						end

						if tonumber(delta) &gt; 30 and players[k].newPlayer == true and not string.find(newItems, b.item, nil, true) then
							newItems = newItems .. b.item .. &quot; (&quot; .. delta .. &quot;), &quot;	
						end

						if (b.item == &quot;keystoneBlock&quot;) and not string.find(newItems, b.item, nil, true) then
							newItems = newItems .. &quot;keystoneBlock (&quot; .. delta .. &quot;), &quot;	
								
							if tonumber(delta) &lt; 0 then
								players[k].keystones = 0
								send(&quot;llp &quot; .. k)
							end
						end
					end
				end
			end

if debug then display (&quot;check inventory 7\n&quot;) end

			if (players[k].watchPlayer == true) then
				if newItems ~= &quot;&quot; then
					for n, m in pairs(igplayers) do
						if (accessLevel(n) &lt; 3) then
							message(&quot;pm &quot; .. n .. &quot; [&quot; .. server.chatColour .. &quot;]Watched player &quot; .. players[k].id .. &quot; &quot; .. players[k].name .. &quot; &quot; .. newItems .. &quot;[-]&quot;)
						end
					end

					irc_QueueMsg(server.ircMain, &quot;Watched player &quot; .. players[k].id .. &quot; &quot; .. players[k].name .. &quot; inventory &quot; .. newItems .. &quot; near &quot; .. math.floor(igplayers[k].xPos) .. &quot; &quot; .. math.ceil(igplayers[k].yPos) .. &quot; &quot; .. math.floor(igplayers[k].zPos))
				end
			end

if debug then display (&quot;check inventory 8\n&quot;) end

			if inventoryChanged == true or (v.oldBelt ~= v.belt) then --  or (belt ~= v.belt)
				conn:execute(&quot;INSERT INTO inventoryTracker (steam, x, y, z, session, belt, pack, equipment) VALUES (&quot; .. k .. &quot;,&quot; .. math.floor(v.xPos) .. &quot;,&quot; .. math.ceil(v.yPos) .. &quot;,&quot; .. math.floor(v.zPos) .. &quot;,&quot; .. players[k].sessionCount .. &quot;,'&quot; .. escape(v.belt) .. &quot;','&quot; .. escape(v.pack) .. &quot;','&quot; .. escape(v.equipment) .. &quot;')&quot;)
				invTemp[k] = items

				if inventoryChanged == true then
					if players[k].timeOnServer == nil or players[k].watchPlayer == true or v.raiding == true then
						for q, w in pairs(changes) do
							irc_QueueMsg(server.ircWatch, string.trim(flags .. &quot; &quot; .. players[k].name .. &quot;  &quot; .. w[1] .. &quot;  &quot; .. w[2] .. &quot;  [ &quot; .. math.floor(v.xPos) .. &quot; &quot; .. math.ceil(v.yPos) .. &quot; &quot; .. math.floor(v.zPos)) .. &quot; ]&quot;)
						end
					else
						if accessLevel(k) &gt; 2 and tonumber(players[k].timeOnServer) &lt; tonumber(server.newPlayerTimer)  then
							for q, w in pairs(changes) do
								irc_QueueMsg(server.ircWatch, string.trim(flags .. &quot; &quot; .. players[k].name .. &quot;  &quot; .. w[1] .. &quot;   &quot; .. w[2] .. &quot;  [ &quot; .. math.floor(v.xPos) .. &quot; &quot; .. math.ceil(v.yPos) .. &quot; &quot; .. math.floor(v.zPos)) .. &quot; ]&quot;)
							end
						end
					end
				end
			end

if debug then display (&quot;check inventory 9\n&quot;) end

			if (items[&quot;keystoneBlock&quot;] and players[k].newPlayer == true and tonumber(items[&quot;keystoneBlock&quot;].quantity) &gt; 4 and accessLevel(k) &gt; 2) and (server.gameType ~= &quot;cre&quot;) then
				conn:execute(&quot;INSERT INTO inventoryTracker (steam, x, y, z, session, belt, pack, equipment) VALUES (&quot; .. k .. &quot;,&quot; .. math.floor(v.xPos) .. &quot;,&quot; .. math.ceil(v.yPos) .. &quot;,&quot; .. math.floor(v.zPos) .. &quot;,&quot; .. players[k].sessionCount .. &quot;,'&quot; .. escape(v.belt) .. &quot;','&quot; .. escape(v.pack) .. &quot;','&quot; .. escape(v.equipment) .. &quot;')&quot;)
				banPlayer(k, &quot;1 week&quot;, &quot;Too many keystones (&quot; .. items[&quot;keystoneBlock&quot;].quantity .. &quot;)&quot;)
				message(&quot;say [&quot; .. server.chatColour .. &quot;]Banning new player &quot; .. igplayers[k].name .. &quot; 1 week for too many keystones (&quot; .. items[&quot;keystoneBlock&quot;].quantity .. &quot;) in inventory.  Cheating suspected.[-]&quot;)
				irc_QueueMsg(server.ircMain, &quot;[BANNED] New player &quot; .. k .. &quot; &quot; .. igplayers[k].name .. &quot; has &quot; .. items[&quot;keystoneBlock&quot;].quantity .. &quot; keystones and has been banned for 1 week&quot;)
				irc_QueueMsg(server.ircAlerts, &quot;[BANNED] New player &quot; .. k .. &quot; &quot; .. igplayers[k].name .. &quot; has &quot; .. items[&quot;keystoneBlock&quot;].quantity .. &quot; keystones and has been banned for 1 week&quot;)
				players[k].watchPlayer = true

				conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. math.floor(v.xPos) .. &quot;,&quot; .. math.ceil(v.yPos) .. &quot;,&quot; .. math.floor(v.zPos) .. &quot;,'&quot; .. serverTime .. &quot;','ban','[BANNED] New player &quot; .. k .. &quot; &quot; .. escape(igplayers[k].name) .. &quot; has &quot; .. items[&quot;keystoneBlock&quot;].quantity .. &quot; keystones and has been banned for 1 week',&quot; .. k .. &quot;)&quot;)

				if db2Connected then
					-- copy in bots db
					connBots:execute(&quot;INSERT INTO events (server, serverTime, type, event, steam) VALUES ('&quot; .. escape(server.ServerName) .. &quot;','&quot; .. serverTime .. &quot;','ban','[BANNED] New player &quot; .. k .. &quot; &quot; .. escape(igplayers[k].name) .. &quot; has &quot; .. items[&quot;keystoneBlock&quot;].quantity .. &quot; keystones and has been banned for 1 week',&quot; .. k .. &quot;)&quot;)
				end
			end

		end

		v.oldBelt = v.belt

if debug then display (&quot;check inventory 10\n&quot;) end

		changes = nil
		
		if (players[k].overstack == false) then
			players[k].overstackScore = 0
		end

		if not server.allowOverstacking then
			if (players[k].overstack == true) and (accessLevel(k) &gt; 2 or server.ignoreAdmins == false) then
				message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]You are overstacking items in your inventory - &quot; .. players[k].overstackItems .. &quot;[-]&quot;)
				irc_QueueMsg(server.ircWatch, igplayers[k].name .. &quot; is overstacking &quot; .. players[k].overstackItems)
			end

			if (tonumber(players[k].overstackScore) == 2) and (players[k].botTimeout == false) then
				message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]If you do not stop overstacking, you will be sent to timeout.  Fix your inventory now.[-]&quot;)
			end

			if tonumber(players[k].overstackScore) &gt; 4 and (players[k].botTimeout == false) then
				if players[k].watchPlayer then
					irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. k .. &quot; &quot; .. players[k].name .. &quot; sent to timeout by bot&quot;)
				end

				players[k].botTimeout = true
				players[k].xPosTimeout = math.floor(players[k].xPos)
				players[k].yPosTimeout = math.ceil(players[k].yPos)
				players[k].zPosTimeout = math.floor(players[k].zPos)

				message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. igplayers[k].name .. &quot; is in timeout for ignoring overstack warnings.[-]&quot;)
				message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]You are still overstacking items. You will stay in timeout until you are not overstacking.[-]&quot;)
				irc_QueueMsg(server.ircWatch, &quot;[TIMEOUT] &quot; .. k .. &quot; &quot; .. igplayers[k].name .. &quot; is in timeout for overstacking the following &quot; .. players[k].overstackItems)
				irc_QueueMsg(server.ircAlerts, &quot;[TIMEOUT] &quot; .. k .. &quot; &quot; .. igplayers[k].name .. &quot; is in timeout for overstacking the following &quot; .. players[k].overstackItems)

				conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. math.floor(v.xPos) .. &quot;,&quot; .. math.ceil(v.yPos) .. &quot;,&quot; .. math.floor(v.zPos) .. &quot;,'&quot; .. serverTime .. &quot;','timeout','Player &quot; .. escape(igplayers[k].name) .. &quot; is in timeout for overstacking the following &quot; .. escape(players[k].overstackItems) .. &quot;',&quot; .. k .. &quot;)&quot;)
			end
		end

		if (ban == true) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Banning new player &quot; .. igplayers[k].name .. &quot; 1 year for suspected inventory cheating.[-]&quot;)
			conn:execute(&quot;INSERT INTO inventoryTracker (steam, x, y, z, session, belt, pack, equipment) VALUES (&quot; .. k .. &quot;,&quot; .. math.floor(v.xPos) .. &quot;,&quot; .. math.ceil(v.yPos) .. &quot;,&quot; .. math.floor(v.zPos) .. &quot;,&quot; .. players[k].sessionCount .. &quot;,'&quot; .. escape(v.belt) .. &quot;','&quot; .. escape(v.pack) .. &quot;','&quot; .. escape(v.equipment) .. &quot;')&quot;)
			banPlayer(k, &quot;1 year&quot;, banReason)
			irc_QueueMsg(server.ircMain, &quot;[BANNED] New player &quot; .. k .. &quot; &quot; .. igplayers[k].name .. &quot; has has been banned for &quot; .. banReason .. &quot;.&quot;)
			irc_QueueMsg(server.ircAlerts, &quot;[BANNED] New player &quot; .. k .. &quot; &quot; .. igplayers[k].name .. &quot; has has been banned for 1 year for &quot; .. banReason .. &quot;.&quot;)
			conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. math.floor(v.xPos) .. &quot;,&quot; .. math.ceil(v.yPos) .. &quot;,&quot; .. math.floor(v.zPos) .. &quot;,'&quot; .. serverTime .. &quot;','ban','Player &quot; .. k .. &quot; &quot; .. escape(igplayers[k].name) .. &quot; has has been banned for 1 year for &quot; .. escape(banReason) .. &quot;.',&quot; .. k .. &quot;)&quot;)

			if db2Connected then
				-- copy in bots db
				connBots:execute(&quot;INSERT INTO events (server, serverTime, type, event, steam) VALUES ('&quot; .. escape(server.ServerName) .. &quot;','&quot; .. serverTime .. &quot;','ban','Player &quot; .. k .. &quot; &quot; .. escape(igplayers[k].name) .. &quot; has has been banned for 1 year for &quot; .. escape(banReason) .. &quot;.',&quot; .. k .. &quot;)&quot;)
			end
		end

		if (timeout == true) then
			v.illegalInventory = true
			conn:execute(&quot;INSERT INTO inventoryTracker (steam, x, y, z, session, belt, pack, equipment) VALUES (&quot; .. k .. &quot;,&quot; .. math.floor(v.xPos) .. &quot;,&quot; .. math.ceil(v.yPos) .. &quot;,&quot; .. math.floor(v.zPos) .. &quot;,&quot; .. players[k].sessionCount .. &quot;,'&quot; .. escape(v.belt) .. &quot;','&quot; .. escape(v.pack) .. &quot;','&quot; .. escape(v.equipment) .. &quot;')&quot;)
			timeoutPlayer(k, timeoutReason, true)
		end

		if (move == true and players[k].exiled ~= 1) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Sending player &quot; .. igplayers[k].name .. &quot; to &quot; .. moveTo .. &quot; for &quot; .. moveReason .. &quot;.[-]&quot;)

			if players[k].watchPlayer then
				irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. k .. &quot; &quot; .. players[k].name .. &quot; exiled by bot&quot;)
			end

			teleport(&quot;tele &quot; .. k .. &quot; &quot; .. locations[moveTo].x .. &quot; &quot; .. locations[moveTo].y + 1 .. &quot; &quot; .. locations[moveTo].z)
			players[k].exiled = 1
			if accessLevel(k) &gt; 2 then players[k].silentBob = true end
			players[k].canTeleport = false
			irc_QueueMsg(server.ircMain, &quot;Moving player &quot; .. k .. &quot; &quot; .. igplayers[k].name .. &quot; to &quot; .. moveTo .. &quot; for &quot; .. moveReason .. &quot;.&quot;)
			irc_QueueMsg(server.ircAlerts, &quot;Moving player &quot; .. k .. &quot; &quot; .. igplayers[k].name .. &quot; to &quot; .. moveTo .. &quot; for &quot; .. moveReason .. &quot;.&quot;)
			conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. math.floor(v.xPos) .. &quot;,&quot; .. math.ceil(v.yPos) .. &quot;,&quot; .. math.floor(v.zPos) .. &quot;,'&quot; .. serverTime .. &quot;','exile','Player &quot; .. k .. &quot; &quot; .. escape(igplayers[k].name) .. &quot; has has been exiled to &quot; .. escape(moveTo) .. &quot; for &quot; .. escape(moveReason) .. &quot;.',&quot; .. k .. &quot;)&quot;)
		end

if debug then display (&quot;check inventory 11\n&quot;) end

		if (players[k].allowBadInventory ~= true) then
			if badItemsFound ~= &quot;&quot; then
				igplayers[k].illegalInventory = true

				if (players[k].timeout == false) and (accessLevel(k) &gt; 2 or server.ignoreAdmins == false) then
					if players[k].watchPlayer then
						irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. k .. &quot; &quot; .. players[k].name .. &quot; sent to timeout by bot&quot;)
					end

					players[k].timeout = true
					players[k].botTimeout = true
					players[k].xPosTimeout = math.floor(players[k].xPos)
					players[k].yPosTimeout = math.ceil(players[k].yPos)
					players[k].zPosTimeout = math.floor(players[k].zPos)

					if accessLevel(k) &gt; 2 then players[k].silentBob = true end
					message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. igplayers[k].name .. &quot; is in timeout for uncraftable items &quot; .. badItemsFound .. &quot;.[-]&quot;)
					message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]You have items in your inventory that are not permitted.[-]&quot;)
					message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]You must drop them if you wish to return to the game.[-]&quot;)

					irc_QueueMsg(server.ircMain, igplayers[k].name .. &quot; detected with uncraftable &quot; .. badItemsFound)
					irc_QueueMsg(server.ircAlerts, igplayers[k].name .. &quot; detected with uncraftable &quot; .. badItemsFound)
					conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event) VALUES (&quot; .. math.floor(igplayers[k].xPos) .. &quot;,&quot; .. math.ceil(igplayers[k].yPos) .. &quot;,&quot; .. math.floor(igplayers[k].zPos) .. &quot;,'&quot; .. serverTime .. &quot;','timeout','Player &quot; .. escape(igplayers[k].name) .. &quot; detected with uncraftable inventory &quot; .. escape(badItemsFound) .. &quot;')&quot;)

					if db2Connected then
						-- copy in bots db
						connBots:execute(&quot;INSERT INTO events (server, serverTime, type, event, steam) VALUES ('&quot; .. escape(server.ServerName) .. &quot;','&quot; .. serverTime .. &quot;','timeout','Player &quot; .. escape(igplayers[k].name) .. &quot; detected with uncraftable inventory &quot; .. escape(badItemsFound) .. &quot;')&quot;)
					end

					break
				end
			end
		end

		if players[k].botTimeout == true and v.illegalInventory == false and players[k].overstack == false then
			players[k].botTimeout = false
			players[k].timeout = false
			players[k].silentBob = false
			players[k].overstackScore = 0
			gmsg(&quot;/return &quot; .. igplayers[k].name)
			message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]You are free to play again.[-]&quot;)
			players[k].xPosOld = 0
			players[k].yPosOld = 0
			players[k].zPosOld = 0
			igplayers[k].lastLocation = &quot;&quot;
		end

	end

if debug then display (&quot;check inventory end\n&quot;) end
end


function readInventorySlot()
	local timestamp, slot, item, quantity, quality, pos, words

	timestamp = os.time()
	item = &quot;&quot;
	slot = &quot;&quot;
	quantity = 0
	quality = 0
	words = {}

	for word in line:gmatch(&quot;%w+&quot;) do table.insert(words, word) end

	--    Slot face: bandanaBlue - quality: 33
	--    Slot armor: leatherJacket - quality: 13
	--    Slot jacket: denimJacket - quality: 25
	--    Slot shirt: plaidShirt - quality: 235
	--    Slot pants: blackDenimPants - quality: 121
	--    Slot boots: wornBoots - quality: 120
	--    Slot gloves: clothGloves - quality: 58
	--    Slot eyes: aviatorGoggles - quality: 24
	--    Slot head: miningHelmet
	--    Slot 31: 003 * emptyJar

	slot = string.sub(line, string.find(line, &quot;Slot&quot;) + 5, string.find(line, &quot;: &quot;) - 1)

	if string.find(line, &quot;*&quot;) then
		slot = tonumber(slot)
		quantity = tonumber(string.sub(line, string.find(line, &quot;:&quot;) + 2, string.find(line, &quot;*&quot;) - 2))
		item = string.trim(string.sub(line, string.find(line, &quot;* &quot;) + 2))
	else
		quantity = 1
	end

	if string.find(line, &quot;quality:&quot;) then
		quality = string.trim(string.sub(line, string.find(line, &quot;quality: &quot;) + 9))

		if string.find(line, &quot;* &quot;) then
			item = string.trim(string.sub(line, string.find(line, &quot;* &quot;) + 2, string.find(line, &quot;quality:&quot;) - 4))
		else
			item = string.trim(string.sub(line, string.find(line, &quot;: &quot;) + 2, string.find(line, &quot;quality:&quot;) - 4))
		end
	else
		if item == &quot;&quot; then
			item = string.trim(string.sub(line, string.find(line, &quot;: &quot;) + 2))
		end
	end

	if (invScan == &quot;belt&quot;) then
		igplayers[invCheckID].inventory = igplayers[invCheckID].inventory .. quantity .. &quot;,&quot; .. item .. &quot;,&quot; .. quality .. &quot;|&quot;
		igplayers[invCheckID].belt = igplayers[invCheckID].belt .. slot .. &quot;,&quot; .. quantity .. &quot;,&quot; .. item .. &quot;,&quot; .. quality .. &quot;|&quot;

		if tonumber(slot) == 7 and tonumber(quantity) &gt; 0 and item == &quot;casinoCoin&quot; then
			-- do a gimme
			if (server.allowGimme) then
				igplayers[invCheckID].playGimme = true
				gimme(invCheckID)
				message(&quot;pm &quot; .. invCheckID .. &quot; [&quot; .. server.chatColour .. &quot;]To stop playing gimme, remove the casino coins from the last slot in your belt.[-]&quot;)
			end
		end
		

		if tonumber(slot) == 7 and tonumber(quantity) &gt; 0 and item == &quot;yuccaFibers&quot; then
			-- run the who command
			message(&quot;pm &quot; .. invCheckID .. &quot; [&quot; .. server.chatColour .. &quot;]Remove grass from last slot of belt stop the spam.[-]&quot;)
			gmsg_who(invCheckID)
		end
	end

	if (invScan == &quot;bagpack&quot;) then
		igplayers[invCheckID].inventory = igplayers[invCheckID].inventory .. quantity .. &quot;,&quot; .. item .. &quot;,&quot; .. quality .. &quot;|&quot;
		igplayers[invCheckID].pack = igplayers[invCheckID].pack .. slot .. &quot;,&quot; .. quantity .. &quot;,&quot; .. item .. &quot;,&quot; .. quality .. &quot;|&quot;
	end

	if (invScan == &quot;equipment&quot;) then
		igplayers[invCheckID].equipment = igplayers[invCheckID].equipment .. slot .. &quot;,&quot; .. item .. &quot;,&quot; .. quality .. &quot;|&quot;
	end

	deleteLine()
end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>OneHourTimer</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function OneHourTimer()
	local counter, rows

	cecho (server.windowDebug, &quot;1 hour timer\n&quot;)

	if server.scheduledRestart == false then send(&quot;sa&quot;) end

	if (announceRoller == nil) then announceRoller = 1 end

	if (tonumber(playersOnline) == 0) then 
		return 
	end

	counter = 1
	cursor,errorString = conn:execute(&quot;SELECT * FROM announcements&quot;)
	rows = cursor:numrows()

	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		if tonumber(announceRoller) == counter then
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,0,'&quot; .. escape(row.message) .. &quot;')&quot;)
		end

		counter = counter + 1
		row = cursor:fetch(row, &quot;a&quot;)	
	end

	announceRoller = announceRoller + 1
	if (tonumber(announceRoller) &gt; rows) then announceRoller = 1 end
	return true
end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>OneMinuteTimer</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function OneMinuteTimer()
	local words, word, rday, rhour, rmin, k,v
	local diff, days, hours, restartTime, zombiePlayers

	zombiePlayers = {}
	diff = gameTick
	days = math.floor(diff / 86400)

	if (days &gt; 0) then
		diff = diff - (days * 86400)
	end

	hours = math.floor(diff / 3600)

	cecho (server.windowDebug, &quot;60 second timer\n&quot;)

	-- save some server fields
	conn:execute(&quot;UPDATE server SET lottery = &quot; .. server.lottery .. &quot;, date = '&quot; .. server.date .. &quot;'&quot;)

	if (scheduledReboot == true or server.scheduledRestart == true) and scheduledRestartPaused == false and tonumber(playersOnline) &gt; 0 and server.allowReboot == true then
		restartTime = server.scheduledRestartTimestamp - os.time()

		if (restartTime &gt; 60 and restartTime &lt; 601) or (restartTime &gt; 1139 and restartTime &lt; 1201) or (restartTime &gt; 1799 and restartTime &lt; 1861) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Rebooting in &quot; .. os.date(&quot;%M minutes %S seconds&quot;,server.scheduledRestartTimestamp - os.time()) .. &quot;.[-]&quot;)
		end
	end

	if (idleKickTimer == nil) then 	idleKickTimer = 0 end

	for k, v in pairs(igplayers) do
--		if (v.afk - os.time() &lt; 421) and (playersOnline &gt;= server.ServerMaxPlayerCount) and (accessLevel(steam) &gt; 2) then
--			message(&quot;pm &quot; .. v.steam .. &quot; [&quot; .. server.chatColour .. &quot;]You appear to be away from your keyboard.  You will be kicked in &quot; .. os.date(&quot;%M minutes %S seconds&quot;,v.afk - os.time()) .. &quot; for being afk.  If you simply move you will not be kicked.[-]&quot;)
--		end

		if (v.killTimer == nil) then
			v.killTimer = 0
		end

		v.killTimer = v.killTimer + 1

		if (v.killTimer &gt; 1) then
			-- save the igplayer to players and destroy the igplayer record

			fixMissingPlayer(k)
			fixMissingIGPlayer(k)

			invTemp[k] = nil

			-- update players table with x y z
			players[k].lastAtHome = nil
			players[k].protectPaused = nil
			players[k].name = v.name
			players[k].xPos = v.xPos
			players[k].yPos = v.yPos
			players[k].zPos = v.zPos
			players[k].seen = serverTime
			players[k].playerKills = v.playerKills
			players[k].deaths = v.deaths
			players[k].zombies = v.zombies
			players[k].score = v.score
			players[k].ping = v.ping

			if (os.time() - players[k].lastLogout) &gt; 300 then
				players[k].relogCount = 0
			end

			if (os.time() - players[k].lastLogout) &lt; 60 then
				players[k].relogCount = tonumber(players[k].relogCount) + 1
			else
				players[k].relogCount = tonumber(players[k].relogCount) - 1
				if tonumber(players[k].relogCount) &lt; 0 then players[k].relogCount = 0 end
			end

			if accessLevel(k) &lt; 3 then
				conn:execute(&quot;DELETE FROM memTracker WHERE steam = &quot; .. k)
			end

			conn:execute(&quot;DELETE FROM messageQueue WHERE recipient = &quot; .. k)
			conn:execute(&quot;DELETE FROM gimmeQueue WHERE steam = &quot; .. k)
			conn:execute(&quot;DELETE FROM commandQueue WHERE steam = &quot; .. k)
			conn:execute(&quot;DELETE FROM playerQueue WHERE steam = &quot; .. k)

			if (v.timeOnServer) then players[k].timeOnServer = players[k].timeOnServer + v.sessionPlaytime end

			lastHotspots[k] = nil
			players[k].lastLogout = os.time()

			-- update the player record in the database
			updatePlayer(k)

			if db2Connected then
				-- update player in bots db
				connBots:execute(&quot;UPDATE players SET ip = '&quot; .. players[k].IP .. &quot;', name = '&quot; .. escape(players[k].name) .. &quot;', online = 0 WHERE steam = &quot; .. k .. &quot; AND botID = &quot; .. server.botID)		
			end

			-- check how many claims they have placed
--			send(&quot;llp &quot; .. k)

			-- flag this ingame player record for deletion
			zombiePlayers[k] = {}
		end
	end

	for k, v in pairs(zombiePlayers) do
		dbug(&quot;Removing zombie player &quot; .. players[k].name .. &quot;\n&quot;)
		igplayers[k] = nil		
	end

	-- check players table for problems and remove
	for k, v in pairs(players) do
		if (k ~= v.steam) or v.id == &quot;-1&quot; then
			players[k] = nil
		end
	end

	if (playersOnline == 0 and gameTick &lt; 0) and (scheduledReboot ~= true) and server.allowReboot == true then
		rebootTimerID = tempTimer( 60, [[startReboot()]] )
		scheduledReboot = true
	end
end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>shop</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


local id, page, count, shopState

function payPlayer()
	if (string.find(chatvars.command, &quot;yes&quot;)) then
		if (players[chatvars.playerid].cash &gt;= igplayers[chatvars.playerid].botQuestionValue) or accessLevel(chatvars.playerid) == 0 then
			players[igplayers[chatvars.playerid].botQuestionID].cash = players[igplayers[chatvars.playerid].botQuestionID].cash + igplayers[chatvars.playerid].botQuestionValue

			if accessLevel(chatvars.playerid) &gt; 0 then
				players[chatvars.playerid].cash = players[chatvars.playerid].cash - igplayers[chatvars.playerid].botQuestionValue
			end

			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. igplayers[chatvars.playerid].botQuestionValue .. &quot; has been paid to &quot; .. players[igplayers[chatvars.playerid].botQuestionID].name .. &quot;[-]&quot;)

			if (igplayers[igplayers[chatvars.playerid].botQuestionID]) then
				message(&quot;pm &quot; .. igplayers[chatvars.playerid].botQuestionID .. &quot; [&quot; .. server.chatColour .. &quot;]Payday! &quot; .. players[chatvars.playerid].name .. &quot; has paid you &quot; .. igplayers[chatvars.playerid].botQuestionValue .. &quot; zennies![-]&quot;)
			end
		else
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]I regret to inform you that you do not have sufficient funds to pay &quot; .. players[igplayers[chatvars.playerid].botQuestionID].name .. &quot;[-]&quot;)
		end
	end

	igplayers[chatvars.playerid].botQuestion = &quot;&quot;
	igplayers[chatvars.playerid].botQuestionID = nil
	igplayers[chatvars.playerid].botQuestionValue = nil
end


function LookupShop(search,all)
	-- build a sorted list of the search result and store in stock table
	local cursor, errorString, row, temp

	shopCode = &quot;&quot;
	shopCategory = &quot;&quot;
	shopItem = &quot;&quot;
	shopStock = 0
	shopPrice = 0
	shopIndex = 0

	conn:execute(&quot;DELETE FROM memShop&quot;)

	if all ~= nil then
		cursor,errorString = conn:execute(&quot;SELECT * FROM shop WHERE item = '&quot; .. escape(search) .. &quot;' or category = '&quot; .. escape(search) .. &quot;' ORDER BY idx&quot;)
	else
		cursor,errorString = conn:execute(&quot;SELECT * FROM shop WHERE item like '%&quot; .. escape(search) .. &quot;%' or category like '%&quot; .. escape(search) .. &quot;%' ORDER BY idx&quot;)
	end

	shopRows = cursor:numrows()
	row = cursor:fetch({}, &quot;a&quot;)

	while row do
		shopCode = shopCategories[row.category].code .. string.format(&quot;%02d&quot;, row.idx)
		shopItem = row.item
		shopIndex = row.idx
		shopCategory = row.category
		shopStock = row.stock
		shopPrice = (row.price + row.variation) * ((100 - row.special) / 100)
		conn:execute(&quot;INSERT INTO memShop (item, idx, category, price, stock, code) VALUES ('&quot; .. escape(row.item) .. &quot;',&quot; .. row.idx .. &quot;,'&quot; .. escape(row.category) .. &quot;',&quot; .. (row.price + row.variation) * ((100 - row.special) / 100) .. &quot;,&quot; .. row.stock .. &quot;,'&quot; .. escape(shopCode) .. &quot;')&quot;)

		row = cursor:fetch(row, &quot;a&quot;)	
	end

	-- search for the shop code
	if shopCode == &quot;&quot; then
		cursor,errorString = conn:execute(&quot;SELECT * FROM shop&quot;)
		row = cursor:fetch({}, &quot;a&quot;)

		while row do
			temp = shopCategories[row.category].code .. string.format(&quot;%02d&quot;, row.idx)
		
			if temp == search then
				shopRows = 1
				shopCode = temp
				shopItem = row.item
				shopIndex = row.idx
				shopCategory = row.category
				shopStock = row.stock
				shopPrice = (row.price + row.variation) * ((100 - row.special) / 100)
				conn:execute(&quot;INSERT INTO memShop (item, idx, category, price, stock, code) VALUES ('&quot; .. escape(row.item) .. &quot;',&quot; .. row.idx .. &quot;,'&quot; .. escape(row.category) .. &quot;',&quot; .. (row.price + row.variation) * ((100 - row.special) / 100) .. &quot;,&quot; .. row.stock .. &quot;,'&quot; .. escape(shopCode) .. &quot;')&quot;)
				return
			end

			row = cursor:fetch(row, &quot;a&quot;)	
		end
	end

	return shopItem
end


function reindexShop(category)
	local nextidx, cursor, errorString, row

	cursor,errorString = conn:execute(&quot;UPDATE shop SET idx = 0 WHERE category = '&quot; .. escape(category) .. &quot;'&quot;)
	cursor,errorString = conn:execute(&quot;SELECT * FROM shop WHERE category = '&quot; .. escape(category) .. &quot;' ORDER BY item&quot;)
	row = cursor:fetch({}, &quot;a&quot;)

	nextidx = 1
	while row do
		conn:execute(&quot;UPDATE shop SET idx = &quot; .. nextidx .. &quot; WHERE item = '&quot; .. escape(row.item) .. &quot;'&quot;)		
		nextidx = nextidx + 1

		row = cursor:fetch(row, &quot;a&quot;)	
	end
end


function drawLottery()
	local winners, winnersCount, prizeDraw, x, rows, thing

	if server.lottery == 0 then
		return
	end

	winners = {}
	winnersCount = 0

	for x=1,100,1 do
		prizeDraw = rand(100)

		cursor,errorString = conn:execute(&quot;SELECT * FROM memLottery WHERE ticket = &quot; .. prizeDraw)
		rows = cursor:numrows()

		if rows &gt; 0 then
			winnersCount = rows
			break
		end
	end

	message(&quot;say [&quot; .. server.chatColour .. &quot;]It's time for the daily lottery draw for &quot; .. server.lottery .. &quot; zennies![-]&quot;)

	if winnersCount &gt; 0 then
		prizeDraw = math.floor(server.lottery / winnersCount)

		row = cursor:fetch({}, &quot;a&quot;)
		while row do
			players[row.steam].cash = players[row.steam].cash + prizeDraw
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[row.steam].name .. &quot; won &quot; .. prizeDraw .. &quot; zennies![-]&quot;)

			if not igplayers[row.steam] then
				if winnersCount &gt; 1 then
					conn:execute(&quot;INSERT INTO mail (sender, recipient, message) VALUES (0,&quot; .. row.steam .. &quot;, 'Congratulations!  You won &quot; .. prizeDraw .. &quot; zennies in the daily lottery along with &quot; .. winnersCount - 1 .. &quot; others. :)')&quot;)
				else
					conn:execute(&quot;INSERT INTO mail (sender, recipient, message) VALUES (0,&quot; .. row.steam .. &quot;, 'Congratulations!  You won &quot; .. prizeDraw .. &quot; zennies in the daily lottery! =D')&quot;)
				end
			end

			row = cursor:fetch(row, &quot;a&quot;)	
		end

		message(&quot;say [&quot; .. server.chatColour .. &quot;]$$$ Congratulation$ $$$   xD[-]&quot;)

		conn:execute(&quot;DELETE FROM memLottery&quot;)
		conn:execute(&quot;DELETE FROM lottery&quot;)
		server.lottery = 0

		conn:execute(&quot;UPDATE server SET lottery = 0&quot;)
	else
		r = rand(7)
		if (r == 1) then message(&quot;say [&quot; .. server.chatColour .. &quot;]Nobody wins again![-]&quot;) end
		if (r == 2) then
			thing = PicknMix()
			thing = getEntity(thing)
			if thing == &quot;&quot; then thing = &quot;A Bunny Rabbit&quot; end 
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Tonight's winner is.. &quot; .. thing .. &quot;! Who gave that a ticket? O.o[-]&quot;) 
		end

		if (r == 3) then 
			message(&quot;say [&quot; .. server.chatColour .. &quot;]OH NO! A zombie ate the winning number![-]&quot;) 
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,0,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]BAD ZOMBIE!  No biscuit![-]&quot;) .. &quot;')&quot;)
		end

		if (r == 4) then 
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,0,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]Tonight's winner is..[-]&quot;) .. &quot;')&quot;)
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,0,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]Nobody again!  That guy has all the luck.[-]&quot;) .. &quot;')&quot;)
		end

		if (r == 5) then 
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,0,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]Tonight's winner is..[-]&quot;) .. &quot;')&quot;)
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,0,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]*CRASH*    BLUUUUEERGH!      AAAAH!  ZOMBIES!   *SCREAM!*[-]&quot;) .. &quot;')&quot;)
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,0,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]CUT!  Go to commercials![-]&quot;) .. &quot;')&quot;)
		end

		if (r == 6) then
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,0,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]Tonight's winner is..[-]&quot;) .. &quot;')&quot;)
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,0,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]Nobody!  But he's won enough so we're doing a redraw![-]&quot;) .. &quot;')&quot;)
			tempTimer( 15, [[drawLottery()]] )
		end

		if (r == 7) then 
			r = rand(6)
			if r == 1 then thing = &quot;severed head&quot; end
			if r == 2 then thing = &quot;severed hand&quot; end
			if r == 3 then thing = &quot;severed foot&quot; end
			if r == 4 then thing = &quot;mouldy eyeball&quot; end
			if r == 5 then thing = &quot;used nappy&quot; end
			if r == 6 then thing = &quot;rotten cheese&quot; end
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,0,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]Tonight's winner is..[-]&quot;) .. &quot;')&quot;)
			conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,0,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]EWW!  Who put a &quot; .. thing .. &quot; in the bag?  That's gross![-]&quot;) .. &quot;')&quot;)
		end
	end
end


function resetShop(forced)
	local specialCount, r, i, discCount

	server.shopCountdown = server.shopCountdown - 1

	if (server.shopCountdown &lt; 0) or forced ~= nil then
		conn:execute(&quot;UPDATE shop SET stock = maxStock&quot;)
		server.shopCountdown = 1
	end
end


function doShop(command, playerid, words)
	local k, v, i, number, cmd, list

	list = &quot;&quot;
	for k, v in pairs(shopCategories) do
		if k ~= &quot;misc&quot; then
			list = list .. k .. &quot;,  &quot;
		end
	end
	list = string.sub(list, 1, string.len(list) - 3)

	shopState = &quot;[OPEN]&quot;

	if server.shopOpenHour ~= server.shopCloseHour then
		if (tonumber(gameHour) &lt; tonumber(server.shopOpenHour) or tonumber(gameHour) &gt; tonumber(server.shopCloseHour)) then
			shopState = &quot;[CLOSED]&quot;
		end
	end

	number = tonumber(string.match(command, &quot; (-?\%d+)&quot;))

	if words[1] == &quot;shop&quot; and words[2] == nil then
		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have &quot; .. players[playerid].cash .. &quot; zennies in the bank. Shop is &quot; .. shopState .. &quot;[-]&quot;)
		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Shop categories are &quot; .. list .. &quot;.[-]&quot;)
		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Type shop food (to browse our fine collection of food).[-]&quot;)
		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Stock arrives every 3 days from other zones.[-]&quot;)
		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Type help shop for more info.[-]&quot;)
		if (accessLevel(playerid) &lt; 3) then message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]shop admin (for admin commands)[-]&quot;) end
		return false
	end


	if (words[1] == &quot;shop&quot; and words[2] == &quot;admin&quot;) and (accessLevel(playerid) &lt; 3) then
		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]shop price &lt;code or item name&gt; &lt;whole number without $&gt;[-]&quot;)
		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]shop restock &lt;code or item name&gt; &lt;quantity&gt; or -1 (add quantity to stock)[-]&quot;)
		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]shop special &lt;code or item name&gt; &lt;number from 0 to 100&gt;[-]&quot;)
		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]shop variation &lt;code or item name&gt; &lt;number&gt; (can be negative)[-]&quot;)
		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can manage categories and items for sale via IRC.[-]&quot;)
		return false
	end
	
	
	if (shopCategories[words[2]]) then
		LookupShop(words[2],all)

		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]To buy type buy &lt;code&gt; &lt;quantity&gt;[-]&quot;)

		cursor,errorString = conn:execute(&quot;SELECT * FROM memShop ORDER BY category, item&quot;)
		row = cursor:fetch({}, &quot;a&quot;)

		while row do
			if tonumber(row.stock) == -1 then
				message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]code:  &quot; .. row.code .. &quot;    item:  &quot; .. row.item .. &quot; price:  &quot; .. row.price .. &quot; UNLIMITED STOCK![-]&quot;)
			else
				if row.stock == 0 then
					message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]code:  &quot; .. row.code .. &quot;    item:  &quot; .. row.item .. &quot; price: &quot; .. row.price .. &quot;[-]  [FF0000]SOLD OUT[-]&quot;)
				else
					message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]code:  &quot; .. row.code .. &quot;    item:  &quot; .. row.item .. &quot; price: &quot; .. row.price.. &quot;  (&quot; .. row.stock .. &quot; left)[-]&quot;)
				end
			end

			row = cursor:fetch(row, &quot;a&quot;)	
		end

		return false
	end	


	if (words[2] == &quot;list&quot;) then
		list = &quot;&quot;

		for k, v in pairs(shopCategories) do
			list = list .. k .. &quot;,  &quot; 
		end
		list = string.sub(list, 1, string.len(list) - 3)

		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]To browse my wares type shop &lt;category&gt;.  The categories are &quot; .. list .. &quot;.[-]&quot;)

		return false
	end

	if (words[2] == &quot;variation&quot; and words[3] ~= nil) then
		if (accessLevel(playerid) &gt; 2) then
			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			return false
		end

		LookupShop(words[3])

		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have changed the price variation for &quot; .. shopItem .. &quot; to &quot; .. number .. &quot;[-]&quot;)
		conn:execute(&quot;UPDATE shop SET variation = &quot; .. number .. &quot; WHERE item = '&quot; .. escape(shopItem) .. &quot;'&quot;)		

		return false
	end


	if (words[2] == &quot;special&quot; and words[3] ~= nil) then
		if (accessLevel(playerid) &gt; 2) then
			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			return false
		end

		LookupShop(words[3])
		number = tonumber(words[4])

		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have changed the shop special for &quot; .. shopItem .. &quot; to &quot; .. number .. &quot;[-]&quot;)

		conn:execute(&quot;UPDATE shop SET special = &quot; .. number .. &quot; WHERE item = '&quot; .. escape(shopItem) .. &quot;'&quot;)
		return false
	end


	if (words[2] == &quot;price&quot; and words[3] ~= nil) then
		if (accessLevel(playerid) &gt; 2) then
			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			return false
		end

		LookupShop(words[3])
		number = tonumber(words[4])

		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have changed the shop price for &quot; .. shopItem .. &quot; to &quot; .. number .. &quot;[-]&quot;)

		conn:execute(&quot;UPDATE shop SET price = &quot; .. number .. &quot; WHERE item = '&quot; .. escape(shopItem) .. &quot;'&quot;)
		return false
	end


	if (words[2] == &quot;restock&quot; and words[3] ~= nil) then
		if (accessLevel(playerid) &gt; 2) then
			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			return false
		end

		LookupShop(words[3])

		if (tonumber(shopStock) &gt; -1) then
			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have added &quot; .. number .. &quot; &quot; .. shopItem .. &quot; to the shop[-]&quot;)

			conn:execute(&quot;UPDATE shop SET stock = stock + &quot; .. number .. &quot; WHERE item = '&quot; .. escape(shopItem) .. &quot;'&quot;)
			conn:execute(&quot;UPDATE shop SET stock = -1 WHERE stock &lt; 0&quot;)
		end

		return false
	end


	if (words[1] == &quot;buy&quot; and words[2] == &quot;ticket&quot;) or words[1] == &quot;gamble&quot; then
		if number == nil then number = 1 end

		if accessLevel(playerid) &lt; 1 then
			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Sorry &quot; .. players[playerid].name .. &quot; server owners may not enter the lottery.[-]&quot;)
			return false
		end

		if players[playerid].cash &lt; (25 * number) then
			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Sorry &quot; .. players[playerid].name .. &quot; but you don't have enough zennies.[-]&quot;)
			return false
		end


		for i=1,number,1 do		
			found = false
			tries = 0
			gotTicket = false

			while not gotTicket do
				r = rand(100)

				cursor,errorString = conn:execute(&quot;SELECT * FROM memLottery WHERE steam = &quot; .. playerid .. &quot; AND ticket = &quot; .. r)
				rows = cursor:numrows()

				if rows &gt; 0 then
					found = true
					break
				end

				if not found then
					conn:execute(&quot;INSERT INTO memLottery (steam, ticket) VALUES (&quot; .. playerid .. &quot;,&quot; .. r .. &quot;)&quot;)
					conn:execute(&quot;INSERT INTO lottery (steam, ticket) VALUES (&quot; .. playerid .. &quot;,&quot; .. r .. &quot;)&quot;)

					players[playerid].cash = players[playerid].cash - 25
					break
				end

				tries = tries + 1
				if (tries &gt; 100) then
					break
				end
			end
		end

		conn:execute(&quot;UPDATE players SET cash = &quot; .. players[playerid].cash .. &quot; WHERE steam = &quot; .. playerid)
		cursor,errorString = conn:execute(&quot;SELECT count(ticket) as tickets FROM lottery WHERE steam = &quot; .. playerid)
		row = cursor:fetch(row, &quot;a&quot;)	

		if tonumber(row.tickets) &gt; 0 then
			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Good Luck!  You have &quot; .. row.tickets .. &quot; tickets in the next draw![-]&quot;)
		end

		return false
	end


	if (words[1] == &quot;buy&quot; and words[2] ~= nil) then
		if server.shopOpenHour ~= server.shopCloseHour then
			if (tonumber(gameHour) &lt; tonumber(server.shopOpenHour) or tonumber(gameHour) &gt; tonumber(server.shopCloseHour)) and (accessLevel(playerid) &gt; 2) then
				message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The shop is closed! Go play with zombies or something![-]&quot;)
				return false
			end
		end

		if server.shopLocation ~= nil then
			dist = distancexz(igplayers[playerid].xPos, igplayers[playerid].zPos, locations[server.shopLocation].x, locations[server.shopLocation].z)

			if (dist &gt; 20) and (accessLevel(playerid) &gt; 2) then
				message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The shop is only available in the &quot; .. server.shopLocation .. &quot; location.[-]&quot;)
				message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Type /&quot; .. server.shopLocation .. &quot; to go there now and /return when finished.[-]&quot;)
				return false
			end
		end

		LookupShop(words[2], true) 

		if words[3] ~= nil then
			number = tonumber(words[3])
		else
			number = 1
		end

		if shopRows &gt; 1 then
			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]I sell several items called &quot; .. words[2] .. &quot;.  Try again using with one of the following fine wares.&quot;)

			cursor,errorString = conn:execute(&quot;SELECT * FROM memShop ORDER BY category, item&quot;)
			row = cursor:fetch({}, &quot;a&quot;)

			while row do
				if tonumber(row.stock) == -1 then
					message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]code:  &quot; .. row.code .. &quot;    item:  &quot; .. row.item .. &quot; price:  &quot; .. row.price .. &quot; UNLIMITED STOCK![-]&quot;)
				else
					if v.remaining == 0 then
						message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]code:  &quot; .. row.code .. &quot;    item:  &quot; .. row.item .. &quot; price: &quot; .. row.price .. &quot;[-]  [FF0000]SOLD OUT[-]&quot;)
					else
						message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]code:  &quot; .. row.code .. &quot;    item:  &quot; .. row.item .. &quot; price: &quot; .. row.price.. &quot;  (&quot; .. row.stock .. &quot; left)[-]&quot;)
					end
				end

				row = cursor:fetch(row, &quot;a&quot;)	
			end

			return false
		end

		if shopItem == &quot;voodooForDummies&quot; then
			number = 1
		end

		if (tonumber(players[playerid].cash) &gt; (tonumber(shopPrice) * number)) and ((number &lt;= tonumber(shopStock) or (tonumber(shopStock) == -1))) then
			players[playerid].cash = tonumber(players[playerid].cash) - (tonumber(shopPrice) * number)

			if shopItem == &quot;P2Ptoken&quot; then
				message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have purchased &quot; .. number .. &quot; &quot; .. shopItem .. &quot;. You have &quot; .. players[playerid].cash .. &quot; zennies remaining.[-]&quot;)
				message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Use a token to teleport to a friend by typing their name with a slash eg. /bob.[-]&quot;)

				if players[playerid].tokens == nil then
					players[playerid].tokens = 0
				end

				players[playerid].tokens = players[playerid].tokens + 1
				conn:execute(&quot;UPDATE players SET tokens = &quot; .. players[playerid].tokens .. &quot; WHERE steam = &quot; .. playerid)
				return false
			end

			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have purchased &quot; .. number .. &quot; &quot; .. shopItem .. &quot;. You have &quot; .. players[playerid].cash .. &quot; zennies remaining.[-]&quot;)
			send(&quot;give &quot; .. playerid .. &quot; &quot; .. shopItem .. &quot; &quot; .. number)
			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Press e now to pick up your purchase.[-]&quot;)

			conn:execute(&quot;UPDATE players SET cash = &quot; .. players[playerid].cash .. &quot; WHERE steam = &quot; .. playerid)
			conn:execute(&quot;UPDATE shop SET stock = &quot; .. shopStock - tonumber(number) .. &quot; WHERE item = '&quot; .. escape(shopItem) .. &quot;'&quot;)

			return false
		else
			if (number &gt; tonumber(shopStock)) and (tonumber(shopStock) &gt; 0)  then
				message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]I do not have that many &quot; .. shopItem .. &quot; in stock.[-]&quot;)
			else
				message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]I am sorry but you have insufficient zennies.[-]&quot;)
			end
		end

		return false
	end


	if (words[1] == &quot;cash&quot; or words[1] == &quot;zennies&quot; or words[1] == &quot;bank&quot; or words[1] == &quot;wallet&quot;) then
		message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have &quot; .. players[playerid].cash .. &quot; zennies in the bank. The shop is &quot; .. shopState .. &quot;[-]&quot;)
		return false
	end


	if (words[1] == &quot;pay&quot; and words[2] ~= nil) then
		id = LookupPlayer(words[2])
		if (id ~= nil) then
			igplayers[playerid].botQuestion = &quot;pay player&quot;
			igplayers[playerid].botQuestionID = id
			igplayers[playerid].botQuestionValue = math.abs(number)
			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You want to pay &quot; .. math.abs(number) .. &quot; zennies to &quot; .. players[id].name .. &quot;? Type /yes to complete the transaction or start over.[-]&quot;)
		end

		return false
	end


	if (words[1] == &quot;shop&quot; and words[2] ~= nil and words[3] == nil) then
		cursor,errorString = conn:execute(&quot;SELECT * FROM shop&quot;)
		shopRows = cursor:numrows()

		if shopRows == 0 then
			message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]CALL THE POLICE!  The shop is empty![-]&quot;)
			return false
		end
	end


	if (words[1] == &quot;shop&quot; and words[2] ~= nil and words[3] == nil) then
		LookupShop(words[2], true)

		cursor,errorString = conn:execute(&quot;SELECT * FROM memShop ORDER BY category, item&quot;)
		row = cursor:fetch({}, &quot;a&quot;)

		while row do
			if tonumber(row.stock) == -1 then
				message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]code:  &quot; .. row.code .. &quot;    item:  &quot; .. row.item .. &quot; price:  &quot; .. row.price .. &quot; UNLIMITED STOCK![-]&quot;)
			else
				if v.remaining == 0 then
					message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]code:  &quot; .. row.code .. &quot;    item:  &quot; .. row.item .. &quot; price: &quot; .. row.price .. &quot;[-]  [FF0000]SOLD OUT[-]&quot;)
				else
					message(&quot;pm &quot; .. playerid .. &quot; [&quot; .. server.chatColour .. &quot;]code:  &quot; .. row.code .. &quot;    item:  &quot; .. row.item .. &quot; price: &quot; .. row.price.. &quot;  (&quot; .. row.stock .. &quot; left)[-]&quot;)
				end
			end

			row = cursor:fetch(row, &quot;a&quot;)	
		end
	
		return false
	end
end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>Core Functions</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function isNewPlayer(steam)
	if igplayers[steam] then
		if (igplayers[steam].sessionPlaytime + players[steam].timeOnServer &lt; (server.newPlayerTimer * 60)) then
			return true
		else
			return false
		end
	else
		if tonumber(players[steam].timeOnServer) &lt; (tonumber(server.newPlayerTimer) * 60) then
			return true
		else
			return false
		end
	end

	return true
end


function isFriend(testid, steamid)
	-- is steamid a friend of testid?

	if testid == nil then
		return false
	end

	if friends[testid] == nil then -- testid is missing from friends data
		return false
	end

	if friends[testid].friends == nil then -- testid has no friends
		return false
	end

	if string.find(friends[testid].friends, steamid) then
		-- found steamid in testid's friends list.
		return true
	end

	-- steamid is not a friend of testid
	return false
end


function message(msg, irc)
	-- parse msg and enclose the actual message in double quotes
	words = {}
	for word in msg:gmatch(&quot;%S+&quot;) do table.insert(words, word) end

	if words[1] == &quot;say&quot; then
		-- say the message in public chat
		send(&quot;say \&quot;&quot; .. string.sub(msg, 5) .. &quot;\&quot;&quot;)
	else
		if players[words[2]].exiled~=1 then
			send(&quot;pm  &quot; .. words[2] .. &quot; \&quot;&quot; .. string.sub(msg, 21) .. &quot;\&quot;&quot;)
		end

		if irc ~= nil then
			-- send a copy of the pm to irc
			irc_QueueMsg(irc, &quot;pm to &quot; .. words[2] .. &quot; &quot; .. string.sub(msg, 21))
		end
	end
end


function pvpZone(x, z)
	-- is the coord x,z a pvp zone?
	if server.northeastZone == &quot;pvp&quot; and tonumber(x) &gt; 0 and tonumber(z) &gt; 0 then
		return true
	end

	if server.northwestZone == &quot;pvp&quot; and tonumber(x) &lt; 0 and tonumber(z) &gt; 0 then
		return true
	end

	if server.southeastZone == &quot;pvp&quot; and tonumber(x) &gt; 0 and tonumber(z) &lt; 0 then
		return true
	end

	if server.southwestZone == &quot;pvp&quot; and tonumber(x) &lt; 0 and tonumber(z) &lt; 0 then
		return true
	end

	for k, v in pairs(locations) do
		if (v.pvp) then
			-- if the coord is inside this pvp location, return the location name
			if math.abs(v.x-x) &lt;= (tonumber(v.size)) and math.abs(v.z-z) &lt;= (tonumber(v.size)) then
				return true
			end
		else
			-- if the coord is inside this pvp location, return the location name
			if math.abs(v.x-x) &lt;= (tonumber(v.size)) and math.abs(v.z-z) &lt;= (tonumber(v.size)) then
				return false
			end
		end
	end

	return false
end


function inLocation(x, z)
	-- is the coord inside a location?
	local closestLocation, closestDistance, dist, reset

	-- since locations can exist inside other locations, work out which location centre is closest
	closestDistance = 100000
	reset = false

	for k, v in pairs(locations) do
		if v.size ~= nil then
			if math.abs(v.x-x) &lt;= tonumber(v.size) and math.abs(v.z-z) &lt;= tonumber(v.size) then
				dist = distancexz(x, z, v.x, v.z)

				if tonumber(dist) &lt; tonumber(closestDistance) then
					closestLocation = v.name
					closestDistance = dist
					reset = v.resetZone
				end	
			end
		else
			if math.abs(v.x-x) &lt; 15 and math.abs(v.z-z) &lt; 15 then
				dist = distancexz(x, z, v.x, v.z)

				if dist &lt; closestDistance then
					closestLocation = v.name
					closestDistance = dist
					reset = v.resetZone
				end	
			end
		end
	end

	if closestLocation ~= nil then
		return closestLocation, reset
	else
		return false, false
	end
end


function LookupArenaPlayer(id)
	-- is id in the arenaPlayers table?
	for k, v in pairs(arenaPlayers) do
		if (id == v.id) then
			return k
		end
	end
end


function LookupPlayer(search, match)
	-- try to find the player amoung those who are playing right now
	local id

	if string.trim(search) == &quot;&quot; then
		return nil
	end

	search = string.lower(search)

	if string.starts(search, &quot;\&quot;&quot;) and string.ends(search,&quot;\&quot;&quot;) then
		search = search:match(&quot;%w+&quot;)
		match = &quot;all&quot;
	end

	for k, v in pairs(igplayers) do
		if search == v.id then
			-- matched the player id
			return k
		end

		if k == search then
			-- matched the steam id
			return k
		end

		if (v.name ~= nil) then
			if match == &quot;all&quot; then
				-- look for an exact match
				if (search == string.lower(v.name)) then
					return k
				end

				if (v.ircAlias ~= nil) and (search == string.lower(v.ircAlias)) then
					return k
				end
			else
				-- if it contains the search it is a match
				if (search == string.lower(v.name)) or (string.find(string.lower(v.name), search, nil, true)) then
					return k
				end

				if (string.find(v.id, search)) then
					return k
				end
			end
		end
	end

	-- no matches so try again but including all players
	id = LookupOfflinePlayer(search, match)

	-- if id isn't nil we found a match
	if id ~= nil then return id end
end


function LookupOfflinePlayer(search, match)
	if string.trim(search) == &quot;&quot; then
		return nil
	end

	search = string.lower(search)

	if string.starts(search, &quot;\&quot;&quot;) and string.ends(search,&quot;\&quot;&quot;) then
		search = search:match(&quot;%w+&quot;)
		match = &quot;all&quot;
	end

	for k, v in pairs(players) do
		if (v.name ~= nil) then
			if match == &quot;all&quot; then
				if (search == string.lower(v.name)) then
					return k
				end

				if (v.ircAlias ~= nil) and (search == string.lower(v.ircAlias)) then
					return k
				end
			else
				if (search == string.lower(v.name)) or (string.find(string.lower(v.name), search, nil, true)) then
					return k
				end
			end
		end

		if search == v.id then
			return k
		end

		if k == search then
			return k
		end
	end

	return nil
end


function LookupIRCPass(pass)
	if string.trim(pass) == &quot;&quot; then
		return nil
	end

	-- is this pass in use?
	pass = string.lower(pass)

	for k, v in pairs(players) do
		if (v.ircPass ~= nil) then
			if (pass == string.lower(v.ircPass)) then
				return k
			end
		end
	end
end


function LookupLocation(command)
	-- is command the name of a location?
	command = string.lower(command)

	if (string.find(command, &quot;/&quot;) == 1) then 
		command = string.sub(command, 2) -- strip off the leading /
	end

	for k, v in pairs(locations) do
		if (command == string.lower(v.name)) then
			return k
		end
	end
end


function LookupTeleportByName(tpname)
	-- find a teleport by its name
	tpname = string.lower(tpname)

	for k, v in pairs(teleports) do
		if (tpname == string.lower(v.name)) then
			return k
		end
	end
end


function LookupTeleport(x,y,z)
	-- is this 3D coord inside a teleport?
	match = 0

	for k, v in pairs(teleports) do
       if ((math.abs(math.abs(x) - math.abs(v.x)) &lt; 1) and (math.abs(math.abs(y) - math.abs(v.y)) &lt; 1) and (math.abs(math.abs(z) - math.abs(v.z)) &lt; 1)) then
			match = 1
			return k
		end

		if(v.dx) then
	       if ((math.abs(math.abs(x) - math.abs(v.dx)) &lt; 1) and (math.abs(math.abs(y) - math.abs(v.dy)) &lt; 1) and (math.abs(math.abs(z) - math.abs(v.dz)) &lt; 1)) then
				match = 2
				return k
			end
		end
	end
end


function ClosestHotspot(x, y, z)
	-- what is the closest hotspot to this 3D coord?
	local closest = 1000
	local dist = 2000
	local spot = 0

	for k, v in pairs(hotspots) do
		dist = distancexyz(x, y, z, v.x, v.y, v.z)
			
		if (dist &lt; closest) and (dist &lt; 21) then
			closest = dist
			spot = k
		end
	end

	if (spot ~= 0) then
		return spot
	end
end


function LookupVillager(steam, village)
	-- is steam a member of village?
	if villagers[steam .. village] ~= nil then
		return true
	else
		return false
	end
end


function tablelength(T)
	-- helper function to count the members of a Lua table
  local count = 0
  for _ in pairs(T) do count = count + 1 end
  return count
end


function getRegion(xpos,zpos)
	-- build the region name from the coords.  Each region is a physical file in the saves folder
	local x
	local z

	x = math.floor(xpos / 512)
	z = math.floor(zpos / 512)
	return &quot;r.&quot; .. x .. &quot;.&quot; .. z .. &quot;.7rg&quot;, x, z
end


function squareDistanceXZXZ(x1, z1, x2, z2, distance)
	-- calculate the square distance between 2 coords
	if math.abs(x2-x1) &gt; tonumber(distance) or math.abs(z2-z1) &gt; tonumber(distance) then
		return true
	else
		return false
	end
end


function squareDistance(x, z, distance)
	-- another square distance calculation
	if math.abs(x) &gt; tonumber(distance) or math.abs(z) &gt; tonumber(distance) then
		return true
	else
		return false
	end
end


function compare(a,b)
	-- simple sort
  return a[1] &lt; b[1]
end


function distancexyz( x1, y1, z1, x2, y2, z2 )
	-- calc the distance between 2 points in 3D
   local dx = x2 - x1
	local dy = y2 - y1
	local dz = z2 - z1	
   return math.sqrt((dx * dx) + (dy * dy) + (dz * dz))
end


function distancexz(x1, z1, x2, z2)
	-- calc the distance between 2 points in 2D (xz)
	local dx = x1 - x2
   local dz = z1 - z2
   return math.sqrt(dx * dx + dz * dz)
end


function say(message)
	-- just a catcher for old code
	send(message)
	return
end


function ToInt(number)
   return math.floor(tonumber(number) or nil)
end


function getAngle(x1, z1, x2, z2)
	-- Returns the angle between two points.
	return math.atan2(z2-z1, x2-x1) 
end


function getCompass(x1, z1, x2, z2)
	-- given 2 pairs of coordinates (the player and something else), determine where it is on a compass in relation to the player.
	local direction
	local angle
	local testangle
	local increment
	local index

	direction = { &quot;south west&quot;,&quot;south&quot;,&quot;south east&quot;,&quot;east&quot;, &quot;north east&quot;,&quot;north&quot;,&quot;north west&quot;,&quot;west&quot; }

	angle = getAngle(x1, z1, x2, z2)

	increment = (2 * math.pi) / 8
	testangle = -math.pi + increment
	index = 1

	while angle &gt; tonumber(testangle) do
	    index = index + 1
	    if(index &gt; 8) then
        return direction[1] --roll over
		end

		testangle = testangle + increment
	end

	return direction[index]
end


function accessLevel(pid)
	-- determine the access level of the player

	if owners[pid] then
		players[pid].accessLevel = 0
		return 0
	end

	if admins[pid] then
		players[pid].accessLevel = 1
		return 1
	end

	if mods[pid] then
		players[pid].accessLevel = 2
		return 2
	end

	if tonumber(server.accessLevelOverride) &lt; 99 then
		return tonumber(server.accessLevelOverride) 
	end

	-- 3 is reserved for visiting admins

	if players[pid].donor == true then
--TODO: Add donor levels
		players[pid].accessLevel = 10
		return 10
	end

	-- anyone stripped of certain rights
	if players[pid].denyRights == true then
		players[pid].accessLevel = 99
		return 99
	end

	-- regulars
	if igplayers[pid] then
		if tonumber(players[pid].timeOnServer) + tonumber(igplayers[pid].sessionPlaytime) &gt; (server.newPlayerTimer * 60) then
			players[pid].accessLevel = 90
			return 90
		end
	else
		if tonumber(players[pid].timeOnServer) &gt; (server.newPlayerTimer * 60) then
			players[pid].accessLevel = 90
			return 90
		end
	end
	
	-- new players
	players[pid].accessLevel = 99
	return 99
end


function fixMissingPlayer(steam)
	-- if any fields are missing from the players player record, add them with default values

	if (players[steam].steamOwner == nil) then
		players[steam].steamOwner = steam
	end

	if (players[steam].canTeleport == nil) then
		players[steam].canTeleport = true
	end

	if (players[steam].country == nil) then
		players[steam].country = &quot;&quot;
	end

	if (players[steam].prisoner == nil) then
		players[steam].prisoner = false
	end

	if (players[steam].whitelisted == nil) then
		players[steam].whitelisted = false
	end

	if (players[steam].permanentBan == nil) then
		players[steam].permanentBan = false
	end

	if (players[steam].tokens == nil) then
		players[steam].tokens = 0
	end

	if (players[steam].removeClaims == nil) then
		players[steam].removeClaims = false
	end

	if (players[steam].exiled == nil) then
		players[steam].exiled = 0
	end

	if (players[steam].removedClaims == nil) then
		players[steam].removedClaims = 0
	end

	if (players[steam].bed == nil) then
		players[steam].bed = &quot;&quot;
	end

	if (players[steam].seen == nil) then
		players[steam].seen = &quot;&quot;
	end

	if (players[steam].IP == nil) then
		players[steam].IP = &quot;&quot;
	end

	if (players[steam].raiding == nil) then
		players[steam].raiding = false
	end

	if (players[steam].watchCash == nil) then
		players[steam].watchCash = false
	end

	if (players[steam].alertPVP == nil) then
		players[steam].alertPVP = true
	end

	if (players[steam].shareWaypoint == nil) then
		players[steam].shareWaypoint = false
	end

	if (players[steam].teleCooldown == nil) then
		players[steam].teleCooldown = 0
	end

	if (players[steam].keystones == nil) then
		players[steam].keystones = 0
	end

	if (players[steam].firstSeen == nil) then
		players[steam].firstSeen = 0
	end

	if (players[steam].level == nil) then
		players[steam].level = 1
	end

	if (players[steam].exitX == nil) then
		players[steam].exitX = 0
		players[steam].exitY = 0
		players[steam].exitZ = 0
	end

	if players[steam].exitX == 0 and players[steam].exitZ == 0 then
		players[steam].exitY = 0
	end

	if (players[steam].exit2X == nil) then
		players[steam].exit2X = 0
		players[steam].exit2Y = 0
		players[steam].exit2Z = 0
	end

	if players[steam].exit2X == 0 and players[steam].exit2Z == 0 then
		players[steam].exit2Y = 0
	end

	if (players[steam].xPos == nil) then
		players[steam].xPos = 0
		players[steam].yPos = 0
		players[steam].zPos = 0
	end

	if (players[steam].xPosOld == nil) then
		players[steam].xPosOld = 0
		players[steam].yPosOld = 0
		players[steam].zPosOld = 0
	end

	if (players[steam].xPosOld2 == nil) then
		players[steam].xPosOld2 = 0
		players[steam].yPosOld2 = 0
		players[steam].zPosOld2 = 0
	end

	if (players[steam].ircAlias == nil) then
		players[steam].ircAlias = &quot;&quot;
		players[steam].ircPass = &quot;&quot;
		players[steam].ircAuthenticated = false
	end

	if (players[steam].baseCooldown == nil) then
		players[steam].baseCooldown = 0
	end

	if (players[steam].silentBob == nil) then
		players[steam].silentBob = false
	end

	if (players[steam].donor == nil) then
		players[steam].donor = false
	end

	if (players[steam].donorExpiry == nil) then
		players[steam].donorLevel = 0
		players[steam].donorExpiry = os.time()
	end

	if (players[steam].timeOnServer == nil) then
		players[steam].timeOnServer = 0
	end

	if (players[steam].protect == nil) then
		players[steam].protect = false
	end

	if (players[steam].protectSize == nil) then
		players[steam].protectSize = server.baseSize
	end

	if (players[steam].protect2 == nil) then
		players[steam].protect2 = false
	end

	if (players[steam].protect2Size == nil) then
		players[steam].protect2Size = server.baseSize
	end

	if (players[steam].homeX == nil) then
		players[steam].homeX = 0
		players[steam].homeY = 0
		players[steam].homeZ = 0
	end

	if players[steam].homeX == 0 and players[steam].homeZ == 0 then
		players[steam].homeY = 0
	end

	if (players[steam].home2X == nil) then
		players[steam].home2X = 0
		players[steam].home2Y = 0
		players[steam].home2Z = 0
	end

	if players[steam].home2X == 0 and players[steam].home2Z == 0 then
		players[steam].home2Y = 0
	end

	if (players[steam].waypointX == nil) then
		players[steam].waypointX = 0
		players[steam].waypointY = 0
		players[steam].waypointZ = 0
	end

	if (players[steam].timeout == nil) then
		players[steam].timeout = false
	end

	if (players[steam].alertPrison == nil) then
		players[steam].alertPrison = true
	end

	if (players[steam].alertReset == nil) then
		players[steam].alertReset = true
	end

	if (players[steam].alertMapLimit == nil) then
		players[steam].alertMapLimit = false
	end

	if (players[steam].alertRemovedClaims == nil) then
		players[steam].alertRemovedClaims = false
	end

	if (players[steam].walkies == nil) then
		players[steam].walkies = false
	end

	if (players[steam].newPlayer == nil) then
		players[steam].newPlayer = true
	end

	if (players[steam].sessionCount == nil) then
		players[steam].sessionCount = 1
	end

	if (players[steam].watchPlayer == nil) then
		players[steam].watchPlayer = true
	end

	if (players[steam].lastBaseRaid == nil) then
		players[steam].lastBaseRaid = 0
	end

	if players[steam].names == nil then
		players[steam].names = players[steam].name
	end

	if players[steam].playtime == nil then
		players[steam].playtime = 0
	end

	if players[steam].playerKills == nil then
		players[steam].playerKills = 0
	end

	if players[steam].deaths == nil then
		players[steam].deaths = 0
	end

	if players[steam].score == nil then
		players[steam].score = 0
	end

	if players[steam].zombies == nil then
		players[steam].zombies = 0
	end

	if players[steam].cash == nil then
		players[steam].cash = 0
	end

	if players[steam].overstackScore == nil then
		players[steam].overstack = false
		players[steam].overstackScore = 0
		players[steam].overstackItems = &quot;&quot;
		players[steam].overstackTimeout = false
	end

	if (players[steam].botTimeout == nil) then
		players[steam].botTimeout = false
	end

	if players[steam].pvpBounty == nil then
		players[steam].pvpBounty = 0
	end

	if (invTemp[steam] == nil) then
		invTemp[steam] = {}
	end

	if (friends[steam] == nil) then
		friends[steam] = {}
		friends[steam].friends = &quot;&quot;
	end

	if (lastHotspots[steam] == nil) then
		lastHotspots[steam] = {}
	end

	if players[steam].denyRights == nil then -- if true, a player is not allowed special roles like admin.
		players[steam].denyRights = false
	end

	if players[steam].lastCommand == nil then
		players[steam].lastCommand = &quot;&quot;
		players[steam].lastCommandTimestamp = os.time()
	end

	if players[steam].lastLogout == nil then
		players[steam].lastLogout = os.time()
		players[steam].relogCount = 0
	end

	if players[steam].atHome == nil then
		players[steam].atHome = false
	end

	if players[steam].autoFriend == nil then
		players[steam].autoFriend = &quot;&quot;
	end

	if players[steam].hackerScore == nil then
		players[steam].hackerScore = 0
	end

	if players[steam].tp == nil then
		players[steam].tp = 0
	end

	if (players[steam].bedX == nil) then
		players[steam].bedX = 0
		players[steam].bedY = 0
		players[steam].bedZ = 0
	end

	if players[steam].packCooldown == nil then
		players[steam].packCooldown = 0
	end
end


function fixMissingIGPlayer(steam)
	-- if any fields are missing from the players in-game player record, add them with default values

	if (igplayers[steam].steamOwner == nil) then
		igplayers[steam].steamOwner = steam
	end

	if igplayers[steam].playGimme == nil then
		igplayers[steam].playGimme = false
	end

	if igplayers[steam].alertRemovedClaims == nil then
		igplayers[steam].alertRemovedClaims = false
	end

	if (igplayers[steam].lastLogin == nil) then
		igplayers[steam].lastLogin = &quot;&quot;
	end

	if (igplayers[steam].greet == nil) then
		igplayers[steam].greet = false
	end

	if (igplayers[steam].greetdelay == nil) then
		igplayers[steam].greetdelay = 0
	end

	if (igplayers[steam].teleCooldown == nil) then
		igplayers[steam].teleCooldown = 0
	end

	if (igplayers[steam].firstSeen == nil) then
		igplayers[steam].firstSeen = os.time()
	end

	if (igplayers[steam].sessionStart == nil) then
		igplayers[steam].sessionStart = os.time()
	end

	if (igplayers[steam].sessionPlaytime == nil) then
		igplayers[steam].sessionPlaytime = 0
	end

	if (igplayers[steam].fetch == nil) then
		igplayers[steam].fetch = false
	end

	if (igplayers[steam].lastHotspot == nil) then
		igplayers[steam].lastHotspot = 0
	end

	if (igplayers[steam].inventory == nil) then
		igplayers[steam].inventory = &quot;&quot;
	end

	if (igplayers[steam].belt == nil) then
		igplayers[steam].belt = &quot;&quot;
	end

	if (igplayers[steam].pack == nil) then
		igplayers[steam].pack = &quot;&quot;
	end

	if (igplayers[steam].equipment == nil) then
		igplayers[steam].equipment = &quot;&quot;
	end

	if (igplayers[steam].illegalInventory == nil) then
		igplayers[steam].illegalInventory = false
	end

	if (igplayers[steam].inventoryLast == nil) then
		igplayers[steam].inventoryLast = &quot;&quot;
	end

	if (igplayers[steam].botQuestion == nil) then
		igplayers[steam].botQuestion = &quot;&quot;
	end

	if (igplayers[steam].region == nil) then
		igplayers[steam].region = &quot;&quot;
	end

	if (igplayers[steam].killTimer == nil) then
		igplayers[steam].killTimer = 0
	end

	if (igplayers[steam].connected == nil) then
		igplayers[steam].connected = true
	end

	if (igplayers[steam].timeOnServer == nil) then
		igplayers[steam].timeOnServer = players[steam].timeOnServer
	end

	if (igplayers[steam].region == nil) then
		igplayers[steam].region = &quot;&quot;
	end

	if (igplayers[steam].ping == nil) then
		igplayers[steam].ping = ping
	end

	if (igplayers[steam].xPos == nil) then
		igplayers[steam].xPos = 0
		igplayers[steam].yPos = 0
		igplayers[steam].zPos = 0

		igplayers[steam].xPosLast = 0
		igplayers[steam].yPosLast = 0
		igplayers[steam].zPosLast = 0

		igplayers[steam].xPosLastOK = 0
		igplayers[steam].yPosLastOK = 0
		igplayers[steam].zPosLastOK = 0
	end

	if (igplayers[steam].afk == nil) then
		igplayers[steam].afk = os.time() + 900
	end

	if igplayers[steam].lastCatchTimestamp == nil then
		igplayers[steam].lastCatchTimestamp = os.time()
	end

	if igplayers[steam].alertLocation == nil then
		igplayers[steam].alertLocation = &quot;&quot;
	end

	if igplayers[steam].notifyTP == nil then
		igplayers[steam].notifyTP = false
	end

	if igplayers[steam].lastLP == nil then
		igplayers[steam].lastLP = os.time()
	end

	if igplayers[steam].doge == nil then
		igplayers[steam].doge = false
	end

	if igplayers[steam].highPingCount == nil then
		igplayers[steam].highPingCount = 0
	end
end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>mysql</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


-- useful reference: luapower.com/mysql

mysql = require &quot;luasql.mysql&quot;

function initBotsData()
	local IP, country

	-- insert players in bots db
	for k, v in pairs(players) do
		if v.IP == nil then 
			IP = &quot;&quot; 
		else
			IP = v.IP
		end

		if v.country == nil then 
			country = &quot;&quot; 
		else
			country = v.country
		end
	end
end


function cleanupBotsData()
	if db2Connected then
		connBots:execute(&quot;UPDATE players set online = 0 WHERE server = '&quot; .. escape(server.ServerName) .. &quot;'&quot;)
	end
end


function registerBot()
	-- the server table in bots db should have 1 unique record for each server.  We achieve this by picking a random number and testing the server table
	-- to see if it is present.  We keep trying random numbers till we find an unused one then we insert a record into the servers table for this server.
	-- we record the new botID locally for later use.

	local id

	if not db2Connected then
		return
	end

	if tonumber(server.botID) == 0 then
		-- delete any server records with a botID of zero
		connBots:execute(&quot;DELETE FROM servers WHERE botID = 0&quot;)

		id = rand(9999)
		cursor,errorString = connBots:execute(&quot;select botID from servers where botID = &quot; .. id)

		while tonumber(cursor:numrows()) &gt; 0 do
			id = rand(9999)
			cursor,errorString = connBots:execute(&quot;select botID from servers where botID = &quot; .. id)
		end

		connBots:execute(&quot;INSERT INTO servers (ServerPort, IP, botName, serverName, playersOnline, tick, botID) VALUES (&quot; .. server.ServerPort .. &quot;,'&quot; .. server.IP .. &quot;','&quot; .. escape(server.botName) .. &quot;','&quot; .. escape(server.ServerName) .. &quot;',&quot; .. playersOnline .. &quot;, now(),&quot; .. id .. &quot;)&quot;)
		server.botID = id
		conn:execute(&quot;UPDATE server SET botID = &quot; .. id)
	end

	-- Try to insert the current players into the players table on bots db
	for k, v in pairs(igplayers) do
		insertBotsPlayer(k)
	end
end


function insertBotsPlayer(steam)
	if not db2Connected then
		return
	end

	connBots:execute(&quot;UPDATE players set online = 0 WHERE steam = &quot; .. steam)

	if tonumber(server.botID) &gt; 0 then
		-- insert player in bots db
		connBots:execute(&quot;INSERT INTO players (botID, server, steam, ip, name, online, level, zombies, score, playerKills, deaths, timeOnServer, playtime, country, ping) VALUES (&quot; .. server.botID .. &quot;,'&quot; .. escape(server.ServerName) .. &quot;',&quot; .. steam .. &quot;,'&quot; .. players[steam].IP .. &quot;','&quot; .. escape(players[steam].name) .. &quot;', 1,&quot; .. players[steam].level .. &quot;,&quot; .. players[steam].zombies .. &quot;,&quot; .. players[steam].score .. &quot;,&quot; .. players[steam].playerKills .. &quot;,&quot; .. players[steam].deaths .. &quot;,&quot; .. players[steam].timeOnServer .. &quot;,&quot; .. igplayers[steam].sessionPlaytime .. &quot;,'&quot; .. players[steam].country .. &quot;',&quot; .. players[steam].ping .. &quot;)&quot;)
	end
end


function updateBotsPlayer(steam)
	if not db2Connected then
		return
	end

	connBots:execute(&quot;UPDATE players set online = 0 WHERE steam = &quot; .. steam)

	if tonumber(server.botID) &gt; 0 then
		-- update player in bots db
		connBots:execute(&quot;UPDATE players SET ip = '&quot; .. players[steam].IP .. &quot;', name = '&quot; .. escape(players[steam].name) .. &quot;', online = 1, level = &quot; .. players[steam].level .. &quot;, zombies = &quot; .. players[steam].zombies .. &quot;, score = &quot; .. players[steam].score .. &quot;, playerKills = &quot; .. players[steam].playerKills .. &quot;, deaths = &quot; .. players[steam].deaths .. &quot;, timeOnServer  = &quot; .. players[steam].timeOnServer .. &quot;, playtime = &quot; .. igplayers[steam].sessionPlaytime .. &quot;, country = '&quot; .. players[steam].country .. &quot;', ping = &quot; .. players[steam].ping .. &quot; WHERE steam = &quot; .. steam .. &quot; AND botID = &quot; .. server.botID)
	end
end


function updateBotsServerTable()
	if not db2Connected then
		return
	end

	connBots:execute(&quot;UPDATE servers SET ServerPort = &quot; .. server.ServerPort .. &quot;, IP = '&quot; .. server.IP .. &quot;', botName = '&quot; .. escape(server.botName) .. &quot;', playersOnline = &quot; .. playersOnline .. &quot;, tick = now() WHERE botID = '&quot; .. escape(server.botID))
	connBots:execute(&quot;UPDATE players set online = 0 WHERE server = '&quot; .. escape(server.ServerName) .. &quot;'&quot;)

	-- updated players on bots db
	for k, v in pairs(igplayers) do
		-- update player in bots db
		connBots:execute(&quot;UPDATE players SET ip = '&quot; .. players[k].IP .. &quot;', name = '&quot; .. escape(v.name) .. &quot;', online = 1, level = &quot; .. v.level .. &quot;, zombies = &quot; .. v.zombies .. &quot;, score = &quot; .. v.score .. &quot;, playerKills = &quot; .. v.playerKills .. &quot;, deaths = &quot; .. v.deaths .. &quot;, timeOnServer  = &quot; .. players[k].timeOnServer .. &quot;, playtime = &quot; .. v.sessionPlaytime .. &quot;, country = '&quot; .. players[k].country .. &quot;', ping = &quot; .. v.ping .. &quot; WHERE steam = &quot; .. k .. &quot; AND botID = &quot; .. server.botID)
	end
end


function dumpTable(table)
	local cursor, errorString, row, fields, values, k, v, file

	cursor,errorString = conn:execute(&quot;SELECT * FROM &quot; .. table)
	row = cursor:fetch({}, &quot;a&quot;)

	file = io.open(homedir .. &quot;/&quot; .. table .. &quot;_&quot; .. os.date(&quot;%Y%m%d_%H%M%S&quot;) .. &quot;.csv&quot;, &quot;a&quot;)

	if row then
		fields = &quot;&quot;

		for k,v in pairs(row) do
			if fields ~= &quot;&quot; then fields = fields .. &quot;,&quot; end
			fields = fields .. k
		end

		file:write(fields .. &quot;\n&quot;)
	end

	while row do
		values = &quot;&quot;

		for k,v in pairs(row) do
			if values ~= &quot;&quot; then values = values .. &quot;,&quot; end
			values = values .. v
		end

		file:write(values .. &quot;\n&quot;)
		row = cursor:fetch(row, &quot;a&quot;)	
	end

	file:close()
end


function isDBBotsConnected()
	cursor,errorString = connBots:execute(&quot;select RAND() as rnum&quot;)
	row = cursor:fetch({}, &quot;a&quot;)

	if not row then
		return false
	else
		return true
	end
end


function isDBConnected()
	cursor,errorString = conn:execute(&quot;select RAND() as rnum&quot;)
	row = cursor:fetch({}, &quot;a&quot;)

	if not row then
		return false
	else
		return true
	end
end


function rand(high, low, real)
	-- generate a random number using MySQL
	if low == nil then low = 1 end
	if real == nil then
		cursor,errorString = conn:execute(&quot;select floor(RAND()*(&quot; .. high .. &quot;-&quot; .. low .. &quot;)+&quot; .. low .. &quot;) as rnum&quot;)
	else
		cursor,errorString = conn:execute(&quot;select RAND()*(&quot; .. high .. &quot;-&quot; .. low .. &quot;)+&quot; .. low .. &quot; as rnum&quot;)
	end

	row = cursor:fetch({}, &quot;a&quot;)
	return tonumber(row.rnum)
end


function nextID(table, idfield)
	local cursor, row, errorString

	cursor,errorString = conn:execute(&quot;SELECT MAX(&quot; .. idfield .. &quot;) as lastid FROM &quot; .. table)
	row = cursor:fetch({}, &quot;a&quot;)

	if row.id ~= nil then
		nextid = tonumber(row.lastid) + 1
	else
		nextid = 1
	end

	cursor:close()
	return nextid
end


function dbBaseDefend(steam, base)
-- experimental
	local cursor, errorString,row, dist

	dist = distancexz(igplayers[steam].xPos, igplayers[steam].zPos, players[base].homeX, players[base].homeZ)

	if dist &lt; server.baseSize then
		cursor,errorString = conn:execute(&quot;SELECT x, y, z FROM tracker WHERE steam = &quot; .. steam ..&quot; AND (abs(x - &quot; .. players[base].homeX .. &quot;) &gt; &quot; .. server.baseSize .. &quot; AND abs(z - &quot; .. players[base].homeZ .. &quot;) &gt; &quot; .. server.baseSize .. &quot;)  AND (abs(x - &quot; .. players[base].homeX .. &quot;) &lt; &quot; .. server.baseSize + 40 .. &quot; AND abs(z - &quot; .. players[base].homeZ .. &quot;) &lt; &quot; .. server.baseSize + 40 .. &quot;) ORDER BY trackerid DESC Limit 0, 50&quot;)
		row = cursor:fetch({}, &quot;a&quot;)
		while row do
			cmd = (&quot;tele &quot; .. steam .. &quot; &quot; .. row.x .. &quot; &quot; .. row.y .. &quot; &quot; .. row.z)
			teleport(cmd)

			if true then
				return
			end

			row = cursor:fetch(row, &quot;a&quot;)	
		end
	end
end


function escape(string)
	-- always escape your strings!

	if string == nil then
		return &quot;&quot;
	else
		return conn:escape(string)
	end
end


function dbTrue(value)
	-- translate db true false to Lua true false
	if value == &quot;0&quot; then
		return false
	else
		return true
	end
end


function dbYN(value)
	-- translate db true false to Lua true false
	if value == &quot;0&quot; then
		return &quot;No&quot;
	else
		return &quot;Yes&quot;
	end
end


function dbBool(value)
	-- translate Lua true false to db 1 or 0
	if value == false then
		return 0
	else
		return 1
	end
end


function initDB()
	alterTables()

	conn:execute(&quot;DELETE FROM ircQueue&quot;)
	conn:execute(&quot;DELETE FROM memTracker&quot;)
	conn:execute(&quot;DELETE FROM messageQueue&quot;)
	conn:execute(&quot;DELETE FROM commandQueue&quot;)
	conn:execute(&quot;DELETE FROM gimmeQueue&quot;)
	conn:execute(&quot;DELETE FROM searchResults&quot;)
end


function closeDB()
	conn:close()
	connBots:close()
	env:close()

	dbConnected = false
end


function openDB()
	lastAction = &quot;Open Database&quot;
	env = mysql.mysql()
-- EDIT ME!
	conn = env:connect(&quot;testbot&quot;, &quot;testbot&quot;, &quot;&quot;)

	conn:execute(&quot;INSERT INTO memRestrictedItems (select * from restrictedItems)&quot;)
	conn:execute(&quot;INSERT INTO memLottery (select * from lottery)&quot;)
end


function openBotsDB()
-- EDIT ME!
	connBots = env:connect(&quot;bots&quot;, &quot;bots&quot;, &quot;&quot;)
end


function importBlacklist()
	local cursor, cursor2, errorString, row

	if not db2Connected then
		return
	end

	cursor,errorString = connBots:execute(&quot;SELECT * FROM IPBlacklist&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		cursor2,errorString = conn:execute(&quot;INSERT INTO IPBlacklist (StartIP, EndIP) values (&quot; .. row.StartIP .. &quot;,&quot; .. row.EndIP .. &quot;)&quot;)
		row = cursor:fetch(row, &quot;a&quot;)	
	end

	cursor:close()
	cursor2:close()
end


function importBadItems()
	local cursor, cursor2, errorString, row

	if not db2Connected then
		return
	end

	conn:execute(&quot;DELETE FROM badItems&quot;)

	cursor,errorString = connBots:execute(&quot;SELECT * FROM badItems&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		cursor2,errorString = conn:execute(&quot;INSERT INTO badItems (item, action) values ('&quot; .. escape(row.item) .. &quot;','&quot; .. row.action .. &quot;')&quot;)
		row = cursor:fetch(row, &quot;a&quot;)	
	end

	cursor:close()
	cursor2:close()
end


function alterTables()
-- These are here to make it easier to update other bots while the bot is in development.
	conn:execute(&quot;ALTER TABLE `hotspots` CHANGE `size` `size` INT(11) NOT NULL DEFAULT '2'&quot;)
	conn:execute(&quot;ALTER TABLE `hotspots` ADD `idx` INT NOT NULL DEFAULT '0'&quot;)
	conn:execute(&quot;ALTER TABLE `keystones` ADD `removed` int(11) NOT NULL DEFAULT '1'&quot;)
	conn:execute(&quot;DROP TABLE `languages`&quot;)
	conn:execute(&quot;ALTER TABLE `locations` ADD `resetZone` tinyint(1) NOT NULL DEFAULT '0'&quot;)
	conn:execute(&quot;ALTER TABLE `players` DROP `teleCooldown`&quot;)
	conn:execute(&quot;ALTER TABLE `server` ADD `gameType` VARCHAR(3) NOT NULL DEFAULT 'pve'&quot;)
	conn:execute(&quot;ALTER TABLE `players` ADD `donorLevel` INT NOT NULL DEFAULT '0' , ADD `donorExpiry` TIMESTAMP NOT NULL&quot;)
	conn:execute(&quot;ALTER TABLE `locations` ADD `other` VARCHAR(10) NULL DEFAULT NULL&quot;)
	conn:execute(&quot;ALTER TABLE `server` ADD `hideCommands` BOOLEAN NOT NULL DEFAULT TRUE&quot;)
	conn:execute(&quot;ALTER TABLE `locations` ADD `killZombies` BOOLEAN NOT NULL DEFAULT FALSE&quot;)
	conn:execute(&quot;ALTER TABLE `players` ADD `autoFriend` VARCHAR(2) NOT NULL COMMENT 'NA/AF/AD'&quot;)
	conn:execute(&quot;ALTER TABLE `server` ADD `botTick` INT NOT NULL DEFAULT '0'&quot;)
	conn:execute(&quot;ALTER TABLE `players` ADD `ircOtherNames` VARCHAR(50) NULL&quot;)
	conn:execute(&quot;ALTER TABLE `performance` ADD `heapMax` FLOAT NOT NULL AFTER `heap`&quot;)
	conn:execute(&quot;ALTER TABLE `proxies` DROP `id`&quot;)
	conn:execute(&quot;ALTER TABLE `players` ADD `steamOwner` BIGINT(17) NOT NULL&quot;)
	conn:execute(&quot;ALTER TABLE `server` ADD `serverGroup` VARCHAR(20) NULL DEFAULT NULL&quot;)
	conn:execute(&quot;ALTER TABLE `server` ADD `botID` INT NOT NULL DEFAULT '0'&quot;)
	conn:execute(&quot;ALTER TABLE `server` ADD `allowOverstacking` BOOLEAN NOT NULL DEFAULT FALSE&quot;)
	conn:execute(&quot;CREATE TABLE IF NOT EXISTS `list` (`thing` varchar(255) NOT NULL) ENGINE=MEMORY DEFAULT CHARSET=latin1 COMMENT='For sorting a list'&quot;)
	conn:execute(&quot;ALTER TABLE `list` ADD UNIQUE KEY `thing` (`thing`)&quot;)
	conn:execute(&quot;ALTER TABLE `server` ADD `announceTeleports` BOOLEAN NOT NULL&quot;)
	conn:execute(&quot;ALTER TABLE `server` ADD `blockCountries` VARCHAR(60) NOT NULL DEFAULT 'CN'&quot;)
	conn:execute(&quot;ALTER TABLE `server` ADD `northeastZone` VARCHAR(5) NOT NULL DEFAULT 'pve', ADD `northwestZone` VARCHAR(5) NOT NULL DEFAULT 'pve' , ADD `southeastZone` VARCHAR(5) NOT NULL DEFAULT 'pve' , ADD `southwestZone` VARCHAR(5) NOT NULL DEFAULT 'pve'&quot;)
	conn:execute(&quot;ALTER TABLE `server` ADD `allowPhysics` BOOLEAN NOT NULL DEFAULT TRUE&quot;)
	conn:execute(&quot;ALTER TABLE `server` ADD `playersCanFly` BOOLEAN NOT NULL DEFAULT FALSE&quot;)
	conn:execute(&quot;ALTER TABLE `server` ADD `accessLevelOverride` INT NOT NULL DEFAULT '99'&quot;)
	conn:execute(&quot;ALTER TABLE `server` ADD `disableBaseProtection` BOOLEAN NOT NULL DEFAULT FALSE&quot;)
	conn:execute(&quot;ALTER TABLE `players` ADD `bedX` INT NOT NULL DEFAULT '0' , ADD `bedY` INT NOT NULL DEFAULT '0' , ADD `bedZ` INT NOT NULL DEFAULT '0'&quot;)
	conn:execute(&quot;ALTER TABLE `server` ADD `packCooldown` INT NOT NULL DEFAULT '0'&quot;)
	conn:execute(&quot;ALTER TABLE `server` ADD `moneyName` VARCHAR(20) NOT NULL DEFAULT 'Zenny|Zennies'&quot;)
	conn:execute(&quot;ALTER TABLE `server` ADD `allowBank` BOOLEAN NOT NULL DEFAULT TRUE&quot;)
	conn:execute(&quot;ALTER TABLE `server` ADD `overstackThreshold` INT NOT NULL DEFAULT '1000'&quot;)
	conn:execute(&quot;ALTER TABLE `server` ADD `enableRegionPM` BOOLEAN NOT NULL DEFAULT TRUE&quot;)
	conn:execute(&quot;ALTER TABLE `players` ADD `showLocationMessages` BOOLEAN NOT NULL DEFAULT TRUE&quot;)
	conn:execute(&quot;ALTER TABLE `server` ADD `allowRapidRelogging` TINYINT NOT NULL DEFAULT '1'&quot;)
	conn:execute(&quot;ALTER TABLE `players` ADD `mute` TINYINT NOT NULL DEFAULT '0'&quot;)
	conn:execute(&quot;ALTER TABLE `server` ADD `allowLottery` TINYINT NOT NULL DEFAULT '1', ADD `lotteryMultiplier` INT NOT NULL DEFAULT '2', ADD `zombieKillReward` INT NOT NULL DEFAULT '3'&quot;)
	conn:execute(&quot;ALTER TABLE `players` ADD `xPosOld2` INT NOT NULL DEFAULT '0' , ADD `yPosOld2` INT NOT NULL DEFAULT '0' , ADD `zPosOld2` INT NOT NULL DEFAULT '0'&quot;)
	conn:execute(&quot;ALTER TABLE `server` ADD `ircTracker` VARCHAR(15) NOT NULL DEFAULT '#new_tracker'&quot;)
	conn:execute(&quot;CREATE TABLE IF NOT EXISTS `whitelist` (`steam` bigint(17) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=latin1&quot;)
end


function readBotTick()
	local cursor, errorString, row

	cursor,errorString = conn:execute(&quot;select botTick from server&quot;)
	row = cursor:fetch({}, &quot;a&quot;)

	if row then
		return tonumber(row.botTick)
	end

	cursor:close()	
end


function writeBotTick()
	if botTick == nil then
		botTick = 0
	end

	botTick = tonumber(botTick) + 1
	conn:execute(&quot;update server set botTick = &quot; .. botTick)

	if db2Connected then
		connBots:execute(&quot;UPDATE servers SET tick = now() WHERE botID = &quot; .. server.botID)
	end
end


function checkBotTick()
	local tick

	tick = readBotTick()

	if tick ~= botTick then
		botDisabled = true
		dbug(&quot;Another bot has been detected.  This bot has been disabled.&quot;)
		irc_QueueMsg(server.ircMain, &quot;Another bot has been detected.  This bot has been disabled.  Do not run multiples of the same bot!&quot;)
		disconnect()
	end
end                                                                                                      </script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_base</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
base commands
=============
set base size
setbed
setbase
protect
base
delbase
protectbase
unprotectbase
setbase &lt;player&gt;
pause
resume
test base
--]]


function gmsg_base()
	calledFunction = &quot;gmsg_base&quot;

	local id, pname, psize,  words, word, dist, debug, dist1, dist2, wait, loc, reset

	debug = false

if debug then dbug(&quot;debug base 0&quot;) end

	-- don't proceed if there is no leading slash
	if (string.sub(chatvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyChat = false
		return false
	end
  
--working
	if (chatvars.words[1] == &quot;set&quot; and (chatvars.words[2] == &quot;base&quot; or chatvars.words[2] == &quot;base2&quot;) and chatvars.words[3] == &quot;size&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				chatvars.faultyChat = false
				return true
			end
		end

		pname = &quot;&quot;
		words = {}
		for word in chatvars.command:gmatch(&quot;%w+&quot;) do table.insert(words, word) end

		id = LookupPlayer(chatvars.words[5])
		if (players[id]) then
			pname = players[id].name
		end

		psize = string.match(chatvars.command, &quot; (%d+)&quot;)
		psize = tonumber(psize)

		if (pname == &quot;&quot;) then
			faultyChat = false
			return
		end

		if (chatvars.words[2] == &quot;base&quot;) then
			if (players[id]) then players[id].protectSize = psize end

			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name ..&quot;'s base is protected to &quot; .. psize .. &quot; metres from their base teleport[-]&quot;)
			conn:execute(&quot;UPDATE players SET protectSize = &quot; .. psize .. &quot; WHERE steam = &quot; .. id)

			if db2Connected then
				-- update player in bots db
				connBots:execute(&quot;UPDATE players SET protectSize = &quot; .. psize .. &quot; WHERE steam = &quot; .. id .. &quot; AND botID = &quot; .. server.botID)
			end
		else
			if (accessLevel(id) &lt; 11) then
				if (players[id]) then players[id].protect2Size = psize end

				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name ..&quot;'s 2nd base is protected to &quot; .. psize .. &quot; metres from their base teleport[-]&quot;)
				conn:execute(&quot;UPDATE players SET protect2Size = &quot; .. psize .. &quot; WHERE steam = &quot; .. id)

				if db2Connected then
					-- update player in bots db
					connBots:execute(&quot;UPDATE players SET protect2Size = &quot; .. psize .. &quot; WHERE steam = &quot; .. id .. &quot; AND botID = &quot; .. server.botID)
				end
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug base 1&quot;) end

	if (chatvars.words[1] == &quot;setbed&quot;) then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/setbed makes your nearest base your spawn point after you die.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Unlike a real bed, this can't be broken or stolen. Also it doesn't show up on the map or compass.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Use it within 50 metres of your base.[-]&quot;)

		dist = distancexz(chatvars.intX, chatvars.intZ, players[chatvars.playerid].homeX, players[chatvars.playerid].homeZ)
		if dist &lt; 50 then
			players[chatvars.playerid].bed = &quot;base1&quot;
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You will respawn at your first base after death.[-]&quot;)

			conn:execute(&quot;UPDATE players SET bed = 'base1' WHERE steam = &quot; .. id)
		end

		if (players[chatvars.playerid].homeX ~= 0 and players[chatvars.playerid].homeZ ~= 0) then
			dist = distancexz(chatvars.intX, chatvars.intZ, players[chatvars.playerid].home2X, players[chatvars.playerid].home2Z)
			if dist &lt; 50 then
				players[chatvars.playerid].bed = &quot;base2&quot;
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You will respawn at your second base after death.[-]&quot;)

				conn:execute(&quot;UPDATE players SET bed = 'base2' WHERE steam = &quot; .. id)
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug base 2&quot;) end

	if (chatvars.words[1] == &quot;man&quot; and chatvars.words[2] == &quot;sethome&quot; or chatvars.words[2] == &quot;setbase&quot; or chatvars.words[2] == &quot;sethome2&quot; or chatvars.words[2] == &quot;setbase2&quot;) then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/setbase (/setbase2) tells the bot where your base(s) are so the bot can defend them and alert you and admins to raids.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]It is also used by /base to teleport you back to the spot where /setbase is done.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can and should set base protection next.  Type /man protect for info.[-]&quot;)

		faultyChat = false
		return true
	end

	if (chatvars.words[1] == &quot;sethome&quot; or chatvars.words[1] == &quot;setbase&quot; or chatvars.words[1] == &quot;sethome2&quot; or chatvars.words[1] == &quot;setbase2&quot;) and chatvars.words[2] == nil then
		if (players[chatvars.playerid].timeout == true) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are in timeout. Trust me, you don't want your base here.[-]&quot;)
			faultyChat = false
			return true
		end

		loc, reset = inLocation(igplayers[chatvars.playerid].xPos, igplayers[chatvars.playerid].zPos)

		if resetRegions[chatvars.region] or reset then --  and (accessLevel(chatvars.playerid) &gt; 2 or server.ignoreAdmins == false)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are in a reset zone. Do not set your base here. It will be deleted when this zone is reset.[-]&quot;)
			faultyChat = false
			return true
		end

		if not validPosition(chatvars.playerid, true) then
			faultyChat = false
			return true
		end

		for k, v in pairs(locations) do
			if v.village == nil then
				dist = distancexz(igplayers[chatvars.playerid].xPos, igplayers[chatvars.playerid].zPos, locations[k].x, locations[k].z)

				if locations[k].size ~= nil then
					psize = locations[k].size
				else
					psize = server.baseSize
				end

				if v.allowBase == true then
					psize = 0
				end

				if dist &lt;= tonumber(psize) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are too close to a location.  You are not allowed to set your base here.[-]&quot;)
					faultyChat = false
					return true
				end
			end
		end

		-- set the players home coords
		if (chatvars.words[1] == &quot;sethome&quot; or chatvars.words[1] == &quot;setbase&quot;) then
			players[chatvars.playerid].homeX = chatvars.intX
			players[chatvars.playerid].homeY = chatvars.intY
			players[chatvars.playerid].homeZ = chatvars.intZ
			players[chatvars.playerid].exitX = chatvars.intX
			players[chatvars.playerid].exitY = chatvars.intY
			players[chatvars.playerid].exitZ = chatvars.intZ
			players[chatvars.playerid].protect = false
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is your new home location.[-]&quot;)

			conn:execute(&quot;UPDATE players SET homeX = &quot; .. chatvars.intX .. &quot;, homeY = &quot; .. chatvars.intY .. &quot;, homeZ = &quot; .. chatvars.intZ .. &quot;, exitX = &quot; .. chatvars.intX .. &quot;, exitY = &quot; .. chatvars.intY .. &quot;, exitZ = &quot; .. chatvars.intZ .. &quot;, protect = 0 WHERE steam = &quot; .. chatvars.playerid)
			conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. chatvars.intX .. &quot;,&quot; .. chatvars.intY .. &quot;,&quot; .. chatvars.intZ .. &quot;,'&quot; .. serverTime .. &quot;','setbase','Player &quot; .. escape(players[chatvars.playerid].name) .. &quot; set a base',&quot; .. chatvars.playerid .. &quot;)&quot;)
			removeInvalidHotspots(chatvars.playerid)
			irc_QueueMsg(server.ircWatch, players[chatvars.playerid].name .. &quot; has setbase at &quot; .. chatvars.intX .. &quot; &quot; .. chatvars.intY .. &quot; &quot; .. chatvars.intZ)

			if db2Connected then
				-- update player in bots db
				connBots:execute(&quot;UPDATE players SET homeX = &quot; .. chatvars.intX .. &quot;, homeY = &quot; .. chatvars.intY .. &quot;, homeZ = &quot; .. chatvars.intZ .. &quot;, exitX = &quot; .. chatvars.intX .. &quot;, exitY = &quot; .. chatvars.intY .. &quot;, exitZ = &quot; .. chatvars.intZ .. &quot;, protect = 0 WHERE steam = &quot; .. id .. &quot; AND botID = &quot; .. server.botID)
			end
		else
			if accessLevel(chatvars.playerid) &lt; 11 then
				players[chatvars.playerid].home2X = chatvars.intX
				players[chatvars.playerid].home2Y = chatvars.intY
				players[chatvars.playerid].home2Z = chatvars.intZ
				players[chatvars.playerid].exit2X = chatvars.intX
				players[chatvars.playerid].exit2Y = chatvars.intY
				players[chatvars.playerid].exit2Z = chatvars.intZ
				players[chatvars.playerid].protect2 = false
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is the location of your 2nd base.[-]&quot;)

				conn:execute(&quot;UPDATE players SET home2X = &quot; .. chatvars.intX .. &quot;, home2Y = &quot; .. chatvars.intY .. &quot;, home2Z = &quot; .. chatvars.intZ .. &quot;, exit2X = &quot; .. chatvars.intX .. &quot;, exit2Y = &quot; .. chatvars.intY .. &quot;, exit2Z = &quot; .. chatvars.intZ .. &quot;, protect2 = 0 WHERE steam = &quot; .. chatvars.playerid)
				removeInvalidHotspots(chatvars.playerid)
				irc_QueueMsg(server.ircWatch, players[chatvars.playerid].name .. &quot; has setbase 2 at &quot; .. chatvars.intX .. &quot; &quot; .. chatvars.intY .. &quot; &quot; .. chatvars.intZ)

				if db2Connected then
					-- update player in bots db
					connBots:execute(&quot;UPDATE players SET home2X = &quot; .. chatvars.intX .. &quot;, home2Y = &quot; .. chatvars.intY .. &quot;, home2Z = &quot; .. chatvars.intZ .. &quot;, exit2X = &quot; .. chatvars.intX .. &quot;, exit2Y = &quot; .. chatvars.intY .. &quot;, exit2Z = &quot; .. chatvars.intZ .. &quot;, protect2 = 0 WHERE steam = &quot; .. id .. &quot; AND botID = &quot; .. server.botID)
				end
			else
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Only donors and admins can have 2 bases. Consider donating. =D[-]&quot;)
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Please let us know if you are still seeing this message after donating.[-]&quot;)
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug base 3&quot;) end

	if (chatvars.words[1] == &quot;man&quot; and chatvars.words[2] == &quot;protect&quot;) and not server.gameType == &quot;pvp&quot; then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/protect defends your base from raiders by teleporting them out.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]From you base tp type /protect then just walk away from your base. The bot will do the rest.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can /pause and /resume protection or permanently allow friends in by friending them with /friend[-]&quot;)

		faultyChat = false
		return true
	end

	if (chatvars.words[1] == &quot;protect&quot; or chatvars.words[1] == &quot;protect2&quot; and not players[chatvars.playerid].prisoner and chatvars.words[2] ~= &quot;village&quot;) then
		if server.disableBaseProtection or server.gameType == &quot;pvp&quot; then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Base protection is disabled on this server.  Use claim blocks instead.[-]&quot;)
			faultyChat = false
			return true
		end

		-- allow base protection after player has played 30 minutes
		if (players[chatvars.playerid].newPlayer == true) and (players[chatvars.playerid].timeOnServer + igplayers[chatvars.playerid].sessionPlaytime &lt; 1800) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is not available to you yet.  It will be automatically unlocked soon.[-]&quot;)
			faultyChat = false
			return true
		end

		id = chatvars.playerid

		if (chatvars.words[2] ~= nil and accessLevel(chatvars.playerid) &lt; 4) then
			pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;protect&quot;) + 8)
			pname = string.trim(pname)
			id = LookupPlayer(pname)
		end

		if players[chatvars.playerid].inLocation ~= &quot;&quot; then
			if locations[players[chatvars.playerid].inLocation].pvp or server.gameType == &quot;pvp&quot; then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Base protection is not allowed where PVP rules are in effect.[-]&quot;)
				faultyChat = false
				return true
			end
		end

		if not validPosition(chatvars.playerid, true) then
			faultyChat = false
			return true
		end

		if chatvars.words[1] == &quot;protect&quot; then
			dist = distancexz(igplayers[chatvars.playerid].xPos, igplayers[chatvars.playerid].zPos, players[id].homeX, players[id].homeZ)
		else
			dist = distancexz(igplayers[chatvars.playerid].xPos, igplayers[chatvars.playerid].zPos, players[id].home2X, players[id].home2Z)
		end

		if (chatvars.words[1] == &quot;protect&quot;) then
			if (tonumber(dist) &lt;  tonumber(players[id].protectSize) + 1) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are too close to the base, but just walk away and I will set it when you are far enough away.[-]&quot;)
				igplayers[chatvars.playerid].alertBaseExit = true
				igplayers[chatvars.playerid].alertBaseID = id
				igplayers[chatvars.playerid].alertBase = 1
				faultyChat = false
				return true
			end

			if (tonumber(dist) &gt;  tonumber(players[id].protectSize) + 20) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are too far from the base, but just walk towards the base and I will set it when you are close enough.[-]&quot;)
				igplayers[chatvars.playerid].alertBaseExit = true
				igplayers[chatvars.playerid].alertBaseID = id
				igplayers[chatvars.playerid].alertBase = 1
				faultyChat = false
				return true
			end

			players[id].exitX = chatvars.intX
			players[id].exitY = chatvars.intY
			players[id].exitZ = chatvars.intZ

			conn:execute(&quot;UPDATE players SET exitX = &quot; .. chatvars.intX .. &quot;, exitY = &quot; .. chatvars.intY .. &quot;, exitZ = &quot; .. chatvars.intZ .. &quot; WHERE steam = &quot; .. id)

			igplayers[chatvars.playerid].alertBaseExit = nil
			igplayers[chatvars.playerid].alertBaseID = nil
			igplayers[chatvars.playerid].alertBase = nil

			if (accessLevel(chatvars.playerid) &lt; 3) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have set an exit teleport for &quot; .. players[id].name .. &quot;'s base.[-]&quot;)
			else
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have set an exit teleport for your base.[-]&quot;)
			end

			-- check for nearby bases
			failProtect = false
			for k, v in pairs(players) do
				if (v.homeX ~= nil) and k ~= id then
						if (v.homeX ~= 0 and v.homeZ ~= 0) then
						dist = distancexz(players[id].homeX, players[id].homeZ, v.homeX, v.homeZ)

						if (tonumber(dist) &lt; tonumber(players[id].protectSize)) then
							if not isFriend(k, id) then
								failProtect = true
							end
						end
					end
				end

				if (v.home2X ~= nil) then
						if (v.home2X ~= 0 and v.home2Z ~= 0) then
						dist = distancexz(players[id].homeX, players[id].homeZ, v.home2X, v.home2Z)

						if (dist &lt; players[id].protectSize + 10) then
							if not isFriend(k, id) then
								failProtect = true
							end
						end
					end
				end
			end

			if failProtect == false then
				players[id].protect = true
				message(&quot;pm &quot; .. id .. &quot; [&quot; .. server.chatColour .. &quot;]Base protection for your base is active.[-]&quot;)

				if db2Connected then
					-- update player in bots db
					connBots:execute(&quot;UPDATE players SET exitX = &quot; .. chatvars.intX .. &quot;, exitY = &quot; .. chatvars.intY .. &quot;, exitZ = &quot; .. chatvars.intZ .. &quot;, protect = 1 WHERE steam = &quot; .. id .. &quot; AND botID = &quot; .. server.botID)
				end
			else
				message(&quot;pm &quot; .. id .. &quot; [&quot; .. server.chatColour .. &quot;]Your base is too close to another player base who is not on your friends list.  Protection cannot be enabled.[-]&quot;)

				if db2Connected then
					-- update player in bots db
					connBots:execute(&quot;UPDATE players SET exitX = &quot; .. chatvars.intX .. &quot;, exitY = &quot; .. chatvars.intY .. &quot;, exitZ = &quot; .. chatvars.intZ .. &quot;, protect = 0 WHERE steam = &quot; .. id .. &quot; AND botID = &quot; .. server.botID)
				end
			end
		else
			if (tonumber(dist) &lt;  tonumber(players[id].protect2Size) + 1) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are too close to the base, but just walk away and I will set it when you are far enough away.[-]&quot;)
				igplayers[chatvars.playerid].alertBaseExit = true
				igplayers[chatvars.playerid].alertBaseID = id
				igplayers[chatvars.playerid].alertBase = 2
				faultyChat = false
				return true
			end

			if (tonumber(dist) &gt;  tonumber(players[id].protect2Size) + 20) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are too far from the base, but just walk towards the base and I will set it when you are close enough.[-]&quot;)
				igplayers[chatvars.playerid].alertBaseExit = true
				igplayers[chatvars.playerid].alertBaseID = id
				igplayers[chatvars.playerid].alertBase = 2
				faultyChat = false
				return true
			end

			players[id].exit2X = chatvars.intX
			players[id].exit2Y = chatvars.intY
			players[id].exit2Z = chatvars.intZ

			conn:execute(&quot;UPDATE players SET exit2X = &quot; .. chatvars.intX .. &quot;, exit2Y = &quot; .. chatvars.intY .. &quot;, exit2Z = &quot; .. chatvars.intZ .. &quot; WHERE steam = &quot; .. id)

			igplayers[chatvars.playerid].alertBaseExit = nil
			igplayers[chatvars.playerid].alertBaseID = nil
			igplayers[chatvars.playerid].alertBase = nil

			if (accessLevel(chatvars.playerid) &lt; 3) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have set an exit teleport for &quot; .. players[id].name .. &quot;'s 2nd base.[-]&quot;)
			else
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have set an exit teleport for your 2nd base.[-]&quot;)
			end

			-- check for nearby bases
			failProtect = false
			for k, v in pairs(players) do
				if (v.homeX) and (v.homeX ~= 0 and v.homeZ ~= 0) then
					dist = distancexz(players[id].home2X, players[id].home2Z, v.homeX, v.homeZ)

					if (dist &lt; players[id].protectSize2 + 10) then
						if not isFriend(k, id) then
							failProtect = true
						end
					end
				end

				if (v.home2X) and (v.home2X ~= 0 and v.home2Z ~= 0) then
					dist = distancexz(players[id].home2X, players[id].home2Z, v.home2X, v.home2Z)

					if (dist &lt; players[id].protectSize2 + 10) then
						if not isFriend(k, id) then
							failProtect = true
						end
					end
				end
			end

			if failProtect == false then
				players[id].protect2 = true
				message(&quot;pm &quot; .. id .. &quot; [&quot; .. server.chatColour .. &quot;]Base protection for your second base is active.[-]&quot;)

				if db2Connected then
					-- update player in bots db
					connBots:execute(&quot;UPDATE players SET exit2X = &quot; .. chatvars.intX .. &quot;, exit2Y = &quot; .. chatvars.intY .. &quot;, exit2Z = &quot; .. chatvars.intZ .. &quot;, protect2 = 1 WHERE steam = &quot; .. id .. &quot; AND botID = &quot; .. server.botID)
				end
			else
				message(&quot;pm &quot; .. id .. &quot; [&quot; .. server.chatColour .. &quot;]Your base is too close to another player base who is not on your friends list.  Protection cannot be enabled.[-]&quot;)

				if db2Connected then
					-- update player in bots db
					connBots:execute(&quot;UPDATE players SET exit2X = &quot; .. chatvars.intX .. &quot;, exit2Y = &quot; .. chatvars.intY .. &quot;, exit2Z = &quot; .. chatvars.intZ .. &quot;, protect2 = 0 WHERE steam = &quot; .. id .. &quot; AND botID = &quot; .. server.botID)
				end
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug base 4&quot;) end

	if chatvars.words[1] == &quot;man&quot; and (chatvars.words[2] == &quot;base&quot; or chatvars.words[2] == &quot;home&quot;) then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Teleport back to your base with /base or /home.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]After using /base there is a delay set by the server owner before you can use it again.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Also the base teleport disables /return so you have to walk to return to where you were.[-]&quot;)

		faultyChat = false
		return true
	end

	if chatvars.words[1] == &quot;homer&quot; and chatvars.words[2] == nil then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Doh![-]&quot;)
		faultyChat = false
		return true
	end

	if (chatvars.words[1] == &quot;base&quot; or chatvars.words[1] == &quot;home&quot; or chatvars.words[1] == &quot;base2&quot; or chatvars.words[1] == &quot;home2&quot;) and chatvars.words[2] == nil then
		if (accessLevel(chatvars.playerid) &gt; 10) and (chatvars.words[1] == &quot;base2&quot; or chatvars.words[1] == &quot;home2&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Only donors can have 2 base teleports and base protections.  Consider donating =D[-]&quot;)
			faultyChat = false
			return true
		end

if debug then dbug(&quot;debug base 4a&quot;) end

		if (players[chatvars.playerid].timeout == true) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are in timeout. Wait for an admin to /return you.[-]&quot;)
			faultyChat = false
			return true
		end

if debug then dbug(&quot;debug base 4b&quot;) end

		if (players[chatvars.playerid].prisoner or not players[chatvars.playerid].canTeleport) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are not allowed to use teleports.[-]&quot;)
			faultyChat = false
			return true
		end

		if (chatvars.words[1] == &quot;base&quot; or chatvars.words[1] == &quot;home&quot;) and (players[chatvars.playerid].homeY == 0) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have not set a base yet. Type /setbase in your base first then /base will work.[-]&quot;)

			if server.coppi then
				igplayers[chatvars.playerid].sendHome = true
				send(&quot;lpb &quot; .. chatvars.playerid)
			end

			faultyChat = false
			return true
		end

		if (accessLevel(chatvars.playerid) &lt; 11) then
			if (chatvars.words[1] == &quot;base2&quot; or chatvars.words[1] == &quot;home2&quot;) and (players[chatvars.playerid].home2Y == 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have not set a 2nd base yet. Type /setbase2 in your base first then /base2 will work.[-]&quot;)
				faultyChat = false
				return true
			end
		end

if debug then dbug(&quot;debug base 4c&quot;) end

		wait = true

		if chatvars.intY &gt; 0 then
			if (players[chatvars.playerid].walkies == true) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have not opted in to using teleports. Type /enabletp to opt-in.[-]&quot;)
				faultyChat = false
				return true
			end

if debug then dbug(&quot;debug base 4d&quot;) end

			dist1 = distancexz(players[chatvars.playerid].xPos, players[chatvars.playerid].zPos, players[chatvars.playerid].homeX, players[chatvars.playerid].homeZ)
			dist2 = distancexz(players[chatvars.playerid].xPos, players[chatvars.playerid].zPos, players[chatvars.playerid].home2X, players[chatvars.playerid].home2Z)

			if (chatvars.words[1] == &quot;base&quot; or chatvars.words[1] == &quot;home&quot;) and (tonumber(dist1) &lt; 201) then
				wait = false
			end

			if (chatvars.words[1] == &quot;base2&quot; or chatvars.words[1] == &quot;home2&quot;) and (tonumber(dist2) &lt; 201) then
				wait = false
			end

			if (accessLevel(chatvars.playerid) &gt; 3) then
				if (players[chatvars.playerid].baseCooldown - os.time() &gt; 0) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have to wait &quot; .. os.date(&quot;%M minutes %S seconds&quot;,players[chatvars.playerid].baseCooldown - os.time()) .. &quot; before you can use /base again.[-]&quot;)
					faultyChat = false
					return true
				end
			end
		end

if debug then dbug(&quot;debug base 4h&quot;) end

		-- first record the current x y z
		if accessLevel(chatvars.playerid) &lt; 3 then
			igplayers[chatvars.playerid].lastLocation = &quot;&quot;
			savePosition(chatvars.playerid)
		else
			igplayers[chatvars.playerid].lastLocation = &quot;&quot;
			players[chatvars.playerid].xPosOld = 0
			players[chatvars.playerid].yPosOld = 0
			players[chatvars.playerid].zPosOld = 0
		end

if debug then dbug(&quot;debug base 4i&quot;) end

		if wait then
			if players[chatvars.playerid].donor then
				players[chatvars.playerid].baseCooldown = (os.time() + math.floor(tonumber(server.baseCooldown) / 2))
			else
				players[chatvars.playerid].baseCooldown = (os.time() + server.baseCooldown)
			end
		end

if debug then dbug(&quot;debug base 4j&quot;) end

		conn:execute(&quot;UPDATE players SET xPosOld = &quot; .. players[chatvars.playerid].xPosOld .. &quot;, yPosOld = &quot; .. players[chatvars.playerid].yPosOld .. &quot;, zPosOld = &quot; .. players[chatvars.playerid].zPosOld .. &quot;, baseCooldown = &quot; .. players[chatvars.playerid].baseCooldown .. &quot; WHERE steam = &quot; .. chatvars.playerid)

if debug then dbug(&quot;debug base 4k&quot;) end

		if (chatvars.words[1] == &quot;base&quot; or chatvars.words[1] == &quot;home&quot;) then
			cmd = &quot;tele &quot; .. chatvars.playerid .. &quot; &quot; .. players[chatvars.playerid].homeX .. &quot; &quot; .. players[chatvars.playerid].homeY + 1 .. &quot; &quot; .. players[chatvars.playerid].homeZ
		else
			cmd = &quot;tele &quot; .. chatvars.playerid .. &quot; &quot; .. players[chatvars.playerid].home2X .. &quot; &quot; .. players[chatvars.playerid].home2Y + 1 .. &quot; &quot; .. players[chatvars.playerid].home2Z
		end

		if wait then
			prepareTeleport(chatvars.playerid, cmd)
			teleport(cmd)
		else
			players[chatvars.playerid].tp = 1
			players[chatvars.playerid].hackerScore = 0
			send(cmd)
		end

if debug then dbug(&quot;debug base 4l&quot;) end

		faultyChat = false
		return true
	end

if debug then display (&quot;debug base 6\n&quot;) end

	if (chatvars.words[1] == &quot;man&quot; and chatvars.words[2] == &quot;delbase&quot;) then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/delbase will make me forget your base which also removes base protection.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]If you are moving your base you can just type /setbase at the new location.[-]&quot;)

		faultyChat = false
		return true
	end

	if (chatvars.words[1] == &quot;delbase&quot;) then
		id = chatvars.playerid

		if (chatvars.playername == &quot;Server&quot;) or (accessLevel(chatvars.playerid) &lt; 3) then
			if (chatvars.words[2] ~= nil) then
				pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;delbase&quot;) + 8)
				pname = string.trim(pname)
				id = LookupPlayer(pname)
				if id == nil then
					if (chatvars.playername ~= &quot;Server&quot;) then 
						message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No player found called &quot; .. pname .. &quot;[-]&quot;)
					else
						irc_QueueMsg(server.ircMain, &quot;No player found called &quot; .. pname)
					end

					faultyChat = false
					return true
				end
			end
		end

		players[id].homeX = 0
		players[id].homeY = 0
		players[id].homeZ = 0
		players[id].exitX = 0
		players[id].exitY = 0
		players[id].exitZ = 0
		players[id].protect = false

		conn:execute(&quot;UPDATE players SET homeX = 0, homeY = 0, homeZ = 0, exitX = 0, exitY = 0, exitZ = 0, protect = 0  WHERE steam = &quot; .. id)

		if db2Connected then
			-- update player in bots db
			connBots:execute(&quot;UPDATE players SET homeX = 0, homeY = 0, homeZ = 0, exitX = 0, exitY = 0, exitZ = 0, protect = 0 WHERE steam = &quot; .. id .. &quot; AND botID = &quot; .. server.botID)
		end

		if id == chatvars.playerid then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Your base and base protection has been removed.[-]&quot;)
		else
			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot;'s base and base protection has been removed.[-]&quot;)
			else
				irc_QueueMsg(server.ircMain, players[id].name .. &quot;'s base and base protection has been removed.&quot;)
			end
		end

		faultyChat = false
		return true
	end

if debug then display (&quot;debug base 7\n&quot;) end

	if chatvars.words[1] == &quot;delbase2&quot; and (accessLevel(chatvars.playerid) &lt; 4) then
		id = chatvars.playerid

		if (chatvars.playername == &quot;Server&quot;) or (accessLevel(chatvars.playerid) &lt; 3) then
			if (chatvars.words[2] ~= nil) then
				pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;delbase2&quot;) + 9)
				pname = string.trim(pname)
				id = LookupPlayer(pname)
				if id == nil then
					if (chatvars.playername ~= &quot;Server&quot;) then 
						message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No player found called &quot; .. pname .. &quot;[-]&quot;)
					else
						irc_QueueMsg(server.ircMain, &quot;No player found called &quot; .. pname)
					end

					faultyChat = false
					return true
				end
			end
		end

		players[id].home2X = 0
		players[id].home2Y = 0
		players[id].home2Z = 0
		players[id].exit2X = 0
		players[id].exit2Y = 0
		players[id].exit2Z = 0
		players[id].protect2 = false

		conn:execute(&quot;UPDATE players SET home2X = 0, home2Y = 0, home2Z = 0, exit2X = 0, exit2Y = 0, exit2Z = 0, protect2 = 0  WHERE steam = &quot; .. id)

		if db2Connected then
			-- update player in bots db
			connBots:execute(&quot;UPDATE players SET home2X = 0, home2Y = 0, home2Z = 0, exit2X = 0, exit2Y = 0, exit2Z = 0, protect2 = 0 WHERE steam = &quot; .. id .. &quot; AND botID = &quot; .. server.botID)
		end

		if id == chatvars.playerid then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Your 2nd base and base protection has been removed.[-]&quot;)
		else
			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot;'s 2nd base and base protection has been removed.[-]&quot;)
			else
				irc_QueueMsg(server.ircMain, players[id].name .. &quot;'s 2nd base and base protection has been removed.&quot;)
			end
		end

		faultyChat = false
		return true
	end

if debug then display (&quot;debug base 8\n&quot;) end

	if (chatvars.words[1] == &quot;unprotectbase&quot; or chatvars.words[1] == &quot;unprotectbase2&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end

		pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;unprotectbase&quot;) + 14)
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if (pname == nil or pname == &quot;&quot;) then
			faultyChat = false
			return true
		end

		if (chatvars.words[1] == &quot;unprotectbase&quot;) then
			if (players[id]) then players[id].protect = false end
			conn:execute(&quot;UPDATE players SET protect = 0 WHERE steam = &quot; .. id)

			if db2Connected then
				-- update player in bots db
				connBots:execute(&quot;UPDATE players SET protect = 0 WHERE steam = &quot; .. id .. &quot; AND botID = &quot; .. server.botID)
			end

			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name ..&quot;'s base is no longer protected[-]&quot;)
			else
				irc_QueueMsg(server.ircMain, players[id].name ..&quot;'s base is no longer protected.&quot;)
			end
		else
			if (players[id].donor == true or (accessLevel(id) &lt; 4)) then
				if (players[id]) then players[id].protect2 = false end
				conn:execute(&quot;UPDATE players SET protect2 = 0 WHERE steam = &quot; .. id)

				if db2Connected then
					-- update player in bots db
					connBots:execute(&quot;UPDATE players SET protect2 = 0 WHERE steam = &quot; .. id .. &quot; AND botID = &quot; .. server.botID)
				end

				if (chatvars.playername ~= &quot;Server&quot;) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name ..&quot;'s 2nd base is no longer protected[-]&quot;)
				else
					irc_QueueMsg(server.ircMain, players[id].name ..&quot;'s 2nd base is no longer protected.&quot;)
				end
			else
				if (chatvars.playername ~= &quot;Server&quot;) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Only donors and admins are allowed 2 base protections[-]&quot;)
				else
					irc_QueueMsg(server.ircMain, &quot;Only donors and admins are allowed 2 base protections.&quot;)
				end
			end
		end

		faultyChat = false
		return true
	end

if debug then display (&quot;debug base 11\n&quot;) end

	-- ###################  do not allow remote commands beyond this point ################
	if (chatvars.playerid == nil) then
		faultyChat = false
		return false
	end
	-- ####################################################################################

if debug then display (&quot;debug base 12\n&quot;) end

	if (chatvars.words[1] == &quot;setbase&quot; and chatvars.words[2] ~= nil) and not players[chatvars.playerid].prisoner then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Type setbase without anything after it.[-]&quot;)
			faultyChat = false
			return true
		end

		pname = chatvars.words[chatvars.wordCount]
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if not validPosition(chatvars.playerid, true) then
			faultyChat = false
			return true
		end

		if (id ~= nil) then
			players[id].homeX = chatvars.intX
			players[id].homeY = chatvars.intY
			players[id].homeZ = chatvars.intZ
			players[id].exitX = chatvars.intX
			players[id].exitY = chatvars.intY
			players[id].exitZ = chatvars.intZ
			players[id].protectSize = server.baseSize
			players[id].protect = false
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot;'s base has been set at where you are standing.[-]&quot;)

			conn:execute(&quot;UPDATE players SET protectSize = &quot; .. server.baseSize .. &quot;, homeX = &quot; .. chatvars.intX .. &quot;, homeY = &quot; .. chatvars.intY .. &quot;, homeZ = &quot; .. chatvars.intZ .. &quot;, protect = 0 WHERE steam = &quot; .. id)
			conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. chatvars.intX .. &quot;,&quot; .. chatvars.intY .. &quot;,&quot; .. chatvars.intZ .. &quot;,'&quot; .. serverTime .. &quot;','setbase','Player &quot; .. escape(players[id].name) .. &quot; set a base',&quot; .. id .. &quot;)&quot;)
			irc_QueueMsg(server.ircWatch, players[id].name .. &quot; has setbase at &quot; .. chatvars.intX .. &quot; &quot; .. chatvars.intY .. &quot; &quot; .. chatvars.intZ)

			if db2Connected then
				-- update player in bots db
				connBots:execute(&quot;UPDATE players SET homeX = &quot; .. chatvars.intX .. &quot;, homeY = &quot; .. chatvars.intY .. &quot;, homeZ = &quot; .. chatvars.intZ .. &quot;, exitX = &quot; .. chatvars.intX .. &quot;, exitY = &quot; .. chatvars.intY .. &quot;, exitZ = &quot; .. chatvars.intZ .. &quot; protect = 0 WHERE steam = &quot; .. id .. &quot; AND botID = &quot; .. server.botID)
			end
		end

		faultyChat = false
		return true
	end

if debug then display (&quot;debug base 13\n&quot;) end

	if (chatvars.words[1] == &quot;setbase2&quot; and chatvars.words[2] ~= nil) and not players[chatvars.playerid].prisoner then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Type setbase without anything after it.[-]&quot;)
			faultyChat = false
			return true
		end

		pname = chatvars.words[chatvars.wordCount]
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if not validPosition(chatvars.playerid, true) then
			faultyChat = false
			return true
		end

		if (id ~= nil) then
			players[id].home2X = chatvars.intX
			players[id].home2Y = chatvars.intY
			players[id].home2Z = chatvars.intZ
			players[id].exit2X = chatvars.intX
			players[id].exit2Y = chatvars.intY
			players[id].exit2Z = chatvars.intZ
			players[id].protect2Size = server.baseSize
			players[id].protect2 = false
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot;'s 2nd base has been set at where you are standing.[-]&quot;)

			conn:execute(&quot;UPDATE players SET protect2Size = &quot; .. server.baseSize .. &quot;, home2X = &quot; .. chatvars.intX .. &quot;, home2Y = &quot; .. chatvars.intY .. &quot;, home2Z = &quot; .. chatvars.intZ .. &quot;, protect2 = 0 WHERE steam = &quot; .. id)
			conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. chatvars.intX .. &quot;,&quot; .. chatvars.intY .. &quot;,&quot; .. chatvars.intZ .. &quot;,'&quot; .. serverTime .. &quot;','setbase','Player &quot; .. escape(players[id].name) .. &quot; set a 2nd base',&quot; .. id .. &quot;)&quot;)
			irc_QueueMsg(server.ircWatch, players[id].name .. &quot; has setbase2 at &quot; .. chatvars.intX .. &quot; &quot; .. chatvars.intY .. &quot; &quot; .. chatvars.intZ)

			if db2Connected then
				-- update player in bots db
				connBots:execute(&quot;UPDATE players SET home2X = &quot; .. chatvars.intX .. &quot;, home2Y = &quot; .. chatvars.intY .. &quot;, home2Z = &quot; .. chatvars.intZ .. &quot;, exit2X = &quot; .. chatvars.intX .. &quot;, exit2Y = &quot; .. chatvars.intY .. &quot;, exit2Z = &quot; .. chatvars.intZ .. &quot; protect2 = 0 WHERE steam = &quot; .. id .. &quot; AND botID = &quot; .. server.botID)
			end
		end

		faultyChat = false
		return true
	end

if debug then display (&quot;debug base 14\n&quot;) end

	if (chatvars.words[1] == &quot;man&quot; and chatvars.words[2] == &quot;test&quot; and chatvars.words[3] == &quot;base&quot;) then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Test your base protection for 30 seconds.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can also check your base with /status[-]&quot;)

		faultyChat = false
		return true
	end

	if (chatvars.words[1] == &quot;test&quot; and chatvars.words[2] == &quot;base&quot;) then
		if players[chatvars.playerid].protect == false and players[chatvars.playerid].protect2 == false then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You don't have base protection established now.  Type /protect at your base or /protect2 at your 2nd base to set it up first.[-]&quot;)
			faultyChat = false
			return true
		end

		igplayers[chatvars.playerid].protectTest = true
		igplayers[chatvars.playerid].protectTestEnd = os.time() + 30

		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Your base protection is active and will keep you out for 30 seconds.[-]&quot;)

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;man&quot; and chatvars.words[2] == &quot;pause&quot;) then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can temporarily give access to your base with /pause.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Protection will automatically resume if you move more than 100 metres away or log off.[-]&quot;)

		faultyChat = false
		return true
	end

	if (chatvars.words[1] == &quot;pause&quot; or chatvars.words[1] == &quot;paws&quot;) and chatvars.words[2] == nil then
		pname = igplayers[chatvars.playerid].name

		if (players[chatvars.playerid].protect == false) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You don't have base protection established now.  An admin is required to set it up or re-establish it.[-]&quot;)
			faultyChat = false
			return true
		end

		dist = distancexz(igplayers[chatvars.playerid].xPos, igplayers[chatvars.playerid].zPos, players[chatvars.playerid].homeX, players[chatvars.playerid].homeZ)
		if (dist &lt; tonumber(players[chatvars.playerid].protectSize) + 100) then
			players[chatvars.playerid].protectPaused = true
		else
			players[chatvars.playerid].protect2Paused = true
		end

		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Your base protection is disabled while you are within 100 meters of your /base teleport.[-]&quot;)

		faultyChat = false
		return true
	end

if debug then display (&quot;debug base 14\n&quot;) end

	if (chatvars.words[1] == &quot;man&quot; and chatvars.words[2] == &quot;resume&quot;) then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Visitors won't leave? Resume your base protection and watch them leave.[-]&quot;)

		faultyChat = false
		return true
	end

	if (chatvars.words[1] == &quot;resume&quot;) then
		pname = igplayers[chatvars.playerid].name
		players[chatvars.playerid].protectPaused = nil
		players[chatvars.playerid].protect2Paused = nil

		if tonumber(players[chatvars.playerid].homeX) ~= 0 and tonumber(players[chatvars.playerid].homeY) ~= 0 and tonumber(players[chatvars.playerid].homeZ) ~= 0 then
			dist = distancexz(igplayers[chatvars.playerid].xPos, igplayers[chatvars.playerid].zPos, players[chatvars.playerid].homeX, players[chatvars.playerid].homeZ)
			if (dist &lt; tonumber(players[chatvars.playerid].protectSize) + 100) then
				if (players[chatvars.playerid].protect == true) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Your base protection is now active.[-]&quot;)
				else
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You don't have base protection. An admin can set up or re-establish it for you.[-]&quot;)
				end
			end
		end

		if tonumber(players[chatvars.playerid].home2X) ~= 0 and tonumber(players[chatvars.playerid].home2Y) ~= 0 and tonumber(players[chatvars.playerid].home2Z) ~= 0 then
			dist = distancexz(igplayers[chatvars.playerid].xPos, igplayers[chatvars.playerid].zPos, players[chatvars.playerid].home2X, players[chatvars.playerid].home2Z)
			if (dist &lt; tonumber(players[chatvars.playerid].protectSize) + 100) then

			if (players[chatvars.playerid].protect2 == true) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Your second base's protection is now active.[-]&quot;)
				else
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You don't have base protection on your second base. An admin can set up or re-establish it for you.[-]&quot;)
				end
			end
		end

		faultyChat = false
		return true
	end

if debug then display (&quot;debug base end\n&quot;) end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_admin</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
add /claims &lt;distance&gt; it will count all claims (using llp) within range.
add /claim owners &lt;distance&gt; will list all the players with claims down in range
update /tp so it accepts coords
admin commands
=============
reload bot
timeout
return &lt;player&gt;
release
give claim
hordeme
leave claims
remove claims
exile
free
player &lt;player&gt; is not new
add donor
remove donor
give
disallow teleport
allow teleport
enable waypoints
disable waypoints
close shop
open shop
set shop open
set shop close
set shop location
clear shop location
ignore player
include player
prisoner
arrest
resettimers
exclude admins
include admins
freeze
unfreeze
move
sendhome
watch &lt;player&gt;
stop watching
send &lt;player1&gt; to &lt;player2&gt;
who visited
bases
admin add
admin remove
goto &lt;player&gt;
offline players nearby
crimescene &lt;player&gt;
near &lt;player&gt;
add bad item
remove bad item
bad items
add restricted item
remove restricted item
restricted items
prisoners
equip admin
release here
playerbase
--]]

function gmsg_admin()
	calledFunction = &quot;gmsg_admin&quot;
	
	local debug, tmp, str

	debug = false
	tmp = {}

if debug then dbug(&quot;debug admin&quot;) end

	-- don't proceed if there is no leading slash
	if (string.sub(chatvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyChat = false
		return false
	end


	if (chatvars.words[1] == &quot;reload&quot; or chatvars.words[1] == &quot;refresh&quot; or chatvars.words[1] == &quot;update&quot;) and chatvars.words[2] == &quot;admins&quot; then
		-- run admin list
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Reading admin list[-]&quot;)
		send(&quot;admin list&quot;)

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;reload&quot; or chatvars.words[1] == &quot;refresh&quot; or chatvars.words[1] == &quot;update&quot;) and chatvars.words[2] == &quot;bot&quot; then
		-- run admin list, gg, ban list and lkp

		message(&quot;say [&quot; .. server.chatColour .. &quot;]Collecting known players[-]&quot;)
		send(&quot;lkp&quot;)

		tempTimer( 4, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]Reading admin list[-]&quot;)]] )
		tempTimer( 4, [[send(&quot;admin list&quot;)]] )

		tempTimer( 6, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]Reading bans[-]&quot;)]] )
		tempTimer( 6, [[send(&quot;ban list&quot;)]] )

		tempTimer( 8, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]Reading server config[-]&quot;)]] )
		tempTimer( 8, [[send(&quot;gg&quot;)]] )

		tempTimer( 10, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]Reading claims[-]&quot;)]])
		tempTimer( 10, [[send(&quot;llp)]] )

		tempTimer( 13, [[send(&quot;pm IPCHECK&quot;)]] )
		tempTimer( 13, [[message(&quot;say [&quot; .. server.chatColour .. &quot;]Reload complete.[-]&quot;)]] )

		tempTimer( 15, [[send(&quot;teleh&quot;)]] )
		tempTimer( 16, [[registerBot()]] )

		faultyChat = false
		return true

	end


	if chatvars.words[1] == &quot;gimme&quot; and chatvars.words[2] == &quot;admin&quot; and server.botName == &quot;Tester&quot; then
		-- add the steamid to the admins table
		admins[players[chatvars.playerid].steam] = {}
		players[chatvars.playerid].newPlayer = false
		players[chatvars.playerid].silentBob = false
		players[chatvars.playerid].walkies = false
		players[chatvars.playerid].exiled = 2
		players[chatvars.playerid].canTeleport = true
		players[chatvars.playerid].botHelp = true

		message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[chatvars.playerid].name .. &quot; has been given admin powers[-]&quot;)
		send(&quot;admin add &quot; .. chatvars.playerid .. &quot; 0&quot;)

		send(&quot;admin list&quot;)

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;timeout&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 90) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end

		if (chatvars.words[2] == nil) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Send a player to timeout where they can only talk.[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can also send yourself to timeout but not other staff.[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/timeout &lt;player&gt;[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]See also: /return &lt;player&gt;[-]&quot;)
			faultyChat = false
			return true
		end

		tmp = {}
		tmp.pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;timeout &quot;) + 8)
		tmp.pname = string.trim(tmp.pname)
		tmp.id = LookupPlayer(tmp.pname)

		if (chatvars.playername ~= &quot;Server&quot;) then 	
			if (players[tmp.id].newPlayer == false and accessLevel(chatvars.playerid) &gt; 3) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are limited to sending new players to timeout. &quot; .. players[tmp.id].name .. &quot; is not new.[-]&quot;)
				faultyChat = false
				return true
			end
		end

		if (players[tmp.id].timeout == true) then
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This player is already in timeout.  Did you mean /return ?[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Player &quot; .. tmp.id .. &quot; &quot; .. players[tmp.id].name .. &quot; is already in timeout.&quot;)
			end

			faultyChat = false
			return true
		end

		if (accessLevel(tmp.id) &lt; 3 and server.ignoreAdmins == true) and tmp.id ~= chatvars.playerid then
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Staff cannot be sent to timeout.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Staff cannot be sent to timeout.&quot;)
			end

			faultyChat = false
			return true
		end

		if accessLevel(tmp.id) &gt; 2	then
			players[tmp.id].silentBob = true
		end

		-- first record their current x y z
		players[tmp.id].timeout = true
		players[tmp.id].xPosTimeout = math.floor(players[tmp.id].xPos)
		players[tmp.id].yPosTimeout = math.ceil(players[tmp.id].yPos)
		players[tmp.id].zPosTimeout = math.floor(players[tmp.id].zPos)

		if (chatvars.playername ~= &quot;Server&quot;) then 
			conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. players[tmp.id].xPosTimeout .. &quot;,&quot; .. players[tmp.id].yPosTimeout .. &quot;,&quot; .. players[tmp.id].zPosTimeout .. &quot;,'&quot; .. serverTime .. &quot;','timeout','Player &quot; .. escape(players[tmp.id].name) .. &quot; SteamID: &quot; .. tmp.id .. &quot; sent to timeout by &quot; .. escape(players[chatvars.playerid].name) .. &quot;',&quot; .. tmp.id .. &quot;)&quot;)
		else
			conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. players[tmp.id].xPosTimeout .. &quot;,&quot; .. players[tmp.id].yPosTimeout .. &quot;,&quot; .. players[tmp.id].zPosTimeout .. &quot;,'&quot; .. serverTime .. &quot;','timeout','Player &quot; .. escape(players[tmp.id].name) .. &quot; SteamID: &quot; .. tmp.id .. &quot; sent to timeout by &quot; .. escape(players[chatvars.ircid].name) .. &quot;',&quot; .. tmp.id .. &quot;)&quot;)
		end

		if players[tmp.id].watchPlayer then
			irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. chatvars.playerid .. &quot; &quot; .. chatvars.playername .. &quot; command &quot; .. chatvars.command  )
		end
		
		-- then teleport the player to timeout
		send(&quot;tele &quot; .. tmp.id .. &quot; &quot; .. players[tmp.id].xPosTimeout .. &quot; 50000 &quot; .. players[tmp.id].zPosTimeout)

		message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[tmp.id].name .. &quot; has been sent to timeout.[-]&quot;)

		conn:execute(&quot;UPDATE players SET timeout = 1, silentBob = 1, xPosTimeout = &quot; .. players[tmp.id].xPosTimeout .. &quot;, yPosTimeout = &quot; .. players[tmp.id].yPosTimeout .. &quot;, zPosTimeout = &quot; .. players[tmp.id].zPosTimeout .. &quot; WHERE steam = &quot; .. tmp.id)		

		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 2&quot;) end

	if (chatvars.words[1] == &quot;return&quot; and chatvars.words[2] ~= nil) then 
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 90) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted. Just type /return.[-]&quot;)
				faultyChat = false
				return true
			end
		end

		tmp = {}

		if string.find(chatvars.command, &quot; to &quot;) then 
			tmp.loc = string.sub(chatvars.command, string.find(chatvars.command, &quot; to &quot;) + 4)
			tmp.loc = string.trim(tmp.loc)
			tmp.loc = LookupLocation(tmp.loc)

			tmp.pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;return &quot;) + 7, string.find(chatvars.command, &quot; to &quot;) - 1)
			tmp.pname = string.trim(tmp.pname)
			tmp.id = LookupPlayer(tmp.pname)
		else
			tmp.pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;return &quot;) + 7)
			tmp.pname = string.trim(tmp.pname)
			tmp.id = LookupPlayer(tmp.pname)
		end

		if (chatvars.playername ~= &quot;Server&quot;) then 
			-- don't allow players to return anyone to a different location.
			if (accessLevel(chatvars.playerid) &gt; 2) then
				tmp.loc = nil
			end
		end

		if (players[tmp.id].timeout == true and tmp.id == chatvars.playerid and accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are in timeout. You cannot release yourself.[-]&quot;)
			faultyChat = false
			return true
		end
		
		if players[tmp.id].timeout == false and players[tmp.id].prisoner and ((tmp.id ~= chatvars.playerid and accessLevel(chatvars.playerid) &gt; 2) or chatvars.playerid == players[id].pvpVictim) then
			gmsg(&quot;/release &quot; .. players[tmp.id].name)
			faultyChat = false
			return true	
		end	

		if (chatvars.playername ~= &quot;Server&quot;) then	
			if accessLevel(chatvars.playerid) &gt; 2 then
				if players[tmp.id].newPlayer == true or players[tmp.id].timeout == false then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can only use this command on new players in timeout and a player sent them there.[-]&quot;)
					faultyChat = false
					return true
				end
			end
		end

		-- return player to previously recorded x y z
		if (igplayers[tmp.id]) then
			if tonumber(players[tmp.id].yPosTimeout) &gt; 0 then
				players[tmp.id].timeout = false
				players[tmp.id].botTimeout = false
				players[tmp.id].freeze = false 
				players[tmp.id].silentBob = false 

				igplayers[tmp.id].skipExcessInventory = true

				if players[tmp.id].watchPlayer then
					irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. chatvars.playerid .. &quot; &quot; .. chatvars.playername .. &quot; command &quot; .. chatvars.command  )
				end

				if tmp.loc ~= nil then
					tmp.cmd = &quot;tele &quot; .. tmp.id .. &quot; &quot; .. locations[tmp.loc].x .. &quot; &quot; .. locations[tmp.loc].y .. &quot; &quot; .. locations[tmp.loc].z
				else
					send(&quot;tele &quot; .. tmp.id .. &quot; &quot; .. players[tmp.id].xPosTimeout .. &quot; &quot; .. players[tmp.id].yPosTimeout .. &quot; &quot; .. players[tmp.id].zPosTimeout)

					players[tmp.id].xPosTimeout = 0
					players[tmp.id].yPosTimeout = 0
					players[tmp.id].zPosTimeout = 0

					conn:execute(&quot;UPDATE players SET timeout = 0, silentBob = 0, botTimeout = 0, xPosTimeout = 0, yPosTimeout = 0, zPosTimeout = 0 WHERE steam = &quot; .. tmp.id)

					message(&quot;say [&quot; .. server.chatColour .. &quot;]Returning &quot; .. players[tmp.id].name .. &quot;[-]&quot;)

					faultyChat = false
					return true
				end

				prepareTeleport(tmp.id, tmp.cmd)
				teleport(tmp.cmd, true)

				players[tmp.id].xPosTimeout = 0
				players[tmp.id].yPosTimeout = 0
				players[tmp.id].zPosTimeout = 0

				if tmp.loc ~= nil then
					message(&quot;say [&quot; .. server.chatColour .. &quot;]Returning &quot; .. players[tmp.id].name .. &quot; to &quot; .. tmp.loc .. &quot;[-]&quot;)
				else
					message(&quot;say [&quot; .. server.chatColour .. &quot;]Returning &quot; .. players[tmp.id].name .. &quot;[-]&quot;)
				end

				conn:execute(&quot;UPDATE players SET timeout = 0, silentBob = 0, botTimeout = 0, xPosTimeout = 0, yPosTimeout = 0, zPosTimeout = 0 WHERE steam = &quot; .. tmp.id)

				faultyChat = false
				return true
			end

			if tonumber(players[tmp.id].yPosOld) &gt; 0 then
				players[tmp.id].timeout = false
				players[tmp.id].botTimeout = false

				if tmp.loc ~= nil then
					tmp.cmd = &quot;tele &quot; .. tmp.id .. &quot; &quot; .. locations[tmp.loc].x .. &quot; &quot; .. locations[tmp.loc].y .. &quot; &quot; .. locations[tmp.loc].z
				else
					tmp.cmd = &quot;tele &quot; .. tmp.id .. &quot; &quot; .. players[tmp.id].xPosOld .. &quot; &quot; .. players[tmp.id].yPosOld .. &quot; &quot; .. players[tmp.id].zPosOld
				end

				if players[tmp.id].watchPlayer then
					irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. chatvars.playerid .. &quot; &quot; .. chatvars.playername .. &quot; command &quot; .. chatvars.command  )
				end

				prepareTeleport(tmp.id, tmp.cmd)
				teleport(tmp.cmd, true)

				players[tmp.id].xPosOld = 0
				players[tmp.id].yPosOld = 0
				players[tmp.id].zPosOld = 0

				conn:execute(&quot;UPDATE players SET timeout = 0, botTimeout = 0, xPosOld = 0, yPosOld = 0, zPosOld = 0 WHERE steam = &quot; .. tmp.id)

				if tmp.loc ~= nil then
					if (chatvars.playername ~= &quot;Server&quot;) then 
						message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Returning &quot; .. players[tmp.id].name .. &quot; to &quot; .. tmp.loc .. &quot;[-]&quot;)
					else
						message(&quot;say [&quot; .. server.chatColour .. &quot;]Returning &quot; .. players[tmp.id].name .. &quot; to &quot; .. tmp.loc .. &quot;[-]&quot;)
					end
				else
					if (chatvars.playername ~= &quot;Server&quot;) then 
						message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Returning &quot; .. players[tmp.id].name .. &quot;[-]&quot;)
					else
						message(&quot;say [&quot; .. server.chatColour .. &quot;]Returning &quot; .. players[tmp.id].name .. &quot;[-]&quot;)
					end
				end
			end
		else
			if (players[tmp.id].yPosTimeout) then
				players[tmp.id].timeout = false
				players[tmp.id].botTimeout = false
				players[tmp.id].location = &quot;return player&quot;
				players[tmp.id].silentBob = false

				message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[tmp.id].name .. &quot; will be returned when they next join the server.[-]&quot;)

				conn:execute(&quot;UPDATE players SET timeout = 0, silentBob = 0, botTimeout = 0 WHERE steam = &quot; .. tmp.id)

				faultyChat = false
				return true
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 3&quot;) end

	if (chatvars.words[1] == &quot;release&quot; or (chatvars.words[1] == &quot;just&quot; and chatvars.words[2] == &quot;release&quot;)) then 	
		prisoner = string.sub(chatvars.command, string.find(chatvars.command, &quot;release &quot;) + 8)
		prisoner = string.trim(prisoner)
		prisonerid = LookupPlayer(prisoner)
		prisoner = players[prisonerid].name

		if prisonerid == nil then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]We don't have a prisoner called &quot; .. prisoner .. &quot;.[-]&quot;)
			faultyChat = false
			return true
		end

		if (chatvars.playername ~= &quot;Server&quot;) then 	
			if (accessLevel(chatvars.playerid) &gt; 2) and (players[prisonerid].pvpVictim ~= chatvars.playerid) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. prisoner .. &quot; is not in prison for your death and cannot be released by you.[-]&quot;)	
				faultyChat = false	
				return true
			end		
		end

		if (players[prisonerid].timeout == true or players[prisonerid].botTimeout == true) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Citizen &quot; .. prisoner .. &quot; is released from timeout.[-]&quot;)
			players[prisonerid].timeout = false
			players[prisonerid].botTimeout = false
			players[prisonerid].freeze = false
			players[prisonerid].silentBob = false 

			conn:execute(&quot;UPDATE players SET timeout = 0, silentBob = 0, botTimeout = 0 WHERE steam = &quot; .. prisonerid)

			faultyChat = false
			return true
		end

		if (not players[prisonerid].prisoner and players[prisonerid].timeout == false) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Citizen &quot; .. prisoner .. &quot; is not a prisoner[-]&quot;)
			faultyChat = false
			return true
		end
		
		players[prisonerid].xPosOld = 0
		players[prisonerid].yPosOld = 0
		players[prisonerid].zPosOld = 0
		
		if (igplayers[prisonerid]) then

			if players[prisonerid].watchPlayer then
				irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. chatvars.playerid .. &quot; &quot; .. chatvars.playername .. &quot; command &quot; .. chatvars.command  )
			end

			message(&quot;say Releasing prisoner &quot; .. prisoner)
			message(&quot;pm &quot; .. prisonerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are released from prison.  Be a good citizen if you wish to remain free.[-]&quot;)

			if (chatvars.words[1] ~= &quot;just&quot;) then
				if (players[prisonerid].prisonxPosOld) then
					cmd = &quot;tele &quot; .. prisonerid .. &quot; &quot; .. players[prisonerid].prisonxPosOld .. &quot; &quot; .. players[prisonerid].prisonyPosOld .. &quot; &quot; .. players[prisonerid].prisonzPosOld
					igplayers[prisonerid].lastTP = cmd
					prepareTeleport(prisonerid, cmd)
					teleport(cmd, true)
				end
			else
				message(&quot;pm &quot; .. prisonerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are a free citizen, but you must find your own way back.[-]&quot;)
			end
		else
			if (players[prisonerid]) then
				players[prisonerid].location = &quot;return player&quot;
				message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[prisonerid].name .. &quot; will be released when they next join the server.[-]&quot;)

				players[prisonerid].xPosOld = players[prisonerid].prisonxPosOld
				players[prisonerid].yPosOld = players[prisonerid].prisonyPosOld
				players[prisonerid].zPosOld = players[prisonerid].prisonzPosOld

				conn:execute(&quot;UPDATE players SET prisoner = 0, silentBob = 0, location = 'return player', xPosOld = &quot; .. players[prisonerid].prisonxPosOld .. &quot;, yPosOld = &quot; .. players[prisonerid].prisonyPosOld .. &quot;, zPosOld = &quot; .. players[prisonerid].prisonzPosOld .. &quot; WHERE steam = &quot; .. prisonerid)
			end
		end

		players[prisonerid].prisoner = false
		players[prisonerid].silentBob = false 
		
		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 4&quot;) end

	if chatvars.words[1] == &quot;give&quot; and (string.find(chatvars.words[2], &quot;claim&quot;) or string.find(chatvars.words[2], &quot;key&quot;) or string.find(chatvars.words[2], &quot;lcb&quot;)) then
		if players[chatvars.playerid].removedClaims &gt; 20 then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]I am holding a lot of claims. Due to bugs with the count I can't release them to you.  Please talk to an admin to get them back so we can verify the count.[-]&quot;)

			faultyChat = false
			return true
		end

		if players[chatvars.playerid].removedClaims &gt; 0 then
			send(&quot;give &quot; .. chatvars.playerid .. &quot; keystoneBlock &quot; .. players[chatvars.playerid].removedClaims)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]I was holding &quot; .. players[chatvars.playerid].removedClaims .. &quot; keystones for you and have dropped them at your feet.  Press e to collect them now.[-]&quot;)
			players[chatvars.playerid].removedClaims = 0
		else
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]I have no keystones to give you at this time.[-]&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 5&quot;) end

	-- ###################  Staff only beyond this point ################
	-- Don't proceed if this is a player.  Server and staff only here.
	if (chatvars.playername ~= &quot;Server&quot;) then 
		if (accessLevel(chatvars.playerid) &gt; 2) then
			faultyChat = false
			return false
		end
	else
		if tonumber(chatvars.ircid) &gt; 0 then
			if (accessLevel(chatvars.ircid) &gt; 2) then
				faultyChat = false
				return false
			end
		end
	end
	-- ##################################################################

if debug then dbug(&quot;admin 6&quot;) end

	if (chatvars.words[1] == &quot;hordeme&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		message(&quot;say [&quot; .. server.chatColour .. &quot;]HORDE!!![-]&quot;)

		for i=1,50,1 do
			cmd = &quot;se &quot; .. players[chatvars.playerid].id .. &quot; &quot; .. PicknMix()
			conn:execute(&quot;INSERT INTO gimmeQueue (steam, command) VALUES (&quot; .. chatvars.playerid .. &quot;,'&quot; .. cmd .. &quot;')&quot;)
		end

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;leave&quot; and chatvars.words[2] == &quot;claims&quot; and chatvars.words[3] ~= nil) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		pname = chatvars.words[3]
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if id ~= nil then
			-- this players claims wil not be removed unless in a reset zone and not staff
			players[id].removeClaims = false
			conn:execute(&quot;UPDATE keystones SET remove = 0 WHERE steam = &quot; .. id)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Player &quot; .. players[id].name .. &quot;'s claims will not be removed unless found in reset zones (if not staff).[-]&quot;)		

			conn:execute(&quot;UPDATE players SET removeClaims = 0 WHERE steam = &quot; .. id)
		end

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;remove&quot; and chatvars.words[2] == &quot;claims&quot; and chatvars.words[3] ~= nil) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		pname = chatvars.words[3]
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if id ~= nil then
			-- flag the player's claims for removal
			players[id].removeClaims = true
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]I will remove all of player &quot; .. players[id].name .. &quot;'s claims when their chunks are loaded.[-]&quot;)		
			send(&quot;llp &quot; .. id)

			conn:execute(&quot;UPDATE players SET removeClaims = 1 WHERE steam = &quot; .. id)
		end

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;exile&quot; and chatvars.words[2] ~= nil) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 2) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		pname = chatvars.words[2]
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if id ~= nil then
			-- flag the player as exiled
			players[id].exiled = 1
			players[id].silentBob = true
			players[id].canTeleport = false
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; has been exiled! D:[-]&quot;)

			conn:execute(&quot;UPDATE players SET exiled = 1, silentBob = 1, canTeleport = 0 WHERE steam = &quot; .. id)
		end

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;free&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		end

		pname = chatvars.words[2]
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if id ~= nil then
			-- flag the player as no longer exiled
			players[id].exiled = 2
			players[id].silentBob = false
			players[id].canTeleport = true
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; has been released from exile! :D[-]&quot;)

			conn:execute(&quot;UPDATE players SET exiled = 2, silentBob = 0, canTeleport = 1 WHERE steam = &quot; .. id)
		end

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;player&quot; and string.find(chatvars.command, &quot;is not new&quot;)) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		end

		pname = chatvars.words[2]
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if id ~= nil then
			-- set the newPlayer flag to false
			players[id].newPlayer = false
			players[id].watchPlayer = false
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; is no longer new here. Welcome back &quot; .. players[id].name .. &quot;! =D[-]&quot;)

			conn:execute(&quot;UPDATE players SET newPlayer = 0, watchPlayer = 0 WHERE steam = &quot; .. id)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 7&quot;) end

	if (chatvars.words[1] == &quot;add&quot; and chatvars.words[2] == &quot;donor&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if (chatvars.words[3] == nil) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Add donors with optional level and expiry. Defaults level 1 and 10 years.[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]eg. /add donor bob level 5 expires 1 week (or month or year)[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Expires automatically. 2nd protected base becomes unprotected 1 week later.[-]&quot;)
			faultyChat = false
			return true
		end

		tmp = {}
		tmp.sql = &quot;UPDATE players SET donor = 1&quot;
		tmp.level = 1
		tmp.expiry = calcTimestamp(&quot;10 years&quot;)

		for i=4,chatvars.wordCount,1 do
			if chatvars.words[i] == &quot;expires&quot; then
				tmp.expiry = string.sub(chatvars.command, string.find(chatvars.command, &quot;expires&quot;) + 8)
				tmp.expiry = calcTimestamp(tmp.expiry)

				if tonumber(tmp.expiry) &lt;= os.time() then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Invalid expiry entered. Expected &lt;number&gt; &lt;week or month or year&gt; eg. 1 month.[-]&quot;)		
					faultyChat = false
					return true
				end
			end					

			if chatvars.words[i] == &quot;level&quot; then
				tmp.level = math.abs(ToInt(chatvars.words[i+1]))

				if tmp.level &gt; 7 then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Level must be a number from 0 to 7.[-]&quot;)		
					faultyChat = false
					return true
				end
				
				if tmp.level == nil then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Level must be a number from 0 to 7.[-]&quot;)		
					faultyChat = false
					return true
				end
			end
		end

		tmp.sql = tmp.sql .. &quot;, donorExpiry = '&quot; .. os.date(&quot;%Y-%m-%d %H:%M:%S&quot;, tmp.expiry) .. &quot;', donorLevel = &quot; .. tmp.level
		tmp.pname = chatvars.words[3]
		tmp.id = LookupPlayer(tmp.pname)

		if tmp.id ~= nil then
			-- set the donor flag to true
			players[tmp.id].donor = true
			players[tmp.id].donorLevel = tmp.level
			players[tmp.id].donorExpiry = tmp.expiry
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[tmp.id].name .. &quot; has donated! Thanks =D[-]&quot;)
			conn:execute(tmp.sql .. &quot; WHERE steam = &quot; .. tmp.id)
		end

		faultyChat = false
		return true
	end


if debug then dbug(&quot;admin 8&quot;) end

	if (chatvars.words[1] == &quot;remove&quot; and chatvars.words[2] == &quot;donor&quot; and chatvars.words[3] ~= nil) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;donor &quot;) + 6)
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if id ~= nil then
			-- set the donor flag to false
			players[id].donor = false
			players[id].donorLevel = 0
			players[id].donorExpiry = os.time() - 1
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; no longer has donor status :([-]&quot;)

			conn:execute(&quot;UPDATE players SET donor = 0, donorLevel = 0, donorExpiry = &quot; .. os.time() - 1 .. &quot; WHERE steam = &quot; .. id)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 10&quot;) end

	if (chatvars.words[1] == &quot;give&quot; and chatvars.words[2] ~= nil) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		for k, v in pairs(igplayers) do
			if accessLevel(k) &gt; 2 then
				if chatvars.number ~= nil then
					send(&quot;give &quot; .. k .. &quot; &quot; .. chatvars.words[2] .. &quot; &quot; .. chatvars.number)
				else
					send(&quot;give &quot; .. k .. &quot; &quot; .. chatvars.words[2] .. &quot; 1&quot;)
				end
				message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;][i]FREE STUFF!  Press E to pick up some &quot; .. chatvars.words[2] .. &quot; now.[/i]&quot;)
			end
		end
	end

if debug then dbug(&quot;admin 11&quot;) end

	if (chatvars.words[1] == &quot;disallow&quot; and chatvars.words[2] == &quot;teleport&quot; and chatvars.words[3] ~= nil) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 2) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;teleport&quot;) + 9)
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if id ~= nil then
			players[id].canTeleport = false
			message(&quot;say [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name ..  &quot; is not allowed to use teleports.[-]&quot;)

			conn:execute(&quot;UPDATE players SET canTeleport = 0 WHERE steam = &quot; .. id)
		end
		
		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 12&quot;) end

	if (chatvars.words[1] == &quot;allow&quot; and chatvars.words[2] == &quot;teleport&quot; and chatvars.words[3] ~= nil) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 2) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;teleport&quot;) + 9)
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if id ~= nil then
			players[id].canTeleport = true
			message(&quot;say [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name ..  &quot; is allowed to use teleports.[-]&quot;)

			conn:execute(&quot;UPDATE players SET canTeleport = 1 WHERE steam = &quot; .. id)
		end
		
		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 13&quot;) end

	if (chatvars.words[1] == &quot;enable&quot; and chatvars.words[2] == &quot;waypoints&quot; and chatvars.words[3] == nil) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		server.allowWaypoints = true

		conn:execute(&quot;UPDATE server SET allowWaypoints = 1&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Waypoints are enabled for donors.[-]&quot;)	
		else
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Waypoints are enabled for donors.[-]&quot;)
		end
		
		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 14&quot;) end

	if (chatvars.words[1] == &quot;disable&quot; and chatvars.words[2] == &quot;waypoints&quot; and chatvars.words[3] == nil) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		server.allowWaypoints = false

		conn:execute(&quot;UPDATE server SET allowWaypoints = 0&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Waypoints are restricted to admins.[-]&quot;)	
		else
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Waypoints are restricted to admins.[-]&quot;)
		end
		
		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 15&quot;) end

	if (chatvars.words[1] == &quot;close&quot; and chatvars.words[2] == &quot;shop&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 1) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		message(&quot;say [&quot; .. server.chatColour .. &quot;]The shop is closed until further notice.[-]&quot;)
		server.allowShop = false

		conn:execute(&quot;UPDATE server SET allowShop = 0&quot;)

		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 16&quot;) end

	if (chatvars.words[1] == &quot;open&quot; and chatvars.words[2] == &quot;shop&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 1) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		message(&quot;say [&quot; .. server.chatColour .. &quot;]The shop is open for business.[-]&quot;)
		server.allowShop = true	

		conn:execute(&quot;UPDATE server SET allowShop = 1&quot;)
		loadShopCategories()

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;reset&quot; and chatvars.words[2] == &quot;shop&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 1) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		message(&quot;say [&quot; .. server.chatColour .. &quot;]Hurrah!  NEW stock![-]&quot;)
		resetShop(true)
		loadShopCategories()

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;set&quot; and chatvars.words[2] == &quot;shop&quot; and chatvars.words[3] == &quot;open&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 1) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if chatvars.number == nil then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A number from 0 to 24 is expected (military time)[-]&quot;)
			faultyChat = false
			return true
		else
			chatvars.number = math.floor(chatvars.number)

			if chatvars.number &lt; 0 or chatvars.number &gt; 24 then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A number from 0 to 24 is expected (military time)[-]&quot;)
				faultyChat = false
				return true
			end

			if chatvars.number == 24 then chatvars.number = 0 end

			if chatvars.number &lt; 12 then
				str = &quot; AM&quot;
			else
				str = &quot; PM&quot;
			end

			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The shop opens at &quot; .. chatvars.number .. str .. &quot;[-]&quot;)
			server.shopOpenHour = chatvars.number
			conn:execute(&quot;UPDATE server SET shopOpenHour = &quot; .. chatvars.number)

			faultyChat = false
			return true
		end
	end


	if (chatvars.words[1] == &quot;set&quot; and chatvars.words[2] == &quot;shop&quot; and chatvars.words[3] == &quot;close&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 1) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if chatvars.number == nil then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A number from 0 to 24 is expected (military time)[-]&quot;)
			faultyChat = false
			return true
		else
			chatvars.number = math.floor(chatvars.number)

			if chatvars.number &lt; 0 or chatvars.number &gt; 24 then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A number from 0 to 24 is expected (military time)[-]&quot;)
				faultyChat = false
				return true
			end

			if chatvars.number == 24 then chatvars.number = 0 end

			if chatvars.number &lt; 12 then
				str = &quot; AM&quot;
			else
				str = &quot; PM&quot;
			end

			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The shop closes at &quot; .. chatvars.number .. str .. &quot;[-]&quot;)
			server.shopCloseHour = chatvars.number
			conn:execute(&quot;UPDATE server SET shopCloseHour = &quot; .. chatvars.number)

			faultyChat = false
			return true
		end
	end


	if (chatvars.words[1] == &quot;set&quot; and chatvars.words[2] == &quot;shop&quot; and chatvars.words[3] == &quot;location&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 1) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		str = string.sub(chatvars.command, string.find(chatvars.command, &quot;location &quot;) + 9)
		str = string.trim(str)
		str = LookupLocation(str)

		if str == nil then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A location is required for this command.[-]&quot;)
			faultyChat = false
			return true
		else
			message(&quot;say [&quot; .. server.chatColour .. &quot;]The shop is now located at &quot;.. str .. &quot;[-]&quot;)
			server.shopLocation = str
			conn:execute(&quot;UPDATE server SET shopLocation = '&quot; .. str .. &quot;'&quot;)

			faultyChat = false
			return true
		end
	end


	if (chatvars.words[1] == &quot;clear&quot; and chatvars.words[2] == &quot;shop&quot; and chatvars.words[3] == &quot;location&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 1) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		message(&quot;say [&quot; .. server.chatColour .. &quot;]The shop is no longer bound to a location.[-]&quot;)
		server.shopLocation = nil
		conn:execute(&quot;UPDATE server SET shopLocation = null&quot;)

		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 17&quot;) end

	if (chatvars.words[1] == &quot;whitelist&quot; and chatvars.words[2] == &quot;add&quot; and chatvars.words[3] ~= nil) then	
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 2) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		pname = nil
		pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;add &quot;) + 4)

		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if (id == nil) then
			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A player name is required.[-]&quot;)
			else
				message(&quot;say [&quot; .. server.chatColour .. &quot;]Command requires a player name or no match found.[-]&quot;)		
			end
				
			faultyChat = false
			return true
		end

		players[id].whitelisted = true
		conn:execute(&quot;INSERT INTO whitelist (steam) VALUES (&quot; .. id .. &quot;)&quot;)				

		if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name .. &quot; has been added to the whitelist.[-]&quot;)	
		else
			message(&quot;say [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name .. &quot; has been added to the whitelist.[-]&quot;)
		end
		
		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 18&quot;) end

	if (chatvars.words[1] == &quot;whitelist&quot; and chatvars.words[2] == &quot;remove&quot; and chatvars.words[3] ~= nil) then	
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 2) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		pname = nil
		pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;remove &quot;) + 7)

		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if (id == nil) then
			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A player name is required.[-]&quot;)
			else
				message(&quot;say [&quot; .. server.chatColour .. &quot;]Command requires a player name or no match found.[-]&quot;)		
			end
				
			faultyChat = false
			return true
		end

		players[id].whitelisted = false
		conn:execute(&quot;DELETE FROM whitelist WHERE steam = &quot; .. id)				

		if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name .. &quot; is no longer whitelisted.[-]&quot;)	
		else
			message(&quot;say [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name .. &quot; is no longer whitelisted.[-]&quot;)
		end
		
		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 19&quot;) end

	if (chatvars.words[1] == &quot;ignore&quot; and chatvars.words[2] == &quot;player&quot; and chatvars.words[3] ~= nil) then	
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 2) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		pname = nil
		pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;player &quot;) + 7)

		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if (id == nil) then
			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A player name is required.[-]&quot;)
			else
				message(&quot;say [&quot; .. server.chatColour .. &quot;]Command requires a player name or no match found.[-]&quot;)		
			end
				
			faultyChat = false
			return true
		end

		if (players[id]) then
			players[id].allowBadInventory = true

			conn:execute(&quot;UPDATE players SET allowBadInventory = 1 WHERE steam = &quot; .. id)
		end

		if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name .. &quot; is allowed to carry uncraftable items.[-]&quot;)	
		else
			message(&quot;say [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name .. &quot; is allowed to carry uncraftable items.[-]&quot;)
		end
		
		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 20&quot;) end

	if (chatvars.words[1] == &quot;include&quot; and chatvars.words[2] == &quot;player&quot; and chatvars.words[3] ~= nil) then	
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 2) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		pname = nil
		pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;player &quot;) + 7)

		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if (id == nil) then
			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A player name is required.[-]&quot;)
			else
				message(&quot;say [&quot; .. server.chatColour .. &quot;]Command requires a player name or no match found.[-]&quot;)		
			end
				
			faultyChat = false
			return true
		end

		if (players[id]) then
			players[id].allowBadInventory = false

			conn:execute(&quot;UPDATE players SET allowBadInventory = 0 WHERE steam = &quot; .. id)
		end

		if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name .. &quot; is no longer allowed to carry uncraftable items.[-]&quot;)	
		else
			message(&quot;say [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name .. &quot; is no longer allowed to carry uncraftable items.[-]&quot;)
		end
		
		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 21&quot;) end

	if (chatvars.words[1] == &quot;prisoner&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 2) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		prisoner = string.sub(chatvars.command, string.find(chatvars.command, &quot;prisoner &quot;) + 9, string.find(chatvars.command, &quot;arrested&quot;) -1)
		prisoner = string.trim(prisoner)
		prisonerid = LookupPlayer(prisoner)
		prisoner = players[prisonerid].name
		reason = nil
		reason = string.sub(chatvars.command, string.find(chatvars.command, &quot;arrested &quot;) + 9)	

		if (prisonerid == nil or not players[prisonerid].prisoner) then
			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;] &quot; .. prisoner .. &quot; is not a prisoner[-]&quot;)
			else
				message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. prisoner .. &quot; is not a prisoner[-]&quot;)
			end

			faultyChat = false
			return true
		end

		if (players[prisonerid].prisoner and players[prisonerid].prisonReason ~= nil) then
			players[prisonerid].prisonReason = reason

			conn:execute(&quot;UPDATE players SET prisonReason = '&quot; .. escape(reason) .. &quot;' WHERE steam = &quot; .. prisonerid)
		end

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You added a reason for prisoner &quot; .. prisoner .. &quot;'s arrest[-]&quot;)
		else
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Reason for prisoner &quot; .. prisoner .. &quot;'s arrest noted.[-]&quot;)
		end
		
		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 22&quot;) end

	if (chatvars.words[1] == &quot;arrest&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 2) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		prisoner = string.sub(chatvars.command, string.find(chatvars.command, &quot;arrest &quot;) + 7)
		prisoner = string.trim(prisoner)
		prisonerid = LookupPlayer(prisoner)

		if prisonerid == nil then
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No player found called &quot; .. prisoner .. &quot;[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;No player found called &quot; .. prisoner)
			end

			faultyChat = false
			return true
		end

		prisoner = players[prisonerid].name

		if (players[prisonerid]) then
			if (players[prisonerid].timeout == true) then
				if (chatvars.playername ~= &quot;Server&quot;) then 
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. prisoner .. &quot; is in timeout. /return them first[-]&quot;)
				else
					irc_QueueMsg(players[chatvars.ircid].ircAlias, prisoner .. &quot; is in timeout. Return them first&quot;)
				end

				faultyChat = false
				return true
			end
		end

		if (chatvars.playername ~= &quot;Server&quot;) then
			if (accessLevel(prisonerid) &lt; 3 and server.ignoreAdmins == true and prisonerid ~= chatvars.playerid) then
				if (chatvars.playername ~= &quot;Server&quot;) then 
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Staff can not be arrested.[-]&quot;)
				else
					irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Staff can not be arrested.&quot;)
				end

				faultyChat = false
				return true
			end
		end

		if locations[&quot;prison&quot;] == nil then
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Create a location called prison first. Sending them to timeout instead..[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Create a location called prison first. Sending them to timeout instead.&quot;)
			end

			gmsg(&quot;/timeout &quot; .. prisoner)
			faultyChat = false
			return true
		end

		message(&quot;say Arresting citizen &quot; .. prisoner)

		if (not players[prisonerid].prisoner) then
			players[prisonerid].prisoner = true
			players[prisonerid].prisonxPosOld = math.floor(igplayers[prisonerid].xPos)
			players[prisonerid].prisonyPosOld = math.ceil(igplayers[prisonerid].yPos)
			players[prisonerid].prisonzPosOld = math.floor(igplayers[prisonerid].zPos)
			igplayers[prisonerid].xPosLastOK = locations[&quot;prison&quot;].x
			igplayers[prisonerid].yPosLastOK = locations[&quot;prison&quot;].y
			igplayers[prisonerid].zPosLastOK = locations[&quot;prison&quot;].z

			if accessLevel(prisonerid) &gt; 2	then
				players[prisonerid].silentBob = true
			end

			conn:execute(&quot;UPDATE players SET prisoner = 1, silentBob = 1, prisonxPosOld = &quot; .. players[prisonerid].prisonxPosOld .. &quot;, prisonyPosOld = &quot; .. players[prisonerid].prisonyPosOld .. &quot;, prisonzPosOld = &quot; .. players[prisonerid].prisonzPosOld .. &quot; WHERE steam = &quot; .. prisonerid)

			message(&quot;pm &quot; .. prisonerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have been sentenced to prison.  There is no escape until you are released by an admin.[-]&quot;)
			cmd = &quot;tele &quot; .. prisonerid .. &quot; &quot; .. locations[&quot;prison&quot;].x .. &quot; &quot; .. locations[&quot;prison&quot;].y .. &quot; &quot; .. locations[&quot;prison&quot;].z
			prepareTeleport(prisonerid, cmd)

			if players[prisonerid].watchPlayer then
				irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. chatvars.playerid .. &quot; &quot; .. chatvars.playername .. &quot; command &quot; .. chatvars.command  )				
			end

			teleport(cmd, true)
			
			conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. players[prisonerid].xPosOld .. &quot;,&quot; .. players[prisonerid].yPosOld .. &quot;,&quot; .. players[prisonerid].zPosOld .. &quot;,'&quot; .. serverTime .. &quot;','arrest','Player &quot; .. escape(players[prisonerid].name) .. &quot; SteamID: &quot; .. prisonerid .. &quot; arrested by &quot; .. escape(players[chatvars.playerid].name)  .. &quot;',&quot; .. prisonerid .. &quot;)&quot;)
			
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 23&quot;) end

	if (chatvars.words[1] == &quot;resettimers&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 2) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		pname = nil
		pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;resettimers &quot;) + 12)

		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if (pname == nil and chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A player name is required.[-]&quot;)
			faultyChat = false
			return true
		end

		if (players[id]) then
			players[id].baseCooldown = 0
			players[id].gimmeCount = 0

			conn:execute(&quot;UPDATE players SET baseCooldown = 0, gimmeCount = 0 WHERE steam = &quot; .. id)
		end

		message(&quot;say [&quot; .. server.chatColour .. &quot;]Cooldown timers have been reset for &quot; .. players[id].name .. &quot;[-]&quot;)

		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 24&quot;) end

	if (chatvars.words[1] == &quot;ignoreadmins&quot;) or (chatvars.words[1] == &quot;exclude&quot; and chatvars.words[2] == &quot;admins&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 2) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		server.ignoreAdmins = true

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Admins can ignore the server rules.[-]&quot;)		
		else
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Admins can ignore the server rules.&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 25&quot;) end

	if (chatvars.words[1] == &quot;includeadmins&quot;) or (chatvars.words[1] == &quot;include&quot; and chatvars.words[2] == &quot;admins&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 2) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		server.ignoreAdmins = false

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Admins must obey the server rules.[-]&quot;)		
		else
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Admins must obey the server rules.&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 26&quot;) end

	if (chatvars.words[1] == &quot;freeze&quot; and chatvars.words[2] ~= nil) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 2) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;freeze&quot;) + 7)
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if (pname == nil or pname == &quot;&quot;) then
			faultyChat = false
			return true 
		end

		if (id ~= nil) then 
			players[id].freeze = true 
			message(&quot;say [&quot; .. server.chatColour .. &quot;]STOP RIGHT THERE CRIMINAL SCUM![-]&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 27&quot;) end

	if (chatvars.words[1] == &quot;unfreeze&quot; and chatvars.words[2] ~= nil) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 2) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;unfreeze&quot;) + 9)
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if (pname == nil or pname == &quot;&quot;) then
			faultyChat = false
			return true 
		end

		if (players[id]) then 
			players[id].freeze = false 
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Citizen &quot; .. players[id].name .. &quot;, you are free to go.[-]&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 28&quot;) end

	if (chatvars.words[1] == &quot;move&quot;) and chatvars.words[2] ~= nil and string.find(chatvars.command, &quot; to &quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 2) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;move&quot;) + 5, string.find(chatvars.command, &quot; to &quot;) - 1)
		pname = string.trim(pname)
		
		location = string.sub(chatvars.command, string.find(chatvars.command, &quot; to &quot;) + 4)
		location = string.trim(location)	

		loc = LookupLocation(location)	
		id = LookupPlayer(pname)

		if (id ~= nil and loc ~= nil) then
			-- if the player is ingame, send them to the lobby otherwise flag it to happen when they rejoin
			if (igplayers[id]) then

				if players[id].watchPlayer then
					irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. chatvars.playerid .. &quot; &quot; .. chatvars.playername .. &quot; command &quot; .. chatvars.command  )
				end

				cmd = &quot;tele &quot; .. id .. &quot; &quot; .. locations[loc].x .. &quot; &quot; .. locations[loc].y .. &quot; &quot; .. locations[loc].z
				igplayers[id].lastTP = cmd
				teleport(cmd, true)

				if (chatvars.playername ~= &quot;Server&quot;) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Player &quot; .. players[id].name .. &quot; has been sent to &quot; .. locations[loc].name .. &quot;[-]&quot;)
				else
					irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Player &quot; .. players[id].name .. &quot; has been sent to &quot; .. locations[loc].name)
				end
			else
				players[id].location = loc

				if (chatvars.playername ~= &quot;Server&quot;) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Player &quot; .. players[id].name .. &quot; will spawn at &quot; .. locations[loc].name .. &quot; next time they join.[-]&quot;)
				else
					irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Player &quot; .. players[id].name .. &quot; will spawn at &quot; .. locations[loc].name .. &quot; next time they join.&quot;)
				end

				conn:execute(&quot;UPDATE players SET location = '&quot; .. loc .. &quot;' WHERE steam = &quot; .. id)
			end
		end

		players[id].xPosOld = locations[loc].x
		players[id].yPosOld = locations[loc].y
		players[id].zPosOld = locations[loc].z
		
		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 29&quot;) end

	if (chatvars.words[1] == &quot;sendhome&quot; or chatvars.words[1] == &quot;sendhome2&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 2) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;sendhome&quot;) + 9)
		pname = string.trim(pname)

		if (pname == &quot;&quot;) then 
			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A player name is required or could not be found for this command[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;A player name is required or could not be found for this command&quot;)
			end

			faultyChat = false
			return true
		else
			id = 0
			id = LookupPlayer(pname)

			if (id == 0) then
				if (chatvars.playername ~= &quot;Server&quot;) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No in-game players found with that name.[-]&quot;)
				else
					irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;No in-game players found called &quot; .. pname)
				end

				faultyChat = false
				return true
			end

			if (players[id].timeout == true) then
				if (chatvars.playername ~= &quot;Server&quot;) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; is in timeout. /return them first[-]&quot;)
				else
					irc_QueueMsg(players[chatvars.ircid].ircAlias, players[id].name .. &quot; is in timeout. Return them first.&quot;)
				end

				faultyChat = false
				return true
			end

			-- first record the current x y z
			if (igplayers[id]) then
				players[id].xPosOld = math.floor(igplayers[id].xPos)
				players[id].yPosOld = math.ceil(igplayers[id].yPos)
				players[id].zPosOld = math.floor(igplayers[id].zPos)
			end

			if (chatvars.words[1] == &quot;sendhome&quot;) then
				if (players[id].homeX == 0 and players[id].homeZ == 0) then
					if (chatvars.playername ~= &quot;Server&quot;) then
						message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name .. &quot; has not set a base yet.[-]&quot;)
					else
						irc_QueueMsg(players[chatvars.ircid].ircAlias, players[id].name .. &quot; has not set a base yet.&quot;)
					end

					faultyChat = false
					return true
				else
					if (igplayers[id]) then
						if players[id].watchPlayer then
							irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. chatvars.playerid .. &quot; &quot; .. chatvars.playername .. &quot; command &quot; .. chatvars.command  )
						end

						cmd = &quot;tele &quot; .. id .. &quot; &quot; .. players[id].homeX .. &quot; &quot; .. players[id].homeY .. &quot; &quot; .. players[id].homeZ
						prepareTeleport(id, cmd)
						teleport(cmd, true)
					end

					if (chatvars.playername ~= &quot;Server&quot;) then
						message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name .. &quot; has been sent home&quot;)
					else
						irc_QueueMsg(players[chatvars.ircid].ircAlias, players[id].name .. &quot; has been sent home.&quot;)
					end
				end
			else
				if (players[id].home2X == 0 and players[id].home2Z == 0) then
					if (chatvars.playername ~= &quot;Server&quot;) then
						message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name .. &quot; has not set a 2nd base yet.[-]&quot;)
					else
						irc_QueueMsg(players[chatvars.ircid].ircAlias, players[id].name .. &quot; has not set a 2nd base yet.&quot;)
					end

					faultyChat = false
					return true
				else
					if (igplayers[id]) then
						if players[id].watchPlayer then
							irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. chatvars.playerid .. &quot; &quot; .. chatvars.playername .. &quot; command &quot; .. chatvars.command  )
						end

						cmd = &quot;tele &quot; .. id .. &quot; &quot; .. players[id].home2X .. &quot; &quot; .. players[id].home2Y .. &quot; &quot; .. players[id].home2Z
						prepareTeleport(id, cmd)
						teleport(cmd, true)
					end

					if (chatvars.playername ~= &quot;Server&quot;) then
						message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;] &quot; .. players[id].name .. &quot; has been sent home&quot;)
					else
						irc_QueueMsg(players[chatvars.ircid].ircAlias, players[id].name .. &quot; has been sent home.&quot;)
					end
				end
			end
		end
		
		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 30&quot;) end

	if (chatvars.words[1] == &quot;watch&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 2) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if (chatvars.words[2] == &quot;new&quot; and chatvars.words[3] == &quot;players&quot;) then
			for k,v in pairs(players) do
				if v.newPlayer == true then
					v.watchPlayer = true
					conn:execute(&quot;UPDATE players SET watchPlayer = 1 WHERE steam = &quot; .. k)
				end
			end

			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]New players will be watched.[-]&quot;)

			faultyChat = false
			return true
		end

		pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;watch &quot;) + 6)
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if not (id == nil) then
			players[id].watchPlayer = true
			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Admins will be alerted whenever &quot; .. players[id].name ..  &quot; enters a base.[-]&quot;)
			end

			conn:execute(&quot;UPDATE players SET watchPlayer = 1 WHERE steam = &quot; .. id)
		end
		
		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 31&quot;) end

	if (chatvars.words[1] == &quot;stop&quot; and chatvars.words[2] == &quot;watching&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 2) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if (chatvars.words[3] == &quot;everyone&quot;) then
			for k,v in pairs(players) do
				v.watchPlayer = false
				conn:execute(&quot;UPDATE players SET watchPlayer = 0 WHERE steam = &quot; .. k)
			end

			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Nobody is being watched right now.[-]&quot;)

			faultyChat = false
			return true
		end

		pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;watching &quot;) + 9)

		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if not (id == nil) then
			players[id].watchPlayer = false
			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Player &quot; .. players[id].name ..  &quot; will no longer be watched.[-]&quot;)
			end

			conn:execute(&quot;UPDATE players SET watchPlayer = 0 WHERE steam = &quot; .. id)
		end
		
		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 32&quot;) end

	if (chatvars.words[1] == &quot;send&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 2) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		id1 = nil
		id2 = nil
		
		for i=2,chatvars.wordCount,1 do 
			if (chatvars.words[i] ~= &quot;to&quot;) then			
				if id1 ~= nil and id2 == nil then 
					id2 = LookupPlayer(chatvars.words[i]) 
				end

				if id1 == nil then 
					id1 = LookupPlayer(chatvars.words[i]) 
				end
			end
		end

		if (id ~= nil and id2 ~= nil) then
			if (players[id1].walkies == true) and (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id1].name .. &quot; has not opted in to being teleported. Ask them to /enabletp first[-]&quot;)
				faultyChat = false
				return true
			end

			if (players[id1].timeout == true) then
				if (chatvars.playername ~= &quot;Server&quot;) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id1].name .. &quot; is in timeout. Return them first[-]&quot;)
				else
					irc_QueueMsg(players[chatvars.ircid].ircAlias, players[id1].name .. &quot; is in timeout. Return them first.&quot;)
				end

				faultyChat = false
				return true
			end

			-- first record the current x y z
			players[id1].xPosOld = math.floor(players[id1].xPos)
			players[id1].yPosOld = math.floor(players[id1].yPos)
			players[id1].zPosOld = math.floor(players[id1].zPos)

			if (igplayers[id2]) then
				if players[id1].watchPlayer then
					irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. chatvars.playerid .. &quot; &quot; .. chatvars.playername .. &quot; command &quot; .. chatvars.command  )
				end

				cmd = &quot;tele &quot; .. id1 .. &quot; &quot; .. id2
				prepareTeleport(id1, cmd)
				teleport(cmd, true)
			else
				if players[id1].watchPlayer then
					irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. chatvars.playerid .. &quot; &quot; .. chatvars.playername .. &quot; command &quot; .. chatvars.command  )
				end

				cmd = &quot;tele &quot; .. id1 .. &quot; &quot; .. math.floor(players[id2].xPos) .. &quot; &quot; .. math.ceil(players[id2].yPos) .. &quot; &quot; .. math.floor(players[id2].zPos)
				prepareTeleport(id1, cmd)
				teleport(cmd, true)
			end
		end
		
		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 33&quot;) end

	if (chatvars.words[1] == &quot;burn&quot; and chatvars.words[2] ~= nil) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 2) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if (chatvars.words[2] ~= nil) then
			pname = chatvars.words[2]
			pid = LookupPlayer(pname)

			if pid == nil then
				if (chatvars.playername ~= &quot;Server&quot;) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No in-game players found with that name.[-]&quot;)
				else
					irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;No in-game players found called &quot; .. pname)
				end

				faultyChat = false
				return true
			end
		end

		send(&quot;buffplayer &quot; .. pid .. &quot; burning&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You set &quot; .. players[pid].name .. &quot; on fire![-]&quot;)
		else
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;You set &quot; .. players[pid].name .. &quot; on fire!&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 34&quot;) end

	if (chatvars.words[1] == &quot;shutdown&quot; and chatvars.words[2] == &quot;bot&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			faultyChat = false
			return true
		else
			if chatvars.ircid ~= yourname then
				faultyChat = false
				return true
			end
		end

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. server.botName .. &quot; is shutting down.[-]&quot;)
		else
			irc_QueueMsg(players[chatvars.ircid].ircAlias, server.botName .. &quot; is shutting down.&quot;)
		end

		shutdownBot()

		faultyChat = false
		return true
	end


	-- ###################  do not allow remote commands beyond this point ################
	if (chatvars.playerid == nil) then
		faultyChat = false
		return false
	end
	-- ####################################################################################


	if (chatvars.words[1] == &quot;who&quot; and chatvars.words[2] == &quot;visited&quot;) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		if (chatvars.words[3] == nil) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]See who visited a player location or base.[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Example with defaults:[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/who visited smeg days 1 hours 1 range 10 height 4[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Add base to just see base visitors[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Setting hours will reset days to zero[-]&quot;)
			faultyChat = false
			return true
		end
		
		-- optional params
			-- range &lt;distance in metres&gt; Default 10
			-- days.  Default is 1 day ago from today (local time not server)

		name1 = nil
		days = 1
		hours = 0
		range = 10
		height = 4
		baseOnly = &quot;player&quot;

		if chatvars.words[3] ~= nil then
			name1 = string.trim(chatvars.words[3])
		end

		for i=3,chatvars.wordCount,1 do
			if chatvars.words[i] == &quot;range&quot; then
				range = tonumber(chatvars.words[i+1])
			end	

			if chatvars.words[i] == &quot;height&quot; then
				height = tonumber(chatvars.words[i+1])
			end	
				
			if chatvars.words[i] == &quot;days&quot; then
				days = tonumber(chatvars.words[i+1])
			end								

			if chatvars.words[i] == &quot;hours&quot; then
				hours = tonumber(chatvars.words[i+1])
				days = 0
			end								

			if chatvars.words[i] == &quot;base&quot; then
				baseOnly = &quot;base&quot;
			end	

			if chatvars.words[i] == &quot;player&quot; then
				baseOnly = &quot;player&quot;
				name1 = string.trim(chatvars.words[i+1])
			end	
		end		

		if name1 ~= nil then
			pid = LookupPlayer(name1)
		else
			pid = chatvars.playerid
		end
		
		if baseOnly == &quot;base&quot; or baseOnly == &quot;all&quot; then
			if players[pid].homeX ~= 0 and players[pid].homeZ ~= 0 then
				if days == 0 then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; Players who visited within &quot; .. range .. &quot; metres of base 1 of &quot; .. players[pid].name .. &quot; in the last &quot; .. hours .. &quot; hours&quot;)
				else
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; Players who visited within &quot; .. range .. &quot; metres of base 1 of &quot; .. players[pid].name .. &quot; in the last &quot; .. days .. &quot; days&quot;)
				end

				dbWho(chatvars.playerid, players[pid].homeX, players[pid].homeY, players[pid].homeZ, range, days, hours, height)
			else
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; &quot; .. players[pid].name .. &quot; does not have a base set yet.&quot;)
			end

			if players[pid].home2X ~= 0 and players[pid].home2Z ~= 0 then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; &quot;)
				if days == 0 then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; Players who visited within &quot; .. range .. &quot; metres of base 2 of &quot; .. players[pid].name .. &quot; in the last &quot; .. hours .. &quot; hours&quot;)
				else
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; Players who visited within &quot; .. range .. &quot; metres of base 2 of &quot; .. players[pid].name .. &quot; in the last &quot; .. days .. &quot; days&quot;)
				end

				dbWho(chatvars.playerid, players[pid].home2X, players[pid].home2Y, players[pid].home2Z, range, days, hours, height)
			end
		end

		if baseOnly == &quot;player&quot; or baseOnly == &quot;all&quot; then
			if days == 0 then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; Players who visited within &quot; .. range .. &quot; metres (X) &quot; .. players[pid].xPos .. &quot; (Z) &quot; .. players[pid].zPos .. &quot; of player &quot; .. players[pid].name .. &quot; in the last &quot; .. hours .. &quot; hours&quot;)
			else
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; Players who visited within &quot; .. range .. &quot; metres (X) &quot; .. players[pid].xPos .. &quot; (Z) &quot; .. players[pid].zPos .. &quot; of player &quot; .. players[pid].name .. &quot; in the last &quot; .. days .. &quot; days&quot;)
			end

			dbWho(chatvars.playerid, players[pid].xPos, players[pid].yPos, players[pid].zPos, range, days, hours, height)
		end		
		
		faultyChat = false
		return true
	end	

if debug then dbug(&quot;admin 35&quot;) end

	if (chatvars.words[1] == &quot;bases&quot; or chatvars.words[1] == &quot;homes&quot;) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		alone = true
		if (chatvars.number == nil) then chatvars.number = 201 end

		if (not string.find(chatvars.command, &quot;range&quot;)) and (not string.find(chatvars.command, &quot;near&quot;)) then
			for k, v in pairs(players) do
				if (v.homeX) and (v.homeX ~= 0 and v.homeZ ~= 0) then
					dist = distancexz(igplayers[chatvars.playerid].xPos, igplayers[chatvars.playerid].zPos, v.homeX, v.homeZ)

					if dist &lt; tonumber(chatvars.number) then
						if (alone == true) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]player bases within &quot; .. chatvars.number .. &quot; meters of you are:[-]&quot;) end

						message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot; distance: &quot; .. string.format(&quot;%-8.2d&quot;, dist) .. &quot; meters[-]&quot;)
						alone = false
					end
				end
				
				if (v.home2X) and (v.home2X ~= 0 and v.home2Z ~= 0) then
					dist = distancexz(igplayers[chatvars.playerid].xPos, igplayers[chatvars.playerid].zPos, v.home2X, v.home2Z)

					if dist &lt; tonumber(chatvars.number) then
						if (alone == true) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]player bases within &quot; .. chatvars.number .. &quot; meters of you are:[-]&quot;) end

						message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot; distance: &quot; .. string.format(&quot;%-8.2d&quot;, dist) .. &quot; meters[-]&quot;)
						alone = false
					end
				end			
			end

			if (alone == true) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]There are none within &quot; .. chatvars.number .. &quot; meters of you.&quot;)
			end
		else
			if string.find(chatvars.command, &quot;range&quot;) then
				name1 = string.sub(chatvars.command, string.find(chatvars.command, &quot;near&quot;) + 5, string.find(chatvars.command, &quot;range&quot;) - 1)
				chatvars.number = string.sub(chatvars.command, string.find(chatvars.command, &quot;range&quot;) + 6)
			else
				name1 = string.sub(chatvars.command, string.find(chatvars.command, &quot;near&quot;) + 5)
			end

			name1 = string.trim(name1)
			pid = LookupPlayer(name1)

			if (pid ~= nil) then
				for k, v in pairs(players) do
					if (v.homeX) and (v.homeX ~= 0 and v.homeZ ~= 0) then
						dist = distancexz(igplayers[pid].xPos, igplayers[pid].zPos, v.homeX, v.homeZ)

						if dist &lt; tonumber(chatvars.number) then
							if (alone == true) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]player bases within &quot; .. chatvars.number .. &quot; meters of &quot; .. players[pid].name .. &quot; are:[-]&quot;) end

							message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot; distance: &quot; .. string.format(&quot;%-8.2d&quot;, dist) .. &quot; meters[-]&quot;)
							alone = false
						end
					end
					
					if (v.home2X) and (v.home2X ~= 0 and v.home2Z ~= 0) then
						dist = distancexz(igplayers[pid].xPos, igplayers[pid].zPos, v.home2X, v.home2Z)

						if dist &lt; tonumber(chatvars.number) then
							if (alone == true) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]player bases within &quot; .. chatvars.number .. &quot; meters of &quot; .. players[pid].name .. &quot; are:[-]&quot;) end

							message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot; distance: &quot; .. string.format(&quot;%-8.2d&quot;, dist) .. &quot; meters[-]&quot;)
							alone = false
						end
					end			
				end

				if (alone == true) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]There are none within &quot; .. chatvars.number .. &quot; meters of &quot; .. players[pid].name .. &quot;[-]&quot;)
				end
			else	
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No player found matching &quot; .. name1 .. &quot;[-]&quot;)
			end	
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 36&quot;) end

	if (string.find(chatvars.command, &quot;admin add &quot;) and accessLevel(chatvars.playerid) == 0) then
		if string.find(chatvars.command, &quot;level&quot;) then
			pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;admin add &quot;) + 10, string.find(chatvars.command, &quot;level&quot;) - 1)
		else
			pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;admin add &quot;) + 10)
		end

		pname = string.trim(pname)
		id = LookupPlayer(pname)
		number = -1

		for i=3,chatvars.wordCount,1 do
			if chatvars.words[i] == &quot;level&quot; then
				number = chatvars.words[i+1]
			end	
		end

		if number == -1 then
			number = 1
		end

		if id ~= nil then
			-- add the steamid to the admins table
			if tonumber(number) == 0 then
				owners[id] = {}
			end

			if tonumber(number) == 1 then
				admins[id] = {}
			end

			if tonumber(number) == 2 then
				mods[id] = {}
			end

			players[id].newPlayer = false
			players[id].silentBob = false
			players[id].walkies = false
			players[id].exiled = 2
			players[id].canTeleport = true
			players[id].botHelp = true

			if tonumber(players[id].accessLevel) &gt; tonumber(number) then
				players[id].accessLevel = number
			end

			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; has been given admin powers[-]&quot;)
			send(&quot;admin add &quot; .. id .. &quot; &quot; .. number)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 37&quot;) end

	if (string.find(chatvars.command, &quot;admin remove &quot;) and accessLevel(chatvars.playerid) == 0) then
		pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;admin remove &quot;) + 13)

		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if id ~= nil then
			-- remove the steamid from the admins table
			owners[players[id].steam] = nil
			admins[players[id].steam] = nil
			mods[players[id].steam] = nil
			players[id].accessLevel = 90

			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot;'s admin powers have been revoked[-]&quot;)
			send(&quot;admin remove &quot; .. id)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 38&quot;) end

	if chatvars.words[1] == &quot;goto&quot; and chatvars.words[2] ~= nil then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		if (players[chatvars.playerid].timeout == true) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are in timeout. You cannot /goto anywhere until you are released.[-]&quot;)
			faultyChat = false
			return true
		end

		pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;goto &quot;) + 5)

		-- first record the current x y z
		players[chatvars.playerid].xPosOld = chatvars.intX
		players[chatvars.playerid].yPosOld = chatvars.intY
		players[chatvars.playerid].zPosOld = chatvars.intZ

		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if not (id == nil) then
			-- then teleport to the player
			cmd = &quot;tele &quot; .. chatvars.playerid .. &quot; &quot; .. math.floor(players[id].xPos) + 1 .. &quot; &quot; .. math.ceil(players[id].yPos) .. &quot; &quot; .. math.floor(players[id].zPos)
			teleport(cmd, true)
		end
		
		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 39&quot;) end

	if (chatvars.words[1] == &quot;offline&quot; and chatvars.words[2] == &quot;players&quot; and chatvars.words[3] == &quot;nearby&quot;) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		chatvars.number = 201
		
		if string.find(chatvars.command, &quot;range&quot;) then
			chatvars.number = string.sub(chatvars.command, string.find(chatvars.command, &quot;range&quot;) + 6)
		end

		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]offline players within &quot; .. chatvars.number .. &quot; meters of you are:[-]&quot;) 

		alone = true

		for k, v in pairs(players) do
			if igplayers[k] == nil and v.xPos ~= nil then	
				dist = distancexz(igplayers[chatvars.playerid].xPos, igplayers[chatvars.playerid].zPos, v.xPos, v.zPos)
				dist = math.abs(dist)

				if tonumber(dist) &lt;= tonumber(chatvars.number) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot; distance: &quot; .. string.format(&quot;%d&quot;, dist) .. &quot;[-]&quot;)
					alone = false
				end
			end
		end

		if (alone == true) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No offline players within range.[-]&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 40&quot;) end

	if (chatvars.words[1] == &quot;crimescene&quot;) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		prisoner = string.sub(chatvars.command, string.find(chatvars.command, &quot;scene &quot;) + 6)
		prisoner = string.trim(prisoner)
		prisonerid = LookupPlayer(prisoner)

		if (players[prisonerid].prisoner) then
			-- first record the current x y z
			players[chatvars.playerid].xPosOld = chatvars.intX
			players[chatvars.playerid].yPosOld = chatvars.intY
			players[chatvars.playerid].zPosOld = chatvars.intZ		
			
			-- then teleport to the prisoners old coords
			cmd = &quot;tele &quot; .. chatvars.playerid .. &quot; &quot; .. players[prisonerid].prisonxPosOld .. &quot; &quot; .. players[prisonerid].prisonyPosOld .. &quot; &quot; .. players[prisonerid].prisonzPosOld
			prepareTeleport(chatvars.playerid, cmd)
			teleport(cmd, true)
		else
			-- tp to their return coords if they are set
			if tonumber(players[prisonerid].yPosTimeout) ~= 0 then
				-- first record the current x y z
				players[chatvars.playerid].xPosOld = chatvars.intX
				players[chatvars.playerid].yPosOld = chatvars.intY
				players[chatvars.playerid].zPosOld = chatvars.intZ		
			
				-- then teleport to the prisoners old coords
				cmd = &quot;tele &quot; .. chatvars.playerid .. &quot; &quot; .. players[prisonerid].xPosTimeout .. &quot; &quot; .. players[prisonerid].yPosTimeout .. &quot; &quot; .. players[prisonerid].zPosTimeout
				prepareTeleport(chatvars.playerid, cmd)
				teleport(cmd, true)
			end
		end
		
		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 41&quot;) end

	if (chatvars.words[1] == &quot;closeto&quot; or chatvars.words[1] == &quot;near&quot;) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		if (players[chatvars.playerid].timeout == true) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are in timeout. You cannot go anywhere until you are released for safety reasons.[-]&quot;)
			faultyChat = false
			return true
		end

		if chatvars.words[1] == &quot;closeto&quot; then
			pname = chatvars.words[2]
		end	

		if chatvars.words[1] == &quot;near&quot; then
			pname = chatvars.words[2]
		end	

		if chatvars.words[3] ~= nil then
			igplayers[chatvars.playerid].followDistance = tonumber(chatvars.words[3])
		end	

		-- first record the current x y z
		players[chatvars.playerid].xPosOld = chatvars.intX
		players[chatvars.playerid].yPosOld = chatvars.intY
		players[chatvars.playerid].zPosOld = chatvars.intZ

		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if not (id == nil) then
			igplayers[chatvars.playerid].following = id

			-- then teleport close to the player
			cmd = &quot;tele &quot; .. chatvars.playerid .. &quot; &quot; .. math.floor(igplayers[id].xPos + 10) .. &quot; &quot; .. math.ceil(igplayers[id].yPos - 20) .. &quot; &quot; .. math.floor(igplayers[id].zPos + 10)
			send(cmd)
		end
		
		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 42&quot;) end

	if (chatvars.words[1] == &quot;add&quot; and chatvars.words[2] == &quot;bad&quot; and chatvars.words[3] == &quot;item&quot; and chatvars.words[4] ~= nil) then
		if (accessLevel(chatvars.playerid) &gt; 1) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is a restricted command[-]&quot;)
			faultyChat = false
			return true
		end

		bad = string.sub(chatvars.command, string.find(chatvars.command, &quot;bad item&quot;) + 9)

		conn:execute(&quot;INSERT INTO badItems SET item = '&quot; .. bad .. &quot;'&quot;)

		badItems[bad] = {}
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You added &quot; .. bad .. &quot; to the list of bad items[-]&quot;)

		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 43&quot;) end

	if (chatvars.words[1] == &quot;remove&quot; and chatvars.words[2] == &quot;bad&quot; and chatvars.words[3] == &quot;item&quot; and chatvars.words[4] ~= nil) then
		if (accessLevel(chatvars.playerid) &gt; 1) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is a restricted command[-]&quot;)
			faultyChat = false
			return true
		end

		bad = string.sub(chatvars.command, string.find(chatvars.command, &quot;bad item&quot;) + 9)

		conn:execute(&quot;DELETE FROM badItems WHERE item = '&quot; .. bad .. &quot;'&quot;)

		badItems[bad] = nil
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You removed &quot; .. bad .. &quot; from the list of bad items[-]&quot;)

		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 44&quot;) end

	if (chatvars.words[1] == &quot;bad&quot; and chatvars.words[2] == &quot;items&quot;) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is a restricted command[-]&quot;)
			faultyChat = false
			return true
		end

		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]I scan for these items in inventory:[-]&quot;)
		for k, v in pairs(badItems) do
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. k .. &quot;[-]&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 45&quot;) end

	if (chatvars.words[1] == &quot;add&quot; and chatvars.words[2] == &quot;restricted&quot;) then
		if (accessLevel(chatvars.playerid) &gt; 1) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is a restricted command[-]&quot;)
			faultyChat = false
			return true
		end

		if (chatvars.words[3] == nil) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Add an item to the inventory scanner for special attention.[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]eg. /add restricted item tnt qty 5 action timeout access 90[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Players with access &gt; 90 will be sent to timeout for more than 5 tnt.[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Valid actions are timeout, ban, the name of a location (for exile), and watch[-]&quot;)
			faultyChat = false
			return true
		end

		item = &quot;&quot;
		qty = 0
		access = 100
		action = &quot;timeout&quot;

		for i=3,chatvars.wordCount,1 do
			if chatvars.words[i] == &quot;item&quot; then
				item = chatvars.wordsOld[i+1]
			end					

			if chatvars.words[i] == &quot;qty&quot; then
				qty = chatvars.words[i+1]
			end

			if chatvars.words[i] == &quot;access&quot; then
				access = chatvars.words[i+1]
			end

			if chatvars.words[i] == &quot;action&quot; then
				action = chatvars.wordsOld[i+1]
			end
		end

		if action ~= &quot;timeout&quot; and action ~= &quot;ban&quot; and not locations[action] and action ~= &quot;watch&quot; then
			action = &quot;timeout&quot;
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Invalid action entered, using timeout instead.[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Valid actions are timeout, ban, the name of a location (for exile), and watch[-]&quot;)
		end

		if item == &quot;&quot; or access == 100 then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Item, qty and access are required.[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]eg. /add restricted item mineCandyTin qty 20 access 99 action timeout[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Valid actions are timeout, ban, exile. Bans last 1 day.[-]&quot;)
		else
			conn:execute(&quot;INSERT INTO restrictedItems (item, qty, accessLevel, action) VALUES ('&quot; .. escape(item) .. &quot;',&quot; .. qty .. &quot;,&quot; .. access .. &quot;,'&quot; .. action .. &quot;') ON DUPLICATE KEY UPDATE item = '&quot; .. escape(item) .. &quot;', qty = &quot; .. qty .. &quot;, accessLevel = &quot; .. access .. &quot;, action = '&quot; .. action .. &quot;'&quot;)
			conn:execute(&quot;INSERT INTO memRestrictedItems (item, qty, accessLevel, action) VALUES ('&quot; .. escape(item) .. &quot;',&quot; .. qty .. &quot;,&quot; .. access .. &quot;,'&quot; .. action .. &quot;') ON DUPLICATE KEY UPDATE item = '&quot; .. escape(item) .. &quot;', qty = &quot; .. qty .. &quot;, accessLevel = &quot; .. access .. &quot;, action = '&quot; .. action .. &quot;'&quot;)

			restrictedItems[item] = {}
			restrictedItems[item].qty = tonumber(qty)
			restrictedItems[item].accessLevel = tonumber(access)
			restrictedItems[item].action = action

			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You added &quot; .. item .. &quot; quantity &quot; .. qty .. &quot; with minimum access level &quot; .. access .. &quot; and action &quot; .. action .. &quot; to restricted items[-]&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 46&quot;) end

	if (chatvars.words[1] == &quot;remove&quot; and chatvars.words[2] == &quot;restricted&quot; and chatvars.words[3] == &quot;item&quot; and chatvars.words[4] ~= nil) then
		if (accessLevel(chatvars.playerid) &gt; 1) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is a restricted command[-]&quot;)
			faultyChat = false
			return true
		end

		bad = string.sub(chatvars.command, string.find(chatvars.command, &quot;restricted item&quot;) + 16)

		conn:execute(&quot;DELETE FROM restrictedItems WHERE item = '&quot; .. bad .. &quot;'&quot;)
		conn:execute(&quot;DELETE FROM memRestrictedItems WHERE item = '&quot; .. bad .. &quot;'&quot;)

		restrictedItems[bad] = nil
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You removed &quot; .. bad .. &quot; from the list of restricted items[-]&quot;)

		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 47&quot;) end

	if (chatvars.words[1] == &quot;restricted&quot; and chatvars.words[2] == &quot;items&quot;) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is a restricted command[-]&quot;)
			faultyChat = false
			return true
		end

		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]I scan for these restricted items in inventory:[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Item      Quantity      Min Access Level[-]&quot;)

		for k, v in pairs(restrictedItems) do
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. k .. &quot; max qty &quot; .. v.qty .. &quot; min access &quot; .. v.accessLevel .. &quot; action &quot; .. v.action .. &quot;[-]&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 48&quot;) end

	if (chatvars.words[1] == &quot;prisoners&quot; and chatvars.words[2] == nil) then	
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		-- pm a list of all the prisoners
		if (prisoners == {}) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Nobody is in prison[-]&quot;)	
			faultyChat = false
			return true
		end

		for k, v in pairs(players) do
			if v.prisoner then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot; &quot; .. v.prisonReason .. &quot;[-]&quot;)
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 49&quot;) end

	if (chatvars.words[1] == &quot;equip&quot; and chatvars.words[2] == &quot;admin&quot;) then	
		if (accessLevel(chatvars.playerid) &gt; 1) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		tmp = {}
		tmp.inventory = igplayers[chatvars.playerid].pack .. igplayers[chatvars.playerid].belt
		tmp.equipment = igplayers[chatvars.playerid].equipment


		if not string.find(tmp.inventory .. tmp.equipment, &quot;ironBoots&quot;) then
			conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; ironBoots 1 600', &quot; .. chatvars.playerid .. &quot;)&quot;)
		else
			tmp.found, tmp.quality = getEquipment(tmp.equipment, &quot;ironBoots&quot;)

			if not tmp.found then
				tmp.found, tmp.quantity, tmp.quality = getInventory(tmp.inventory, &quot;ironBoots&quot;)
			end

			if tmp.found and tonumber(tmp.quality) &lt; 300 then
				conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; ironBoots 1 600', &quot; .. chatvars.playerid .. &quot;)&quot;)
			end
		end


		if not string.find(tmp.inventory, &quot;auger&quot;) then
			conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; auger 1 600', &quot; .. chatvars.playerid .. &quot;)&quot;)
		else
			tmp.found, tmp.quantity, tmp.quality = getInventory(tmp.inventory, &quot;auger&quot;)

			if tmp.found and tonumber(tmp.quality) &lt; 300 then
				conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; auger 1 600', &quot; .. chatvars.playerid .. &quot;)&quot;)
			end
		end


		if not string.find(tmp.inventory, &quot;chainsaw&quot;) then
			conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; chainsaw 1 600', &quot; .. chatvars.playerid .. &quot;)&quot;)
		end


		if not string.find(tmp.inventory, &quot;nailgun&quot;) then
			conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; nailgun 1', &quot; .. chatvars.playerid .. &quot;)&quot;)
		end


		if not string.find(tmp.inventory .. tmp.equipment, &quot;miningHelmet&quot;) then
			conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; miningHelmet 1 600', &quot; .. chatvars.playerid .. &quot;)&quot;)
		else
			tmp.found, tmp.quality = getEquipment(tmp.equipment, &quot;miningHelmet&quot;)

			if not tmp.found then
				tmp.found, tmp.quantity, tmp.quality = getInventory(tmp.inventory, &quot;miningHelmet&quot;)
			end

			if tmp.found and tmp.quality &lt; 300 then
				conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; miningHelmet 1 600', &quot; .. chatvars.playerid .. &quot;)&quot;)
			end
		end


		if not string.find(tmp.inventory .. tmp.equipment, &quot;ironChestArmor&quot;) then
			conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; ironChestArmor 1 600', &quot; .. chatvars.playerid .. &quot;)&quot;)
		else
			tmp.found, tmp.quality = getEquipment(tmp.equipment, &quot;ironChestArmor&quot;)

			if not tmp.found then
				tmp.found, tmp.quantity, tmp.quality = getInventory(tmp.inventory, &quot;ironChestArmor&quot;)
			end

			if tmp.found and tmp.quality &lt; 300 then
				conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; ironChestArmor 1 600', &quot; .. chatvars.playerid .. &quot;)&quot;)
			end
		end


		if not string.find(tmp.inventory .. tmp.equipment, &quot;ironLegArmor&quot;) then
			conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; ironLegArmor 1 600', &quot; .. chatvars.playerid .. &quot;)&quot;)
		else
			tmp.found, tmp.quality = getEquipment(tmp.equipment, &quot;ironLegArmor&quot;)

			if not tmp.found then
				tmp.found, tmp.quantity, tmp.quality = getInventory(tmp.inventory, &quot;ironLegArmor&quot;)
			end
		end


		if not string.find(tmp.inventory .. tmp.equipment, &quot;ironGloves&quot;) then
			conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; ironGloves 1 600', &quot; .. chatvars.playerid .. &quot;)&quot;)
		else
			tmp.found, tmp.quality = getEquipment(tmp.equipment, &quot;ironGloves&quot;)

			if not tmp.found then
				tmp.found, tmp.quantity, tmp.quality = getInventory(tmp.inventory, &quot;ironGloves&quot;)
			end
		end


		if not string.find(tmp.inventory .. tmp.equipment, &quot;leatherDuster&quot;) then
			conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; leatherDuster 1 600', &quot; .. chatvars.playerid .. &quot;)&quot;)
		else
			tmp.found, tmp.quality = getEquipment(tmp.equipment, &quot;leatherDuster&quot;)

			if not tmp.found then
				tmp.found, tmp.quantity, tmp.quality = getInventory(tmp.inventory, &quot;leatherDuster&quot;)
			end
		end


		if not string.find(tmp.inventory, &quot;keystoneBlock&quot;) then
			conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; keystoneBlock 10', &quot; .. chatvars.playerid .. &quot;)&quot;)
		else
			tmp.found, tmp.quantity, tmp.quality = getInventory(tmp.inventory, &quot;keystoneBlock&quot;)

			if tonumber(tmp.quantity) &lt; 10 then
				conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; keystoneBlock &quot; .. 10 - tonumber(tmp.quantity) .. &quot;', &quot; .. chatvars.playerid .. &quot;)&quot;)
			end
		end


		if not string.find(tmp.inventory, &quot;redTea&quot;) then
			conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; redTea 10', &quot; .. chatvars.playerid .. &quot;)&quot;)
		else
			tmp.found, tmp.quantity, tmp.quality = getInventory(tmp.inventory, &quot;redTea&quot;)

			if tonumber(tmp.quantity) &lt; 10 then
				conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; redTea &quot; .. 10 - tonumber(tmp.quantity) .. &quot;', &quot; .. chatvars.playerid .. &quot;)&quot;)
			end
		end


		if not string.find(tmp.inventory, &quot;gasCan&quot;) then
			conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; gasCan 400', &quot; .. chatvars.playerid .. &quot;)&quot;)
		else
			tmp.found, tmp.quantity, tmp.quality = getInventory(tmp.inventory, &quot;gasCan&quot;)

			if tonumber(tmp.quantity) &lt; 400 then
				conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; gasCan &quot; .. 400 - tonumber(tmp.quantity) .. &quot;', &quot; .. chatvars.playerid .. &quot;)&quot;)
			end
		end


		if not string.find(tmp.inventory, &quot;meatStew&quot;) then
			conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; meatStew 20', &quot; .. chatvars.playerid .. &quot;)&quot;)
		else
			tmp.found, tmp.quantity, tmp.quality = getInventory(tmp.inventory, &quot;meatStew&quot;)

			if tonumber(tmp.quantity) &lt; 20 then
				conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; meatStew &quot; .. 20 - tonumber(tmp.quantity) .. &quot;', &quot; .. chatvars.playerid .. &quot;)&quot;)
			end
		end


		if not string.find(tmp.inventory, &quot;firstAidKit&quot;) then
			conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; firstAidKit 10', &quot; .. chatvars.playerid .. &quot;)&quot;)
		else
			tmp.found, tmp.quantity, tmp.quality = getInventory(tmp.inventory, &quot;firstAidKit&quot;)

			if tonumber(tmp.quantity) &lt; 10 then
				conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; firstAidKit &quot; .. 10 - tonumber(tmp.quantity) .. &quot;', &quot; .. chatvars.playerid .. &quot;)&quot;)
			end
		end


		if not string.find(tmp.inventory, &quot;antibiotics&quot;) then
			conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; antibiotics 10', &quot; .. chatvars.playerid .. &quot;)&quot;)
		else
			tmp.found, tmp.quantity, tmp.quality = getInventory(tmp.inventory, &quot;antibiotics&quot;)

			if tonumber(tmp.quantity) &lt; 10 then
				conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; antibiotics &quot; .. 10 - tonumber(tmp.quantity) .. &quot;', &quot; .. chatvars.playerid .. &quot;)&quot;)
			end
		end


		if not string.find(tmp.inventory, &quot;shotgunShell&quot;) then
			conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; shotgunShell 500', &quot; .. chatvars.playerid .. &quot;)&quot;)
		else
			tmp.found, tmp.quantity, tmp.quality = getInventory(tmp.inventory, &quot;shotgunShell&quot;)

			if tonumber(tmp.quantity) &lt; 500 then
				conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; shotgunShell &quot; .. 500 - tonumber(tmp.quantity) .. &quot;', &quot; .. chatvars.playerid .. &quot;)&quot;)
			end
		end


		if not string.find(tmp.inventory, &quot;gunPumpShotgun&quot;) then
			conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; gunPumpShotgun 1', &quot; .. chatvars.playerid .. &quot;)&quot;)
		else
			tmp.found, tmp.quantity, tmp.quality = getInventory(tmp.inventory, &quot;gunPumpShotgun&quot;)

			if tonumber(tmp.quality) &lt; 300 then
				conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; gunPumpShotgun 1', &quot; .. chatvars.playerid .. &quot;)&quot;)
			end
		end

		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]We deliver :)[-]&quot;)
		faultyChat = false
		return true
	end

	if (chatvars.words[1] == &quot;supplies&quot;) then	
		if (accessLevel(chatvars.playerid) &gt; 1) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		tmp = {}
		tmp.inventory = igplayers[chatvars.playerid].pack .. igplayers[chatvars.playerid].belt
		tmp.equipment = igplayers[chatvars.playerid].equipment

		if not string.find(tmp.inventory, &quot;redTea&quot;) then
			conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; redTea 10', &quot; .. chatvars.playerid .. &quot;)&quot;)
		else
			tmp.found, tmp.quantity, tmp.quality = getInventory(tmp.inventory, &quot;redTea&quot;)

			if tonumber(tmp.quantity) &lt; 10 then
				conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; redTea &quot; .. 10 - tonumber(tmp.quantity) .. &quot;', &quot; .. chatvars.playerid .. &quot;)&quot;)
			end
		end


		if not string.find(tmp.inventory, &quot;gasCan&quot;) then
			conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; gasCan 800', &quot; .. chatvars.playerid .. &quot;)&quot;)
		else
			tmp.found, tmp.quantity, tmp.quality = getInventory(tmp.inventory, &quot;gasCan&quot;)

			if tonumber(tmp.quantity) &lt; 800 then
				conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; gasCan &quot; .. 800 - tonumber(tmp.quantity) .. &quot;', &quot; .. chatvars.playerid .. &quot;)&quot;)
			end
		end


		if not string.find(tmp.inventory, &quot;meatStew&quot;) then
			conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; meatStew 20', &quot; .. chatvars.playerid .. &quot;)&quot;)
		else
			tmp.found, tmp.quantity, tmp.quality = getInventory(tmp.inventory, &quot;meatStew&quot;)

			if tonumber(tmp.quantity) &lt; 20 then
				conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; meatStew &quot; .. 20 - tonumber(tmp.quantity) .. &quot;', &quot; .. chatvars.playerid .. &quot;)&quot;)
			end
		end


		if not string.find(tmp.inventory, &quot;firstAidKit&quot;) then
			conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; firstAidKit 10', &quot; .. chatvars.playerid .. &quot;)&quot;)
		else
			tmp.found, tmp.quantity, tmp.quality = getInventory(tmp.inventory, &quot;firstAidKit&quot;)

			if tonumber(tmp.quantity) &lt; 10 then
				conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; firstAidKit &quot; .. 10 - tonumber(tmp.quantity) .. &quot;', &quot; .. chatvars.playerid .. &quot;)&quot;)
			end
		end


		if not string.find(tmp.inventory, &quot;antibiotics&quot;) then
			conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; antibiotics 10', &quot; .. chatvars.playerid .. &quot;)&quot;)
		else
			tmp.found, tmp.quantity, tmp.quality = getInventory(tmp.inventory, &quot;antibiotics&quot;)

			if tonumber(tmp.quantity) &lt; 10 then
				conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; antibiotics &quot; .. 10 - tonumber(tmp.quantity) .. &quot;', &quot; .. chatvars.playerid .. &quot;)&quot;)
			end
		end


		if not string.find(tmp.inventory, &quot;shotgunShell&quot;) then
			conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; shotgunShell 500', &quot; .. chatvars.playerid .. &quot;)&quot;)
		else
			tmp.found, tmp.quantity, tmp.quality = getInventory(tmp.inventory, &quot;shotgunShell&quot;)

			if tonumber(tmp.quantity) &lt; 500 then
				conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; shotgunShell &quot; .. 500 - tonumber(tmp.quantity) .. &quot;', &quot; .. chatvars.playerid .. &quot;)&quot;)
			end
		end

		if not string.find(tmp.inventory .. tmp.equipment, &quot;miningHelmet&quot;) then
			conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; miningHelmet 1 600', &quot; .. chatvars.playerid .. &quot;)&quot;)
		else
			tmp.found, tmp.quality = getEquipment(tmp.equipment, &quot;miningHelmet&quot;)

			if not tmp.found then
				tmp.found, tmp.quantity, tmp.quality = getInventory(tmp.inventory, &quot;miningHelmet&quot;)
			end

			if tmp.found and tmp.quality &lt; 300 then
				conn:execute(&quot;INSERT into gimmeQueue (command, steam) VALUES ('give &quot; .. chatvars.playerid .. &quot; miningHelmet 1 600', &quot; .. chatvars.playerid .. &quot;)&quot;)
			end
		end

		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]SUPPLIES![-]&quot;)
		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 50&quot;) end

	if (chatvars.words[1] == &quot;release&quot; and chatvars.words[2] == &quot;here&quot; and chatvars.words[3] ~= nil) then	
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		prisoner = string.sub(chatvars.command, string.find(chatvars.command, &quot;: /release here &quot;) + 16)
		prisoner = string.trim(prisoner)
		prisonerid = LookupPlayer(prisoner)

		if (players[prisonerid].prisoner == false) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Citizen &quot; .. players[prisonerid].name .. &quot; is not a prisoner[-]&quot;)
			faultyChat = false
			return true
		end

		players[prisonerid].prisoner = false

		conn:execute(&quot;UPDATE players SET prisoner = 0 WHERE steam = &quot; .. prisonerid)

		message(&quot;say [&quot; .. server.chatColour .. &quot;]Releasing prisoner &quot; .. players[prisonerid].name .. &quot;[-]&quot;)

		if (players[prisonerid].steam) then
			message(&quot;pm &quot; .. prisonerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are released from prison.  Be a good citizen if you wish to remain free.[-]&quot;)
			cmd = &quot;tele &quot; .. prisonerid .. &quot; &quot; .. chatvars.playerid
			prepareTeleport(prisonerid, cmd)

			if players[prisonerid].watchPlayer then
				irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. chatvars.playerid .. &quot; &quot; .. chatvars.playername .. &quot; command &quot; .. chatvars.command  )
			end

			teleport(cmd, true)
			players[prisonerid].xPosOld = 0
			players[prisonerid].yPosOld = 0
			players[prisonerid].zPosOld = 0
			players[prisonerid].prisonxPosOld = 0
			players[prisonerid].prisonyPosOld = 0
			players[prisonerid].prisonzPosOld = 0
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin 51&quot;) end

	if (chatvars.words[1] == &quot;playerhome&quot; or chatvars.words[1] == &quot;playerbase&quot; or chatvars.words[1] == &quot;playerhome2&quot; or chatvars.words[1] == &quot;playerbase2&quot;) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		pname = string.sub(chatvars.command, string.find(chatvars.command, chatvars.words[1], nil, true) + string.len(chatvars.words[1]))
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if (pname == &quot;&quot;) then 
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A player name is required or could not be found for this command[-]&quot;)
			faultyChat = false
			return true
		else
			if (chatvars.words[1] == &quot;playerhome&quot; or chatvars.words[1] == &quot;playerbase&quot;) then
				if (players[id].homeX == 0 and players[id].homeZ == 0) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; Has not set a base yet.[-]&quot;)
					faultyChat = false
					return true
				else
					-- first record the current x y z
					players[chatvars.playerid].xPosOld = math.floor(igplayers[chatvars.playerid].xPos)
					players[chatvars.playerid].yPosOld = math.ceil(igplayers[chatvars.playerid].yPos)
					players[chatvars.playerid].zPosOld = math.floor(igplayers[chatvars.playerid].zPos)

					cmd = &quot;tele &quot; .. chatvars.playerid .. &quot; &quot; .. players[id].homeX .. &quot; &quot; .. players[id].homeY .. &quot; &quot; .. players[id].homeZ
					prepareTeleport(chatvars.playerid, cmd)
					teleport(cmd, true)
				end
			else
				if (players[id].home2X == 0 and players[id].home2Z == 0) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. pname .. &quot; Has not set a 2nd base yet.[-]&quot;)
					faultyChat = false
					return true
				else
					-- first record the current x y z
					players[chatvars.playerid].xPosOld = math.floor(igplayers[chatvars.playerid].xPos)
					players[chatvars.playerid].yPosOld = math.ceil(igplayers[chatvars.playerid].yPos)
					players[chatvars.playerid].zPosOld = math.floor(igplayers[chatvars.playerid].zPos)

					cmd = &quot;tele &quot; .. chatvars.playerid .. &quot; &quot; .. players[id].home2X .. &quot; &quot; .. players[id].home2Y .. &quot; &quot; .. players[id].home2Z
					prepareTeleport(chatvars.playerid, cmd)
					teleport(cmd, true)
				end
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;admin end&quot;) end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_fun</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
fun commands
=============
place bounty
bounty
beer
gimme peace
reset gimmehell
gimme reset
gimme gimme
gimme off
gimme on
suicide
santa
gimme
ragequit
gimmehell
--TODO add commands that annoy the dupers or anyone else who you've caught cheating
burn &lt;player&gt; burns the player once
trail &lt;player&gt; &lt;optional item&gt; every time their position changes spawn a shit or another item if specified
shits &lt;player&gt; give them the shits
mini horde &lt;player&gt; &lt;offset&gt; &lt;list of zeds&gt; dist &lt;distance&gt; dir &lt;direction&gt; (dist and dir are optional)
bees &lt;player&gt; &lt;number&gt;
stun &lt;player&gt;
coffee &lt;player&gt; (applies the coffee buff)
booze &lt;player&gt;

--]]

function gmsg_fun()
	calledFunction = &quot;gmsg_fun&quot;

	-- don't proceed if there is no leading slash
	if (string.sub(chatvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyChat = false
		return false
	end


	if (chatvars.words[1] == &quot;place&quot; and chatvars.words[2] == &quot;bounty&quot;) then
		pname = chatvars.words[3]
		id = LookupPlayer(pname)

		bounty = math.abs(chatvars.words[4])

		if players[chatvars.playerid].cash &gt;= bounty then
			oldBounty = players[id].pvpBounty
			players[id].pvpBounty = players[id].pvpBounty + bounty
			players[chatvars.playerid].cash = players[chatvars.playerid].cash - bounty
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[chatvars.playerid].name .. &quot; has placed a bounty of &quot; .. bounty .. &quot; on &quot; .. players[id].name .. &quot;'s head![-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You now have &quot; .. players[chatvars.playerid].cash .. &quot; zennies.[-]&quot;)

			-- update the player's bounty
			conn:execute(&quot;UPDATE players SET pvpBounty = &quot; .. players[id].pvpBounty .. &quot; WHERE steam = &quot; .. id)

			-- reduce the cash of the player who placed the bounty
			conn:execute(&quot;UPDATE players SET cash = &quot; .. players[chatvars.playerid].cash .. &quot; WHERE steam = &quot; .. chatvars.playerid)

			if oldBounty &gt; 0 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot;'s life is now worth &quot; .. players[id].pvpBounty .. &quot;.[-]&quot;)
			end
		else
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You do not have enough zennies to place that bounty.[-]&quot;)
		end

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;bounty&quot;) then
		id = chatvars.playerid

		if (chatvars.words[2] ~= nil) then
			pname = string.sub(chatvars.command, 9)
			id = LookupPlayer(pname)
		end

		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; has &quot; .. players[id].playerKills .. &quot; kills. Kill them for &quot; .. players[id].pvpBounty .. &quot; zennies.[-]&quot;)

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;haven&quot; and chatvars.words[2] ~= nil) then
		if type(brchat) ~= &quot;table&quot; then
		  brchat = {}
		end

		table.insert(brchat, { os.time(), &quot;BR-&quot; .. players[chatvars.playerid].name .. &quot;:&quot; .. string.sub(chatvars.command, string.find(chatvars.command, &quot;haven&quot;) + 6) } )

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;waiter&quot; or chatvars.words[1] == &quot;beer&quot; and chatvars.words[2] == nil) then
		if inLocation(chatvars.intX, chatvars.intZ) == &quot;library&quot; then
			send(&quot;give &quot; .. chatvars.playerid .. &quot; beer 1&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Enjoy your beer![-]&quot;)
		end

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;gimme&quot; and chatvars.words[2] == &quot;peace&quot;) then
		message(&quot;say [&quot; .. server.chatColour .. &quot;]Gimme has been silenced[-]&quot;)
		server.gimmePeace = true

		conn:execute(&quot;UPDATE server SET gimmePeace = 1&quot;)

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;reset&quot; and chatvars.words[2] == &quot;gimmehell&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is for admins only[-]&quot;)
				faultyChat = false
				return true
			end
		end

		if (chatvars.playername == &quot;Server&quot;) then 
			resetGimmeHell()

			faultyChat = false
			return true
		end

		dist = distancexyz(igplayers[chatvars.playerid].xPos, igplayers[chatvars.playerid].yPos, igplayers[chatvars.playerid].zPos, locations[&quot;arena&quot;].x, locations[&quot;arena&quot;].y, locations[&quot;arena&quot;].z)
		if (dist &lt; locations[&quot;arena&quot;].size + 5) or (chatvars.playername == &quot;Server&quot;) or (accessLevel(chatvars.playerid) &lt; 3) then
			resetGimmeHell()

			faultyChat = false
			return true
		end
	end


	if (chatvars.words[1] == &quot;gimme&quot; and chatvars.words[2] == &quot;reset&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is for admins only[-]&quot;)
				faultyChat = false
				return true
			end
		end

		gimmeReset()
		disableTrigger(&quot;gimmeReset&quot;)
		enableTigger(&quot;gimmeReset&quot;)

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;gimme&quot; and chatvars.words[2] == &quot;gimme&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end

		message(&quot;say [&quot; .. server.chatColour .. &quot;]Gimme messages are now public[-]&quot;)
		server.gimmePeace = false

		conn:execute(&quot;UPDATE server SET gimmePeace = 0&quot;)

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;gimme&quot; and chatvars.words[2] == &quot;off&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end

		message(&quot;say [&quot; .. server.chatColour .. &quot;]Gimme has been disabled[-]&quot;)
		server.allowGimme = false

		conn:execute(&quot;UPDATE server SET allowGimme = 0&quot;)

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;gimme&quot; and chatvars.words[2] == &quot;on&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end

		message(&quot;say [&quot; .. server.chatColour .. &quot;]Gimme has been enabled[-]&quot;)
		server.allowGimme = true

		conn:execute(&quot;UPDATE server SET allowGimme = 1&quot;)

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;suicide&quot;) then
		if players[chatvars.playerid].prisoner or players[chatvars.playerid].timeout == true or players[chatvars.playerid].botTimeout == true then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]BANG![-]&quot;)
		else
			if players[chatvars.playerid].lastSuicide ~= nil then
				if os.time() - players[chatvars.playerid].lastSuicide &lt; 180 then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&gt;CLICK!&lt;  Darn your gun jammed.  Try again in a few minutes.[-]&quot;)

					faultyChat = false
					return true
				end
			end

			send(&quot;kill &quot; .. chatvars.playerid)
			players[chatvars.playerid].lastSuicide = os.time()
		end

		faultyChat = false
		return true
	end


	-- ###################  do not allow remote commands beyond this point ################
	if (chatvars.playerid == nil) then
		faultyChat = false
		return false
	end
	-- ####################################################################################


	if (chatvars.words[1] == &quot;santa&quot; and specialDay == &quot;christmas&quot; and chatvars.words[2] == nil) then
		if (not players[chatvars.playerid].santa) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]HO HO HO  Merry Christmas!  Press e now, don't let the Grinch steal Christmas.[-]&quot;)
			send (&quot;give &quot; .. chatvars.playerid .. &quot; shades 1&quot;)
			send (&quot;give &quot; .. chatvars.playerid .. &quot; turd 1&quot;)	
			send (&quot;give &quot; .. chatvars.playerid .. &quot; beer 2&quot;)
			send (&quot;give &quot; .. chatvars.playerid .. &quot; coalOre 1&quot;)
			send (&quot;give &quot; .. chatvars.playerid .. &quot; pipeBomb 1&quot;)
			send (&quot;give &quot; .. chatvars.playerid .. &quot; splint 1&quot;)

			r = rand(2)
			if r == 1 then send (&quot;give &quot; .. chatvars.playerid .. &quot; firstAidBandage 1&quot;) end
			if r == 2 then send (&quot;give &quot; .. chatvars.playerid .. &quot; firstAidKit 1&quot;) end

			r = rand(2)
			if r == 1 then players[chatvars.playerid].tokens = tonumber(players[chatvars.playerid].tokens) + 1 end
			if r == 2 then players[chatvars.playerid].zennies = tonumber(players[chatvars.playerid].zennies) + 200 end

			r = rand(26)
			if r == 1 then send (&quot;give &quot; .. chatvars.playerid .. &quot; canBeef 1&quot;) end
			if r == 2 then send (&quot;give &quot; .. chatvars.playerid .. &quot; canBoiledWater 1&quot;) end
			if r == 3 then send (&quot;give &quot; .. chatvars.playerid .. &quot; canCatfood 1&quot;) end
			if r == 4 then send (&quot;give &quot; .. chatvars.playerid .. &quot; canChicken 1&quot;) end
			if r == 5 then send (&quot;give &quot; .. chatvars.playerid .. &quot; canChili 1&quot;) end
			if r == 6 then send (&quot;give &quot; .. chatvars.playerid .. &quot; candle 1&quot;) end 
			if r == 7 then send (&quot;give &quot; .. chatvars.playerid .. &quot; candleStick 1&quot;) end
			if r == 8 then send (&quot;give &quot; .. chatvars.playerid .. &quot; candleTable 1&quot;) end
			if r == 9 then send (&quot;give &quot; .. chatvars.playerid .. &quot; candleWall 1&quot;) end
			if r == 10 then send (&quot;give &quot; .. chatvars.playerid .. &quot; canDogfood 1&quot;) end
			if r == 11 then send (&quot;give &quot; .. chatvars.playerid .. &quot; candyTin 1&quot;) end
			if r == 12 then send (&quot;give &quot; .. chatvars.playerid .. &quot; canEmpty 1&quot;) end
			if r == 13 then send (&quot;give &quot; .. chatvars.playerid .. &quot; canHam 1&quot;) end
			if r == 14 then send (&quot;give &quot; .. chatvars.playerid .. &quot; canLamb 1&quot;) end
			if r == 15 then send (&quot;give &quot; .. chatvars.playerid .. &quot; canMiso 1&quot;) end
			if r == 16 then send (&quot;give &quot; .. chatvars.playerid .. &quot; canMurkyWater 1&quot;) end
			if r == 17 then send (&quot;give &quot; .. chatvars.playerid .. &quot; canPasta 1&quot;) end
			if r == 18 then send (&quot;give &quot; .. chatvars.playerid .. &quot; canPears 1&quot;) end
			if r == 19 then send (&quot;give &quot; .. chatvars.playerid .. &quot; canPeas 1&quot;) end
			if r == 20 then send (&quot;give &quot; .. chatvars.playerid .. &quot; canSalmon 1&quot;) end
			if r == 21 then send (&quot;give &quot; .. chatvars.playerid .. &quot; canSoup 1&quot;) end
			if r == 22 then send (&quot;give &quot; .. chatvars.playerid .. &quot; canStock 1&quot;) end
			if r == 23 then send (&quot;give &quot; .. chatvars.playerid .. &quot; canTuna 1&quot;) end
			if r == 24 then send (&quot;give &quot; .. chatvars.playerid .. &quot; gasCan 1&quot;) end
			if r == 25 then send (&quot;give &quot; .. chatvars.playerid .. &quot; gasCanSchematic 1&quot;) end
			if r == 26 then send (&quot;give &quot; .. chatvars.playerid .. &quot; mineCandyTin 1&quot;) end

			players[chatvars.playerid].santa = &quot;hohoho&quot;
		else
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]HO HO You have already received your stocking stuffer Ho.[-]&quot;)
		end

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;gimmie&quot; or chatvars.words[1] == &quot;gimme&quot;) and chatvars.words[2] == nil then
		if (server.allowGimme) then
			if (chatvars.playername ~= &quot;Server&quot;) then 
				if (accessLevel(chatvars.playerid) &gt; 1) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Gimme is now triggered by casino coins in the last slot of your belt and runs every 30 seconds. Remove the coins to stop playing gimme.[-]&quot;)
					faultyChat = false
					return true
				end
			end

			dist1 = distancexz(igplayers[chatvars.playerid].xPos, igplayers[chatvars.playerid].zPos, players[chatvars.playerid].homeX, players[chatvars.playerid].homeZ)
			dist2 = distancexz(igplayers[chatvars.playerid].xPos, igplayers[chatvars.playerid].zPos, players[chatvars.playerid].home2X, players[chatvars.playerid].home2Z)

			if (dist1 &lt; players[chatvars.playerid].protectSize) or (dist2 &lt; players[chatvars.playerid].protect2Size) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Gimme will not spawn any zeds while you are inside your base protection.[-]&quot;)
			end

			gimme(chatvars.playerid)
		else
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Sorry, an admin has disabled gimme =([-]&quot;)
		end

		faultyChat = false
		return true
	end


	if string.find(chatvars.words[1], &quot;quit&quot;) and chatvars.words[2] ==  nil then
		if string.find(chatvars.words[1], &quot;rage&quot;) and chatvars.words[2] ==  nil then
			send(&quot;kick &quot; .. chatvars.playerid .. &quot; RAAAAGE! xD&quot;)
		else
			r = rand(3)
			if r == 1 then send(&quot;kick &quot; .. chatvars.playerid .. &quot; High Five! xD&quot;) end
			if r == 2 then send(&quot;kick &quot; .. chatvars.playerid .. &quot; O.o  The Quit is strong in this one.&quot;) end
			if r == 3 then send(&quot;kick &quot; .. chatvars.playerid .. &quot; Nice quit    *removes glasses*    YEEEEEEEEAH!&quot;) end
		end

		r = rand(4)

		if r == 1 then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[chatvars.playerid].name .. &quot; has left the building.[-]&quot;)
		end

		if r == 2 then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[chatvars.playerid].name .. &quot; has left *SLAM!*[-]&quot;)
		end

		if r == 3 then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[chatvars.playerid].name .. &quot; &quot; .. chatvars.words[1] .. &quot;![-]&quot;)
		end

		if r == 4 then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[chatvars.playerid].name .. &quot; quit like a BOSS![-]&quot;)
		end

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;quit&quot;) then
		msg = string.sub(line, string.find(line, &quot;quit&quot;) + 5)

		if msg ~= nil then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[chatvars.playerid].name .. &quot; quit with this parting shot.. &quot; .. msg ..&quot;[-]&quot;)
		end

		send(&quot;kick &quot; .. chatvars.playerid .. &quot;\&quot;That'll learn em! xD\&quot;&quot;)

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;gimmehell&quot; and chatvars.words[2] == nil) then
		-- abort if not in arena

		dist = distancexyz(igplayers[chatvars.playerid].xPos, igplayers[chatvars.playerid].yPos, igplayers[chatvars.playerid].zPos, locations[&quot;arena&quot;].x, locations[&quot;arena&quot;].y, locations[&quot;arena&quot;].z)

		if (tonumber(dist) &gt; tonumber(locations[&quot;arena&quot;].size)) and (tonumber(dist) &lt; tonumber(locations[&quot;arena&quot;].size) + 5) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Nobody is in the arena.  You can't play from the spectator area.  Get in the arena coward.[-]&quot;)
			faultyChat = false
			return true
		end

		if (tonumber(dist) &gt; tonumber(locations[&quot;arena&quot;].size)) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command can only be issued in the arena[-]&quot;)
			faultyChat = false
			return true
		end

		if (gimmeHell == 0) then
			gimmeHell = 1

			setupArenaPlayers(chatvars.playerid)
			areaTimer1 = tempTimer( 5, [[ announceGimmeHell(1) ]] )
			areaTimer2 = tempTimer( 10, [[ queueGimmeHell(1) ]] )
			areaTimer3 = tempTimer( 60, [[ announceGimmeHell(2) ]] )
			areaTimer4 = tempTimer( 65, [[ queueGimmeHell(2) ]] )
			areaTimer5 = tempTimer( 120, [[ announceGimmeHell(3) ]] )
			areaTimer6 = tempTimer( 125, [[ queueGimmeHell(3) ]] )
			areaTimer7 = tempTimer( 180, [[ announceGimmeHell(4) ]] )
			areaTimer8 = tempTimer( 185, [[ queueGimmeHell(4) ]] )
			faultChat = false	
			return true
		else
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Wait until the current gimmehell is concluded. You can reset it with /reset gimmehell[-]&quot;)
			faultyChat = false
			return true
		end	
	end


	if chatvars.words[1] == &quot;doge&quot; and (chatvars.words[2] == &quot;on&quot; or chatvars.words[2] == &quot;mode&quot;) then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have activated doge mode.[-]&quot;)
		igplayers[chatvars.playerid].doge = true

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;doge&quot; and chatvars.words[2] == &quot;off&quot;) then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have de-activated doge mode.[-]&quot;)
		igplayers[chatvars.playerid].doge = false

		faultyChat = false
		return true
	end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_hotspots</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
hotspot commands
=============
man hotspots
resize hotspot
move hotspot
delete hotspots
delete hotspot
hotspot
hotspots
--]]

function removeInvalidHotspots(steam)
	local dist, size, delete

	-- abort if staff member
	if accessLevel(steam) &lt; 3 then
		return
	end

	cursor,errorString = conn:execute(&quot;select * from hotspots where owner = &quot; .. steam)
	row = cursor:fetch({}, &quot;a&quot;)

	while row do
		delete = true
		dist = distancexz(row.x, row.z, players[steam].homeX, players[steam].homeZ)
		size = tonumber(players[steam].protectSize)

		if (dist &lt; tonumber(size + 16)) then
			delete = false
		end

		if math.abs(players[steam].home2X) &gt; 0 and math.abs(players[steam].home2Z) &gt; 0 then
			dist = distancexz(row.x, row.z, players[steam].home2X, players[steam].home2Z)
			size = tonumber(players[steam].protect2Size)

			if (dist &lt; tonumber(size + 16)) then
				delete = false
			end
		end

		if delete then
			-- remove this hotspot
			hotspots[row.idx] = nil
			conn:execute(&quot;DELETE FROM hotspots WHERE idx = &quot; .. row.idx)
		end

		row = cursor:fetch(row, &quot;a&quot;)
	end
end


function gmsg_hotspots()
	calledFunction = &quot;gmsg_hotspots&quot;

	local idx, size, hotspotmsg, nextidx, debug

	debug = false
	size = nil

	-- don't proceed if there is no leading slash
	if (string.sub(chatvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyChat = false
		return false
	end


	-- ###################  do not allow remote commands beyond this point ################
	if (chatvars.playerid == nil) then
		faultyChat = false
		return false
	end
	-- ####################################################################################

if debug then dbug(&quot;debug hotspots&quot;) end

	if (chatvars.words[1] == &quot;man&quot; and chatvars.words[2] == &quot;hotspots&quot;) then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Hotspots are private messages triggered by proximity.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can set their size from 1 to 10 metres (default 2).[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]For command help type /help hotspots[-]&quot;)

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug hotspots 1&quot;) end

	if (chatvars.words[1] == &quot;resize&quot; and chatvars.words[2] == &quot;hotspot&quot; and chatvars.words[3] ~= nil) then
		if accessLevel(chatvars.playerid) == 99 then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]New players are not allowed to play with hotspots.[-]&quot;)
			faultyChat = false
			return true
		end

		if (chatvars.words[3] == nil) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Change a hotspot's radius to a max of 10 (unlimited for admins).[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]eg. /resize hotspot 3 size 5[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Type /hotspots for a list of your hotspots[-]&quot;)
			faultyChat = false
			return true	
		end

		idx = tonumber(chatvars.words[3])
		if idx == nil then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Number required for hotspot.[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]eg. /resize hotspot 3 size 5[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Type /hotspots for a list of your hotspots[-]&quot;)
			faultyChat = false
			return true
		end

	
		if chatvars.words[5] ~= nil then
			size = math.abs(tonumber(chatvars.words[5])) + 1

			if accessLevel(chatvars.playerid) &lt; 3 then
				if size == nil or size == 1 then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Number required for size greater than 0.[-]&quot;)
					faultyChat = false
					return true
				end
			else
				if size == nil or size &gt; 11 then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Number required for size in the range 1 to 10.[-]&quot;)
					faultyChat = false
					return true
				end

				size = math.floor(size) - 1
			end	
		end
				
		hotspots[idx].size = size
		conn:execute(&quot;UPDATE hotspots SET size = &quot; .. size .. &quot; WHERE idx = &quot; .. idx)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Hotspot: &quot; .. hotspots[idx].hotspot .. &quot; now covers &quot; .. size * 2 .. &quot; metres[-]&quot;)
		faultyChat = false
		return true	
	end

if debug then dbug(&quot;debug hotspots 2&quot;) end			

	if (chatvars.words[1] == &quot;move&quot; and chatvars.words[2] == &quot;hotspot&quot; and chatvars.words[3] ~= nil) then
		if accessLevel(chatvars.playerid) == 99 then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]New players are not allowed to play with hotspots.[-]&quot;)
			faultyChat = false
			return true
		end

		if (chatvars.number == nil) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Hotspot number required eg. /move hotspot 25.[-]&quot;)
			faultyChat = false
			return true
		end
		
		if accessLevel(chatvars.playerid) &gt; 2 then
			if not players[chatvars.playerid].atHome then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Your hotspots may be no further than &quot; .. tonumber(server.baseSize) + 15 .. &quot; metres from your first or second bot protected base.[-]&quot;)
				faultyChat = false
				return true			
			end
		end

		if accessLevel(chatvars.playerid) &lt; 4 then
			if hotspots[chatvars.number] then
				conn:execute(&quot;UPDATE hotspots SET x = &quot; .. chatvars.intX .. &quot;, y = &quot; .. chatvars.intY .. &quot;, z = &quot; .. chatvars.intZ .. &quot; WHERE idx = &quot; .. chatvars.number)
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You moved the hotspot: &quot; .. hotspots[chatvars.number].hotspot .. &quot;[-]&quot;)
				hotspots[chatvars.number].x = chatvars.intX
				hotspots[chatvars.number].y = chatvars.intY
				hotspots[chatvars.number].z = chatvars.intZ

				faultyChat = false
				return true
			else
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]There is no hotspot #&quot; .. chatvars.number .. &quot;.[-]&quot;)
				faultyChat = false
				return true
			end
		else
			cursor,errorString = conn:execute(&quot;select * from hotspots where idx = &quot; .. chatvars.number)
			rows = cursor:numrows()

			if rows &gt; 0 then
				row = cursor:fetch({}, &quot;a&quot;)
				if row.owner ~= chatvars.playerid then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You don't own this hotspot.[-]&quot;)
					faultyChat = false
					return true
				else
					if hotspots[chatvars.number] then
						conn:execute(&quot;UPDATE hotspots SET x = &quot; .. chatvars.intX .. &quot;, y = &quot; .. chatvars.intY .. &quot;, z = &quot; .. chatvars.intZ .. &quot; WHERE idx = &quot; .. chatvars.number)
						message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You moved the hotspot: &quot; .. hotspots[chatvars.number].hotspot .. &quot;[-]&quot;)
						hotspots[chatvars.number].x = chatvars.intX
						hotspots[chatvars.number].y = chatvars.intY
						hotspots[chatvars.number].z = chatvars.intZ

						faultyChat = false
						return true
					else
						message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]There is no hotspot #&quot; .. chatvars.number .. &quot;.[-]&quot;)
						faultyChat = false
						return true
					end
				end
			end
		end
	end

if debug then dbug(&quot;debug hotspots 3&quot;) end

	if (chatvars.words[1] == &quot;delete&quot; or chatvars.words[1] == &quot;remove&quot;) and chatvars.words[2] == &quot;hotspots&quot; then
		if accessLevel(chatvars.playerid) == 99 then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]New players are not allowed to play with hotspots.[-]&quot;)
			faultyChat = false
			return true
		end

		if accessLevel(chatvars.playerid) &lt; 3 then		
			pid = chatvars.playerid
		
			if chatvars.words[3] ~= nil then
				pid = string.sub(chatvars.command, string.find(chatvars.command, &quot;hotspots &quot;) + 10)
				pid = string.trim(pid)
				pid = LookupPlayer(pid)

				if (pid == nil) then 
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No player found with that name.[-]&quot;)
					faultyChat = false
					return true
				end
			end

			conn:execute(&quot;DELETE FROM hotspots WHERE owner = &quot; .. pid)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You deleted the hotspots belonging to &quot; .. players[pid].name .. &quot;[-]&quot;)
			-- reload the hotspots lua table
			loadHotspots()
		else
			conn:execute(&quot;DELETE FROM hotspots WHERE owner = &quot; .. chatvars.playerid)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Your hotspots have been deleted.[-]&quot;)
			-- reload the hotspots lua table
			loadHotspots()		
		end

		faultyChat = false
		return true
	end
	
if debug then dbug(&quot;debug hotspots 4&quot;) end

	if (chatvars.words[1] == &quot;delete&quot; and chatvars.words[2] == &quot;hotspot&quot;) then
		if accessLevel(chatvars.playerid) == 99 then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]New players are not allowed to play with hotspots.[-]&quot;)
			faultyChat = false
			return true
		end

		if chatvars.number == nil then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Hotspot number required eg. /hotspot delete 25.[-]&quot;)
			faultyChat = false
			return true
		end

		if accessLevel(chatvars.playerid) &lt; 3 then
			if hotspots[chatvars.number] then
				conn:execute(&quot;DELETE FROM hotspots WHERE idx = &quot; .. chatvars.number)
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You deleted the hotspot: &quot; .. hotspots[chatvars.number].hotspot .. &quot;[-]&quot;)
				hotspots[chatvars.number] = nil
			else
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]There is no hotspot #&quot; .. chatvars.number .. &quot;.[-]&quot;)
				faultyChat = false
				return true
			end
		else
			cursor,errorString = conn:execute(&quot;select * from hotspots where idx = &quot; .. chatvars.number)
			rows = cursor:numrows()

			if rows &gt; 0 then
				row = cursor:fetch({}, &quot;a&quot;)
				if row.owner ~= chatvars.playerid then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You don't own this hotspot.[-]&quot;)
					faultyChat = false
					return true
				else
					if hotspots[chatvars.number] then
						conn:execute(&quot;DELETE FROM hotspots WHERE idx = &quot; .. chatvars.number)
						message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You deleted the hotspot: &quot; .. hotspots[chatvars.number].hotspot .. &quot;[-]&quot;)
						hotspots[chatvars.number] = nil
					else
						message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]There is no hotspot #&quot; .. chatvars.number .. &quot;.[-]&quot;)
						faultyChat = false
						return true
					end
				end
			end
		end

		faultyChat = false
		return true
	end
		
if debug then dbug(&quot;debug hotspots 5&quot;) end

	if (chatvars.words[1] == &quot;hotspot&quot;) then
		if accessLevel(chatvars.playerid) == 99 then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]New players are not allowed to play with hotspots.[-]&quot;)
			faultyChat = false
			return true
		end

		if chatvars.words[2] == nil then
			faultyChat = help(&quot;hotspots&quot;)
			return true
		end

		if chatvars.words[3] == nil and chatvars.number ~= nil then
			if accessLevel(chatvars.playerid) &lt; 3 then
				-- teleport the admin to the coords of the numbered hotspot
				cursor,errorString = conn:execute(&quot;select * from hotspots where idx = &quot; .. chatvars.number)
				rows = cursor:numrows()

				if rows &gt; 0 then
					row = cursor:fetch({}, &quot;a&quot;)

					-- first record the players current position
					savePosition(chatvars.playerid)

					cmd = &quot;tele &quot; .. chatvars.playerid .. &quot; &quot; .. row.x .. &quot; &quot; .. row.y .. &quot; &quot; .. row.z
					prepareTeleport(chatvars.playerid, cmd)
					teleport(cmd, true)
				else
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]There is no hotspot #&quot; .. chatvars.number .. &quot;.[-]&quot;)
				end

				faultyChat = false
				return true
			else
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Only admins can teleport to a hotspot.[-]&quot;)
				faultyChat = false
				return true
			end
		end


		if (chatvars.number == nil) then
			if accessLevel(chatvars.playerid) &gt; 2 and not players[chatvars.playerid].atHome then			
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can only create hotspots in and around your base.[-]&quot;)
				faultyChat = false
				return true
			end

			hotspotmsg = string.sub(chatvars.command, string.find(chatvars.command, &quot;hotspot &quot;) + 8)
			hotspotmsg = string.trim(hotspotmsg)

			cursor,errorString = conn:execute(&quot;select max(idx) as max_idx from hotspots&quot;)
			row = cursor:fetch({}, &quot;a&quot;)

			if row.max_idx ~= nil then
				nextidx = tonumber(row.max_idx) + 1
			else
				nextidx = 1
			end

			hotspots[nextidx] = {}
			hotspots[nextidx].hotspot = hotspotmsg
			hotspots[nextidx].owner = chatvars.playerid
			hotspots[nextidx].size = 2
			hotspots[nextidx].x = chatvars.intX
			hotspots[nextidx].y = chatvars.intY
			hotspots[nextidx].z = chatvars.intZ

			conn:execute(&quot;INSERT INTO hotspots (idx, hotspot, x, y, z, owner) VALUES (&quot; .. nextidx .. &quot;,'&quot; .. escape(hotspotmsg) .. &quot;',&quot; .. chatvars.intX .. &quot;,&quot; .. chatvars.intY .. &quot;,&quot; .. chatvars.intZ .. &quot;,&quot; .. chatvars.playerid .. &quot;)&quot;)

			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You made a hotspot with the message &quot; .. hotspotmsg .. &quot;[-]&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug hotspots 6&quot;) end

	if (chatvars.words[1] == &quot;hotspots&quot;) then
		if accessLevel(chatvars.playerid) == 99 then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]New players are not allowed to play with hotspots.[-]&quot;)
			faultyChat = false
			return true
		end

		if (chatvars.number == nil) then
			if (accessLevel(chatvars.playerid) &lt; 3) then
				if chatvars.words[2] ~= nil then
					pid = string.sub(chatvars.command, string.find(chatvars.command, &quot;hotspots &quot;) + 10)
					pid = string.trim(pid)
					pid = LookupPlayer(pid)
				else
					chatvars.number = 20
				end
			else
				pid = chatvars.playerid
			end

			if (pid == nil and chatvars.number == nil) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No player found with that name.[-]&quot;)
				faultyChat = false
				return true
			end

			if (pid ~= nil) then 
				cursor,errorString = conn:execute(&quot;select * from hotspots where owner = &quot; .. pid)
				row = cursor:fetch({}, &quot;a&quot;)

				while row do
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]#&quot; .. row.idx .. &quot; &quot; .. row.hotspot .. &quot;[-]&quot;)
					row = cursor:fetch(row, &quot;a&quot;)
				end

				faultyChat = false
				return true
			end
		end

		if (chatvars.number ~= nil) then
			if (accessLevel(chatvars.playerid) &gt; 2) then
				chatvars.number = 20
				cursor,errorString = conn:execute(&quot;select * from hotspots where owner =  &quot; .. chatvars.playerid .. &quot; and abs(x - &quot; .. chatvars.intX .. &quot;) &lt;= &quot; .. chatvars.number .. &quot; and abs(y - &quot; .. chatvars.intY .. &quot;) &lt;= &quot; .. chatvars.number .. &quot; and abs(z - &quot; .. chatvars.intZ .. &quot;) &lt;= &quot; .. chatvars.number)
			else
				if (chatvars.number == nil) then chatvars.number = 20 end
				cursor,errorString = conn:execute(&quot;select * from hotspots where abs(x - &quot; .. chatvars.intX .. &quot;) &lt;= &quot; .. chatvars.number .. &quot; and abs(y - &quot; .. chatvars.intY .. &quot;) &lt;= &quot; .. chatvars.number .. &quot; and abs(z - &quot; .. chatvars.intZ .. &quot;) &lt;= &quot; .. chatvars.number)
			end

			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The following hotspots are within &quot; .. chatvars.number .. &quot; metres of you[-]&quot;)
			row = cursor:fetch({}, &quot;a&quot;)

			while row do
				if accessLevel(chatvars.playerid) &lt; 3 then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]#&quot; .. row.idx .. &quot; &quot; .. players[row.owner].name .. &quot; size &quot; .. row.size * 2 .. &quot;m &quot; .. row.hotspot .. &quot;[-]&quot;)
				else
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]#&quot; .. row.idx .. &quot; size &quot; .. row.size * 2 .. &quot;m &quot; .. row.hotspot .. &quot;[-]&quot;)
				end

				row = cursor:fetch(row, &quot;a&quot;)
			end

			faultyChat = false
			return true
		end
	end

if debug then dbug(&quot;debug hotspots end&quot;) end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_info</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
info commands
=============
uptime
whats new
where
info
help
commands
new players
fps
when/next reboot
--]]

function gmsg_info()
	calledFunction = &quot;gmsg_info&quot;

	local xdir, zdir, dist, x, z, diff, days, hours, minutes, result, tokens, time	, werds, word, cmd

	local debug
	debug = false

	-- don't proceed if there is no leading slash
	if (string.sub(chatvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyChat = false
		return false
	end

if debug then dbug(&quot;debug info 1&quot;) end

	result = false

	if (chatvars.words[1] == &quot;uptime&quot; and chatvars.words[2] == nil) then
			diff = os.difftime(os.time(), botStarted)
			days = math.floor(diff / 86400)

			if (days &gt; 0) then
				diff = diff - (days * 86400)
			end

			hours = math.floor(diff / 3600)

			if (hours &gt; 0) then
				diff = diff - (hours * 3600)
			end

			minutes = math.floor(diff / 60)

			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. server.botName .. &quot; has been online &quot; .. days .. &quot; days &quot; .. hours .. &quot; hours &quot; .. minutes ..&quot; minutes.[-]&quot;)

			if gameTick &lt; 0 then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Server uptime is unknown due to a server fault. Ask and admin to reboot the server.[-]&quot;)
			else
				diff = gameTick
				days = math.floor(diff / 86400)

				if (days &gt; 0) then
					diff = diff - (days * 86400)
				end

				hours = math.floor(diff / 3600)

				if (hours &gt; 0) then
					diff = diff - (hours * 3600)
				end

				minutes = math.floor(diff / 60)

				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Server uptime is &quot; .. days .. &quot; days &quot; .. hours .. &quot; hours &quot; .. minutes ..&quot; minutes.[-]&quot;)
			end

		faultyChat = false
		return true
	end 

if debug then dbug(&quot;debug info 2&quot;) end

	-- ###################  do not allow remote commands beyond this point ################
	if (chatvars.playerid == nil) then
		faultyChat = false
		return false
	end
	-- ####################################################################################

--	if chatvars.words[1] == &quot;whats&quot; and chatvars.words[2] == &quot;new&quot; then
--		conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,&quot; .. chatvars.playerid .. &quot;,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]This bot is being trialled here. Let us know if something doesn't work.[-]&quot;) .. &quot;')&quot;)
--		conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,&quot; .. chatvars.playerid .. &quot;,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]Many boring changes such as a new database (EXCITING!)[-]&quot;) .. &quot;')&quot;)
--		conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,&quot; .. chatvars.playerid .. &quot;,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]Teleporting has been altered yet again![-]&quot;) .. &quot;')&quot;)
--		conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,&quot; .. chatvars.playerid .. &quot;,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]More boring changes designed to make the bot more stable and better at its many jobs.[-]&quot;) .. &quot;')&quot;)
--		conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,&quot; .. chatvars.playerid .. &quot;,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]The bot will be released with all the codez on September 6th![-]&quot;) .. &quot;')&quot;)
--		conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (0,&quot; .. chatvars.playerid .. &quot;,'&quot; .. escape(&quot;[&quot; .. server.chatColour .. &quot;]Also the bot's website will be announced.[-]&quot;) .. &quot;')&quot;)
--		faultyChat = false
--		return true
--	end

if debug then dbug(&quot;debug info 3&quot;) end

	if chatvars.words[1] == &quot;where&quot; or chatvars.words[1] == &quot;whereami&quot; and chatvars.words[2] == nil then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are &quot; .. string.format(&quot;%.2f&quot;, (distancexz(chatvars.intX, chatvars.intZ,0,0) / 1000)) .. &quot; km from the center of the map.[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are at &quot; .. mapPosition(chatvars.playerid) .. &quot;[-]&quot;)

		if pvpZone(chatvars.intX, chatvars.intZ) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]PVP is allowed here.[-]&quot;)
		else
			if (server.gameType ~= &quot;pvp&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]PVE rules apply here. Do not kill players.[-]&quot;)
			end
		end

		if players[chatvars.playerid].inLocation ~= &quot;&quot; then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are in the location &quot; .. players[chatvars.playerid].inLocation .. &quot;[-]&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug info 4&quot;) end

	if string.find(chatvars.command, &quot;server&quot;) and (string.find(chatvars.command, &quot;favourite&quot;) or string.find(chatvars.command, &quot;favs&quot;) or string.find(chatvars.command, &quot;called&quot;) or string.find(chatvars.command, &quot;name&quot;) or string.find(chatvars.command, &quot; ip&quot;)) then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This server is &quot; .. server.ServerName .. &quot; &quot; .. server.IP .. &quot;:&quot; .. server.ServerPort .. &quot;[-]&quot;)
		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug info 5&quot;) end

	if (chatvars.words[1] == &quot;server&quot; or chatvars.words[1] == &quot;info&quot;) and chatvars.words[2] == nil then
		-- Server name
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This server is &quot; .. server.ServerName .. &quot; &quot; .. server.IP .. &quot;:&quot; .. server.ServerPort .. &quot;[-]&quot;)	

		if (server.gameType == &quot;pve&quot;) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is a PVE server.[-]&quot;) end
		if (server.gameType == &quot;pvp&quot;) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is a PVP server.[-]&quot;) end
		if (server.gameType == &quot;cre&quot;) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is a creative mode server.[-]&quot;) end

		-- day/night length
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A full day runs &quot; .. server.DayNightLength .. &quot; minutes[-]&quot;)

		-- drop on death
		if (server.DropOnDeath == 0) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You drop everything on death[-]&quot;) end
		if (server.DropOnDeath == 1) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You drop toolbelt on death[-]&quot;) end
		if (server.DropOnDeath == 2) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You drop backpack on death[-]&quot;) end
		if (server.DropOnDeath == 3) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You permanently lose everything on death[-]&quot;) end

		-- drop on quit
		if (server.DropOnQuit == 0) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You keep everything on quit[-]&quot;) end
		if (server.DropOnQuit == 1) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You drop everything on quit[-]&quot;) end
		if (server.DropOnQuit == 2) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You drop toolbelt only on quit[-]&quot;) end
		if (server.DropOnQuit == 3) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You drop backpack only on quit[-]&quot;) end

		-- land claim size
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Land claim size is &quot; .. server.LandClaimSize .. &quot; meters. Expiry 30 days[-]&quot;)

		-- block durability
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Block durability is &quot; .. server.BlockDurabilityModifier .. &quot;%[-]&quot;)

		-- loot abundance
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Loot abundance is &quot; .. server.LootAbundance .. &quot;%[-]&quot;)

		-- loot respawn
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Loot respawns after &quot; .. server.LootRespawnDays .. &quot; days[-]&quot;)

		-- zombies run
		if (server.ZombiesRun == 0) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Zombies run at night[-]&quot;) end
		if (server.ZombiesRun == 1) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Zombies never run[-]&quot;) end
		if (server.ZombiesRun == 2) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Zombies always run[-]&quot;) end

		-- zombie memory
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Zombie memory is &quot; .. server.EnemySenseMemory .. &quot; seconds[-]&quot;)

		-- map limit
		if players[chatvars.playerid].donor == true then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The world is limited to  &quot; .. (server.mapSize + 10000) / 1000 .. &quot; km from map center[-]&quot;)
		else
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The world is limited to  &quot; .. server.mapSize / 1000 .. &quot; km from map center[-]&quot;)
		end

		--message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]When the server is full, idle players are kicked after 15 minutes.[-]&quot;)
	
		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug info 6&quot;) end

	-- help
	if (chatvars.words[1] == &quot;help&quot;) then
		if chatvars.words[2] ~= nil then
			cmd = string.trim(string.sub(chatvars.command, 7))
		end

		help(cmd)

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;commands&quot;) then
		help(&quot;commands&quot;)
		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug info 7&quot;) end


	if (chatvars.words[1] == &quot;fps&quot; and chatvars.words[2] == nil) then
		cursor,errorString = conn:execute(&quot;SELECT * FROM performance  ORDER BY serverdate DESC Limit 0, 1&quot;)
		row = cursor:fetch({}, &quot;a&quot;)

		if row then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Server FPS: &quot; .. server.fps .. &quot; Players: &quot; .. row.players .. &quot; Zombies: &quot; .. row.zombies .. &quot; Entities: &quot; .. row.entities .. &quot; Heap: &quot; .. row.heap .. &quot; HeapMax: &quot; .. row.heapMax .. &quot;[-]&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug info 8&quot;) end

	if (chatvars.words[1] == &quot;server&quot; and (chatvars.words[2] == &quot;date&quot; or chatvars.words[2] == &quot;time&quot;)) and chatvars.words[3] == nil then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The server date is &quot; .. serverTime .. &quot;[-]&quot;)
		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug info 9&quot;) end

	if (chatvars.words[1] == &quot;server&quot; and (chatvars.words[2] == &quot;status&quot; or chatvars.words[2] == &quot;stats&quot;)) and chatvars.words[3] == nil then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]24 hour stats to now:[-]&quot;)

		cursor,errorString = conn:execute(&quot;SELECT COUNT(id) as number FROM events WHERE event LIKE '%pvp%' AND timestamp &gt; DATE_SUB(now(), INTERVAL 1 DAY)&quot;)
		row = cursor:fetch({}, &quot;a&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]PVPs: &quot; .. row.number .. &quot;[-]&quot;)

		cursor,errorString = conn:execute(&quot;SELECT COUNT(id) as number FROM events WHERE event LIKE '%timeout%' AND timestamp &gt; DATE_SUB(now(), INTERVAL 1 DAY)&quot;)
		row = cursor:fetch({}, &quot;a&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Timeouts: &quot; .. row.number .. &quot;[-]&quot;)

		cursor,errorString = conn:execute(&quot;SELECT COUNT(id) as number FROM events WHERE event LIKE '%arrest%' AND timestamp &gt; DATE_SUB(now(), INTERVAL 1 DAY)&quot;)
		row = cursor:fetch({}, &quot;a&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Arrests: &quot; .. row.number .. &quot;[-]&quot;)

		cursor,errorString = conn:execute(&quot;SELECT COUNT(id) as number FROM events WHERE event LIKE '%new%' AND timestamp &gt; DATE_SUB(now(), INTERVAL 1 DAY)&quot;)
		row = cursor:fetch({}, &quot;a&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]New players: &quot; .. row.number .. &quot;[-]&quot;)

		cursor,errorString = conn:execute(&quot;SELECT COUNT(id) as number FROM events WHERE event LIKE '%ban%' AND timestamp &gt; DATE_SUB(now(), INTERVAL 1 DAY)&quot;)
		row = cursor:fetch({}, &quot;a&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Bans: &quot; .. row.number .. &quot;[-]&quot;)

		cursor,errorString = conn:execute(&quot;SELECT MAX(players) as number FROM performance WHERE timestamp &gt; DATE_SUB(now(), INTERVAL 1 DAY)&quot;)
		row = cursor:fetch({}, &quot;a&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Most players online: &quot; .. row.number .. &quot;[-]&quot;)

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug info 10&quot;) end

	if (chatvars.words[1] == &quot;new&quot; and chatvars.words[2] == &quot;players&quot;) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end
		
		if chatvars.number == nil then 
			number = 86400 
		else
			number = chatvars.number * 86400
		end

		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]New players in the last &quot; .. math.floor(number / 86400) .. &quot; days:[-]&quot;)

		cursor,errorString = conn:execute(&quot;SELECT * FROM events where timestamp &gt;= '&quot; .. os.date('%Y-%m-%d %H:%M:%S', os.time() - number).. &quot;' and type = 'new player' order by timestamp desc&quot;)
		row = cursor:fetch({}, &quot;a&quot;)

		while row do
			msg = &quot;steam: &quot; .. row.steam .. &quot; id: &quot; .. string.format(&quot;%8d&quot;, players[row.steam].id) .. &quot; name: &quot; .. players[row.steam].name .. &quot; at [ &quot; .. players[row.steam].xPos .. &quot; &quot; .. players[row.steam].yPos .. &quot; &quot; .. players[row.steam].zPos .. &quot; ] &quot; .. players[row.steam].country
			msg = msg .. &quot; PVP &quot; .. players[row.steam].playerKills

			if (igplayers[row.steam]) then
				time = tonumber(players[row.steam].timeOnServer) + tonumber(igplayers[row.steam].sessionPlaytime)
			else
				time = tonumber(players[row.steam].timeOnServer)
			end

			hours = math.floor(time / 3600)

			if (hours &gt; 0) then
				time = time - (hours * 3600)
			end

			minutes = math.floor(time / 60)

			msg = msg .. &quot; Playtime &quot; .. hours .. &quot;h &quot; .. minutes .. &quot;m&quot;

			cursor2,errorString = conn:execute(&quot;SELECT * FROM bans WHERE steam =  &quot; .. row.steam)
			if cursor2:numrows() &gt; 0 then
				msg = msg .. &quot; BANNED&quot;
			end

			if players[row.steam].timeout == true then
				msg = msg .. &quot; TIMEOUT&quot;
			end

			if players[row.steam].country == &quot;CN&quot; or players[row.steam].country == &quot;HK&quot; then
				msg = msg .. &quot; Chinese&quot;
			end

			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. msg .. &quot;[-]&quot;)
		
			row = cursor:fetch(row, &quot;a&quot;)	
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug info 11&quot;) end

	if (chatvars.words[1] == &quot;status&quot;) then
		faultyChat = baseStatus(chatvars.command, chatvars.playerid)
		return true
	end

if debug then dbug(&quot;debug info 12&quot;) end

	if (chatvars.words[1] == &quot;tokens&quot; and chatvars.words[2] == nil) then
		if players[chatvars.playerid].tokens == nil then
			players[chatvars.playerid].tokens = 0
		end

		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have &quot; .. players[chatvars.playerid].tokens .. &quot; tokens remaining.[-]&quot;)

		if players[chatvars.playerid].tokens == 0 then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Tokens can be purchased from the shop.  They give you access to special features such as teleporting directly to a friend.[-]&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug info 13&quot;) end

	if string.find(chatvars.command, &quot;pvp&quot;) and (accessLevel(chatvars.playerid) == 99) and (chatvars.words[1] ~= &quot;help&quot;) then
		if (server.gameType == &quot;pvp&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is a PVP server.[-]&quot;)
		else
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is a PVE server.  No PVP except in PVP zones.  Read /help pvp for info.[-]&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug info 14&quot;) end

	if (chatvars.words[1] == &quot;rules&quot; and chatvars.words[2] == nil)  then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. server.rules ..&quot;[-]&quot;)
		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug info 15&quot;) end

	if (chatvars.words[1] == &quot;seen&quot;) then
		pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;seen &quot;) + 5)
		pname = string.trim(pname)

		id = LookupPlayer(pname)

		if (igplayers[id]) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]player &quot; .. players[id].name .. &quot; is playing right now.  Press TAB.[-]&quot;)	
			faultyChat = false
			return true
		end

		if (players[id]) then
			werds = {}
			for word in serverTime:gmatch(&quot;%w+&quot;) do table.insert(werds, word) end

			ryear = werds[1]
			rmonth = werds[2]
			rday = string.sub(werds[3], 1, 2)
			rhour = string.sub(werds[3], 4, 5)
			rmin = werds[4]
			rsec = werds[5]

			dateNow = {year=ryear, month=rmonth, day=rday, hour=rhour, min=rmin, sec=rsec}
			Now = os.time(dateNow)

			werds = {}
			for word in players[id].seen:gmatch(&quot;%w+&quot;) do table.insert(werds, word) end

			ryear = werds[1]
			rmonth = werds[2]
			rday = werds[3]
			rhour = werds[4]
			rmin = werds[5]
			rsec = 0

			dateSeen = {year=ryear, month=rmonth, day=rday, hour=rhour, min=rmin, sec=rsec}
			Seen = os.time(dateSeen)

			diff = os.difftime(Now, Seen)
			days = math.floor(diff / 86400)

			if (days &gt; 0) then
				diff = diff - (days * 86400)
			end

			hours = math.floor(diff / 3600)

			if (hours &gt; 0) then
				diff = diff - (hours * 3600)
			end

			minutes = math.floor(diff / 60)

			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; ..players[id].name .. &quot; was last seen &quot; .. days .. &quot; days &quot; .. hours .. &quot; hours &quot; .. minutes ..&quot; minutes ago[-]&quot;)	
		else
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Sorry I don't know a player called &quot; .. pname .. &quot;. Check your spelling.[-]&quot;)	
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug info 16&quot;) end

	if (chatvars.words[1] == &quot;who&quot; and chatvars.words[3] == nil) then	
		if not string.find(chatvars.oldLine, &quot; command 'pm&quot;) then
			if accessLevel(chatvars.playerid) &gt; 2 and not server.coppi then
 				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Who now requires grass in slot 8 of your belt.  You do not use the who command in chat anymore.[-]&quot;)
				faultyChat = false
				return true
			end
		end

		alone = true

		if (chatvars.number == nil) then chatvars.number = 500 end

		if (accessLevel(chatvars.playerid) &gt; 2) then
			chatvars.number = 300
		end

		if (accessLevel(chatvars.playerid) &gt; 10) then
			chatvars.number = 200
		end

		x = math.floor(igplayers[chatvars.playerid].xPos / 512)
		z = math.floor(igplayers[chatvars.playerid].zPos / 512)

		if (tonumber(chatvars.intX) &lt; 0) then xdir = &quot; west &quot; else xdir = &quot; east &quot; end
		if (tonumber(chatvars.intZ) &lt; 0) then zdir = &quot; south&quot; else zdir = &quot; north&quot; end
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are at &quot; .. chatvars.intX .. xdir .. chatvars.intZ .. zdir .. &quot; at a height of &quot; .. chatvars.intY .. &quot;[-]&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are in region r.&quot; .. x .. &quot;.&quot; .. z .. &quot;.7rg[-]&quot;)

		if (pvpZone(chatvars.intX, chatvars.intZ) == false) or (server.gameType ~= &quot;pvp&quot;) then
			for k, v in pairs(igplayers) do
				dist = distancexz(chatvars.intX, chatvars.intZ, v.xPos, v.zPos)

				if dist &lt;= tonumber(chatvars.number) then
					if (v.steam ~= chatvars.playerid) then
						if (alone == true) then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]players within &quot; .. chatvars.number .. &quot; meters of you are:[-]&quot;) end

						if (accessLevel(chatvars.playerid) &lt; 4) then
							x = math.floor(v.xPos / 512)
							z = math.floor(v.zPos / 512)

							message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot; distance: &quot; .. string.format(&quot;%d&quot;, dist) .. &quot; region r.&quot; .. x .. &quot;.&quot; .. z .. &quot;.7rg[-]&quot;)
						else
							if (players[chatvars.playerid].watchPlayer == true) and accessLevel(v.steam) &gt; 2 then
								message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot;[-]&quot;)
							end

							if (players[chatvars.playerid].watchPlayer == false) then
								message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot;[-]&quot;)
							end
						end
						alone = false
					end
				end
			end

			if alone then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Nobody is within &quot; .. chatvars.number .. &quot; meters of you.[-]&quot;)
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug info 17&quot;) end

	if (chatvars.words[1] == &quot;alert&quot;) then
		if (chatvars.words[2] == nil) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Please include a message eg /alert Claimed shop here![-]&quot;)
			faultyChat = false
			return true
		end

		command = string.sub(chatvars.command, string.find(chatvars.command, &quot;alert &quot;) + 6)
		cecho(&quot;alerts&quot;, &quot;***** &quot; .. chatvars.playername .. &quot; at position &quot; .. chatvars.intX .. &quot; &quot; .. chatvars.intY .. &quot; &quot; .. chatvars.intZ .. &quot; said: &quot; .. command .. &quot;\n&quot;)
		sendIrc(server.ircAlerts, &quot;***** &quot; .. chatvars.playername .. &quot; at position &quot; .. chatvars.intX .. &quot; &quot; .. chatvars.intY .. &quot; &quot; .. chatvars.intZ .. &quot; said: &quot; .. command .. &quot;\n&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Thank you! Your message has been recorded! =D[-]&quot;)

		conn:execute(&quot;INSERT INTO alerts (steam, x, y, z, message) VALUES (&quot; .. chatvars.playerid .. &quot;,&quot; .. chatvars.intX .. &quot;,&quot; .. chatvars.intY .. &quot;,&quot; .. chatvars.intZ .. &quot;,'&quot; .. command .. &quot;')&quot;)

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug info 18&quot;) end

	if (chatvars.words[1] == &quot;info&quot; and chatvars.words[2] ~= nil) then		
		pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;info&quot;) + 5)
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if accessLevel(chatvars.playerid) &gt; 2 then
			if chatvars.playerid ~= id then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You may only view your own info.[-]&quot;)
				faultyChat = false
				return true
			end
		end

		if (id ~= nil) then
			if (igplayers[id]) then
				time = tonumber(players[id].timeOnServer) + tonumber(igplayers[id].sessionPlaytime)
			else
				time = tonumber(players[id].timeOnServer)
			end

			days = math.floor(time / 86400)

			if (days &gt; 0) then
				time = time - (days * 86400)
			end

			hours = math.floor(time / 3600)

			if (hours &gt; 0) then
				time = time - (hours * 3600)
			end

			minutes = math.floor(time / 60)
			time = time - (minutes * 60)

			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Info for player &quot; .. players[id].name .. &quot;[-]&quot;)
			if players[id].newPlayer == true then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A new player.[-]&quot;) end
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Steam: &quot; .. id .. &quot; ID: &quot; .. players[id].id .. &quot;[-]&quot;)
			if players[id].firstSeen ~= nil then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]First seen: &quot; .. os.date(&quot;%Y-%m-%d %H:%M:%S&quot;, players[id].firstSeen) .. &quot;[-]&quot;) end
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Total time played: &quot; .. days .. &quot; days &quot; .. hours .. &quot; hours &quot; .. minutes .. &quot; minutes &quot; .. time .. &quot; seconds[-]&quot;)

			werds = {}
			for word in serverTime:gmatch(&quot;%w+&quot;) do table.insert(werds, word) end

			ryear = werds[1]
			rmonth = werds[2]
			rday = string.sub(werds[3], 1, 2)
			rhour = string.sub(werds[3], 4, 5)
			rmin = werds[4]
			rsec = werds[5]

			dateNow = {year=ryear, month=rmonth, day=rday, hour=rhour, min=rmin, sec=rsec}
			Now = os.time(dateNow)
		
			werds = {}
			for word in players[id].seen:gmatch(&quot;%w+&quot;) do table.insert(werds, word) end

			ryear = werds[1]
			rmonth = werds[2]
			rday = string.sub(werds[3], 1, 2)
			rhour = string.sub(werds[3], 4, 5)
			rmin = werds[4]
			rsec = werds[5]

			dateSeen = {year=ryear, month=rmonth, day=rday, hour=rhour, min=rmin, sec=rsec}
			Seen = os.time(dateSeen)

			diff = os.difftime(Now, Seen)
			days = math.floor(diff / 86400)

			if (days &gt; 0) then
				diff = diff - (days * 86400)
			end

			hours = math.floor(diff / 3600)

			if (hours &gt; 0) then
				diff = diff - (hours * 3600)
			end

			minutes = math.floor(diff / 60)

			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; ..players[id].name .. &quot; was last seen &quot; .. days .. &quot; days &quot; .. hours .. &quot; hours &quot; .. minutes ..&quot; minutes ago[-]&quot;)			
					
			if players[id].timeout then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Is in timeout[-]&quot;) end
			if players[id].prisoner then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Is a prisoner[-]&quot;)
				if players[id].prisonReason ~= nil then message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Reason Arrested: &quot; .. players[id].prisonReason .. &quot;[-]&quot;) end
			end
			
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Keystones placed &quot; .. players[id].keystones .. &quot;[-]&quot;)

			if server.allowBank then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Zennies &quot; .. players[id].cash .. &quot;[-]&quot;)
			end

			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Current Session &quot; .. players[id].sessionCount .. &quot;[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]IP &quot; .. players[id].ip .. &quot;[-]&quot;)

			if players[id].donor then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Is a donor[-]&quot;)
			else
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Is not a donor[-]&quot;)
			end
			
			cursor,errorString = conn:execute(&quot;SELECT * FROM bans WHERE steam =  &quot; .. id)
			if cursor:numrows() &gt; 0 then
				row = cursor:fetch({}, &quot;a&quot;)
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]BANNED until &quot; .. row.BannedTo .. &quot; &quot; .. row.Reason .. &quot;[-]&quot;)
			end


		else	
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Player name required or no match found.[-]&quot;)	
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug info 19&quot;) end

	if (chatvars.words[1] == &quot;when&quot; or chatvars.words[1] == &quot;next&quot;) and chatvars.words[2] == &quot;reboot&quot; then		
		nextReboot()

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug info end&quot;) end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_trial_code</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


-- trial code goes here.  These commands are not accessible to players until moved to other sections.

function gmsg_trial_code()
	calledFunction = &quot;gmsg_trial_code&quot;

	-- don't proceed if there is no leading slash
	if (string.sub(chatvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyChat = false
		return false
	end


	-- ###################  do not allow remote commands beyond this point ################
	if (chatvars.playerid == nil) then
		faultyChat = false
		return false
	end
	-- ####################################################################################

	-- ###################  Staff only beyond this point ################
	-- Don't proceed if this is a player.  Server and staff only here.
	if (chatvars.playername ~= &quot;Server&quot;) then 
		if (accessLevel(chatvars.playerid) &gt; 2) then
			faultyChat = false
			return false
		end
	end
	-- ##################################################################

	if (chatvars.words[1] == &quot;test&quot; and chatvars.words[2] == &quot;test&quot; and accessLevel(chatvars.playerid) == 0) then
		-- add a command to test here.  restricted to server owners.

		if locations[&quot;lobby&quot;] then
			cursor,errorString = conn:execute(&quot;select * from locationSpawns where location='lobby'&quot;)
			if cursor:numrows() &gt; 0 then
				randomPVPTP(chatvars.playerid, &quot;lobby&quot;)
			else
				cmd = &quot;tele &quot; .. chatvars.playerid .. &quot; &quot; .. locations[&quot;lobby&quot;].x .. &quot; &quot; .. locations[&quot;lobby&quot;].y .. &quot; &quot; .. locations[&quot;lobby&quot;].z
				prepareTeleport(chatvars.playerid, cmd)
				teleport(cmd, true)
			end
		end
	end


	if (chatvars.words[1] == &quot;most&quot; and chatvars.words[2] == &quot;wanted&quot;) or chatvars.words[1] == &quot;bounty&quot; then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The top 10 payers with a bounty on their heads are:[-]&quot;)

		for k, v in pairs(top10) do
			--message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;] &quot; .. v.name .. &quot; $&quot; .. v.bounty .. &quot;[-]&quot;)
		end

		faultyChat = false
		return true
	end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_locations</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
location commands
=================
location clear
location remove
location pvp/pve
location enable
location disable
location private
location public
lobby
location owner
location set reset
location clear reset
location allow base
location disallow base
location size
location access
location add
protect location
unprotect location
location move
locations
location ends here
location random
location &lt;name&gt;
--]]

function gmsg_locations()
	calledFunction = &quot;gmsg_locations&quot;

	local debug, temp
	debug = false

	local loc, locationName, locationName, id, pname, active

	-- don't proceed if there is no leading slash
	if (string.sub(chatvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyChat = false
		return false
	end

if debug then dbug(&quot;debug locations 1&quot;) end

	if chatvars.words[1] == &quot;location&quot; and string.find(chatvars.command, &quot;clear&quot;) and chatvars.words[3] ~= &quot;reset&quot; then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end
		
		locationName = &quot;&quot;
		locationName = string.sub(chatvars.command, string.find(chatvars.command, &quot;location &quot;) + 9, string.find(chatvars.command, &quot;clear&quot;) - 2)
		locationName = string.trim(locationName)			
		loc = LookupLocation(locationName)

		if loc ~= nil then
			conn:execute(&quot;DELETE FROM locationSpawns WHERE location = '&quot; .. escape(loc) .. &quot;'&quot;)
			
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Location &quot; .. locationName .. &quot;'s teleports have been deleted.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Location &quot; .. locationName .. &quot;'s teleports have been deleted.&quot;)
			end			
		else
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;That location does not exist.&quot;)
			end					
		end

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;location&quot; and chatvars.words[2] == &quot;remove&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end

		locationName = &quot;&quot;
		locationName = string.sub(chatvars.command, string.find(chatvars.command, &quot;remove &quot;) + 7)
		locationName = string.trim(locationName)
		loc = LookupLocation(locationName)

		if locationName == string.lower(&quot;prison&quot;) and server.gameType ~= &quot;pvp&quot; then
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The server needs a prison.  PVPs will be temp-banned instead.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;The server needs a prison.  PVPs will be temp-banned instead.&quot;)
			end			
		end 

		if (loc == nil) then 
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;That location does not exist.&quot;)
			end			
		else	
			locations[loc] = nil
			conn:execute(&quot;DELETE FROM locations WHERE name = '&quot; .. locationName .. &quot;'&quot;)

			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You removed a location called &quot; .. locationName .. &quot;.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;You removed a location called &quot; .. locationName)
			end			
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug locations 2&quot;) end

	if chatvars.words[1] == &quot;location&quot; and (string.find(chatvars.command, &quot;pvp&quot;) or string.find(chatvars.command, &quot;pve&quot;)) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end
		
		locationName = &quot;&quot;
		locationName = string.sub(chatvars.command, string.find(chatvars.command, &quot;location &quot;) + 9, string.find(chatvars.command, &quot; pv&quot;) - 1)
		locationName = string.trim(locationName)	
		loc = LookupLocation(locationName)

		if loc ~= nil then
			if string.find(chatvars.command, &quot;pve&quot;) then
				locations[loc].pvp = false
				conn:execute(&quot;UPDATE locations set pvp = false WHERE name = '&quot; .. escape(locationName) .. &quot;'&quot;)
				message(&quot;say [&quot; .. server.chatColour .. &quot;]The location &quot; .. locations[loc].name .. &quot; is now a PVE zone.[-]&quot;)

				if (chatvars.playername ~= &quot;Server&quot;) then 
					irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;The location &quot; .. locations[loc].name .. &quot; is now a PVE zone.&quot;)
				end	
			else
				locations[loc].pvp = true
				conn:execute(&quot;UPDATE locations set pvp = true WHERE name = '&quot; .. escape(locationName) .. &quot;'&quot;)
				message(&quot;say [&quot; .. server.chatColour .. &quot;]The location &quot; .. locations[loc].name .. &quot; is now a PVP zone![-]&quot;)		

				if (chatvars.playername ~= &quot;Server&quot;) then 
					irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;The location &quot; .. locations[loc].name .. &quot; is now a PVP zone.&quot;)
				end	
			end			
		else
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;That location does not exist.&quot;)
			end	
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug locations 3&quot;) end

	if (chatvars.words[1] == &quot;location&quot; and chatvars.words[2] == &quot;enable&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end

		locationName = string.sub(chatvars.command, string.find(chatvars.command, &quot;enable &quot;) + 7)
		locationName = string.trim(locationName)
		loc = LookupLocation(locationName)

		if (loc == nil) then 
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;That location does not exist.&quot;)
			end	
		else	
			locations[loc].active = true
			conn:execute(&quot;UPDATE locations set active = true WHERE name = '&quot; .. escape(locationName) .. &quot;'&quot;)

			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The location called &quot; .. locationName .. &quot; is now enabled.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;The location called &quot; .. locationName .. &quot; is now enabled.&quot;)
			end	
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug locations 4&quot;) end

	if (chatvars.words[1] == &quot;location&quot; and chatvars.words[2] == &quot;disable&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end

		locationName = string.sub(chatvars.command, string.find(chatvars.command, &quot;disable &quot;) + 8)
		locationName = string.trim(locationName)
		loc = LookupLocation(locationName)

		if (loc == nil) then 
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;That location does not exist.&quot;)
			end	
		else	
			locations[loc].active = false
			conn:execute(&quot;UPDATE locations set active = false WHERE name = '&quot; .. escape(locationName) .. &quot;'&quot;)

			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The location called &quot; .. locationName .. &quot; is now disabled.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;The location called &quot; .. locationName .. &quot; is now disabled.&quot;)
			end	
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug locations 5&quot;) end

	if (chatvars.words[1] == &quot;location&quot; and chatvars.words[2] == &quot;private&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end

		locationName = string.sub(chatvars.command, string.find(chatvars.command, &quot;private &quot;) + 8)
		locationName = string.trim(locationName)
		loc = LookupLocation(locationName)

		if (loc == nil) then 
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;That location does not exist.&quot;)
			end	
		else	
			locations[loc].public = false
			conn:execute(&quot;UPDATE locations set public = false WHERE name = '&quot; .. escape(locationName) .. &quot;'&quot;)

			message(&quot;say [&quot; .. server.chatColour .. &quot;]The location called &quot; .. locationName .. &quot; is now private[-]&quot;)

			if (chatvars.playername ~= &quot;Server&quot;) then 
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;The location called &quot; .. locationName .. &quot; is now private.&quot;)
			end	
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug locations 6&quot;) end

	if (chatvars.words[1] == &quot;location&quot; and chatvars.words[2] == &quot;public&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end

		locationName = &quot;&quot;
		locationName = string.sub(chatvars.command, string.find(chatvars.command, &quot;public &quot;) + 7)
		locationName = string.trim(locationName)
		loc = LookupLocation(locationName)

		if (loc == nil) then 
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;That location does not exist.&quot;)
			end	
		else	
			locations[loc].public = true
			conn:execute(&quot;UPDATE locations set public = true WHERE name = '&quot; .. locationName .. &quot;'&quot;)

			message(&quot;say [&quot; .. server.chatColour .. &quot;]The location called &quot; .. locationName .. &quot; is now public[-]&quot;)

			if (chatvars.playername ~= &quot;Server&quot;) then 
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;The location called &quot; .. locationName .. &quot; is now public.&quot;)
			end	
		end

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;location&quot; and chatvars.words[2] == &quot;set&quot; and chatvars.words[3] == &quot;reset&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end

		locationName = &quot;&quot;
		locationName = string.sub(chatvars.command, string.find(chatvars.command, &quot;reset &quot;) + 6)
		locationName = string.trim(locationName)

		loc = LookupLocation(locationName)

		if (loc == nil) then 
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;That location does not exist.&quot;)
			end	
		else	
			locations[loc].resetZone = true
			conn:execute(&quot;UPDATE locations set resetZone = true WHERE name = '&quot; .. locationName .. &quot;'&quot;)

			message(&quot;say [&quot; .. server.chatColour .. &quot;]The location called &quot; .. locationName .. &quot; is now a reset zone[-]&quot;)

			if (chatvars.playername ~= &quot;Server&quot;) then 
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;The location called &quot; .. locationName .. &quot; is now a reset zone.&quot;)
			end	
		end

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;location&quot; and chatvars.words[2] == &quot;clear&quot; and chatvars.words[3] == &quot;reset&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end

		locationName = &quot;&quot;
		locationName = string.sub(chatvars.command, string.find(chatvars.command, &quot;reset &quot;) + 6)
		locationName = string.trim(locationName)

		loc = LookupLocation(locationName)

		if (loc == nil) then 
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;That location does not exist.&quot;)
			end	
		else	
			locations[loc].resetZone = false
			conn:execute(&quot;UPDATE locations set resetZone = false WHERE name = '&quot; .. locationName .. &quot;'&quot;)

			message(&quot;say [&quot; .. server.chatColour .. &quot;]The location called &quot; .. locationName .. &quot; is no longer a reset zone[-]&quot;)

			if (chatvars.playername ~= &quot;Server&quot;) then 
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;The location called &quot; .. locationName .. &quot; is no longer a reset zone.&quot;)
			end	
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug locations 7&quot;) end

	if (chatvars.words[1] == &quot;lobby&quot; and chatvars.words[2] ~= nil) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end

		pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;lobby &quot;) + 6)
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if (id ~= nil) then
			-- if the player is ingame, send them to the lobby otherwise flag it to happen when they rejoin
			if (igplayers[id]) then
				cmd = &quot;tele &quot; .. id .. &quot; &quot; .. locations[&quot;spawnpoint1&quot;].x .. &quot; &quot; .. locations[&quot;spawnpoint1&quot;].y .. &quot; &quot; .. locations[&quot;spawnpoint1&quot;].z
				teleport(cmd)

				if (chatvars.playername ~= &quot;Server&quot;) then 
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Player &quot; .. players[id].name .. &quot; has been sent to the lobby.[-]&quot;)
				else
					irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Player &quot; .. players[id].name .. &quot; has been sent to the lobby.&quot;)
				end	
			else
				players[id].lobby = true
				conn:execute(&quot;UPDATE players set location = 'lobby' WHERE steam = &quot; .. id)

				if (chatvars.playername ~= &quot;Server&quot;) then 
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; will spawn in the lobby next time they connect to the server.[-]&quot;)
				else
					irc_QueueMsg(players[chatvars.ircid].ircAlias, players[id].name .. &quot; will spawn in the lobby next time they connect to the server.&quot;)
				end	
			end
		else
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No player matched that name.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;No player matched that name.&quot;)
			end	
		end
		
		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug locations 8&quot;) end

	if (chatvars.words[1] == &quot;location&quot; and chatvars.words[3] == &quot;owner&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end

		id = LookupPlayer(chatvars.words[4]) 
		if (players[id]) then
			pname = players[id].name
		else
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No player matched that name.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;No player matched that name.&quot;)
			end	

			faultyChat = false
			return true
		end

		loc = string.trim(chatvars.words[2])
		loc = LookupLocation(loc)

		if (loc ~= nil) then
			locations[loc].owner = id
			conn:execute(&quot;UPDATE locations set owner = &quot; .. id .. &quot; WHERE name = '&quot; .. escape(loc) .. &quot;'&quot;)
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; is the proud new owner of the location called &quot; .. loc .. &quot;[-]&quot;)
		else
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;That location does not exist.&quot;)
			end	
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug locations 9&quot;) end

	if (chatvars.words[1] == &quot;location&quot; and chatvars.words[2] == &quot;allow&quot; and chatvars.words[3] == &quot;base&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end

		locationName = string.sub(chatvars.command, string.find(chatvars.command, &quot;base &quot;) + 5)
		locationName = string.trim(locationName)
		loc = LookupLocation(locationName)

		if (loc == nil) then 
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;That location does not exist.&quot;)
			end	
		else	
			locations[loc].allowBase = true
			conn:execute(&quot;UPDATE locations SET allowBase = true WHERE name = '&quot; .. escape(locationName) .. &quot;'&quot;)

			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Players may setbase in &quot; .. locationName .. &quot;.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Players may setbase in &quot; .. locationName .. &quot;.&quot;)
			end	
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug locations 10&quot;) end

	if (chatvars.words[1] == &quot;location&quot; and chatvars.words[2] == &quot;disallow&quot; and chatvars.words[3] == &quot;base&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end

		locationName = string.sub(chatvars.command, string.find(chatvars.command, &quot;base &quot;) + 5)
		locationName = string.trim(locationName)
		loc = LookupLocation(locationName)

		if (loc == nil) then 
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;That location does not exist.&quot;)
			end	
		else	
			locations[loc].allowBase = true
			conn:execute(&quot;UPDATE locations SET allowBase = false WHERE name = '&quot; .. escape(locationName) .. &quot;'&quot;)

			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Players may not setbase in &quot; .. locationName .. &quot;.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Players may not setbase in &quot; .. locationName .. &quot;.&quot;)
			end	
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug locations 11&quot;) end

	if chatvars.words[1] == &quot;location&quot; and string.find(chatvars.command, &quot;access&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end
		
		locationName = string.sub(chatvars.command, string.find(chatvars.command, &quot;location &quot;) + 9, string.find(chatvars.command, &quot;access&quot;) - 2)
		locationName = string.trim(locationName)	
		loc = LookupLocation(locationName)

		if chatvars.number ~= nil and loc ~= nil then
			locations[loc].accessLevel = math.floor(tonumber(chatvars.number))
			conn:execute(&quot;UPDATE locations set accessLevel = &quot; .. math.floor(tonumber(chatvars.number)) .. &quot; WHERE name = '&quot; .. escape(locationName) .. &quot;'&quot;)

			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The location &quot; .. locationName .. &quot; is restricted to players with access level &quot; .. locations[loc].accessLevel .. &quot; and above.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;The location &quot; .. locationName .. &quot; is restricted to players with access level &quot; .. locations[loc].accessLevel .. &quot; and above.&quot;)
			end	
		end

		if loc == nil then
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;That location does not exist.&quot;)
			end	
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug locations 12&quot;) end

	if chatvars.words[1] == &quot;location&quot; and string.find(chatvars.command, &quot;size&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end
		
		locationName = string.sub(chatvars.command, string.find(chatvars.command, &quot;location &quot;) + 9, string.find(chatvars.command, &quot;size&quot;) - 2)
		locationName = string.trim(locationName)			
		loc = LookupLocation(locationName)

		if chatvars.number ~= nil and loc ~= nil then
			locations[locationName].size = math.floor(tonumber(chatvars.number))
			conn:execute(&quot;UPDATE locations set size = &quot; .. math.floor(tonumber(chatvars.number)) .. &quot;, protectSize = &quot; .. math.floor(tonumber(chatvars.number)) .. &quot; WHERE name = '&quot; .. locationName .. &quot;'&quot;)

			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The location &quot; .. locations[loc].name .. &quot; now spans &quot; .. tonumber(chatvars.number * 2) .. &quot; metres.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;The location &quot; .. locations[loc].name .. &quot; now spans &quot; .. tonumber(chatvars.number * 2) .. &quot; metres.&quot;)
			end	

			if loc == string.lower(&quot;prison&quot;) then
				server.prisonSize = math.floor(tonumber(chatvars.number))
				conn:execute(&quot;UPDATE server SET prisonSize = &quot; .. math.floor(tonumber(chatvars.number)))
			end
		end

		if loc == nil then
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;That location does not exist.&quot;)
			end	
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug locations 13&quot;) end

	if (chatvars.words[1] == &quot;location&quot; and chatvars.words[2] == &quot;safe&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end

		locationName = string.sub(chatvars.command, string.find(chatvars.command, &quot;safe &quot;) + 5)
		locationName = string.trim(locationName)
		loc = LookupLocation(locationName)

		if (loc == nil) then 
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;That location does not exist.&quot;)
			end	
		else	
			locations[loc].killZombies = true
			scanZombies = true
			conn:execute(&quot;UPDATE locations set killZombies = true WHERE name = '&quot; .. escape(locationName) .. &quot;'&quot;)

			message(&quot;say [&quot; .. server.chatColour .. &quot;]The location called &quot; .. locationName .. &quot; is now a safezone.[-]&quot;)

			if (chatvars.playername ~= &quot;Server&quot;) then 
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;The location called &quot; .. locationName .. &quot; is now a safezone.&quot;)
			end	
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug locations 14&quot;) end

	if (chatvars.words[1] == &quot;location&quot; and chatvars.words[2] == &quot;unsafe&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end

		locationName = string.sub(chatvars.command, string.find(chatvars.command, &quot;unsafe &quot;) + 7)
		locationName = string.trim(locationName)
		loc = LookupLocation(locationName)

		if (loc == nil) then 
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;That location does not exist.&quot;)
			end	
		else	
			locations[loc].killZombies = false
			conn:execute(&quot;UPDATE locations set killZombies = false WHERE name = '&quot; .. escape(locationName) .. &quot;'&quot;)

			message(&quot;say [&quot; .. server.chatColour .. &quot;]The location called &quot; .. locationName .. &quot; is no longer a safezone![-]&quot;)

			if (chatvars.playername ~= &quot;Server&quot;) then 
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;The location called &quot; .. locationName .. &quot; is no longer a safezone.&quot;)
			end	
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug locations 15&quot;) end

	if chatvars.words[1] == &quot;location&quot; and string.find(chatvars.command, &quot;minigame&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end

		locationName = chatvars.words[2]
		loc = LookupLocation(locationName)

		if (loc == nil) then 
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;That location does not exist.&quot;)
			end	
		else	
			miniGame = string.sub(chatvars.command, string.find(chatvars.command, &quot;minigame&quot;) + 9)

			if (miniGame == nil) then 
				if (chatvars.playername ~= &quot;Server&quot;) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You didn't enter a minigame (eg. ctf, contest).[-]&quot;)
				else
					irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;You didn't enter a minigame (eg. ctf, contest).&quot;)
				end

				faultyChat = false
				return true
			end

			locations[loc].miniGame = miniGame
			conn:execute(&quot;UPDATE locations set miniGame = '&quot; .. escape(miniGame) .. &quot;' WHERE name = '&quot; .. loc .. &quot;'&quot;)

			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The location &quot; .. locationName .. &quot; is the mini-game &quot; .. miniGame .. &quot;.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;The location &quot; .. locationName .. &quot; is the mini-game &quot; .. miniGame)
			end			
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug locations 16&quot;) end

	if chatvars.words[1] == &quot;location&quot; and string.find(chatvars.command, &quot;cost&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end
		
		locationName = string.sub(chatvars.command, string.find(chatvars.command, &quot;location &quot;) + 9, string.find(chatvars.command, &quot;cost&quot;) - 2)
		locationName = string.trim(locationName)	
		loc = LookupLocation(locationName)

		if chatvars.number ~= nil and loc ~= nil then
			locations[loc].cost = math.floor(tonumber(chatvars.number))

			if locations[loc].currency == nil then
				locations[loc].currency = &quot;zennies&quot;
			end

			conn:execute(&quot;UPDATE locations set cost = &quot; .. math.floor(tonumber(chatvars.number)) .. &quot;, currency = '&quot; .. locations[loc].currency .. &quot;' WHERE name = '&quot; .. escape(locationName) .. &quot;'&quot;)

			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The location &quot; .. locationName .. &quot; requires &quot; .. locations[loc].cost .. &quot; &quot; .. locations[loc].currency .. &quot; to teleport.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;The location &quot; .. locationName .. &quot; requires &quot; .. locations[loc].cost .. &quot; &quot; .. locations[loc].currency .. &quot; to teleport.&quot;)
			end	
		end

		if loc == nil then
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;That location does not exist.&quot;)
			end	
		end

		faultyChat = false
		return true
	end

	-- ###################  do not allow remote commands beyond this point ################
	if (chatvars.playerid == nil) then
		faultyChat = false
		return false
	end
	-- ####################################################################################

if debug then dbug(&quot;debug locations 17&quot;) end

	if (chatvars.words[1] == &quot;protect&quot; and chatvars.words[2] == &quot;location&quot; and igplayers[chatvars.playerid].alertLocation ~= &quot;&quot;) then	
		igplayers[chatvars.playerid].alertLocationExit = igplayers[chatvars.playerid].alertLocation
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Walk out of &quot; .. igplayers[chatvars.playerid].alertLocation .. &quot; and I will do the rest.[-]&quot;)
		
		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug locations 18&quot;) end

	if (chatvars.words[1] == &quot;unprotect&quot; and chatvars.words[2] == &quot;location&quot; and igplayers[chatvars.playerid].alertLocation ~= &quot;&quot;) then	
		locations[igplayers[chatvars.playerid].alertLocation].protected = false
		conn:execute(&quot;UPDATE locations SET protected = 0 WHERE name = '&quot; .. escape(igplayers[chatvars.playerid].alertLocation) .. &quot;'&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have disabled protection for &quot; .. igplayers[chatvars.playerid].alertLocation .. &quot;.[-]&quot;)
		
		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug locations 19&quot;) end

	if (chatvars.words[1] == &quot;location&quot; and chatvars.words[2] == &quot;add&quot;) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		locationName = string.sub(chatvars.command, string.find(chatvars.command, &quot;add &quot;) + 4)
		locationName = string.trim(locationName)
		loc = LookupLocation(locationName)

		if (loc ~= nil) then 
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location already exists.[-]&quot;)
			faultyChat = false
			return true
		else	
			locations[locationName] = {}
			locations[locationName].name = locationName
			locations[locationName].x = chatvars.intX
			locations[locationName].y = chatvars.intY
			locations[locationName].z = chatvars.intZ
			locations[locationName].active = true
			locations[locationName].public = false
			locations[locationName].owner = chatvars.playerid
			locations[locationName].size = 20
			locations[locationName].killZombies = false

			conn:execute(&quot;INSERT INTO locations (name, x, y, z) VALUES ('&quot; .. escape(locationName) .. &quot;',&quot; .. chatvars.intX .. &quot;,&quot; .. chatvars.intY .. &quot;,&quot; .. chatvars.intZ .. &quot;) ON DUPLICATE KEY UPDATE x = &quot; .. chatvars.intX .. &quot;, y = &quot; .. chatvars.intY .. &quot;, z = &quot; .. chatvars.intZ)
			conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. chatvars.intX .. &quot;,&quot; .. chatvars.intY .. &quot;,&quot; .. chatvars.intZ .. &quot;,'&quot; .. serverTime .. &quot;','location added','Location &quot; .. escape(locationName) .. &quot; added',&quot; .. chatvars.playerid .. &quot;)&quot;)
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. chatvars.playername .. &quot; has created a location called &quot; .. locationName .. &quot;[-]&quot;)

			loadLocations(locationName)
		end

		if (locationName == &quot;prison&quot;) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Server PVP protection is now enabled.[-]&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug locations 20&quot;) end

	if (chatvars.words[1] == &quot;location&quot; and chatvars.words[2] == &quot;move&quot;) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		locationName = string.sub(chatvars.command, string.find(chatvars.command, &quot;move &quot;) + 5)
		locationName = string.trim(locationName)
		loc = LookupLocation(locationName)

		if (loc == nil) then 
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			faultyChat = false
			return true
		else	
			locations[loc].x = chatvars.intX
			locations[loc].y = chatvars.intY
			locations[loc].z = chatvars.intZ

			conn:execute(&quot;INSERT INTO locations (name, x, y, z) VALUES ('&quot; .. escape(locationName) .. &quot;',&quot; .. chatvars.intX .. &quot;,&quot; .. chatvars.intY .. &quot;,&quot; .. chatvars.intZ .. &quot;) ON DUPLICATE KEY UPDATE x = &quot; .. chatvars.intX .. &quot;, y = &quot; .. chatvars.intY .. &quot;, z = &quot; .. chatvars.intZ)
			conn:execute(&quot;INSERT INTO events (x, y, z, serverTime, type, event, steam) VALUES (&quot; .. chatvars.intX .. &quot;,&quot; .. chatvars.intY .. &quot;,&quot; .. chatvars.intZ .. &quot;,'&quot; .. serverTime .. &quot;','location moved','Location &quot; .. escape(locationName) .. &quot; moved',&quot; .. chatvars.playerid .. &quot;)&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have moved a location called &quot; .. locationName .. &quot;[-]&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug locations 21&quot;) end

	if (chatvars.words[1] == &quot;locations&quot; and chatvars.words[2] == nil) then
		for k, v in pairs(locations) do
			if (v.active == true) then
				active = &quot;enabled&quot;
			else
				active = &quot;disabled&quot;
			end
		
			if (not v.public and accessLevel(chatvars.playerid) &lt; 3) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/&quot; .. v.name .. &quot; private &quot; .. active .. &quot;[-]&quot;)
			end

			if (v.public) then
				if (accessLevel(chatvars.playerid) &lt; 3) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/&quot; .. v.name .. &quot; public &quot; .. active .. &quot;[-]&quot;)
				else
					if v.active then
						message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/&quot; .. v.name .. &quot;[-]&quot;)
					end
				end
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug locations 22&quot;) end

	if chatvars.words[1] == &quot;location&quot; and string.find(chatvars.command, &quot;ends here&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end
		
		locationName = string.sub(chatvars.command, string.find(chatvars.command, &quot;location &quot;) + 9, string.find(chatvars.command, &quot;end&quot;) - 2)
		locationName = string.trim(locationName)			
		loc = LookupLocation(locationName)

		if loc ~= nil then
			dist = distancexz(locations[loc].x, locations[loc].z, igplayers[chatvars.playerid].xPos, igplayers[chatvars.playerid].zPos)
			locations[loc].size = string.format(&quot;%d&quot;, dist)
			conn:execute(&quot;UPDATE locations set size = &quot; .. locations[loc].size .. &quot;, protectSize = &quot; .. locations[loc].size .. &quot; WHERE name = '&quot; .. locationName .. &quot;'&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The location &quot; .. loc .. &quot; now spans &quot; .. string.format(&quot;%d&quot;, dist * 2) .. &quot; meters.[-]&quot;)

			if loc == &quot;Prison&quot; then
				server.prisonSize = math.floor(tonumber(locations[loc].size))
				conn:execute(&quot;UPDATE server SET prisonSize = &quot; .. math.floor(tonumber(locations[loc].size)))
			end
		else
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug locations 23&quot;) end

	if chatvars.words[1] == &quot;location&quot; and string.find(chatvars.command, &quot;random&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end
		
		locationName = string.sub(chatvars.command, string.find(chatvars.command, &quot;location &quot;) + 9, string.find(chatvars.command, &quot;random&quot;) - 2)
		locationName = string.trim(locationName)			
		loc = LookupLocation(locationName)

		if loc ~= nil then
			igplayers[chatvars.playerid].location = loc
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are now creating spawn points for location &quot; .. loc .. &quot;. DO NOT FLY.[-]&quot;)
		else
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug locations 24&quot;) end

	if (chatvars.words[1] == &quot;location&quot;) then
		-- display details about the location

		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end

		locationName = string.sub(chatvars.command, string.find(chatvars.command, &quot;location &quot;) + 9)
		locationName = string.trim(locationName)
		loc = LookupLocation(locationName)

		if (loc == nil) then 
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]That location does not exist.[-]&quot;)
			faultyChat = false
			return true
		else	
			cursor,errorString = conn:execute(&quot;SELECT * FROM locations WHERE name = '&quot; .. locationName ..&quot;'&quot;)
			row = cursor:fetch({}, &quot;a&quot;)

			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Location: &quot; .. row.name .. &quot;[-]&quot;)				
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Active: &quot; .. dbYN(row.active) .. &quot;[-]&quot;)				
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Reset Zone: &quot; .. dbYN(row.resetZone) .. &quot;[-]&quot;)				
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Safe Zone: &quot; .. dbYN(row.killZombies) .. &quot;[-]&quot;)				
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Public: &quot; .. dbYN(row.public) .. &quot;[-]&quot;)				
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Allow Bases: &quot; .. dbYN(row.allowBase) .. &quot;[-]&quot;)				

			if row.miniGame ~= nil then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Mini Game: &quot; .. row.miniGame .. &quot;[-]&quot;)				
			end

			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Village: &quot; .. dbYN(row.village) .. &quot;[-]&quot;)				

			temp = LookupPlayer(row.mayor)
			if row.owner ~= &quot;0&quot; then 
				temp = LookupPlayer(row.mayor)
			else
				temp = &quot;&quot;
			end

			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Mayor: &quot; .. temp .. &quot;[-]&quot;)				
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Protected: &quot; .. dbYN(row.protected) .. &quot;[-]&quot;)				
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]PVP: &quot; .. dbYN(row.pvp) .. &quot;[-]&quot;)				
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Access Level: &quot; .. row.accessLevel .. &quot;[-]&quot;)				

			temp = LookupPlayer(row.owner)
			if row.owner ~= &quot;0&quot; then 
				temp = LookupPlayer(row.owner)
			else
				temp = &quot;&quot;
			end

			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Owner: &quot; .. temp .. &quot;[-]&quot;)				
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Coords: &quot; .. row.x .. &quot; &quot; .. row.y .. &quot; &quot; .. row.z .. &quot;[-]&quot;)				
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Size: &quot; .. row.size * 2 .. &quot;[-]&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Cost: &quot; .. row.cost .. &quot;[-]&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug locations 25&quot;) end

	if (chatvars.words[1] == &quot;show&quot; and chatvars.words[2] == &quot;locations&quot;) then
		players[chatvars.playerid].showLocationMessages = true
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You will be alerted when you enter or leave locations.[-]&quot;)				

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug locations 26&quot;) end

	if (chatvars.words[1] == &quot;hide&quot; and chatvars.words[2] == &quot;locations&quot;) then
		players[chatvars.playerid].showLocationMessages = false
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The only location messages you will see will be PVE and PVP zones.[-]&quot;)				

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug locations 27&quot;) end

	-- look for command in locations table
	loc = LookupLocation(chatvars.command)

	if (loc ~= nil) then
		if (players[chatvars.playerid].prisoner or not players[chatvars.playerid].canTeleport) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are not allowed to use teleports.[-]&quot;)
			faultyChat = false
			return true
		end

		if (players[chatvars.playerid].walkies) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have not opted in to using teleports. Type /enabletp to opt-in.[-]&quot;)
			faultyChat = false
			return true
		end

		cursor,errorString = conn:execute(&quot;SELECT * FROM locations WHERE name = '&quot; .. escape(loc) ..&quot;'&quot;)
		row = cursor:fetch({}, &quot;a&quot;)

		if (locations[loc].village == true) then
 			if villagers[chatvars.playerid .. loc] then
				if (players[chatvars.playerid].baseCooldown - os.time() &gt; 0) and (accessLevel(chatvars.playerid) &gt; 2 or server.ignoreAdmins == false) then --  and server.ignoreAdmins == false
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have to wait &quot; .. os.date(&quot;%M minutes %S seconds&quot;,players[chatvars.playerid].baseCooldown - os.time()) .. &quot; before you can use /&quot; .. loc .. &quot; again.[-]&quot;)
					faultyChat = false
					return true
				else
					if players[chatvars.playerid].donor then
						players[chatvars.playerid].baseCooldown = (os.time() + math.floor(tonumber(server.baseCooldown) / 2))
					else
						players[chatvars.playerid].baseCooldown = (os.time() + server.baseCooldown)
					end

					players[chatvars.playerid].xPosOld = 0
					players[chatvars.playerid].yPosOld = 0
					players[chatvars.playerid].zPosOld = 0
					igplayers[chatvars.playerid].lastLocation = loc

					if players[chatvars.playerid].watchPlayer then
						irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. chatvars.playerid .. &quot; &quot; .. chatvars.playername .. &quot; command &quot; .. chatvars.command  )
					end

					cursor,errorString = conn:execute(&quot;select * from locationSpawns where location='&quot; .. loc .. &quot;'&quot;)
					if cursor:numrows() &gt; 0 then
						randomPVPTP(chatvars.playerid, loc)
					else
						cmd = &quot;tele &quot; .. chatvars.playerid .. &quot; &quot; .. locations[loc].x .. &quot; &quot; .. locations[loc].y .. &quot; &quot; .. locations[loc].z
						teleport(cmd)
					end

					faultyChat = false
					return true
				end
			end
		end

		if (row.public == &quot;0&quot; and accessLevel(chatvars.playerid) &gt; 2) and row.owner ~= chatvars.playerid then --  and not LookupVillager(chatvars.playerid, loc)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. row.name .. &quot; is private[-]&quot;)
			faultyChat = false
			return true
		end

		if (row.active == &quot;0&quot; and accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. row.name .. &quot; is not enabled right now[-]&quot;)
			faultyChat = false
			return true
		end

		if (accessLevel(chatvars.playerid) &gt; tonumber(row.accessLevel)) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are not authorised to visit &quot; .. row.name .. &quot;.[-]&quot;)
			faultyChat = false
			return true
		end

		if tonumber(row.cost) &gt; 0 then
			if row.currency == &quot;zennies&quot; then
				if players[chatvars.playerid].cash &lt; tonumber(row.cost) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You do not have enough zennies to travel there.[-]&quot;)
					faultyChat = false
					return true
				else
					-- collect payment
					players[chatvars.playerid].cash = players[chatvars.playerid].cash - tonumber(row.cost)
				end
			else
				if not inInventory(chatvars.playerid, row.currency, row.cost) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You do not have enough of the required item to travel there.[-]&quot;)
					faultyChat = false
					return true
				end
			end
		end

		if tonumber(chatvars.intY) &gt; -1 then
			if igplayers[chatvars.playerid].lastLocation ~= loc then
				savePosition(chatvars.playerid)
				igplayers[chatvars.playerid].lastLocation = loc
			else
				savePosition(chatvars.playerid, 2)
			end
		end

		cursor,errorString = conn:execute(&quot;select * from locationSpawns where location='&quot; .. escape(loc) .. &quot;'&quot;)
		if cursor:numrows() &gt; 0 then
			if players[chatvars.playerid].watchPlayer then
				irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. chatvars.playerid .. &quot; &quot; .. chatvars.playername .. &quot; command &quot; .. chatvars.command  )
			end

			randomPVPTP(chatvars.playerid, loc)

			if server.announceTeleports then
				if server.coppi and tonumber(chatvars.accessLevel) &gt; 2 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. chatvars.playername .. &quot; has moved to &quot; .. loc .. &quot;[-]&quot;) end
			end
		else
			cmd = &quot;tele &quot; .. chatvars.playerid .. &quot; &quot; .. row.x .. &quot; &quot; .. row.y .. &quot; &quot; .. row.z

			if players[chatvars.playerid].watchPlayer then
				irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. chatvars.playerid .. &quot; &quot; .. chatvars.playername .. &quot; command &quot; .. chatvars.command  )
			end

			prepareTeleport(chatvars.playerid, cmd)
			teleport(cmd)

			if server.announceTeleports then
				if server.coppi and tonumber(chatvars.accessLevel) &gt; 2 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. chatvars.playername .. &quot; has moved to &quot; .. loc .. &quot;[-]&quot;) end
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug locations end&quot;) end

end

</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_resets</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
reset zones commands
====================
reset zones
add reset zone
delete reset zone
--]]

function gmsg_resets()
	calledFunction = &quot;gmsg_resets&quot;

	local region, x, z, debug

	debug = false

	-- don't proceed if there is no leading slash
	if (string.sub(chatvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyChat = false
		return false
	end


	-- ###################  do not allow remote commands beyond this point ################
	if (chatvars.playerid == nil) then
		faultyChat = false
		return false
	end
	-- ####################################################################################

if debug then dbug(&quot;debug resets 1&quot;) end

	if (chatvars.words[1] == &quot;add&quot; or chatvars.words[1] == &quot;remove&quot; or chatvars.words[1] == &quot;delete&quot;) and chatvars.words[2] == &quot;reset&quot; and (chatvars.words[3] == &quot;region&quot; or chatvars.words[3] == &quot;zone&quot;) then
		if (accessLevel(chatvars.playerid) &gt; 3) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		x = math.floor(igplayers[chatvars.playerid].xPos / 512)
		z = math.floor(igplayers[chatvars.playerid].zPos / 512)
		region = &quot;r.&quot; .. x .. &quot;.&quot; .. z .. &quot;.7rg&quot;

		if (chatvars.words[1] == &quot;add&quot;) then
			resetRegions[region] = {}
			conn:execute(&quot;INSERT INTO resetZones (region) VALUES ('&quot; .. region .. &quot;')&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Region &quot; .. region .. &quot; is now a reset zone.[-]&quot;)
		else
			resetRegions[region] = nil
			conn:execute(&quot;DELETE FROM resetZones WHERE region = '&quot; .. region .. &quot;')&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Region &quot; .. region .. &quot; is no longer a reset zone.[-]&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug resets 2&quot;) end

	if chatvars.words[1] == &quot;reset&quot; and chatvars.words[2] == &quot;zones&quot; then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		cursor,errorString = conn:execute(&quot;select * from resetZones&quot;)
		if cursor:numrows() == 0 then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No regions have been flagged as reset zones.[-]&quot;)
		else
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The following regions are reset zones:[-]&quot;)

			row = cursor:fetch({}, &quot;a&quot;)
			while row do
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. row.region .. &quot;[-]&quot;)
				row = cursor:fetch(row, &quot;a&quot;)	
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug resets end&quot;) end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_server</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
server commands
===============
translate on
translate off
reboot
set prison size
set map size
set base cooldown
motd
set motd
reset server (wipes all info from bot and collects info from server)
reset bot (wipes most info but retains player data)
cancel reboot
pause reboot
unpause reboot
enable/disable reboot
set chat colour
say&lt;fr&gt;&lt;es&gt;&lt;de&gt; etc  eg sayfr
restore backup
set website
set irc server
set irc main/alerts/watch
set/clear max ping
set/clear welcome message
max zombies
max animals
max players
set server pvp/pve/creative/contest
set max uptime
set new player timer
set server group
allow overstack
disallow overstack
blacklist action
show teleports
hide teleports
--]]

function gmsg_server()
	calledFunction = &quot;gmsg_server&quot;

local debug, tmp

debug = false

if debug then dbug(&quot;debug server 0&quot;) end

	-- don't proceed if there is no leading slash
	if (string.sub(chatvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyChat = false
		return false
	end

if debug then dbug(&quot;debug server 1&quot;) end

	if (chatvars.words[1] == &quot;translate&quot; and chatvars.words[2] == &quot;on&quot; and chatvars.words[3] ~= nil) then
		pname = string.sub(chatvars.command, string.find(chatvars.command, &quot; on &quot;) + 5)
		pname = string.trim(pname)
		id = LookupPlayer(pname)
		if not (id == nil) then
			players[id].translate = true
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Chat from player &quot; .. players[id].name ..  &quot; will be translated to English.[-]&quot;)

			conn:execute(&quot;UPDATE players SET translate = 1 WHERE steam = &quot; .. id)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 2&quot;) end

	if (chatvars.words[1] == &quot;translate&quot; and chatvars.words[2] == &quot;off&quot; and chatvars.words[3] ~= nil) then
		pname = string.sub(chatvars.command, string.find(chatvars.command, &quot; off &quot;) + 6)
		pname = string.trim(pname)
		id = LookupPlayer(pname)
		if not (id == nil) then
			players[id].translate = false
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Chat from player &quot; .. players[id].name ..  &quot; will no longer be translated.[-]&quot;)

			conn:execute(&quot;UPDATE players SET translate = 0 WHERE steam = &quot; .. id)
		end
		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 3&quot;) end

	if (string.find(chatvars.words[1], &quot;say&quot;) and (string.len(chatvars.words[1]) == 5) and chatvars.words[2] ~= nil) then
		msg = string.sub(chatvars.command, string.len(chatvars.words[1]) + 2)
		msg = string.trim(msg)

		if (msg ~= &quot;&quot;) then
			Translate(chatvars.playerid, msg, string.sub(chatvars.words[1], 4), true)
		end
		faultyChat = false
		return true
	end

	-- ###################  Staff only beyond this point ################
	-- Don't proceed if this is a player.  Server and staff only here.
	if (chatvars.playername ~= &quot;Server&quot;) then 
		if (accessLevel(chatvars.playerid) &gt; 2) then
			faultyChat = false
			return false
		end
	else
		if tonumber(chatvars.ircid) &gt; 0 then
			if (accessLevel(chatvars.ircid) &gt; 2) then
				faultyChat = false
				return false
			end
		end
	end
	-- ##################################################################

if debug then dbug(&quot;debug server 4&quot;) end

	if (chatvars.words[1] == &quot;restore&quot; and chatvars.words[2] == &quot;backup&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 1) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		importLuaData()
		
		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The last bot backup is restored.[-]&quot;)
		else
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;The last bot backup is restored.&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 5&quot;) end

	if (chatvars.words[1] == &quot;set&quot; and chatvars.words[2] == &quot;irc&quot; and chatvars.words[3] == &quot;server&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 1) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		tmp = string.sub(chatvars.command, string.find(chatvars.command, &quot;server&quot;) + 7)
		tmp = string.trim(tmp)

		if tmp == nil then
			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A server name is required.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;A server name is required.&quot;)
			end
		else
			message(&quot;say [&quot; .. server.chatColour .. &quot;]We have an irc server at &quot; .. tmp .. &quot;. See you there! :3[-]&quot;)
			server.ircServer = tmp
			conn:execute(&quot;UPDATE server SET ircServer = '&quot; .. escape(tmp) .. &quot;'&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 6&quot;) end

	if (chatvars.words[1] == &quot;set&quot; and chatvars.words[2] == &quot;irc&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 1) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		pname = chatvars.words[4]

		if chatvars.words[3] == &quot;main&quot; then
			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The main irc channel is now &quot; .. pname .. &quot;, alerts is &quot; ..  pname .. &quot;_alerts&quot; .. &quot;, watch is &quot; ..  pname .. &quot;_watch&quot; .. &quot;, and _tracker is &quot; ..  pname .. &quot;_tracker&quot; .. &quot;.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;The main irc channel is now &quot; .. pname .. &quot;, alerts is &quot; ..  pname .. &quot;_alerts&quot; .. &quot;, watch is &quot; ..  pname .. &quot;_watch&quot; .. &quot;, and _tracker is &quot; ..  pname .. &quot;_tracker&quot;)			
			end

			server.ircMain = &quot;#&quot; .. pname
			server.ircAlerts = &quot;#&quot; .. pname .. &quot;_alerts&quot;
			server.ircWatch = &quot;#&quot; .. pname .. &quot;_watch&quot;
			server.ircTracker = &quot;#&quot; .. pname .. &quot;_tracker&quot;
		end

		if chatvars.words[3] == &quot;alerts&quot; then
			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The alerts irc channel is now &quot; .. pname .. &quot;.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;The alerts irc channel is now &quot; .. pname)
			end

			server.ircAlerts = &quot;#&quot; .. pname
		end

		if chatvars.words[3] == &quot;watch&quot; then
			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The watch irc channel is now &quot; .. pname .. &quot;.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;The watch irc channel is now &quot; .. pname)				
			end

			server.ircWatch = &quot;#&quot; .. pname
		end

		if chatvars.words[3] == &quot;tracker&quot; then
			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The tracker irc channel is now &quot; .. pname .. &quot;.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;The tracker irc channel is now &quot; .. pname)				
			end

			server.ircTracker = &quot;#&quot; .. pname
		end

		conn:execute(&quot;UPDATE server SET ircMain = '&quot; .. server.ircMain .. &quot;', ircAlerts = '&quot; .. server.ircAlerts .. &quot;', ircWatch = '&quot; .. server.ircWatch .. &quot;', ircTracker = '&quot; .. server.ircTracker .. &quot;'&quot;)

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 7&quot;) end

	if (chatvars.words[1] == &quot;reboot&quot;) then
			if server.allowReboot == false then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is disabled for this server.  Reboot manually.[-]&quot;)
				faultyChat = false
				return true
			end

		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if tonumber(chatvars.ircid) &gt; 0 then
			if (accessLevel(chatvars.ircid) &gt; 1) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
			end
		end

		if (chatvars.words[2] ~= &quot;now&quot;) then
			if (server.scheduledRestart == true) then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]A reboot is already scheduled.  Cancel it first.[-]&quot;)
				faultyChat = false
				return true
			end
		else
			scheduledReboot = false
			server.scheduledIdleRestart = false
			server.scheduledRestart = false
			server.scheduledRestartTimestamp = os.time()
			scheduledRestartPaused = nil
			scheduledRestartForced = nil

			if (rebootTimerID ~= nil) then killTimer(rebootTimerID) end
			if (rebootTimerDelayID ~= nil) then killTimer(rebootTimerDelayID) end

			rebootTimerID = nil
			rebootTimerDelayID = nil

			send(&quot;sa&quot;)
			finishReboot()

			faultyChat = false
			return true
		end

		restartDelay = string.match(chatvars.command, &quot;%d+&quot;)
		if (restartDelay == nil) then
			restartDelay = 120
			message(&quot;say [&quot; .. server.chatColour .. &quot;]A server reboot is happening in 2 minutes.[-]&quot;)
		end

		if (chatvars.playername ~= &quot;Server&quot;) then
			if (accessLevel(chatvars.playerid) &lt; 2) then
				if (string.find(chatvars.command, &quot;forced&quot;)) then
					scheduledRestartForced = true
				end
			end
		end

		if (string.find(chatvars.command, &quot;minute&quot;)) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]A server reboot is happening in &quot; .. restartDelay .. &quot; minutes.[-]&quot;)
			restartDelay = restartDelay * 60
		end

		if (string.find(chatvars.command, &quot;hour&quot;)) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]A server reboot is happening in &quot; .. restartDelay .. &quot; hours time.[-]&quot;)
			restartDelay = restartDelay * 60 * 60
		end

		scheduledRestartPaused = false
		server.scheduledRestart = true
		server.scheduledRestartTimestamp = os.time() + restartDelay
		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 8&quot;) end

	-- don't proceed if there is no leading slash
	if (string.sub(chatvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyChat = false
		return false
	end

	if (chatvars.words[1] == &quot;set&quot; and chatvars.words[2] == &quot;prison&quot; and chatvars.words[3] == &quot;size&quot;) then
		if chatvars.number ~= nil then
			server.prisonSize = math.floor(tonumber(chatvars.number) / 2)
			conn:execute(&quot;UPDATE server SET prisonSize = &quot; .. server.prisonSize)
			location[&quot;prison&quot;].size = server.prisonSize

			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The prison is now &quot; .. tonumber(chatvars.number) .. &quot; meters wide.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;The prison is now &quot; .. tonumber(chatvars.number) .. &quot; meters wide.&quot;)
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 9&quot;) end

	if (chatvars.words[1] == &quot;set&quot; and chatvars.words[2] == &quot;map&quot; and chatvars.words[3] == &quot;size&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if chatvars.number ~= nil then
			server.mapSize = chatvars.number
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Players are now restricted to &quot; .. chatvars.number .. &quot; meters from 0,0[-]&quot;)

			conn:execute(&quot;UPDATE server SET mapSize = &quot; .. chatvars.number)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 10&quot;) end

	if (chatvars.words[1] == &quot;set&quot; and chatvars.words[2] == &quot;base&quot; and chatvars.words[3] == &quot;cooldown&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 1) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if chatvars.number ~= nil then
			server.baseCooldown = chatvars.number
			conn:execute(&quot;UPDATE server SET baseCooldown = &quot; .. chatvars.number)

			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Players must wait &quot; .. math.floor(tonumber(chatvars.number) / 60) .. &quot; minutes after using /base before it becomes available again.[-]&quot;)
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Donors must wait &quot; .. math.floor((tonumber(chatvars.number) / 60) / 2) .. &quot; minutes.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Players must wait &quot; .. math.floor(tonumber(chatvars.number) / 60) .. &quot; minutes after using /base before it becomes available again.&quot;)
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Donors must wait &quot; .. math.floor((tonumber(chatvars.number) / 60) / 2) .. &quot; minutes.&quot;)
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 11&quot;) end

	if (chatvars.words[1] == &quot;motd&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if chatvars.words[2] == nil then
			if server.MOTD == nil then
				if (chatvars.playername ~= &quot;Server&quot;) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]There is no MOTD set.[-]&quot;)
				else
					irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;There is no MOTD set.&quot;)
				end
			else
				if (chatvars.playername ~= &quot;Server&quot;) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. server.MOTD .. &quot;[-]&quot;)
				else
					irc_QueueMsg(players[chatvars.ircid].ircAlias, server.MOTD)
				end
			end
		else
			server.MOTD = string.sub(chatvars.oldLine, string.find(chatvars.oldLine, &quot;motd&quot;) + 5)
			conn:execute(&quot;UPDATE server SET MOTD = '&quot; .. escape(server.MOTD) .. &quot;'&quot;)

			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]New message of the day recorded.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;New message of the day recorded.&quot;)
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 12&quot;) end

	if (chatvars.words[1] == &quot;cancel&quot; and chatvars.words[2] == &quot;reboot&quot; and chatvars.words[3] == nil) then
		if (chatvars.playername ~= &quot;Server&quot;) then
			if accessLevel(chatvars.playerid) &gt; 1 then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is for admins only[-]&quot;)
				faultyChat = false
				return true
			end
		end

		if (chatvars.playername ~= &quot;Server&quot;) then
			if (scheduledRestartForced == true) and (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]A forced reboot is scheduled and will proceed as planned.[-]&quot;)
				faultyChat = false
				return true
			end
		end

		scheduledReboot = false
		server.scheduledIdleRestart = false
		server.scheduledRestart = false
		server.scheduledRestartTimestamp = os.time()
		scheduledRestartPaused = nil
		scheduledRestartForced = nil

		if (rebootTimerID ~= nil) then killTimer(rebootTimerID) end
		if (rebootTimerDelayID ~= nil) then killTimer(rebootTimerDelayID) end

		rebootTimerID = nil
		rebootTimerDelayID = nil

		message(&quot;say [&quot; .. server.chatColour .. &quot;]A server reboot has been cancelled.[-]&quot;)

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 13&quot;) end

	if (chatvars.words[1] == &quot;pause&quot; and chatvars.words[2] == &quot;reboot&quot; and chatvars.words[3] == nil) then
		if server.scheduledRestart == true and scheduledRestartPaused == false then
			scheduledRestartPaused = true
			restartTimeRemaining = server.scheduledRestartTimestamp - os.time()

			message(&quot;say [&quot; .. server.chatColour .. &quot;]The reboot has been paused.[-]&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 14&quot;) end

	if (chatvars.words[1] == &quot;unpause&quot; and chatvars.words[2] == &quot;reboot&quot; and chatvars.words[3] == nil) then
		if scheduledRestartPaused == true then
			server.scheduledRestartTimestamp = os.time() + restartTimeRemaining
			scheduledRestartPaused = false
			rebootTimer = restartTimeRemaining

			message(&quot;say [&quot; .. server.chatColour .. &quot;]The reboot countdown has resumed.[-]&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 15&quot;) end

	if (chatvars.words[1] == &quot;enable&quot; or chatvars.words[1] == &quot;disable&quot;) and chatvars.words[2] == &quot;reboot&quot; then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 1) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if chatvars.words[1] == &quot;enable&quot; then
			server.allowReboot = true
			conn:execute(&quot;UPDATE server SET allowReboot = true&quot;)

			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]I will automatically reboot the server as needed.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;I will automatically reboot the server as needed.&quot;)
			end
		else
			server.allowReboot = false
			conn:execute(&quot;UPDATE server SET allowReboot = false&quot;)

			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]I will not reboot the server.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;I will not reboot the server.&quot;)
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 16&quot;) end

	if (chatvars.words[1] == &quot;name&quot; and chatvars.words[2] == &quot;bot&quot; and chatvars.words[3] ~= nil) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		tmp = string.sub(chatvars.oldLine, string.find(chatvars.oldLine, chatvars.words[2], nil, true) + 4, string.len(chatvars.oldLine))
		if tmp == &quot;Tester&quot; and chatvars.playerid ~= Smegz0r then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]That name is reserved.[-]&quot;)
			faultyChat = false
			return true
		end

		server.botName = string.sub(chatvars.oldLine, string.find(chatvars.oldLine, chatvars.words[2], nil, true) + 4, string.len(chatvars.oldLine))
		message(&quot;say [&quot; .. server.chatColour .. &quot;]I shall henceforth be known as &quot; .. server.botName .. &quot;.[-]&quot;)

		msg = &quot;say [&quot; .. server.chatColour .. &quot;]Hello I am the server bot, &quot; .. server.botName .. &quot;. Pleased to meet you. :3[-]&quot;
		tempTimer( 5, [[message(msg)]] )

		conn:execute(&quot;UPDATE server SET botName = '&quot; .. escape(server.botName) .. &quot;'&quot;)

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 17&quot;) end

	if (chatvars.words[1] == &quot;set&quot; and chatvars.words[2] == &quot;chat&quot; and (chatvars.words[3] == &quot;colour&quot; or chatvars.words[3] == &quot;color&quot;)) then
		server.chatColour = chatvars.words[4]
		conn:execute(&quot;UPDATE server SET chatColour = '&quot; .. escape(server.chatColour) .. &quot;'&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have changed my chat colour.[-]&quot;)
		else
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;You have changed my chat colour.&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 18&quot;) end

	if (chatvars.words[1] == &quot;set&quot; and chatvars.words[2] == &quot;website&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 1) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		tmp = string.sub(chatvars.command, string.find(chatvars.command, &quot;website&quot;) + 8)
		tmp = string.trim(tmp)

		if tmp == nil then
			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A website or group is required.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;A website or group is required.&quot;)
			end
		else
			server.website = tmp
			conn:execute(&quot;UPDATE server SET website = '&quot; .. escape(tmp) .. &quot;'&quot;)

			message(&quot;say [&quot; .. server.chatColour .. &quot;]Our website/group is &quot; .. tmp .. &quot;. Check us out! :3[-]&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 19&quot;) end

	if (chatvars.words[1] == &quot;set&quot; and chatvars.words[2] == &quot;server&quot; and chatvars.words[3] == &quot;ip&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 1) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		tmp = chatvars.words[4]

		if tmp == nil then
			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The server ip is required.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;The server ip is required.&quot;)
			end
		else
			server.IP = tmp
			conn:execute(&quot;UPDATE server SET IP = '&quot; .. escape(tmp) .. &quot;'&quot;)

			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The server ip is &quot; .. tmp .. &quot;.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;The server ip is &quot; .. tmp)
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 20&quot;) end

	if (chatvars.words[1] == &quot;set&quot; or chatvars.words[1] == &quot;clear&quot;) and chatvars.words[2] == &quot;max&quot; and chatvars.words[3] == &quot;ping&quot; then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 1) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if chatvars.words[1] == &quot;clear&quot; then
			server.pingKick = -1
			conn:execute(&quot;UPDATE server SET pingKick = -1&quot;)

			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Ping kicking is disabled.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Ping kicking is disabled.&quot;)
			end

			faultyChat = false
			return true
		end

		if chatvars.number ~= nil then
			if tonumber(chatvars.number) &gt; -1 and tonumber(chatvars.number) &lt; 100 then
				if (chatvars.playername ~= &quot;Server&quot;) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. chatvars.number .. &quot; is quite low. Enter a number &gt; 99[-]&quot;)
				else
					irc_QueueMsg(players[chatvars.ircid].ircAlias, chatvars.number .. &quot; is quite low. Enter a number &gt; 99&quot;)
				end
			else
				server.pingKick = chatvars.number
				conn:execute(&quot;UPDATE server SET pingKick = &quot; .. chatvars.number)

				if (chatvars.playername ~= &quot;Server&quot;) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]New players with a ping above &quot; .. chatvars.number .. &quot; will be kicked from the server.[-]&quot;)
				else
					irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;New players with a ping above &quot; .. chatvars.number .. &quot; will be kicked from the server.&quot;)
				end
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 21&quot;) end

	if (chatvars.words[1] == &quot;set&quot; or chatvars.words[1] == &quot;clear&quot;) and chatvars.words[2] == &quot;welcome&quot; and chatvars.words[3] == &quot;message&quot; then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 1) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if chatvars.words[1] == &quot;clear&quot; then
			server.welcome = nil
			conn:execute(&quot;UPDATE server SET welcome = null&quot;)

			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Server welcome message cleared.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Server welcome message cleared.&quot;)
			end

			faultyChat = false
			return true
		end

		msg = string.sub(chatvars.oldLine, string.find(chatvars.oldLine, &quot;message&quot;) + 8)
		msg = string.trim(msg)

		server.welcome = msg
		conn:execute(&quot;UPDATE server SET welcome = '&quot; .. escape(msg) .. &quot;'&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]New welcome message &quot; .. msg .. &quot;[-]&quot;)
		else
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;New welcome message &quot; .. msg)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 22&quot;) end

	if (chatvars.words[1] == &quot;set&quot; or chatvars.words[1] == &quot;server&quot;) and chatvars.words[3] ~= nil then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 1) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if chatvars.words[3] == &quot;pvp&quot; then
			server.gameType = &quot;pvp&quot;
			server.northwestZone = &quot;pvp&quot;
			server.southwestZone = &quot;pvp&quot;
			server.northeastZone = &quot;pvp&quot;
			server.southeastZone = &quot;pvp&quot;
			message(&quot;say [&quot; .. server.chatColour .. &quot;]This server is now PVP.[-]&quot;)
			conn:execute(&quot;UPDATE server SET gameType = 'pvp', northwestZone = 'pvp', southwestZone = 'pvp', northeastZone = 'pvp', southeastZone = 'pvp'&quot;)

			faultyChat = false
			return true
		end

		if chatvars.words[3] == &quot;pve&quot; then
			server.gameType = &quot;pve&quot;
			server.northwestZone = &quot;pve&quot;
			server.southwestZone = &quot;pve&quot;
			server.northeastZone = &quot;pve&quot;
			server.southeastZone = &quot;pve&quot;
			message(&quot;say [&quot; .. server.chatColour .. &quot;]This server is now PVE.[-]&quot;)
			conn:execute(&quot;UPDATE server SET gameType = 'pve', northwestZone = 'pve', southwestZone = 'pve', northeastZone = 'pve', southeastZone = 'pve'&quot;)

			faultyChat = false
			return true
		end

		if chatvars.words[3] == &quot;creative&quot; then
			server.gameType = &quot;cre&quot;
			message(&quot;say [&quot; .. server.chatColour .. &quot;]This server is now creative.[-]&quot;)
			conn:execute(&quot;UPDATE server SET gameType = 'cre'&quot;)

			faultyChat = false
			return true
		end

		if chatvars.words[3] == &quot;contest&quot; then
			server.gameType = &quot;con&quot;
			message(&quot;say [&quot; .. server.chatColour .. &quot;]This server is now in contest mode.[-]&quot;)
			conn:execute(&quot;UPDATE server SET gameType = 'con'&quot;)

			faultyChat = false
			return true
		end

	end

if debug then dbug(&quot;debug server 23&quot;) end

	if (chatvars.words[1] == &quot;disallow&quot; and chatvars.words[2] == &quot;bad&quot; and chatvars.words[3] == &quot;names&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 1) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]I will kick players with names that have no letters.[-]&quot;)
		else
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;I will kick players with names that have no letters.&quot;)
		end

		server.allowNumericNames = false
		server.allowGarbageNames = false
		conn:execute(&quot;UPDATE server SET allowNumericNames = 0, allowGarbageNames = 0&quot;)

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 24&quot;) end

	if (chatvars.words[1] == &quot;allow&quot; and chatvars.words[2] == &quot;bad&quot; and chatvars.words[3] == &quot;names&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 1) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Players can call themselves anything they like.[-]&quot;)
		else
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;]Players can call themselves anything they like.&quot;)
		end

		server.allowNumericNames = true
		server.allowGarbageNames = true
		conn:execute(&quot;UPDATE server SET allowNumericNames = 1, allowGarbageNames = 1&quot;)

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 25&quot;) end

	if chatvars.words[1] == &quot;max&quot; and (chatvars.words[2] == &quot;zeds&quot; or chatvars.words[2] == &quot;zombies&quot;) and chatvars.words[3] ~= nil then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if chatvars.number ~= nil then
			chatvars.number = math.abs(math.floor(chatvars.number))

			if chatvars.number &gt; 150 then
				if (chatvars.playername ~= &quot;Server&quot;) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. chatvars.number .. &quot; is too high. Set a lower limit.[-]&quot;)
				else
					irc_QueueMsg(players[chatvars.ircid].ircAlias, chatvars.number .. &quot; is too high. Set a lower limit.&quot;)
				end

				faultyChat = false
				return true
			end

			send(&quot;sg MaxSpawnedZombies &quot; .. chatvars.number)

			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Max spawned zombies is now &quot; .. chatvars.number .. &quot;[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Max spawned zombies is now &quot; .. chatvars.number)
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 26&quot;) end

	if chatvars.words[1] == &quot;max&quot; and chatvars.words[2] == &quot;players&quot; and chatvars.words[3] ~= nil then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if chatvars.number ~= nil then
			chatvars.number = math.abs(math.floor(chatvars.number))

			send(&quot;sg ServerMaxPlayerCount &quot; .. chatvars.number)

			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Max players is now &quot; .. chatvars.number .. &quot;[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Max players is now &quot; .. chatvars.number)
			end

		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 27&quot;) end

	if chatvars.words[1] == &quot;max&quot; and chatvars.words[2] == &quot;animals&quot; and chatvars.words[3] ~= nil then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if chatvars.number ~= nil then
			chatvars.number = math.abs(math.floor(chatvars.number))

			if chatvars.number &gt; 150 then
				if (chatvars.playername ~= &quot;Server&quot;) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. chatvars.number .. &quot; is too high. Set a lower limit.[-]&quot;)
				else
					irc_QueueMsg(players[chatvars.ircid].ircAlias, chatvars.number .. &quot; is too high. Set a lower limit.&quot;)
				end

				faultyChat = false
				return true
			end

			send(&quot;sg MaxSpawnedAnimals &quot; .. chatvars.number)

			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Max spawned animals is now &quot; .. chatvars.number .. &quot;[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Max spawned animals is now &quot; .. chatvars.number)
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 28&quot;) end

	if chatvars.words[1] == &quot;set&quot; and chatvars.words[2] == &quot;max&quot; and chatvars.words[3] == &quot;uptime&quot; then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if chatvars.number ~= nil then
			chatvars.number = math.abs(math.floor(chatvars.number))

			server.maxServerUptime = chatvars.number
			conn:execute(&quot;UPDATE server SET maxServerUptime = &quot; .. chatvars.number)

			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]I will reboot the server when the server has been running &quot; .. chatvars.number .. &quot; hours.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;I will reboot the server when the server has been running &quot; .. chatvars.number .. &quot; hours.&quot;)
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 29&quot;) end

	if chatvars.words[1] == &quot;set&quot; and chatvars.words[2] == &quot;new&quot; and chatvars.words[3] == &quot;player&quot; and chatvars.words[4] == &quot;timer&quot; then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if chatvars.number ~= nil then
			chatvars.number = math.abs(math.floor(chatvars.number))

			server.newPlayerTimer = chatvars.number
			conn:execute(&quot;UPDATE server SET newPlayerTimer = &quot; .. chatvars.number)

			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]New players stop being new after &quot; .. chatvars.number .. &quot; minutes total play time.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;New players stop being new after &quot; .. chatvars.number .. &quot; minutes total play time.&quot;)
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 30&quot;) end

	if chatvars.words[1] == &quot;set&quot; and chatvars.words[2] == &quot;server&quot; and chatvars.words[3] == &quot;group&quot; then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		tmp = {}
		tmp.group = chatvars.wordsOld[4]

		if tmp.group == nil then
			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Group name required.  One word, no spaces.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Group name required.  One word, no spaces.&quot;)
			end

			faultyChat = false
			return true
		else
			server.group = tmp.group
			conn:execute(&quot;UPDATE server SET serverGroup = '&quot; .. escape(tmp.group) .. &quot;'&quot;)

			if db2Connected then
				-- update server in bots db
				connBots:execute(&quot;UPDATE servers SET serverGroup = '&quot; .. escape(tmp.group) .. &quot;' WHERE serverName = '&quot; .. escape(server.ServerName) .. &quot;'&quot;)
			end

			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This server is now a member of &quot; .. tmp.group .. &quot;.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This server is now a member of &quot; .. tmp.group .. &quot;.&quot;)
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 31&quot;) end

	if chatvars.words[1] == &quot;allow&quot; and string.find(chatvars.words[2], &quot;overstack&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		server.allowOverstacking = true
		conn:execute(&quot;UPDATE server SET allowOverstacking = 1&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]I will ignore overstacking.[-]&quot;)
		else
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;I will ignore overstacking.&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 32&quot;) end

	if chatvars.words[1] == &quot;disallow&quot; and string.find(chatvars.words[2], &quot;overstack&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		server.allowOverstacking = false
		conn:execute(&quot;UPDATE server SET allowOverstacking = 0&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]I will monitor stack sizes, warn and alert for overstacking.[-]&quot;)
		else
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;I will monitor stack sizes, warn and alert for overstacking.&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 33&quot;) end

	if chatvars.words[1] == &quot;blacklist&quot; and string.find(chatvars.words[2], &quot;action&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if chatvars.words[3] ~= &quot;exile&quot; and chatvars.words[3] ~= &quot;ban&quot; then
			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Expected ban or exile as 3rd word.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Expected ban or exile as 3rd word.&quot;)
			end

			faultyChat = false
			return true
		end

		server.blacklistResponse = chatvars.words[3]
		conn:execute(&quot;UPDATE server SET blacklistResponse  = '&quot; .. escape(chatvars.words[3]) .. &quot;'&quot;)

		if chatvars.words[3] == &quot;ban&quot; then
			chatvars.words[3] = &quot;banned&quot;
		else
			chatvars.words[3] = &quot;exiled&quot;
		end

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Blacklisted players will be &quot; .. chatvars.words[3] .. &quot;.[-]&quot;)
		else
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Blacklisted players will be &quot; .. chatvars.words[3] .. &quot;.&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 34&quot;) end

	if chatvars.words[1] == &quot;show&quot; and string.find(chatvars.words[2], &quot;teleports&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		server.announceTeleports = true
		conn:execute(&quot;UPDATE server SET announceTeleports = 1&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Players teleporting to locations will be announced in chat.[-]&quot;)
		else
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Players teleporting to locations will be announced in chat.&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 35&quot;) end

	if chatvars.words[1] == &quot;hide&quot; and string.find(chatvars.words[2], &quot;teleports&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		server.announceTeleports = false
		conn:execute(&quot;UPDATE server SET announceTeleports = 0&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Players teleporting to locations will be hidden from chat.[-]&quot;)
		else
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Players teleporting to locations will be hidden from chat.&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 36&quot;) end

	if chatvars.words[1] == &quot;setup&quot; and string.find(chatvars.words[2], &quot;map&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		send(&quot;webpermission add web.map 2000&quot;)
		send(&quot;webpermission add webapi.getlandclaims 1000&quot;)
		send(&quot;webpermission add webapi.viewallplayers 2&quot;)
		send(&quot;webpermission add webapi.viewallclaims 2&quot;)
		send(&quot;webpermission add webapi.getplayerinventory 2&quot;)
		send(&quot;webpermission add webapi.getplayerslocation 2&quot;)
-- uncomment if you want everyone to see animal or zed locations
--		send(&quot;webpermission add webapi.gethostilelocation 2000&quot;)
--		send(&quot;webpermission add webapi.getanimalslocation 2000&quot;)
		send(&quot;webpermission add webapi.getplayersonline 2000&quot;)
		send(&quot;webpermission add webapi.getstats 2000&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The map permissions have been set.[-]&quot;)
		else
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;The map permissions have been set.&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 37&quot;) end

	if chatvars.words[1] == &quot;northeast&quot; and chatvars.words[2] ~= nil then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if chatvars.words[2] ~= &quot;pvp&quot; and chatvars.words[2] ~= &quot;pve&quot; then
			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Command expects pvp or pve as 2nd part eg /northeast pvp.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Command expects pvp or pve as 2nd part eg /northeast pvp.&quot;)
			end

			faultyChat = false
			return true
		end

		server.northeastZone = chatvars.words[2]
		conn:execute(&quot;UPDATE server SET northeastZone = '&quot; .. escape(chatvars.words[2]) .. &quot;'&quot;)

		message(&quot;say [&quot; .. server.chatColour .. &quot;]Northeast of 0,0 is now a &quot; .. chatvars.words[2] .. &quot; zone![-]&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Northeast of 0,0 is now a &quot; .. chatvars.words[2] .. &quot; zone!&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 38&quot;) end

	if chatvars.words[1] == &quot;northwest&quot; and chatvars.words[2] ~= nil then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if chatvars.words[2] ~= &quot;pvp&quot; and chatvars.words[2] ~= &quot;pve&quot; then
			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Command expects pvp or pve as 2nd part eg /northwest pvp.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Command expects pvp or pve as 2nd part eg /northwest pvp.&quot;)
			end

			faultyChat = false
			return true
		end

		server.northwestZone = chatvars.words[2]
		conn:execute(&quot;UPDATE server SET northwestZone = '&quot; .. escape(chatvars.words[2]) .. &quot;'&quot;)

		message(&quot;say [&quot; .. server.chatColour .. &quot;]Northwest of 0,0 is now a &quot; .. chatvars.words[2] .. &quot; zone![-]&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Northwest of 0,0 is now a &quot; .. chatvars.words[2] .. &quot; zone!&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 39&quot;) end

	if chatvars.words[1] == &quot;southeast&quot; and chatvars.words[2] ~= nil then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if chatvars.words[2] ~= &quot;pvp&quot; and chatvars.words[2] ~= &quot;pve&quot; then
			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Command expects pvp or pve as 2nd part eg /southeast pvp.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Command expects pvp or pve as 2nd part eg /southeast pvp.&quot;)
			end

			faultyChat = false
			return true
		end

		server.southeastZone = chatvars.words[2]
		conn:execute(&quot;UPDATE server SET southeastZone = '&quot; .. escape(chatvars.words[2]) .. &quot;'&quot;)

		message(&quot;say [&quot; .. server.chatColour .. &quot;]Southeast of 0,0 is now a &quot; .. chatvars.words[2] .. &quot; zone![-]&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Southeast of 0,0 is now a &quot; .. chatvars.words[2] .. &quot; zone!&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 40&quot;) end

	if chatvars.words[1] == &quot;southwest&quot; and chatvars.words[2] ~= nil then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if chatvars.words[2] ~= &quot;pvp&quot; and chatvars.words[2] ~= &quot;pve&quot; then
			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Command expects pvp or pve as 2nd part eg /southwest pvp.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Command expects pvp or pve as 2nd part eg /southwest pvp.&quot;)
			end

			faultyChat = false
			return true
		end

		server.southwestZone = chatvars.words[2]
		conn:execute(&quot;UPDATE server SET southwestZone = '&quot; .. escape(chatvars.words[2]) .. &quot;'&quot;)

		message(&quot;say [&quot; .. server.chatColour .. &quot;]Southwest of 0,0 is now a &quot; .. chatvars.words[2] .. &quot; zone![-]&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Southwest of 0,0 is now a &quot; .. chatvars.words[2] .. &quot; zone!&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 41&quot;) end

	if chatvars.words[1] == &quot;north&quot; and chatvars.words[2] ~= nil then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if chatvars.words[2] ~= &quot;pvp&quot; and chatvars.words[2] ~= &quot;pve&quot; then
			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Command expects pvp or pve as 2nd part eg /north pvp.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Command expects pvp or pve as 2nd part eg /north pvp.&quot;)
			end

			faultyChat = false
			return true
		end

		server.northeastZone = chatvars.words[2]
		server.northwestZone = chatvars.words[2]
		conn:execute(&quot;UPDATE server SET northwestZone = '&quot; .. escape(chatvars.words[2]) .. &quot;', northeastZone = '&quot; .. escape(chatvars.words[2]) .. &quot;'&quot;)

		message(&quot;say [&quot; .. server.chatColour .. &quot;]North of 0,0 is now a &quot; .. chatvars.words[2] .. &quot; zone![-]&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;North of 0,0 is now a &quot; .. chatvars.words[2] .. &quot; zone!&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 42&quot;) end

	if chatvars.words[1] == &quot;south&quot; and chatvars.words[2] ~= nil then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if chatvars.words[2] ~= &quot;pvp&quot; and chatvars.words[2] ~= &quot;pve&quot; then
			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Command expects pvp or pve as 2nd part eg /south pvp.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Command expects pvp or pve as 2nd part eg /south pvp.&quot;)
			end

			faultyChat = false
			return true
		end

		server.southeastZone = chatvars.words[2]
		server.southwestZone = chatvars.words[2]
		conn:execute(&quot;UPDATE server SET southwestZone = '&quot; .. escape(chatvars.words[2]) .. &quot;', southeastZone = '&quot; .. escape(chatvars.words[2]) .. &quot;'&quot;)

		message(&quot;say [&quot; .. server.chatColour .. &quot;]South of 0,0 is now a &quot; .. chatvars.words[2] .. &quot; zone![-]&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;South of 0,0 is now a &quot; .. chatvars.words[2] .. &quot; zone!&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 43&quot;) end

	if chatvars.words[1] == &quot;east&quot; and chatvars.words[2] ~= nil then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if chatvars.words[2] ~= &quot;pvp&quot; and chatvars.words[2] ~= &quot;pve&quot; then
			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Command expects pvp or pve as 2nd part eg /east pvp.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Command expects pvp or pve as 2nd part eg /east pvp.&quot;)
			end

			faultyChat = false
			return true
		end

		server.northeastZone = chatvars.words[2]
		server.southeastZone = chatvars.words[2]
		conn:execute(&quot;UPDATE server SET northeastZone = '&quot; .. escape(chatvars.words[2]) .. &quot;', southeastZone = '&quot; .. escape(chatvars.words[2]) .. &quot;'&quot;)

		message(&quot;say [&quot; .. server.chatColour .. &quot;]East of 0,0 is now a &quot; .. chatvars.words[2] .. &quot; zone![-]&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;East of 0,0 is now a &quot; .. chatvars.words[2] .. &quot; zone!&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 44&quot;) end

	if chatvars.words[1] == &quot;west&quot; and chatvars.words[2] ~= nil then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if chatvars.words[2] ~= &quot;pvp&quot; and chatvars.words[2] ~= &quot;pve&quot; then
			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Command expects pvp or pve as 2nd part eg /west pvp.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Command expects pvp or pve as 2nd part eg /west pvp.&quot;)
			end

			faultyChat = false
			return true
		end

		server.northwestZone = chatvars.words[2]
		server.southwestZone = chatvars.words[2]
		conn:execute(&quot;UPDATE server SET northwestZone = '&quot; .. escape(chatvars.words[2]) .. &quot;', southwestZone = '&quot; .. escape(chatvars.words[2]) .. &quot;'&quot;)

		message(&quot;say [&quot; .. server.chatColour .. &quot;]West of 0,0 is now a &quot; .. chatvars.words[2] .. &quot; zone![-]&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;West of 0,0 is now a &quot; .. chatvars.words[2] .. &quot; zone!&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 45&quot;) end

	if chatvars.words[1] == &quot;allow&quot; and chatvars.words[2] == &quot;flying&quot; then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		server.playersCanFly = true
		conn:execute(&quot;UPDATE server SET playersCanFly = 1&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Players are allowed to fly![-]&quot;)
		else
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Players are allowed to fly!&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 46&quot;) end

	if chatvars.words[1] == &quot;disallow&quot; and chatvars.words[2] == &quot;flying&quot; then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		server.playersCanFly = false
		conn:execute(&quot;UPDATE server SET playersCanFly = 0&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Players may not fly![-]&quot;)
		else
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Players may not fly!&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 47&quot;) end

	if chatvars.words[1] == &quot;override&quot; and chatvars.words[2] == &quot;access&quot; and chatvars.words[3] ~= nil then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if chatvars.number ~= nil then
			chatvars.number = math.abs(math.floor(chatvars.number))

			if chatvars.number &lt; 3 then
				if (chatvars.playername ~= &quot;Server&quot;) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Do not set the access override lower than 3![-]&quot;)
				else
					irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Do not set the access override lower than 3!&quot;)
				end

				faultyChat = false
				return true
			end

			server.accessLevelOverride = chatvars.number
			conn:execute(&quot;UPDATE server SET accessLevelOverride = &quot; .. chatvars.number)

			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Player access levels have been over-ridden! Minimum access level is now &quot; .. chatvars.number .. &quot;.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Player access levels have been over-ridden! Minimum access level is now &quot; .. chatvars.number .. &quot;.&quot;)
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 48&quot;) end

	if chatvars.words[1] == &quot;disable&quot; and chatvars.words[2] == &quot;base&quot; and chatvars.words[3] == &quot;protection&quot; then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		server.disableBaseProtection = true
		conn:execute(&quot;UPDATE server SET disableBaseProtection = 1&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Base protection is disabled server wide!  Only claim blocks will protect from player damage now.[-]&quot;)
		else
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Base protection is disabled server wide!  Only claim blocks will protect from player damage now.&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 49&quot;) end

	if chatvars.words[1] == &quot;enable&quot; and chatvars.words[2] == &quot;base&quot; and chatvars.words[3] == &quot;protection&quot; then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		server.disableBaseProtection = false
		conn:execute(&quot;UPDATE server SET disableBaseProtection = 0&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Base protection is enabled server wide!  The bot will keep unfriended players out of bases.[-]&quot;)
		else
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Base protection is enabled server wide!  The bot will keep unfriended players out of bases&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 50&quot;) end

	if chatvars.words[1] == &quot;set&quot; and chatvars.words[2] == &quot;pack&quot; and chatvars.words[3] == &quot;cooldown&quot; then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if chatvars.number ~= nil then
			chatvars.number = math.abs(math.floor(chatvars.number))

			server.packCooldown = chatvars.number
			conn:execute(&quot;UPDATE server SET packCooldown = &quot; .. chatvars.number)

			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]After death a player must wait &quot; .. chatvars.number .. &quot; seconds before they can use /pack.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;After death a player must wait &quot; .. chatvars.number .. &quot; seconds before they can use /pack.&quot;)
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 51&quot;) end

	if chatvars.words[1] == &quot;enable&quot; and chatvars.words[2] == &quot;bank&quot; then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		server.allowBank = true
		conn:execute(&quot;UPDATE server SET allowBank = 1&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This server uses game money.[-]&quot;)
		else
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This server uses game money.&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 52&quot;) end

	if chatvars.words[1] == &quot;disable&quot; and chatvars.words[2] == &quot;bank&quot; then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		server.allowBank = false
		conn:execute(&quot;UPDATE server SET allowBank = 0&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This server will not use game money.[-]&quot;)
		else
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This server will not use game money.&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 53&quot;) end

	if chatvars.words[1] == &quot;set&quot; and chatvars.words[2] == &quot;overstack&quot; then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		server.overstackThreshold = chatvars.number
		conn:execute(&quot;UPDATE server SET overstackThreshold = &quot; .. chatvars.number)

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]If no overstack limit is recored, the minimum stack size to trigger an overstack warning is &quot; .. server.overstackThreshold .. &quot;.[-]&quot;)
		else
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;If no overstack limit is recored, the minimum stack size to trigger an overstack warning is &quot; .. server.overstackThreshold .. &quot;.&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 54&quot;) end

	if chatvars.words[1] == &quot;enable&quot; and chatvars.words[2] == &quot;region&quot; and chatvars.words[3] == &quot;pm&quot; then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		server.enableRegionPM = true
		conn:execute(&quot;UPDATE server SET enableRegionPM = 1&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The current region will be PM'ed to admins.[-]&quot;)
		else
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;The current region will be PM'ed to admins.&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 55&quot;) end

	if chatvars.words[1] == &quot;disable&quot; and chatvars.words[2] == &quot;region&quot; and chatvars.words[3] == &quot;pm&quot; then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		server.enableRegionPM = false
		conn:execute(&quot;UPDATE server SET enableRegionPM = 0&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The current region will not be PM'ed to admins.[-]&quot;)
		else
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;The current region will not be PM'ed to admins.&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 56&quot;) end

	if (chatvars.words[1] == &quot;open&quot; and chatvars.words[2] == &quot;lottery&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 2) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		server.allowLottery = true
		conn:execute(&quot;UPDATE server SET allowLottery = 1&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The daily lottery is OFF.[-]&quot;)
		else
			irc_QueueMsg(server.ircMain, &quot;The daily lottery is OFF.&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 57&quot;) end

	if (chatvars.words[1] == &quot;close&quot; and chatvars.words[2] == &quot;lottery&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 2) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		server.allowLottery = false
		conn:execute(&quot;UPDATE server SET allowLottery = 0&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The daily lottery is ON.[-]&quot;)
		else
			irc_QueueMsg(server.ircMain, &quot;The daily lottery is ON.&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 58&quot;) end

	if chatvars.words[1] == &quot;set&quot; and chatvars.words[2] == &quot;lottery&quot; and chatvars.words[3] == &quot;multiplier&quot; then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if chatvars.number ~= nil then
			chatvars.number = math.abs(math.floor(chatvars.number))

			server.lotteryMultiplier = chatvars.number
			conn:execute(&quot;UPDATE server SET lotteryMultiplier = &quot; .. chatvars.number)

			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The lottery will grow by zombie kills multiplied by &quot; .. chatvars.number .. &quot;.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;The lottery will grow by zombie kills multiplied by &quot; .. chatvars.number)
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 59&quot;) end

	if chatvars.words[1] == &quot;set&quot; and chatvars.words[2] == &quot;zombie&quot; and chatvars.words[3] == &quot;reward&quot; then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 0) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 0) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		if chatvars.number ~= nil then
			chatvars.number = math.abs(math.floor(chatvars.number))

			server.zombieKillReward = chatvars.number
			conn:execute(&quot;UPDATE server SET zombieKillReward = &quot; .. chatvars.number)

			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Players will be awarded &quot; .. chatvars.number .. &quot; zennies for every zombie killed.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Players will be awarded &quot; .. chatvars.number .. &quot; zennies for every zombie killed.&quot;)
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 60&quot;) end

	if chatvars.words[1] == &quot;clear&quot; and chatvars.words[2] == &quot;whitelist&quot; and chatvars.words[3] == nil then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 1) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		conn:execute(&quot;TRUNCATE TABLE whitelist&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The whitelist has been cleared.[-]&quot;)
		else
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;The whitelist has been cleared.&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 61&quot;) end

	if chatvars.words[1] == &quot;whitelist&quot; and chatvars.words[2] == &quot;everyone&quot; or chatvars.words[2] == &quot;all&quot; then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 1) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)		
				faultyChat = false
				return true
			end
		else
			if (accessLevel(chatvars.ircid) &gt; 1) then
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;This command is restricted.&quot;)
				faultyChat = false
				return true
			end
		end

		for k,v in pairs(players) do
			if not string.find(server.blockCountries, v.country) then
				conn:execute(&quot;INSERT INTO whitelist (steam) VALUES (&quot; .. k .. &quot;)&quot;)				
			end
		end

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Everyone except blacklisted players has been whitelisted.[-]&quot;)
		else
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;Everyone except blacklisted players has been whitelisted.&quot;)
		end

		faultyChat = false
		return true
	end

	-- ###################  do not allow remote commands beyond this point ################
	if (chatvars.playerid == nil) then
		faultyChat = false
		return false
	end
	-- ####################################################################################

if debug then dbug(&quot;debug server 62&quot;) end

	if (chatvars.words[1] == &quot;reset&quot;) and (chatvars.words[2] == &quot;server&quot;) then
		if accessLevel(chatvars.playerid) &gt; 0 then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Are you sure you want to wipe me completely clean?  Answer yes to proceed or anything else to cancel.[-]&quot;)
		igplayers[chatvars.playerid].botQuestion = &quot;reset server&quot;

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 63&quot;) end

	if (chatvars.words[1] == &quot;reset&quot;) and (chatvars.words[2] == &quot;bot&quot;) then
		if accessLevel(chatvars.playerid) &gt; 0 then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Are you sure you want to reset me?  Answer yes to proceed or anything else to cancel.[-]&quot;)
		igplayers[chatvars.playerid].botQuestion = &quot;reset bot&quot;

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server 64&quot;) end

	if (chatvars.words[1] == &quot;no&quot;) and (chatvars.words[2] == &quot;reset&quot;) then
		if accessLevel(chatvars.playerid) &gt; 0 then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true3
		end

		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Oh ok then.[-]&quot;)
		server.warnBotReset = false

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug server end&quot;) end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_shop</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
shop commands
=============
shop
buy
cash
pay
zennies
bank
gamble
wallet
lottery
show cash
hide cash
--]]

function gmsg_shop()
	calledFunction = &quot;gmsg_shop&quot;

	-- don't proceed if there is no leading slash
	if (string.sub(chatvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyChat = false
		return false
	end


	-- ###################  do not allow remote commands beyond this point ################
	if (chatvars.playerid == nil) then
		faultyChat = false
		return false
	end
	-- ####################################################################################


	if (chatvars.words[1] == &quot;shop&quot;or chatvars.words[1] == &quot;buy&quot;) then
		if (accessLevel(chatvars.playerid) &gt; 2) and (server.allowShop == false) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The shop is closed until further notice.[-]&quot;)
			faultyChat = false
			return true
		end

		faultyChat = doShop(chatvars.command, chatvars.playerid, chatvars.words)
		return true
	end


	if (chatvars.words[1] == &quot;cash&quot; or chatvars.words[1] == &quot;pay&quot; or chatvars.words[1] == &quot;zennies&quot; or chatvars.words[1] == &quot;bank&quot; or chatvars.words[1] == &quot;gamble&quot; or chatvars.words[1] == &quot;wallet&quot;) then
		faultyChat = doShop(chatvars.command, chatvars.playerid, chatvars.words)
		return true
	end


	if (chatvars.words[1] == &quot;zcoins&quot; or chatvars.words[1] == &quot;zgate&quot;) then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No zgates or zcoins here. We are using our own server bot :3[-]&quot;)
		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;lottery&quot; or chatvars.words[1] == &quot;lotto&quot; or chatvars.words[1] == &quot;tickets&quot;) then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The lottery prize pool has reached &quot; .. server.lottery .. &quot; zennies![-]&quot;)
		cursor,errorString = conn:execute(&quot;SELECT count(ticket) as tickets FROM lottery WHERE steam = &quot; .. chatvars.playerid)
		row = cursor:fetch({}, &quot;a&quot;)

		if tonumber(row.tickets) &gt; 0 then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have &quot; .. row.tickets .. &quot; tickets in the next draw![-]&quot;)
		end

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;show&quot; and chatvars.words[2] == &quot;cash&quot;) then
		players[chatvars.playerid].watchCash = true
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You will see your zennies increase with each zombie kill.[-]&quot;)
		conn:execute(&quot;UPDATE players SET watchCash = 1 WHERE steam = &quot; .. chatvars.playerid)

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;hide&quot; and chatvars.words[2] == &quot;cash&quot;) then
		players[chatvars.playerid].watchCash = nil
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Your zennies will not be reported with each zombie kill.[-]&quot;)
		conn:execute(&quot;UPDATE players SET watchCash = 0 WHERE steam = &quot; .. chatvars.playerid)

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;yes&quot; and chatvars.words[2] == nil) then
		if igplayers[chatvars.playerid].botQuestion == &quot;pay player&quot; then
			payPlayer()

			faultyChat = false
			return true
		end
	end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_teleports</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
teleport commands
=============
killtp
privatetp
publictp
activatetp
deactivatetp
onetp
twotp
enabletp
disabletp
fetch
pack
stuck
return
teleports
opentp
closetp
--]]

function gmsg_teleports()
	calledFunction = &quot;gmsg_teleports&quot;

	local debug

	debug = false

if debug then dbug(&quot;teleports 0&quot;) end

	-- don't proceed if there is no leading slash
	if (string.sub(chatvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyChat = false
		return false
	end

if debug then dbug(&quot;teleports 1&quot;) end

	if (chatvars.words[1] == &quot;killtp&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end

		tpname = &quot;&quot;
		tpname = string.sub(chatvars.command, string.find(chatvars.command, &quot;killtp &quot;) + 7)
		tpname = string.trim(tpname)

		if (tpname == &quot;&quot;) then 
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A name is required for the teleport[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;A name is required for the teleport&quot;)
			end

			faultyChat = false
			return true
		else
			tp = &quot;&quot;
			tp = LookupTeleportByName(tpname)

			teleports[tp] = nil
		end

		conn:execute(&quot;DELETE FROM teleports WHERE name = '&quot; .. escape(tp) .. &quot;'&quot;)
		
		if (chatvars.playername ~= &quot;Server&quot;) then 
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have deleted a teleport called &quot; .. tpname .. &quot;[-]&quot;)
		else
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;You have deleted a teleport called &quot; .. tpname)
		end		
		
		faultyChat = false
		return true
	end

if debug then dbug(&quot;teleports 2&quot;) end

	if (chatvars.words[1] == &quot;privatetp&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end

		tpname = &quot;&quot;
		tpname = string.sub(chatvars.command, string.find(chatvars.command, &quot;privatetp &quot;) + 10)
		tpname = string.trim(tpname)

		if (tpname == &quot;&quot;) then 
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A name is required for the teleport[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;A name is required for the teleport&quot;)
			end
			
			faultyChat = false
			return true
		else
			tp = &quot;&quot;
			tp = LookupTeleportByName(tpname)

			teleports[tp].public = false
		end
	
		conn:execute(&quot;UPDATE teleports SET public = 0 WHERE name = '&quot; .. escape(tp) .. &quot;'&quot;)
		
		if (chatvars.playername ~= &quot;Server&quot;) then 
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You changed a teleport called &quot; .. tpname .. &quot; to private[-]&quot;)
		else
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;You changed a teleport called &quot; .. tpname .. &quot; to private&quot;)
		end				

		faultyChat = false
		return true
	end

if debug then dbug(&quot;teleports 3&quot;) end

	if (chatvars.words[1] == &quot;publictp&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end

		tpname = &quot;&quot;
		tpname = string.sub(chatvars.command, string.find(chatvars.command, &quot;publictp &quot;) + 9)
		tpname = string.trim(tpname)

		if (tpname == &quot;&quot;) then 
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A name is required for the teleport[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;A name is required for the teleport&quot;)
			end		
		
			faultyChat = false
			return true
		else
			tp = &quot;&quot;
			tp = LookupTeleportByName(tpname)

			teleports[tp].public = true
		end
		
		conn:execute(&quot;UPDATE teleports SET public = 1 WHERE name = '&quot; .. escape(tp) .. &quot;'&quot;)
		
		if (chatvars.playername ~= &quot;Server&quot;) then 
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You changed a teleport called &quot; .. tpname .. &quot; to public[-]&quot;)
		else
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;You changed a teleport called &quot; .. tpname .. &quot; to public&quot;)
		end				

		faultyChat = false
		return true
	end

if debug then dbug(&quot;teleports 4&quot;) end

	if (chatvars.words[1] == &quot;activatetp&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end

		tpname = &quot;&quot;
		tpname = string.sub(chatvars.command, string.find(chatvars.command, &quot;activatetp &quot;) + 11)
		tpname = string.trim(tpname)

		if (tpname == &quot;&quot;) then 
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A name is required for the teleport[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;A name is required for the teleport&quot;)
			end

			faultyChat = false
			return true
		else
			tp = &quot;&quot;
			tp = LookupTeleportByName(tpname)

			teleports[tp].active = true
		end
		
		conn:execute(&quot;UPDATE teleports SET active = 1 WHERE name = '&quot; .. escape(tp) .. &quot;'&quot;)
		
		if (chatvars.playername ~= &quot;Server&quot;) then 
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You enabled a teleport called &quot; .. tpname .. &quot;[-]&quot;)
		else
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;You enabled a teleport called &quot; .. tpname)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;teleports 5&quot;) end

	if (chatvars.words[1] == &quot;deactivatetp&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (not admins[chatvars.playerid]) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is for admins only[-]&quot;)
				faultyChat = false
				return true
			end
		end

		tpname = &quot;&quot;
		tpname = string.sub(chatvars.command, string.find(chatvars.command, &quot;deactivatetp &quot;) + 13)
		tpname = string.trim(tpname)

		if (tpname == &quot;&quot;) then 
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A name is required for the teleport[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;A name is required for the teleport&quot;)
			end

			faultyChat = false
			return true
		else
			tp = &quot;&quot;
			tp = LookupTeleportByName(tpname)

			teleports[tp].active = false
		end
		
		conn:execute(&quot;UPDATE teleports SET active = 0 WHERE name = '&quot; .. escape(tp) .. &quot;'&quot;)
		
		if (chatvars.playername ~= &quot;Server&quot;) then 
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You disabled a teleport called &quot; .. tpname .. &quot;[-]&quot;)
		else
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;You disabled a teleport called &quot; .. tpname)
		end		

		faultyChat = false
		return true
	end

if debug then dbug(&quot;teleports 6&quot;) end

	if (chatvars.words[1] == &quot;onetp&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end

		tpname = string.trim(chatvars.words[2])

		tp = &quot;&quot;
		tp = LookupTeleportByName(tpname)

		if (tp ~= &quot;&quot;) then
			teleports[tp].oneway = true
			conn:execute(&quot;UPDATE teleports SET oneway = 1 WHERE name = '&quot; .. escape(tp) .. &quot;'&quot;)			

			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. teleports[tp].name .. &quot; is a one way teleport.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, teleports[tp].name .. &quot; is a one way teleport.&quot;)
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;teleports 7&quot;) end

	if (chatvars.words[1] == &quot;twotp&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end

		tpname = string.trim(chatvars.words[2])

		tp = &quot;&quot;
		tp = LookupTeleportByName(tpname)

		if (tp ~= &quot;&quot;) then
			teleports[tp].oneway = false
			conn:execute(&quot;UPDATE teleports SET oneway = 0 WHERE name = '&quot; .. escape(tp) .. &quot;'&quot;)			
			
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. teleports[tp].name .. &quot; is a two way teleport.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, teleports[tp].name .. &quot; is a two way teleport.&quot;)
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;teleports 8&quot;) end

	if (chatvars.words[1] == &quot;owntp&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end
		
		id = LookupPlayer(chatvars.words[3]) 
		if (players[id]) then
			pname = players[id].name
		end

		tp = &quot;&quot;
		tp = LookupTeleportByName(chatvars.words[2])

		if (tp ~= &quot;&quot;) then
			teleports[tp].owner = id
			conn:execute(&quot;UPDATE teleports SET owner = &quot; .. id .. &quot; WHERE name = '&quot; .. escape(tp) .. &quot;'&quot;)			
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; is the proud new owner of a teleport called &quot; .. teleports[tp].name .. &quot;[-]&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;teleports 9&quot;) end

	-- ###################  do not allow remote commands beyond this point ################
	if (chatvars.playerid == nil) then
		faultyChat = false
		return false
	end
	-- ####################################################################################


	if (chatvars.words[1] == &quot;enabletp&quot;) then
		id = chatvars.playerid	
		pname = igplayers[chatvars.playerid].name
		
		if (admins[chatvars.playerid] and chatvars.words[2] ~= nil) then
			id = LookupPlayer(string.sub(chatvars.command, string.find(chatvars.command, &quot;enabletp&quot;) + 9))
			if (id == nil) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No matching player found.[-]&quot;)
				faultyChat = false
				return true		
			else
				players[id].walkies = false
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Player &quot; .. players[id].name .. &quot; can now use teleports[-]&quot;)

				conn:execute(&quot;UPDATE players SET walkies = 0 WHERE steam = &quot; .. id)

				faultyChat = false
				return true
			end
		end

		players[id].walkies = false
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]you can use teleports and admins can teleport you[-]&quot;)
		conn:execute(&quot;UPDATE players SET walkies = 0 WHERE steam = &quot; .. id)

		faultyChat = false
		return true
	end

if debug then dbug(&quot;teleports 10&quot;) end

	if (chatvars.words[1] == &quot;disabletp&quot;) then
		id = chatvars.playerid	
		pname = igplayers[chatvars.playerid].name

		players[id].walkies = true

		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]you cannot use teleports and admins can't teleport you (some exceptions)[-]&quot;)
		conn:execute(&quot;UPDATE players SET walkies = 1 WHERE steam = &quot; .. id)

		faultyChat = false
		return true
	end

if debug then dbug(&quot;teleports 11&quot;) end

	if (chatvars.words[1] == &quot;fetch&quot;) then
		if (chatvars.words[1] == &quot;fetch&quot;) then
			pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;fetch &quot;) + 6)
		end
		
		if (accessLevel(chatvars.playerid) &gt; 2) and players[chatvars.playerid].tokens &lt;= 0 then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A P2P Token is required. Purchase one from the shop in soyspecials.[-]&quot;)
			faultyChat = false
			return true					
		end

		pname = string.trim(pname)
		id = LookupPlayer(pname)
		
		if id == nil then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No player found matching &quot; .. pname .. &quot;[-]&quot;)
			faultyChat = false
			return true		
		end

		if not igplayers[id] then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Player &quot; .. players[id].name .. &quot; is not playing right now.[-]&quot;)
			faultyChat = false
			return true		
		end

		if (accessLevel(id) &lt; 3) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Staff cannot be fetched.[-]&quot;)
			faultyChat = false
			return true
		end
		
		if (accessLevel(chatvars.playerid) &gt; 2) then
			-- reject if not a friend
			if (not isFriend(id,  chatvars.playerid)) and (accessLevel(chatvars.playerid) &gt; 2) and (id ~= chatvars.playerid) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Only friends of &quot; .. players[id].name .. &quot; and staff can do this.&quot;)

				faultyChat = false
				result = true
				return
			end
		end

		if players[id].xPosOld == nil then
			-- first record their current x y z
			savePosition(id)
		end
		
		-- then teleport the player to you
		cmd = &quot;tele &quot; .. id .. &quot; &quot; .. chatvars.intX + 1 .. &quot; &quot; .. chatvars.intY .. &quot; &quot; .. chatvars.intZ

		if players[id].watchPlayer then
			irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. chatvars.playerid .. &quot; &quot; .. chatvars.playername .. &quot; command &quot; .. chatvars.command  )
		end

		prepareTeleport(chatvars.playerid, cmd)
		teleport(cmd, true)

		if (accessLevel(chatvars.playerid) &gt; 2) then
			players[chatvars.playerid].tokens = players[chatvars.playerid].tokens - 1		
		end
		
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; is being teleported to your location now.&quot;)			
		message(&quot;pm &quot; .. id .. &quot; [&quot; .. server.chatColour .. &quot;]You are being teleported to &quot; .. players[chatvars.playerid].name .. &quot;'s location.&quot;)					
		
		faultyChat = false
		return true
	end

if debug then dbug(&quot;teleports 12&quot;) end

	if chatvars.words[1] == &quot;pack&quot; and chatvars.words[2] == nil then 
		if players[chatvars.playerid].deathX ~= 0 then
			if players[chatvars.playerid].packCooldown &gt; os.time() then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You can /pack in &quot; .. os.date(&quot;%M minutes %S seconds&quot;, players[chatvars.playerid].packCooldown - os.time()) .. &quot; seconds.[-]&quot;)
				faultyChat = false
				return true
			end

			cursor,errorString = conn:execute(&quot;SELECT x, y, z FROM tracker WHERE steam = &quot; .. chatvars.playerid .. &quot; and ((abs(x - &quot; .. players[chatvars.playerid].deathX .. &quot;) &gt; 0 and abs(x - &quot; .. players[chatvars.playerid].deathX .. &quot;) &lt; 50) and (abs(z - &quot; .. players[chatvars.playerid].deathZ .. &quot;) &gt; 5 and abs(z - &quot; .. players[chatvars.playerid].deathZ .. &quot;) &lt; 50))  ORDER BY trackerid DESC Limit 0, 1&quot;)
			if cursor:numrows() &gt; 0 then
				row = cursor:fetch({}, &quot;a&quot;)	
				cmd = (&quot;tele &quot; .. chatvars.playerid .. &quot; &quot; .. row.x .. &quot; &quot; .. row.y .. &quot; &quot; .. row.z)

				-- first record their current x y z
				savePosition(chatvars.playerid)

				if players[chatvars.playerid].watchPlayer then
					irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. chatvars.playerid .. &quot; &quot; .. chatvars.playername .. &quot; command &quot; .. chatvars.command  )
				end

				prepareTeleport(chatvars.playerid, cmd)
				teleport(cmd, true)
			else
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Sorry I am unable to find a spot close to your pack to send you there.[-]&quot;)
			end

		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;teleports 13&quot;) end

	if chatvars.words[1] == &quot;stuck&quot; and chatvars.words[2] == nil then 
		if (tonumber(chatvars.intY) &gt; 0 and tonumber(chatvars.intY) &lt; 256) and (players[chatvars.playerid].lastCommand ~= chatvars.command)  then
			-- bump the players position up 1 meter y + 1
			send(&quot;tele &quot; .. chatvars.playerid .. &quot; &quot; .. math.floor(igplayers[chatvars.playerid].xPos) .. &quot; &quot; .. math.ceil(igplayers[chatvars.playerid].yPos) + 1 .. &quot; &quot; .. math.floor(igplayers[chatvars.playerid].zPos))
		else
			cursor,errorString = conn:execute(&quot;SELECT x, y, z FROM tracker WHERE steam = &quot; .. chatvars.playerid .. &quot; AND ((abs(x - &quot; .. chatvars.intX .. &quot;) &gt; 2 and abs(x - &quot; .. chatvars.intX .. &quot;) &lt; 30) and (abs(z - &quot; .. chatvars.intZ .. &quot;) &gt; 2 and abs(z - &quot; .. chatvars.intZ .. &quot;) &lt; 30))  ORDER BY trackerid DESC Limit 0, 1&quot;)
			if cursor:numrows() &gt; 0 then
				row = cursor:fetch({}, &quot;a&quot;)	
				send(&quot;tele &quot; .. chatvars.playerid .. &quot; &quot; .. row.x .. &quot; &quot; .. row.y + 1 .. &quot; &quot; .. row.z)
			else
				-- bump the players position up 1 meter y + 1
				send(&quot;tele &quot; .. chatvars.playerid .. &quot; &quot; .. math.floor(igplayers[chatvars.playerid].xPos) .. &quot; &quot; .. math.ceil(igplayers[chatvars.playerid].yPos) + 1 .. &quot; &quot; .. math.floor(igplayers[chatvars.playerid].zPos))
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;teleports 14&quot;) end

	if (chatvars.words[1] == &quot;return&quot;) and chatvars.words[2] == nil then 
		-- return to previously recorded x y z
		if tonumber(players[chatvars.playerid].yPosOld) ~= 0 or tonumber(players[chatvars.playerid].yPosOld2) ~= 0 then
			if tonumber(players[chatvars.playerid].yPosOld2) ~= 0 then
				-- the player has teleported within the same location so they are returning to somewhere in that location
				cmd = &quot;tele &quot; .. chatvars.playerid .. &quot; &quot; .. players[chatvars.playerid].xPosOld2 .. &quot; &quot; .. players[chatvars.playerid].yPosOld2 .. &quot; &quot; .. players[chatvars.playerid].zPosOld2

				if players[chatvars.playerid].watchPlayer then
					irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. chatvars.playerid .. &quot; &quot; .. chatvars.playername .. &quot; command &quot; .. chatvars.command  )
				end

				prepareTeleport(chatvars.playerid, cmd)
				teleport(cmd)

				if players[chatvars.playerid].yPos &lt; 1000 then
					players[chatvars.playerid].xPosOld2 = 0
					players[chatvars.playerid].yPosOld2 = 0
					players[chatvars.playerid].zPosOld2 = 0

					conn:execute(&quot;UPDATE players SET xPosOld2 = 0, yPosOld2 = 0, zPosOld2 = 0 WHERE steam = &quot; .. chatvars.playerid)
				end

				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have another /return available.[-]&quot;)
			else
				-- the player has teleported from outside their current location so they are returning to there.
				cmd = &quot;tele &quot; .. chatvars.playerid .. &quot; &quot; .. players[chatvars.playerid].xPosOld .. &quot; &quot; .. players[chatvars.playerid].yPosOld .. &quot; &quot; .. players[chatvars.playerid].zPosOld

				if players[chatvars.playerid].watchPlayer then
					irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. chatvars.playerid .. &quot; &quot; .. chatvars.playername .. &quot; command &quot; .. chatvars.command  )
				end

				prepareTeleport(chatvars.playerid, cmd)
				teleport(cmd)

				if players[chatvars.playerid].yPos &lt; 1000 then
					players[chatvars.playerid].xPosOld = 0
					players[chatvars.playerid].yPosOld = 0
					players[chatvars.playerid].zPosOld = 0
					igplayers[chatvars.playerid].lastLocation = &quot;&quot;

					conn:execute(&quot;UPDATE players SET xPosOld = 0, yPosOld = 0, zPosOld = 0 WHERE steam = &quot; .. chatvars.playerid)
				end
			end
		else
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have used all your returns.[-]&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;teleports 15&quot;) end

	if (chatvars.words[1] == &quot;teleports&quot; and chatvars.words[3] == nil) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		id = nil
		if (chatvars.words[2]) then
			pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;teleports &quot;) + 10)
			pname = string.trim(pname)
			if (pname ~= nil) then id = LookupPlayer(pname) end
		end

		for k, v in pairs(teleports) do
			if (v.public == true) then
				public = &quot;public&quot;
			else
				public = &quot;private&quot;
			end

			if (id == nil) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot; &quot; .. public .. &quot;[-]&quot;)
			else
				if (v.owner == id) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot; &quot; .. public .. &quot;[-]&quot;)
				end
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;teleports 16&quot;) end

	if (chatvars.words[1] == &quot;tp&quot;) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		teleName = &quot;&quot;
		teleName = string.sub(chatvars.command, string.find(chatvars.command, &quot;tp &quot;) + 3)
		teleName = string.trim(teleName)

		if (teleName == &quot;&quot;) then 
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A name is required for the /tp command[-]&quot;)
			faultyChat = false
			return true
		else
			tp = &quot;&quot;
			tp = LookupTeleportByName(teleName)

			-- first record their current x y z
			savePosition(chatvars.playerid)

			cmd = &quot;tele &quot; .. chatvars.playerid .. &quot; &quot; .. math.floor(teleports[tp].x) .. &quot; &quot; .. math.ceil(teleports[tp].y) .. &quot; &quot; .. math.floor(teleports[tp].z)
			prepareTeleport(chatvars.playerid, cmd)
			teleport(cmd, true)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;teleports 17&quot;) end

	if (chatvars.words[1] == &quot;opentp&quot;) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		teleName = &quot;&quot;
		teleName = string.sub(chatvars.command, string.find(chatvars.command, &quot;opentp &quot;) + 7)
		teleName = string.trim(teleName)

		if (teleName == &quot;&quot;) then 
			message(&quot;pm &quot; .. chatvars.playername .. &quot; [&quot; .. server.chatColour .. &quot;]A name is required for the teleport[-]&quot;)
			faultyChat = false
			return true
		else	
			tp = &quot;&quot;
			tp = LookupTeleportByName(teleName)
			action = &quot;moved&quot;

			if (tp == nil) then
				teleports[teleName] = {}
				action = &quot;created&quot;
				teleports[teleName].public = false
				teleports[teleName].active = false
				teleports[teleName].friends = false
				teleports[teleName].name = teleName
				teleports[teleName].owner = igplayers[chatvars.playerid].steam
				teleports[teleName].oneway = false
		   end

			teleports[teleName].x = chatvars.intX
			teleports[teleName].y = chatvars.intY
			teleports[teleName].z = chatvars.intZ
		end

		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have &quot; .. action .. &quot; a teleport called &quot; .. teleName .. &quot;[-]&quot;)
		conn:execute(&quot;INSERT INTO teleports (name, owner, x, y, z) VALUES ('&quot; .. teleName .. &quot;',&quot; .. chatvars.playerid .. &quot;,&quot; .. chatvars.intX .. &quot;,&quot; .. chatvars.intY .. &quot;,&quot; .. chatvars.intZ .. &quot;) ON DUPLICATE KEY UPDATE x = &quot; .. chatvars.intX .. &quot;, y = &quot; .. chatvars.intY .. &quot;, z = &quot; ..chatvars.intZ)

		faultyChat = false
		return true
	end

if debug then dbug(&quot;teleports 18&quot;) end

	if (chatvars.words[1] == &quot;closetp&quot;) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true								
		end

		teleName = &quot;&quot;
		teleName = string.sub(chatvars.command, string.find(chatvars.command, &quot;closetp &quot;) + 8)
		teleName = string.trim(teleName)

		if (teleName == &quot;&quot;) then 
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A name is required for the teleport[-]&quot;)
			faultyChat = false
			return true
		else
			tp = &quot;&quot;
			tp = LookupTeleportByName(teleName)

			if (teleports[tp].owner == igplayers[chatvars.playerid].steam) and (teleports[tp].name == teleName) then
				teleports[tp].dx = chatvars.intX
				teleports[tp].dy = chatvars.intY
				teleports[tp].dz = chatvars.intZ

				if (teleports[tp].x ~= nil) then teleports[tp].active = true end
			end
		end

		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have activated a teleport called &quot; .. teleName .. &quot;[-]&quot;)
		conn:execute(&quot;UPDATE teleports SET dx = &quot; .. teleports[tp].dx .. &quot;, dy = &quot; .. teleports[tp].dy .. &quot;, dz = &quot; .. teleports[tp].dz .. &quot; WHERE name = '&quot; .. escape(tp) .. &quot;'&quot;)

		faultyChat = false
		return true
	end

if debug then dbug(&quot;teleports end&quot;) end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_villages</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
village commands
================
/elect
/add member
/remove member
/add village
/remove village
/village size
/villagers
/protect village
--]]

function gmsg_villages()
	calledFunction = &quot;gmsg_villages&quot;

	local debug

	debug = false

	-- don't proceed if there is no leading slash
	if (string.sub(chatvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyChat = false
		return false
	end

if debug then display (&quot;debug villages 1\n&quot;) end

	if (chatvars.words[1] == &quot;elect&quot; and chatvars.words[2] ~= nil) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false				return true
			end
		end

		if (string.find(chatvars.command, &quot;village&quot;)) then
			name1 = string.sub(chatvars.command, string.find(chatvars.command, &quot;elect&quot;) + 6, string.find(chatvars.command, &quot;village&quot;) - 1)
			name1 = string.trim(name1)
			pid = LookupPlayer(name1)
			
			villageName = string.sub(chatvars.command, string.find(chatvars.command, &quot;village&quot;) + 8)
			villageName = string.trim(villageName)		

			vid = LookupLocation(villageName)
			if vid == nil then
				if (chatvars.playername ~= &quot;Server&quot;) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]There is no village called &quot; .. villageName .. &quot;[-]&quot;)
				else
					irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;There is no village called &quot; .. villageName)
				end

				faultyChat = false
				return true
			end
			
			if (pid ~= nil) then
				if locations[villageName] ~= nil then
					locations[villageName].mayor = pid
					message(&quot;say [&quot; .. server.chatColour .. &quot;]Congratulations &quot; .. players[pid].name .. &quot; on becoming the new mayor of &quot; .. villageName .. &quot;[-]&quot;)								

					conn:execute(&quot;UPDATE locations SET mayor = &quot; .. pid .. &quot; WHERE name = '&quot; .. escape(villageName) .. &quot;'&quot;)
					conn:execute(&quot;INSERT INTO villagers SET steam = &quot; .. pid .. &quot;, village = '&quot; .. escape(villageName) .. &quot;'&quot;)

					villagers[pid .. vid] = {}
					villagers[pid .. vid].village = villageName
				end
			end
		end

		faultyChat = false
		return true
	end

if debug then display (&quot;debug villages 2\n&quot;) end

	if (chatvars.words[1] == &quot;add&quot; and chatvars.words[2] == &quot;member&quot;) then
		if (string.find(chatvars.command, &quot;village&quot;)) then
			name1 = string.sub(chatvars.command, string.find(chatvars.command, &quot;member&quot;) + 7, string.find(chatvars.command, &quot;village&quot;) - 1)
			name1 = string.trim(name1)

			pid = LookupPlayer(name1)

			villageName = string.sub(chatvars.command, string.find(chatvars.command, &quot;village&quot;) + 8)
			villageName = string.trim(villageName)		

			if (chatvars.playername ~= &quot;Server&quot;) then 
				if (accessLevel(chatvars.playerid) &gt; 2) and (locations[villageName].mayor ~= chatvars.playerid) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
					faultyChat = false
					return true
				end
			end

			vid = LookupLocation(villageName)
			if vid == nil then
				if (chatvars.playername ~= &quot;Server&quot;) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]There is no village called &quot; .. villageName .. &quot;[-]&quot;)
				else
					irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;There is no village called &quot; .. villageName)
				end

				faultyChat = false
				return true
			end

			if locations[vid].village ~= true then
				if (chatvars.playername ~= &quot;Server&quot;) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. villageName .. &quot; is not a village.[-]&quot;)
				else
					irc_QueueMsg(players[chatvars.ircid].ircAlias, villageName .. &quot; is not a village.&quot;)
				end

				faultyChat = false
				return true
			end
			
			if (pid ~= nil) then
				conn:execute(&quot;INSERT INTO villagers SET steam = &quot; .. pid .. &quot;, village = '&quot; .. escape(villageName) .. &quot;'&quot;)

				villagers[pid .. vid] = {}
				villagers[pid .. vid].village = villageName

				message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[pid].name .. &quot; is now a member of &quot; .. villageName .. &quot; village.[-]&quot;)								

				if (chatvars.playername ~= &quot;Server&quot;) then
					irc_QueueMsg(players[chatvars.ircid].ircAlias, players[pid].name .. &quot; is now a member of &quot; .. villageName .. &quot; village.&quot;)
				end
			end
		end

		faultyChat = false
		return true
	end

if debug then display (&quot;debug villages 3\n&quot;) end

	if (chatvars.words[1] == &quot;remove&quot; and chatvars.words[2] == &quot;village&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end

		villageName = string.trim(string.sub(chatvars.command, string.find(chatvars.command, &quot;village &quot;) + 8))

		vid = LookupLocation(villageName)
		if vid == nil then
			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]There is no village called &quot; .. villageName .. &quot;[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;There is no village called &quot; .. villageName)
			end

			faultyChat = false
			return true
		end

		locations[vid] = nil

		conn:execute(&quot;DELETE FROM villagers WHERE village = '&quot; .. escape(vid) .. &quot;'&quot;)
		conn:execute(&quot;DELETE FROM locations WHERE name = '&quot; .. escape(vid) .. &quot;'&quot;)

		for k, v in pairs(villagers) do
			if (v.villageName == vid) then
				k = nil
			end
		end

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. chatvars.playername .. &quot; has removed a village portal called &quot; .. vid .. &quot;[-]&quot;)
		else
			message(&quot;say [&quot; .. server.chatColour .. &quot;]A village called &quot; .. vid .. &quot; has been removed.[-]&quot;)
			irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;A village called &quot; .. vid .. &quot; has been removed.&quot;)
		end

		faultyChat = false
		return true
	end

if debug then display (&quot;debug villages 4\n&quot;) end

	if (chatvars.words[1] == &quot;village&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end

		villageName = string.trim(string.sub(chatvars.command, string.find(chatvars.command, &quot;village &quot;) + 8, string.find(chatvars.command, &quot;size&quot;) - 1))

		vid = LookupLocation(villageName)
		if vid == nil then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]There is no village called &quot; .. villageName .. &quot;[-]&quot;)
			faultyChat = false
			return true
		end

		baseprotection = tonumber(string.sub(chatvars.command, string.find(chatvars.command, &quot;size &quot;) + 5))
		if (baseprotection == nil) then
			baseprotection = 50
		end

		if (locations[vid]) then
			locations[vid].size = baseprotection
			locations[vid].protect = false
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. chatvars.playername .. &quot; has set village protection to &quot; .. baseprotection .. &quot; meters for village &quot; .. vid .. &quot;[-]&quot;)
			conn:execute(&quot;UPDATE locations SET size = &quot; .. baseprotection .. &quot;, protect=0 WHERE name = '&quot; .. escape(vid) .. &quot;'&quot;)
		end

		faultyChat = false
		return true
	end

if debug then display (&quot;debug villages 5\n&quot;) end

	if (chatvars.words[1] == &quot;remove&quot; and chatvars.words[2] == &quot;member&quot;) then
		if (string.find(chatvars.command, &quot;village&quot;)) then
			name1 = string.sub(chatvars.command, string.find(chatvars.command, &quot;member&quot;) + 7, string.find(chatvars.command, &quot;village&quot;) - 1)
			name1 = string.trim(name1)
			pid = LookupPlayer(name1)
			
			villageName = string.sub(chatvars.command, string.find(chatvars.command, &quot;village&quot;) + 8)
			villageName = string.trim(villageName)		
			
			if (chatvars.playername ~= &quot;Server&quot;) then 
				if (accessLevel(chatvars.playerid) &gt; 2) and (locations[villageName].mayor ~= chatvars.playerid) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
					faultyChat = false
					return true
				end
			end

			vid = LookupLocation(villageName)
			if vid == nil then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]There is no village called &quot; .. villageName .. &quot;[-]&quot;)
				faultyChat = false
				return true
			end
			
			if (pid ~= nil) then
				conn:execute(&quot;DELETE FROM villagers WHERE village = '&quot; .. escape(vid) .. &quot;' and steam = &quot; .. pid)
				villagers[pid .. vid] = nil
				message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. players[pid].name .. &quot; has been cast out of village &quot; .. vid .. &quot;[-]&quot;)			
			end
		end

		faultyChat = false
		return true
	end

if debug then display (&quot;debug villages 6\n&quot;) end

	if (chatvars.words[1] == &quot;villages&quot; and chatvars.words[2] == nil) then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]List of villages:[-]&quot;)

		for k, v in pairs(locations) do
			if (v.village == true) then
				pid = nil

				if v.mayor ~= nil then
					pid = LookupOfflinePlayer(v.mayor)
				end

				if pid ~= nil then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot; the Mayor is &quot; .. players[pid].name .. &quot;[-]&quot;)
				else
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. v.name .. &quot;[-]&quot;)
				end		
			end
		end

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;villagers&quot;) then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]List of villagers:[-]&quot;)

		villageName = nil
		if (chatvars.words[2] ~= nil) then
			villageName = string.sub(chatvars.command, string.find(chatvars.command, &quot;villagers &quot;) + 10)
		end

		if villageName ~= nil then
			villageName = string.trim(villageName)
			cursor1,errorString = conn:execute(&quot;SELECT * FROM locations WHERE name = '&quot; .. escape(villageName) ..&quot;' and village = 1&quot;)
		else
			cursor1,errorString = conn:execute(&quot;SELECT * FROM locations WHERE village = 1&quot;)
		end

		row1 = cursor1:fetch({}, &quot;a&quot;)
		while row1 do
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The village of &quot; .. row1.name .. &quot;[-]&quot;)

			cursor2,errorString = conn:execute(&quot;SELECT * FROM villagers WHERE village = '&quot; .. escape(row1.name) ..&quot;'&quot;)
			row2 = cursor2:fetch({}, &quot;a&quot;)
			while row2 do
				if row1.mayor == row2.steam then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[row2.steam].name .. &quot;  (The Mayor)[-]&quot;)
				else
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[row2.steam].name .. &quot;[-]&quot;)
				end
				row2 = cursor2:fetch(row2, &quot;a&quot;)	
			end

			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;][-]&quot;)

			row1 = cursor1:fetch(row1, &quot;a&quot;)	
		end

		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;][-]&quot;)

		faultyChat = false
		return true
	end

if debug then display (&quot;debug villages 7\n&quot;) end

	-- ###################  do not allow remote commands beyond this point ################
	if (chatvars.playerid == nil) then
		faultyChat = false
		return false
	end
	-- ####################################################################################


	if (chatvars.words[1] == &quot;add&quot; and chatvars.words[2] == &quot;village&quot;) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		villageName = string.trim(string.sub(chatvars.command, string.find(chatvars.command, &quot;village &quot;) + 8))

		if not locations[villageName] then
			locations[villageName] = {}
			locations[villageName].name = villageName
			locations[villageName].owner = chatvars.playerid
			locations[villageName].x = chatvars.intX
			locations[villageName].y = chatvars.intY
			locations[villageName].z = chatvars.intZ
			locations[villageName].size = server.baseSize
			locations[villageName].active = true
			locations[villageName].public = false
			locations[villageName].village = true
			locations[villageName].mayor = 0
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. chatvars.playername .. &quot; has created a village portal called &quot; .. villageName .. &quot;[-]&quot;)
			message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. villageName .. &quot; needs villagers and a mayor.[-]&quot;)				

			conn:execute(&quot;INSERT INTO locations (name, owner, x, y, z, village, size) VALUES ('&quot; .. escape(villageName) .. &quot;',&quot; .. chatvars.playerid .. &quot;,&quot; .. chatvars.intX .. &quot;,&quot; .. chatvars.intY .. &quot;,&quot; .. chatvars.intZ .. &quot;,1,&quot; .. server.baseSize .. &quot;) ON DUPLICATE KEY UPDATE x = &quot; .. chatvars.intZ .. &quot;, y = &quot; .. chatvars.intY .. &quot;, z = &quot; .. chatvars.intZ .. &quot;, village=1, size=&quot; .. server.baseSize)
		else
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. villageName .. &quot; already exists.[-]&quot;)
		end

		faultyChat = false
		return true
	end

if debug then display (&quot;debug villages 8\n&quot;) end

	if (chatvars.words[1] == &quot;protect&quot; and (chatvars.words[2] == &quot;village&quot;) and chatvars.words[3] ~= nil) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		if (chatvars.words[2] ~= nil) then
			pname = string.sub(chatvars.oldLine, string.find(chatvars.oldLine, &quot;village&quot;) + 8)
			pname = string.trim(pname)
		else
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You need to tell me the name of the village you are protecting.[-]&quot;)	
		end

		dist = distancexz(igplayers[chatvars.playerid].xPos, igplayers[chatvars.playerid].zPos, locations[pname].x, locations[pname].z)

		if (dist &lt;  tonumber(locations[pname].size) + 1) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are too close to the village, but just walk away and I will set it when you are far enough.[-]&quot;)
			igplayers[chatvars.playerid].alertLocationExit = pname
			faultyChat = false
			return true
		end

		faultyChat = false
		return true
	end

if debug then display (&quot;debug villages 9\n&quot;) end

	if (chatvars.words[1] == &quot;unprotect&quot; and (chatvars.words[2] == &quot;village&quot;) and chatvars.words[3] ~= nil) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
				faultyChat = false
				return true
			end
		end

		if (chatvars.words[2] ~= nil) then
			pname = string.sub(chatvars.oldLine, string.find(chatvars.oldLine, &quot;village&quot;) + 8)
			pname = string.trim(pname)

			if locations[pname] then
				locations[pname].protect = false
				conn:execute(&quot;UPDATE locations SET protect = 0 WHERE name = '&quot; .. escape(pname) .. &quot;'&quot;)
				message(&quot;say [&quot; .. server.chatColour .. &quot;]Protection has been removed from &quot; .. pname .. &quot;.[-]&quot;)	
			end
		else
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You need to tell me the name of the village you are removing protection from.[-]&quot;)	
		end

		faultyChat = false
		return true
	end

if debug then display (&quot;debug villages end\n&quot;) end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_waypoints</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
waypoint commands
=================
open waypoint
close waypoint
set waypoint
clear waypoint
waypoints
--]]

function gmsg_waypoints()
	calledFunction = &quot;gmsg_waypoints&quot;

	local debug

	debug = false

	-- don't proceed if there is no leading slash
	if (string.sub(chatvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyChat = false
		return false
	end


	-- ###################  do not allow remote commands beyond this point ################
	if (chatvars.playerid == nil) then
		faultyChat = false
		return false
	end
	-- ####################################################################################

if debug then display (&quot;debug waypoints 1\n&quot;) end

	if chatvars.words[1] == &quot;open&quot; and (chatvars.words[2] == &quot;waypoint&quot; or chatvars.words[2] == &quot;wp&quot;) then
		if(accessLevel(chatvars.playerid) &gt; 10) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Only donors and admins can have waypoints.[-]&quot;)
			faultyChat = false
			return true		
		end

		-- set the players waypoint coords
		players[chatvars.playerid].shareWaypoint = true
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Your friends can now teleport to your waypoint by typing just &quot; .. players[chatvars.playerid].name .. &quot; or part of it.[-]&quot;)	

		conn:execute(&quot;UPDATE players SET shareWaypoint = 1 WHERE steam = &quot; .. chatvars.playerid)

		faultyChat = false
		return true
	end

if debug then display (&quot;debug waypoints 2\n&quot;) end

	if chatvars.words[1] == &quot;close&quot; and (chatvars.words[2] == &quot;waypoint&quot; or chatvars.words[2] == &quot;wp&quot;) then
		if (accessLevel(chatvars.playerid) &gt; 10) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Only donors and admins can have waypoints.[-]&quot;)
			faultyChat = false
			return true		
		end

		-- set the players waypoint coords
		players[chatvars.playerid].shareWaypoint = false
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Only you can teleport to your waypoint.[-]&quot;)	

		conn:execute(&quot;UPDATE players SET shareWaypoint = 0 WHERE steam = &quot; .. chatvars.playerid)

		faultyChat = false
		return true
	end

if debug then display (&quot;debug waypoints 3\n&quot;) end

	if chatvars.words[1] == &quot;set&quot; and (chatvars.words[2] == &quot;waypoint&quot; or chatvars.words[2] == &quot;wp&quot;) then
		if (accessLevel(chatvars.playerid) &gt; 10) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Only donors and admins can have waypoints.[-]&quot;)
			faultyChat = false
			return true		
		end

		-- set the players waypoint coords
		players[chatvars.playerid].waypointX = chatvars.intX
		players[chatvars.playerid].waypointY = chatvars.intY
		players[chatvars.playerid].waypointZ = chatvars.intZ	
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have set a waypoint.  You can tp to it with /waypoint.[-]&quot;)	

		conn:execute(&quot;UPDATE players SET waypointX = &quot; .. chatvars.intX .. &quot;, waypointY = &quot; .. chatvars.intY .. &quot;, waypointZ = &quot; .. chatvars.intZ .. &quot; WHERE steam = &quot; .. chatvars.playerid)

		faultyChat = false
		return true
	end

if debug then display (&quot;debug waypoints 4\n&quot;) end

	if (chatvars.words[1] == &quot;clear&quot; or chatvars.words[1] == &quot;delete&quot; or chatvars.words[1] == &quot;kill&quot;) and chatvars.words[2] == &quot;waypoint&quot; then
		if (accessLevel(chatvars.playerid) &gt; 10) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Only donors and admins can have waypoints.[-]&quot;)
			faultyChat = false
			return true		
		end

		-- set the players waypoint coords
		players[chatvars.playerid].waypointX = nil
		players[chatvars.playerid].waypointY = nil
		players[chatvars.playerid].waypointZ = nil
		players[chatvars.playerid].shareWaypoint = false
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Your waypoint has been cleared.[-]&quot;)	

		conn:execute(&quot;UPDATE players SET waypointX = 0, waypointY = 0, waypointZ = 0 WHERE steam = &quot; .. chatvars.playerid)

		faultyChat = false
		return true
	end

if debug then display (&quot;debug waypoints 5\n&quot;) end

	if (chatvars.words[1] == &quot;waypoint&quot; or chatvars.words[1] == &quot;wp&quot; and chatvars.words[2] == nil) then
		if (accessLevel(chatvars.playerid) &gt; 10) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Only donors and admins can have waypoints.[-]&quot;)
			faultyChat = false
			return true		
		end

		if tonumber(players[chatvars.playerid].waypointX) == 0 and tonumber(players[chatvars.playerid].waypointY) == 0 and tonumber(players[chatvars.playerid].waypointZ) == 0 then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You do not have a waypoint set.[-]&quot;)
			faultyChat = false
			return true		
		end
		
		-- store the current coords
		players[chatvars.playerid].xPosOld = chatvars.intX
		players[chatvars.playerid].yPosOld = chatvars.intY
		players[chatvars.playerid].zPosOld = chatvars.intZ

		-- tp the player to their waypointwaypoint
		cmd = &quot;tele &quot; .. chatvars.playerid .. &quot; &quot; .. players[chatvars.playerid].waypointX .. &quot; &quot; .. players[chatvars.playerid].waypointY .. &quot; &quot; .. players[chatvars.playerid].waypointZ
		teleport(cmd, true)

		faultyChat = false
		return true
	end

if debug then display (&quot;debug waypoints 6\n&quot;) end

	if (chatvars.words[1] == &quot;waypoints&quot;) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		if (chatvars.words[2] == nil) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]A player name or id is required.[-]&quot;)
			faultyChat = false
			return true
		end

		id = nil
		if (chatvars.words[2]) then
			pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;waypoints &quot;) + 10)
			pname = string.trim(pname)
			if (pname ~= nil) then id = LookupPlayer(pname) end
			
			if (id ~= nil) then
				if (players[id].waypointX) then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; &quot; .. players[id].waypointX .. &quot; &quot; .. players[id].waypointY .. &quot; &quot; .. players[id].waypointZ .. &quot;[-]&quot;)
				else
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; Doesn't have a waypoint set.[-]&quot;)			
				end		
				
				faultyChat = false
				return true			
			else
				faultyChat = false
				return true			
			end
		end

		faultyChat = false
		return true
	end

if debug then display (&quot;debug waypoints end\n&quot;) end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_unslashed</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
unslashed commands
=============
pay player
build reset
when feral
wait
when/next reboot
--]]

function gmsg_unslashed()
	calledFunction = &quot;gmsg_unslashed&quot;

	local debug

	debug = true

if debug then dbug(&quot;debug unslashed&quot;) end

	-- ###################  do not allow remote commands beyond this point ################
	if (chatvars.playerid == nil) then
		faultyChat = false
		return false
	end
	-- ####################################################################################


	-- ###################  do not allow the bot to respond to itself ################
	if string.sub(chatvars.command, 1, 1) ~= &quot;/&quot; and chatvars.playername == &quot;Server&quot; then
		faultyChat = false
		return true
	end
	-- ####################################################################################


	-- #################  do not proceed if the line starts with a slash  #################
	if (string.sub(chatvars.command, 1, 1) == &quot;/&quot;) then
		-- line starts with a slash so stop processing it.
		faultyChat = false
		return false
	end
	-- ####################################################################################

if debug then dbug(&quot;debug unslashed 0&quot;) end

	if igplayers[chatvars.playerid].botQuestion == &quot;pay player&quot; then
		payPlayer()

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug unslashed 1&quot;) end

	if (chatvars.playername ~= &quot;Server&quot;) then
		if igplayers[chatvars.playerid].botQuestion == &quot;reset server&quot; and chatvars.words[1] == &quot;yes&quot; and accessLevel(chatvars.playerid) == 0 then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Deleting all bot data and restarting it..[-]&quot;)
			ResetServer()

			igplayers[chatvars.playerid].botQuestion = &quot;&quot;
			igplayers[chatvars.playerid].botQuestionID = nil
			igplayers[chatvars.playerid].botQuestionValue = nil
			faultyChat = false
			return true
		end
	end


	if (chatvars.playername ~= &quot;Server&quot;) then
		if igplayers[chatvars.playerid].botQuestion == &quot;reset bot&quot; and chatvars.words[1] == &quot;yes&quot; and accessLevel(chatvars.playerid) == 0 then
			ResetBot()
			message(&quot;say [&quot; .. server.chatColour .. &quot;]I have been reset.  All bases, inventories etc are forgotten, but not the players.[-]&quot;)

			igplayers[chatvars.playerid].botQuestion = &quot;&quot;
			igplayers[chatvars.playerid].botQuestionID = nil
			igplayers[chatvars.playerid].botQuestionValue = nil
			faultyChat = false
			return true
		end
	end

	if (string.find(chatvars.command, &quot;build&quot;) and string.find(chatvars.command, &quot;reset&quot;)) then
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Reset zones are deleted and regenerate with random POIs and prefabs.  Anything you build there will be lost.  Resets are done manually.[-]&quot;)
		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug unslashed 2&quot;) end

	if (string.find(chatvars.command, &quot;wait&quot;) and scheduledRestartForced == false and (server.scheduledRestartTimestamp - os.time() &lt; 61)) then
		scheduledRestartForced = true

		if rebootTimerID ~= nil and rebootTimerDelayID == nil then
			disableTimer(rebootTimerID)
			rebootTimerDelayID = tempTimer( 60, [[enableTimer(]] .. rebootTimerID .. [[)]] )
			message(&quot;say [&quot; .. server.chatColour .. &quot;]The scheduled reboot has been delayed for 2 minutes. Clear all forges, campfires and stop crafting![-]&quot;)
			rebootTimer = rebootTimer + 120
		end

		if server.scheduledRestart == true then
			server.scheduledRestartTimestamp = server.scheduledRestartTimestamp + 120
			message(&quot;say [&quot; .. server.chatColour .. &quot;]The scheduled reboot has been delayed for 2 minutes. Clear all forges, campfires and stop crafting![-]&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug unslashed 3&quot;) end

	if (string.find(chatvars.command, &quot;when&quot;) and string.find(chatvars.command, &quot;feral&quot;)) then
		if (gameDay % 7 == 0) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Feral hordes will run tonight![-]&quot;)
			faultyChat = false
			return true
		end

		if ((gameDay + 1) % 7 == 0) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Feral hordes are expected tomorrow[-]&quot;)
			faultyChat = false
			return true
		end

		if ((gameDay + 2) % 7 == 0) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Feral hordes are expected in 2 days[-]&quot;)
			faultyChat = false
			return true
		end

		if ((gameDay + 3) % 7 == 0) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Feral hordes are expected in 3 days[-]&quot;)
			faultyChat = false
			return true
		end

		if ((gameDay + 4) % 7 == 0) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Feral hordes are expected in 4 days[-]&quot;)
			faultyChat = false
			return true
		end

		if ((gameDay + 5) % 7 == 0) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Feral hordes are expected in 5 days[-]&quot;)
			faultyChat = false
			return true
		end

		if ((gameDay + 6) % 7 == 0) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]Feral hordes are expected in 6 days[-]&quot;)
			faultyChat = false
			return true
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug unslashed 4&quot;) end

	if (chatvars.words[2] == &quot;server&quot; or chatvars.words[2] == &quot;bot&quot; or chatvars.words[2] == string.lower(server.botName)) and (chatvars.words[3] == nil) and (chatvars.playername ~= &quot;Server&quot;) then
		if (chatvars.words[1] == &quot;thanks&quot; or chatvars.words[1] == &quot;ty&quot; or string.find(chatvars.words[1], &quot;thx&quot;)) then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]You're welcome &quot; .. chatvars.playername .. &quot; &lt;3[-]&quot;)
		else
			r = rand(18)

			if r &lt; 6 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. chatvars.words[1]:gsub(&quot;^%l&quot;, string.upper)  .. &quot; &quot; .. chatvars.playername .. &quot;[-]&quot;)
				faultyChat = false
				return true
			end

			if string.find(chatvars.words[1], &quot;love&quot;) then
				l = rand(5)
				if l == 1 then message(&quot;say [&quot; .. server.chatColour .. &quot;]I know.[-]&quot;) end
				if l == 2 then message(&quot;say [&quot; .. server.chatColour .. &quot;]Thanks =D.[-]&quot;) end
				if l == 3 then message(&quot;say [&quot; .. server.chatColour .. &quot;]I love you too :3[-]&quot;) end
				if l == 4 then message(&quot;say [&quot; .. server.chatColour .. &quot;]PDA!  PDA![-]&quot;) end
				if l == 5 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. chatvars.words[1]:gsub(&quot;^%l&quot;, string.upper)  .. &quot; &quot; .. chatvars.playername .. &quot;[-]&quot;) end

				faultyChat = false
				return true
			end

			if string.find(chatvars.words[1], &quot;pretty&quot;) then
				l = rand(4)
				if l == 1 then message(&quot;say [&quot; .. server.chatColour .. &quot;]&quot; .. chatvars.words[1]:gsub(&quot;^%l&quot;, string.upper)  .. &quot; &quot; .. chatvars.playername .. &quot;[-]&quot;) end
				if l == 2 then message(&quot;say [&quot; .. server.chatColour .. &quot;]I know.[-]&quot;) end
				if l == 3 then message(&quot;say [&quot; .. server.chatColour .. &quot;]Thanks :&gt;[-]&quot;) end
				if l == 4 then message(&quot;say [&quot; .. server.chatColour .. &quot;]O.o[-]&quot;) end

				faultyChat = false
				return true
			end

			if string.find(chatvars.words[1], &quot;cool&quot;) or string.find(chatvars.words[1], &quot;great&quot;)then
				l = rand(3)
				if l == 1 then message(&quot;say [&quot; .. server.chatColour .. &quot;]Thanks &quot; .. chatvars.playername .. &quot;![-]&quot;) end
				if l == 2 then message(&quot;say [&quot; .. server.chatColour .. &quot;]Indeed.[-]&quot;) end
				if l == 3 then message(&quot;say [&quot; .. server.chatColour .. &quot;]I know.[-]&quot;) end

				faultyChat = false
				return true
			end

			if r == 6 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]Yo no hablo inglés[-]&quot;)
			end

			if r == 7 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]You again?[-]&quot;)
			end

			if r == 8 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]*sigh*  Next![-]&quot;)
			end

			if r == 9 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]I DIDN'T DO IT!  YOU CAN'T PROVE A THING![-]&quot;)
			end

			if r == 10 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]OH HEY![-]&quot;)
			end

			if r == 11 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]No lollygagging[-]&quot;)
			end

			if r == 12 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]No comment[-]&quot;)
			end

			if r == 13 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]OH HAI![-]&quot;)
			end

			if r == 14 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]Oh rly!?[-]&quot;)
			end

			if r == 15 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]I'm sorry, &quot; .. server.botName .. &quot; is not in right now.  Please leave a message after the beep.   BEEP[-]&quot;)
			end

			if r == 16 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]¿Hablas español?[-]&quot;)
			end

			if r == 17 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]o.O[-]&quot;)
			end

			if r == 18 then
				message(&quot;say [&quot; .. server.chatColour .. &quot;]O.o[-]&quot;)
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug unslashed 5&quot;) end

	if players[chatvars.playerid].newPlayer == true and (string.find(chatvars.command, &quot;where&quot;) or (string.find(chatvars.command, &quot;any&quot;))) and (string.find(chatvars.command, &quot;zed&quot;) or string.find(chatvars.command, &quot;zom&quot;)) then
		r = rand(7)
		if (r == 2) then r = 3 end
		if (r == 5) then r = 6 end

		send(&quot;se &quot; .. igplayers[chatvars.playerid].id .. &quot; &quot; .. r)

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug unslashed 6&quot;) end

	if (string.find(chatvars.command, &quot;server&quot;)) and (string.find(chatvars.command, &quot;suck&quot;) or string.find(chatvars.command, &quot;stupid&quot;) or string.find(chatvars.command, &quot;gay&quot;)) then
		r = rand(4)
		if (r == 1) then message(&quot;say [&quot; .. server.chatColour .. &quot;]Look who's talking :P[-]&quot;) end
		if (r == 2) then message(&quot;say [&quot; .. server.chatColour .. &quot;]Just ragequit! :)[-]&quot;) end
		if (r == 3) then message(&quot;say [&quot; .. server.chatColour .. &quot;]This is not the server you are looking for.  Move along.  Move along.[-]&quot;) end
		if (r == 4) then message(&quot;say [&quot; .. server.chatColour .. &quot;]Let me guess, did someone steal your sweet roll?[-]&quot;) end
		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug unslashed 7&quot;) end

	if (string.find(chatvars.command, &quot;when&quot;) or string.find(chatvars.command, &quot;next&quot;)) and string.find(chatvars.command, &quot;reboot&quot;) then
		nextReboot()

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug unslashed end&quot;) end

end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_tracker</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
tracker commands
=============


--]]

function gmsg_tracker()
	calledFunction = &quot;gmsg_tracker&quot;

	local debug

	debug = false

	-- don't proceed if there is no leading slash
	if (string.sub(chatvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyChat = false
		return false
	end


	-- ###################  do not allow remote commands beyond this point ################
	if (chatvars.playerid == nil) then
		faultyChat = false
		return false
	end
	-- ####################################################################################

	-- ###################  Staff only beyond this point ################
	-- Don't proceed if this is a player.  Server and staff only here.
	if (chatvars.playername ~= &quot;Server&quot;) then 
		if (accessLevel(chatvars.playerid) &gt; 2) then
			faultyChat = false
			return false
		end
	end
	-- ##################################################################

if debug then display (&quot;debug tracker 1\n&quot;) end

	if (chatvars.words[1] == &quot;skip&quot; and chatvars.number ~= nil) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			faultyChat = false
			return true
		end

		igplayers[chatvars.playerid].trackerSkip = chatvars.number

		faultyChat = false
		return true
	end

if debug then display (&quot;debug tracker 2\n&quot;) end

	if (chatvars.words[1] == &quot;speed&quot; and chatvars.number ~= nil) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			faultyChat = false
			return true
		end

		igplayers[chatvars.playerid].trackerSpeed = chatvars.number

		faultyChat = false
		return true
	end

if debug then display (&quot;debug tracker 3\n&quot;) end

	if (chatvars.words[1] == &quot;forward&quot; or chatvars.words[1] == &quot;advance&quot; and chatvars.number ~= nil) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			faultyChat = false
			return true
		end

		igplayers[chatvars.playerid].trackerCount = igplayers[chatvars.playerid].trackerCount + chatvars.number
		igplayers[chatvars.playerid].trackerStopped = false
		igplayers[chatvars.playerid].trackerStop = true

		faultyChat = false
		return true
	end

if debug then display (&quot;debug tracker 4\n&quot;) end

	if (chatvars.words[1] == &quot;back&quot; and chatvars.number ~= nil) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			faultyChat = false
			return true
		end

		igplayers[chatvars.playerid].trackerCount = igplayers[chatvars.playerid].trackerCount - chatvars.number
		igplayers[chatvars.playerid].trackerStopped = false
		igplayers[chatvars.playerid].trackerStop = true

		faultyChat = false
		return true
	end

if debug then display (&quot;debug tracker 5\n&quot;) end

	if (chatvars.words[1] == &quot;goto&quot; and chatvars.words[2] == &quot;start&quot;) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			faultyChat = false
			return true
		end

		igplayers[chatvars.playerid].trackerReversed = false
		igplayers[chatvars.playerid].trackerCount = 0

		faultyChat = false
		return true
	end

if debug then display (&quot;debug tracker 6\n&quot;) end

	if (chatvars.words[1] == &quot;goto&quot; and chatvars.words[2] == &quot;end&quot;) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			faultyChat = false
			return true
		end

		igplayers[chatvars.playerid].trackerReversed = true
		igplayers[chatvars.playerid].trackerCount = 1000000000

		faultyChat = false
		return true
	end

if debug then display (&quot;debug tracker 7\n&quot;) end

	if (chatvars.words[1] == &quot;go&quot; and chatvars.words[2] == &quot;back&quot;) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			faultyChat = false
			return true
		end

		if 	igplayers[chatvars.playerid].trackerReversed == true then
			igplayers[chatvars.playerid].trackerReversed = false
		else
			igplayers[chatvars.playerid].trackerReversed = true
		end

		igplayers[chatvars.playerid].trackerStopped = false

		faultyChat = false
		return true
	end

if debug then display (&quot;debug tracker 8\n&quot;) end

	if (chatvars.words[1] == &quot;stop&quot; or chatvars.words[1] == &quot;sotp&quot; and chatvars.words[2] == nil) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			faultyChat = false
			return true
		end

		r = rand(100)
		if r == 99 then
			message(&quot;say [&quot; .. server.chatColour .. &quot;]HAMMER TIME![-]&quot;)
		end

		igplayers[chatvars.playerid].trackerStopped = true
		igplayers[chatvars.playerid].following = nil
		igplayers[chatvars.playerid].location = nil
		faultyChat = false
		return true
	end

if debug then display (&quot;debug tracker 9\n&quot;) end

	if (chatvars.words[1] == &quot;go&quot; and chatvars.words[2] == nil) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			faultyChat = false
			return true
		end

		igplayers[chatvars.playerid].trackerStopped = false
		faultyChat = false
		return true
	end

if debug then display (&quot;debug tracker 10\n&quot;) end

	if (chatvars.words[1] == &quot;stop&quot; and chatvars.words[2] == &quot;tracking&quot;) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			faultyChat = false
			return true
		end

		igplayers[chatvars.playerid].trackerStopped = true
		conn:execute(&quot;DELETE FROM memTracker WHERE admin = &quot; .. chatvars.playerid)
		igplayers[chatvars.playerid].trackerCount = nil

		faultyChat = false
		return true
	end

if debug then display (&quot;debug tracker 11\n&quot;) end

	if (chatvars.words[1] == &quot;track&quot;) or (chatvars.words[1] == &quot;next&quot;) or (chatvars.words[1] == &quot;last&quot;) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		conn:execute(&quot;DELETE FROM memTracker WHERE admin = &quot; .. chatvars.playerid)

		igplayers[chatvars.playerid].trackerStopped = false
		igplayers[chatvars.playerid].trackerReversed = false

		if igplayers[chatvars.playerid].trackerSpeed == nil then
			igplayers[chatvars.playerid].trackerSpeed = 3
		end

		if igplayers[chatvars.playerid].trackerSkip == nil then
			igplayers[chatvars.playerid].trackerSkip = 1
		end

		if (chatvars.words[1] ~= &quot;next&quot;) and (chatvars.words[1] ~= &quot;last&quot;) then
			igplayers[chatvars.playerid].trackerCountdown = igplayers[chatvars.playerid].trackerSpeed
			igplayers[chatvars.playerid].trackerCount = 0
			igplayers[chatvars.playerid].trackerSteam = 0
			igplayers[chatvars.playerid].trackerSession = 0
			id = nil
		
			if string.find(chatvars.command, &quot;session&quot;) then
				pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;track&quot;) + 6, string.find(chatvars.command, &quot;session&quot;) - 1)
				pname = string.trim(pname)
				id = LookupPlayer(pname)
				igplayers[chatvars.playerid].trackerSession = string.sub(chatvars.command, string.find(chatvars.command, &quot;session&quot;) + 8)

				if id ~= nil then
					igplayers[chatvars.playerid].trackerSteam = id
				end
			else
				pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;track &quot;) + 6)
				pname = string.trim(pname)
				id = LookupPlayer(pname)

				if id ~= nil then
					igplayers[chatvars.playerid].trackerSession = players[id].sessionCount
					igplayers[chatvars.playerid].trackerSteam = id
				end
			end
		else
			id = igplayers[chatvars.playerid].trackerSteam

			if (chatvars.words[1] == &quot;next&quot;) then
				igplayers[chatvars.playerid].trackerSession = igplayers[chatvars.playerid].trackerSession + 1
				igplayers[chatvars.playerid].trackerCount = 0
				igplayers[chatvars.playerid].trackerReversed = false
			end

			if (chatvars.words[1] == &quot;last&quot;) then
				igplayers[chatvars.playerid].trackerSession = igplayers[chatvars.playerid].trackerSession - 1
				igplayers[chatvars.playerid].trackerCount = 1000000000
				igplayers[chatvars.playerid].trackerReversed = true
			end
		end

		if id ~= nil then
			conn:execute(&quot;INSERT into memTracker (SELECT trackerID, &quot; .. chatvars.playerid .. &quot; AS admin, steam, timestamp, x, y, z, SESSION , flag from tracker where steam = &quot; .. id .. &quot; and session = &quot; .. igplayers[chatvars.playerid].trackerSession .. &quot;)&quot;)					
		else
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No player called &quot; .. pname .. &quot; found.[-]&quot;)
		end

		faultyChat = false
		return true
	end

if debug then display (&quot;debug tracker 12\n&quot;) end

	if (chatvars.words[1] == &quot;check&quot;) and (chatvars.words[2] == &quot;bases&quot;) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		igplayers[chatvars.playerid].trackerID = 0
		conn:execute(&quot;DELETE FROM memTracker WHERE admin = &quot; .. chatvars.playerid)
		cursor,errorString = conn:execute(&quot;SELECT steam, homeX, homeY, homeZ, home2X, home2Y, home2Z from players&quot;)

		row = cursor:fetch({}, &quot;a&quot;)
		while row do
			if tonumber(row.homeX) ~= 0 and tonumber(row.homeY) ~= 0 and tonumber(row.homeZ) ~= 0 then
				conn:execute(&quot;INSERT into memTracker (admin, steam, x, y, z, flag) VALUES (&quot; .. chatvars.playerid .. &quot;,&quot; .. row.steam .. &quot;,&quot; .. row.homeX .. &quot;,&quot; .. row.homeY .. &quot;,&quot; .. row.homeZ .. &quot;,'base1')&quot;)
			end

			if tonumber(row.home2X) ~= 0 and tonumber(row.home2Y) ~= 0 and tonumber(row.home2Z) ~= 0 then
				conn:execute(&quot;INSERT into memTracker (admin, steam, x, y, z, flag) VALUES (&quot; .. chatvars.playerid .. &quot;,&quot; .. row.steam .. &quot;,&quot; .. row.home2X .. &quot;,&quot; .. row.home2Y .. &quot;,&quot; .. row.home2Z .. &quot;,'base2')&quot;)
			end

			row = cursor:fetch(row, &quot;a&quot;)	
		end

		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Bases are loaded into the tracker. Use /nb to move forward, /pb to move back and /killbase to remove the current base.[-]&quot;)

		faultyChat = false
		return true
	end

if debug then display (&quot;debug tracker 13\n&quot;) end

	if (chatvars.words[1] == &quot;nb&quot; and chatvars.words[2] == nil) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		igplayers[chatvars.playerid].trackerID = igplayers[chatvars.playerid].trackerID + 1

		cursor,errorString = conn:execute(&quot;select * from memTracker where admin = &quot; .. chatvars.playerid .. &quot; and trackerID &gt; &quot; .. igplayers[chatvars.playerid].trackerID .. &quot; order by trackerID limit 1&quot;)
		row = cursor:fetch({}, &quot;a&quot;)

		if row then
			send(&quot;tele &quot; .. chatvars.playerid .. &quot; &quot; .. row.x .. &quot; &quot; .. row.y .. &quot; &quot; .. row.z)
			igplayers[chatvars.playerid].atBase = row.steam
			igplayers[chatvars.playerid].trackerID = row.trackerID

			if row.flag == &quot;base1&quot; then
				igplayers[chatvars.playerid].whichBase = 1
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is base one of &quot; .. players[igplayers[chatvars.playerid].atBase].name .. &quot;.[-]&quot;)
			else
				igplayers[chatvars.playerid].whichBase = 2
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is base two of &quot; .. players[igplayers[chatvars.playerid].atBase].name .. &quot;.[-]&quot;)
			end
		end

		faultyChat = false
		return true
	end

if debug then display (&quot;debug tracker 14\n&quot;) end

	if (chatvars.words[1] == &quot;pb&quot; and chatvars.words[2] == nil) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		igplayers[chatvars.playerid].trackerID = igplayers[chatvars.playerid].trackerID - 1

		cursor,errorString = conn:execute(&quot;select * from memTracker where admin = &quot; .. chatvars.playerid .. &quot; and trackerID &lt; &quot; .. igplayers[chatvars.playerid].trackerID .. &quot; order by trackerID desc limit 1&quot;)
		row = cursor:fetch({}, &quot;a&quot;)

		if row then
			send(&quot;tele &quot; .. chatvars.playerid .. &quot; &quot; .. row.x .. &quot; &quot; .. row.y .. &quot; &quot; .. row.z)
			igplayers[chatvars.playerid].atBase = row.steam
			igplayers[chatvars.playerid].trackerID = row.trackerID

			if row.flag == &quot;base1&quot; then
				igplayers[chatvars.playerid].whichBase = 1
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is base one of &quot; .. players[igplayers[chatvars.playerid].atBase].name .. &quot;.[-]&quot;)
			else
				igplayers[chatvars.playerid].whichBase = 2
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This is base two of &quot; .. players[igplayers[chatvars.playerid].atBase].name .. &quot;.[-]&quot;)
			end
		else
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have reached the first base.[-]&quot;)
		end

		faultyChat = false
		return true
	end

if debug then display (&quot;debug tracker 15\n&quot;) end

	if (chatvars.words[1] == &quot;killbase&quot; and chatvars.words[2] == nil) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		if igplayers[chatvars.playerid].atBase ~= nil then
			if tonumber(igplayers[chatvars.playerid].whichBase) == 1 then
				players[igplayers[chatvars.playerid].atBase].homeX = 0
				players[igplayers[chatvars.playerid].atBase].homeY = 0
				players[igplayers[chatvars.playerid].atBase].homeZ = 0
				players[igplayers[chatvars.playerid].atBase].protect = false

				conn:execute(&quot;UPDATE players SET homeX = 0, homeY = 0, homeZ = 0, protect = 0  WHERE steam = &quot; .. igplayers[chatvars.playerid].atBase)

				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Base one of &quot; .. players[igplayers[chatvars.playerid].atBase].name .. &quot; has been deleted.[-]&quot;)
			else
				players[igplayers[chatvars.playerid].atBase].home2X = 0
				players[igplayers[chatvars.playerid].atBase].home2Y = 0
				players[igplayers[chatvars.playerid].atBase].home2Z = 0
				players[igplayers[chatvars.playerid].atBase].protect2 = false

				conn:execute(&quot;UPDATE players SET home2X = 0, home2Y = 0, home2Z = 0, protect2 = 0  WHERE steam = &quot; .. igplayers[chatvars.playerid].atBase)

				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Base two of &quot; .. players[igplayers[chatvars.playerid].atBase].name .. &quot; has been deleted.[-]&quot;)
			end
		end

		faultyChat = false
		return true
	end

if debug then display (&quot;debug tracker end\n&quot;) end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_mail</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
mail commands
=============


--]]

function gmsg_mail()
	calledFunction = &quot;gmsg_mail&quot;

	local counter, status, debug, n

	debug = false

if debug then dbug(&quot;debug mail&quot;) end

	-- ###################  do not allow remote commands beyond this point ################
	if (chatvars.playerid == nil) then
		faultyChat = false
		return false
	end
	-- ####################################################################################

	if (chatvars.words[1] == &quot;pm&quot; and chatvars.words[2] ~= nil) then
		msg = string.sub(chatvars.command, 4, string.len(chatvars.command))		

		irc_QueueMsg(server.ircMain, gameDate .. &quot; &quot; .. chatvars.playername .. &quot; said &quot; .. msg)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Your hidden message has been sent to IRC.[-]&quot;)

		faultyChat = false
		return true
	end


	-- ####################################################################################
	-- don't proceed if there is no leading slash or pm
	if (string.sub(chatvars.command, 1, 1) ~= &quot;/&quot;) and not (string.find(chatvars.oldLine, &quot; command 'pm&quot;) or string.find(chatvars.oldLine, &quot; command '@&quot;)) then
		faultyChat = false
		return false
	end
	-- ####################################################################################

if debug then dbug(&quot;debug mail 1&quot;) end

	if (chatvars.words[1] == &quot;read&quot; and chatvars.words[2] == &quot;mail&quot;) then
		counter = 1

		if chatvars.number ~= nil then
			cursor,errorString = conn:execute(&quot;SELECT * FROM mail WHERE recipient = &quot; .. chatvars.playerid)
		else
			cursor,errorString = conn:execute(&quot;SELECT * FROM mail WHERE recipient = &quot; .. chatvars.playerid .. &quot; and status = 0&quot;)
		end

		row = cursor:fetch({}, &quot;a&quot;)
		while row do
			if chatvars.number ~= nil then
				if tonumber(chatvars.number) == counter then
					conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (&quot; .. row.sender .. &quot;,&quot; .. row.recipient .. &quot;,'&quot; .. escape(row.message) .. &quot;')&quot;)
					conn:execute(&quot;UPDATE mail set status = 1 WHERE id = &quot; .. row.id)
				end
			else
				conn:execute(&quot;INSERT INTO messageQueue (sender, recipient, message) VALUES (&quot; .. row.sender .. &quot;,&quot; .. row.recipient .. &quot;,'&quot; .. escape(row.message) .. &quot;')&quot;)
				conn:execute(&quot;UPDATE mail set status = 1 WHERE id = &quot; .. row.id)
			end

			counter = counter + 1
			row = cursor:fetch(row, &quot;a&quot;)	
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug mail 2&quot;) end

	if (chatvars.words[1] == &quot;list&quot; and chatvars.words[2] == &quot;mail&quot;) then
		counter = 1

		cursor,errorString = conn:execute(&quot;SELECT * FROM mail WHERE recipient = &quot; .. chatvars.playerid)
		row = cursor:fetch({}, &quot;a&quot;)
		while row do
			if row.status == &quot;0&quot; then status = &quot; [NEW]&quot; end
			if row.status == &quot;1&quot; then status = &quot; [READ]&quot; end
			if row.status == &quot;2&quot; then status = &quot; [SAVED]&quot; end

			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;](&quot; .. counter .. &quot;)  Message from &quot; .. players[row.sender].name .. status .. &quot; &quot; .. string.sub(row.message, 1, 12) .. &quot;..[-]&quot;)

			counter = counter + 1
			row = cursor:fetch(row, &quot;a&quot;)	
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug mail 3&quot;) end

	if (chatvars.words[1] == &quot;save&quot; and chatvars.words[2] == &quot;mail&quot; and chatvars.number ~= nil) then
		counter = 1

		cursor,errorString = conn:execute(&quot;SELECT * FROM mail WHERE recipient = &quot; .. chatvars.playerid)
		row = cursor:fetch({}, &quot;a&quot;)
		while row do
			if tonumber(chatvars.number) == counter then
				conn:execute(&quot;UPDATE mail SET status = 2 WHERE id = &quot; .. row.id)
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Message (&quot; .. counter .. &quot;) saved.[-]&quot;)

				faultyChat = false
				return true
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug mail 4&quot;) end

	if (chatvars.words[1] == &quot;delete&quot; and chatvars.words[2] == &quot;mail&quot; and chatvars.number ~= nil) then
		counter = 1

		cursor,errorString = conn:execute(&quot;SELECT * FROM mail WHERE recipient = &quot; .. chatvars.playerid)
		row = cursor:fetch({}, &quot;a&quot;)
		while row do
			if tonumber(chatvars.number) == counter then
				conn:execute(&quot;DELETE FROM mail WHERE id = &quot; .. row.id)
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Message (&quot; .. counter .. &quot;) deleted.[-]&quot;)

				faultyChat = false
				return true
			end

			counter = counter + 1
			row = cursor:fetch(row, &quot;a&quot;)	
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug mail 5&quot;) end

	-- ####################################################################################
	-- don't proceed if not using the console
	if not string.find(chatvars.oldLine, &quot; command 'pm&quot;) and not server.coppi then
		faultyChat = false
		return false
	end
	-- ####################################################################################

if debug then dbug(&quot;debug mail 6&quot;) end

	if (string.find(chatvars.words[1], &quot;@&quot;) and chatvars.words[2] ~= nil) then
		pname = string.sub(chatvars.words[1], 2, string.len(chatvars.words[1]))
		pname = string.trim(pname)

		id = LookupPlayer(pname)
		n = string.len(chatvars.wordsOld[1]) + 1
		msg = string.sub(chatvars.oldLine, string.find(chatvars.oldLine, chatvars.wordsOld[1], nil, true) + n), string.len(chatvars.oldLine)

if debug then dbug(&quot;debug mail msg&quot; .. msg) end

		if string.lower(pname) == &quot;admin&quot; or  string.lower(pname) == &quot;admins&quot; then
			for k,v in pairs(players) do
				if accessLevel(k) &lt; 3 then
					if igplayers[k] then
						message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]Message from &quot; .. players[chatvars.playerid].name .. &quot;: &quot; .. msg .. &quot;[-]&quot;)
					else
						conn:execute(&quot;INSERT INTO mail (sender, recipient, message) VALUES (&quot; .. chatvars.playerid .. &quot;,&quot; .. k .. &quot;, '&quot; .. escape(msg) .. &quot;')&quot;)
					end
				end
			end

			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Thank you. An admin will receive your message soon.[-]&quot;)

			faultyChat = false
			return true
		end

		if id ~= nil then
			if isFriend(id, chatvars.playerid) or accessLevel(chatvars.playerid) &lt; 3 then
				if igplayers[id] then
					message(&quot;pm &quot; .. id .. &quot; [&quot; .. server.chatColour .. &quot;]Message from &quot; .. players[chatvars.playerid].name .. &quot;: &quot; .. msg .. &quot;[-]&quot;)
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; has received your message.[-]&quot;)
				else
					conn:execute(&quot;INSERT INTO mail (sender, recipient, message) VALUES (&quot; .. chatvars.playerid .. &quot;,&quot; .. id .. &quot;, '&quot; .. escape(msg) .. &quot;')&quot;)
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; will receive your message when they return.[-]&quot;)
				end
			else
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; has not friended you so you are not allowed to send them private messages yet.[-]&quot;)
			end
		else
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]I do not know a player called &quot; .. pname .. &quot;[-]&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug mail end&quot;) end

end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_friends</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
friend commands
=============


--]]

function gmsg_friends()
	calledFunction = &quot;gmsg_friends&quot;

	local pid, pname, debug

	debug = false

	-- don't proceed if there is no leading slash
	if (string.sub(chatvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyChat = false
		return false
	end


	-- ###################  do not allow remote commands beyond this point ################
	if (chatvars.playerid == nil) then
		faultyChat = false
		return false
	end
	-- ####################################################################################

if debug then display (&quot;debug friends 1\n&quot;) end

	if (chatvars.words[1] == &quot;friend&quot;) then
		pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;friend &quot;) + 7)
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if (id == chatvars.playerid) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]I know you are lonely but you're supposed to make friends with OTHER people.[-]&quot;)
			faultyChat = false
			return true
		end

		-- add to friends table
		if (friends[chatvars.playerid].friends == nil) then
			friends[chatvars.playerid] = {}
			friends[chatvars.playerid].friends = &quot;&quot;
		end

		if (id ~= nil) then
			if (not string.find(friends[chatvars.playerid].friends, players[id].steam)) then
				friends[chatvars.playerid].friends = friends[chatvars.playerid].friends .. players[id].steam .. &quot;,&quot;
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; is now recognised as a friend[-]&quot;)	
				conn:execute(&quot;INSERT INTO friends (steam, friend) VALUES (&quot; .. chatvars.playerid .. &quot;,&quot; .. id .. &quot;)&quot;)
			end
		else
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are already friends with &quot; .. players[id].name .. &quot;.[-]&quot;)		
		end
		
		faultyChat = false
		return true
	end

if debug then display (&quot;debug friends 2\n&quot;) end

	if (chatvars.words[1] == &quot;clear&quot; and chatvars.words[2] == &quot;friends&quot;) then
		if (accessLevel(chatvars.playerid) &lt; 3) then
			pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;friends&quot;) + 8)
			pname = string.trim(pname)
			id = LookupPlayer(pname)

			if id ~= nil then
				-- reset the players friends list
				friends[id] = {}
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Player &quot; .. players[id].name .. &quot; have no friends :([-]&quot;)	

				conn:execute(&quot;DELETE FROM friends WHERE steam = &quot; .. id .. &quot;)&quot;)

				faultyChat = false
				return true
			end
		end

		-- reset the players friends list
		friends[chatvars.playerid] = {}
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have no friends :([-]&quot;)	

		conn:execute(&quot;DELETE FROM friends WHERE steam = &quot; .. chatvars.playerid .. &quot;)&quot;)

		faultyChat = false
		return true
	end

if debug then display (&quot;debug friends 3\n&quot;) end

	if (chatvars.words[1] == &quot;unfriend&quot;) then
		if chatvars.words[2] == nil then
			faultyChat = help(&quot;help friends&quot;, chatvars.playerid)
			return true
		end

		pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;unfriend &quot;) + 9)
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		-- unfriend someone
		if (friends[chatvars.playerid] == nil or friends[chatvars.playerid] == {}) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have no friends :([-]&quot;)	
			faultyChat = false
			return true
		end

		if (id ~= nil) then
			friendlist = string.split(friends[chatvars.playerid].friends, &quot;,&quot;)

			-- now simply rebuild friend skipping over the one we are removing
			friends[chatvars.playerid].friends = &quot;&quot;
			for i=1,table.maxn(friendlist),1 do
				if (friendlist[i] ~= players[id].steam) and friendlist[i] ~= &quot;&quot; then
					friends[chatvars.playerid].friends = friends[chatvars.playerid].friends .. friendlist[i] .. &quot;,&quot;
				end
			end
		
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are not friends with &quot; .. players[id].name .. &quot;[-]&quot;)	
			conn:execute(&quot;DELETE FROM friends WHERE steam = &quot; .. chatvars.playerid .. &quot; AND friend = &quot; .. id .. &quot;)&quot;)
		end

		faultyChat = false
		return true
	end

if debug then display (&quot;debug friends 4\n&quot;) end

	if (chatvars.words[1] == &quot;friendme&quot;) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;friendme &quot;) + 9)
		pname = string.trim(pname)
		id = LookupPlayer(pname)

		if (id ~= nil) then
			if (not isFriend(id, chatvars.playerid)) then
				friends[id].friends = friends[id].friends .. &quot;,&quot; .. chatvars.playerid
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot; now lists you as a friend.[-]&quot;)	
				conn:execute(&quot;INSERT INTO friends (steam, friend) VALUES (&quot; .. id .. &quot;,&quot; .. chatvars.playerid .. &quot;)&quot;)

				faultyChat = false
				return true
			end
		else
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are already a friend of &quot; .. players[id].name .. &quot;.[-]&quot;)		
		end	
	end

if debug then display (&quot;debug friends 5\n&quot;) end

	if (chatvars.words[1] == &quot;unfriendme&quot;) then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		id = 0

		if chatvars.words[2] ~= &quot;everyone&quot; then
			pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;unfriendme &quot;) + 12)
			pname = string.trim(pname)
			id = LookupPlayer(pname)
		end

		for k, v in pairs(friends) do
			if (k == id) or chatvars.words[2] == &quot;everyone&quot; then
				friendlist = string.split(friends[k].friends, &quot;,&quot;)

				-- now simply rebuild friend skipping over the one we are removing
				friends[k].friends = &quot;&quot;
				for i=1,table.maxn(friendlist),1 do
					if (friendlist[i] ~= chatvars.playerid) then
						friends[k].friends = friends[k].friends .. friendlist[i] .. &quot;,&quot;
					end
				end
				
				if (k == id) then			
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are off &quot; .. players[id].name .. &quot;'s friends list.[-]&quot;)	
					conn:execute(&quot;DELETE FROM friends WHERE steam = &quot; .. k .. &quot; AND friend = &quot; .. chatvars.playerid .. &quot;)&quot;)
					faultyChat = false		
					return true
				end
			end
		end
		
		if (chatvars.words[2] == &quot;everyone&quot;) then			
			conn:execute(&quot;DELETE FROM friends WHERE friend = &quot; .. chatvars.playerid .. &quot;)&quot;)
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are off everyones friends list.[-]&quot;)	
			faultyChat = false		
			return true
		end	
	end

if debug then display (&quot;debug friends 6\n&quot;) end

	if (chatvars.words[1] == &quot;friends&quot;) then	
		pid = chatvars.playerid

		if accessLevel(chatvars.playerid) &gt; 2  and chatvars.words[2] ~= nil then
			faultyChat = false
			return true
		end

		if accessLevel(chatvars.playerid) &lt; 3  and chatvars.words[2] ~= nil then
			pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;friends&quot;) + 8, string.len(chatvars.command))
			pid = LookupPlayer(pname)
		end

		-- pm a list of all the players friends
		if (friends[pid] == nil) then
			if (pid == chatvars.playerid) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You have no friends :([-]&quot;)	
			else
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[pid].name .. &quot;  has no friends.[-]&quot;)	
			end

			faultyChat = false
			return true
		end

		friendlist = string.split(friends[pid].friends, &quot;,&quot;)

		if (pid == chatvars.playerid) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You are friends with..[-]&quot;)
		else
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[pid].name .. &quot; is friends with..[-]&quot;)
		end

		for i=1,table.maxn(friendlist),1 do
			if (friendlist[i] ~= &quot;&quot;) then
				id = LookupPlayer(friendlist[i])
				if id ~= nil then
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[id].name .. &quot;[-]&quot;)	
				end
			end
		end		
		
		faultyChat = false
		return true
	end

if debug then display (&quot;debug friends end\n&quot;) end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>Load Lua Tables</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function loadServer()
	calledFunction = &quot;loadServer&quot;

	-- load server
	getTableFields(&quot;server&quot;)

	server = {}

	cursor,errorString = conn:execute(&quot;select * from server&quot;)
	rows = tonumber(cursor:numrows())

	if rows == 0 then
		initServer()
	else
		row = cursor:fetch({}, &quot;a&quot;)
		
		server.botName = row.botName
		server.windowGMSG = row.windowGMSG
		server.windowAlerts = row.windowAlerts
		server.windowDebug = row.windowDebug
		server.windowLists = row.windowLists
		server.windowPlayers = row.windowPlayers
		server.ServerPort = row.ServerPort
		server.allowGimme = dbTrue(row.allowGimme)
		server.mapSize = tonumber(row.mapSize)
		server.prisonSize = tonumber(row.prisonSize)
		server.MOTD = row.MOTD
		server.IP = row.IP
		server.lottery = tonumber(row.lottery)
		server.allowShop = dbTrue(row.allowShop)
		server.allowWaypoints = dbTrue(row.allowWaypoints)
		server.ircAlerts = row.ircAlerts
		server.ircMain = row.ircMain
		server.ircWatch = row.ircWatch
		server.ircTracker = row.ircTracker
		server.chatColour = row.chatColour
		server.maxPlayers = tonumber(row.maxPlayers)
		server.maxServerUptime = tonumber(row.maxServerUptime)
		server.baseSize = tonumber(row.baseSize)
		server.baseCooldown = tonumber(row.baseCooldown)
		server.protectionMaxDays = tonumber(row.protectionMaxDays)
		server.ircBotName = row.ircBotName
		server.ServerName = row.serverName
		server.rules = row.rules
		server.shopCountdown = tonumber(row.shopCountdown)
		server.gimmePeace = dbTrue(row.gimmePeace)
		server.lastDailyReboot = tonumber(row.lastDailyReboot)
		server.allowNumericNames = dbTrue(row.allowNumericNames)
		server.allowGarbageNames = dbTrue(row.allowGarbageNames)
		server.allowReboot = dbTrue(row.allowReboot)
		server.newPlayerTimer = tonumber(row.newPlayerTimer)
		server.blacklistResponse = row.blacklistResponse
		server.gameDay = tonumber(row.gameDay)
		server.shopLocation = row.shopLocation
		server.website = row.website
		server.ircServer = row.ircServer
		server.pingKick = tonumber(row.pingKick)
		server.gameType = row.gameType
		server.hideCommands = dbTrue(row.hideCommands)
		server.serverGroup = row.serverGroup
		server.botID = tonumber(row.botID)
		server.allowOverstacking = dbTrue(row.allowOverstacking)
		server.announceTeleports = dbTrue(row.announceTeleports)
		server.blockCountries = row.blockCountries
		server.allowPhysics = dbTrue(row.allowPhysics)
		server.northeastZone = row.northeastZone
		server.northwestZone = row.northwestZone
		server.southeastZone = row.southeastZone
		server.southwestZone = row.southwestZone
		server.playersCanFly = dbTrue(row.playersCanFly)
		server.accessLevelOverride = tonumber(row.accessLevelOverride)
		server.disableBaseProtection = dbTrue(row.disableBaseProtection)
		server.packCooldown = tonumber(row.packCooldown)
		server.allowBank = dbTrue(row.allowBank)
		server.moneyName = row.moneyName
		server.overstackThreshold = tonumber(row.overstackThreshold)
		server.enableRegionPM = dbTrue(row.enableRegionPM)
		server.allowRapidRelogging = dbTrue(row.allowRapidRelogging)
		server.allowLottery = dbTrue(row.allowLottery)
		server.lotteryMultiplier = tonumber(row.lotteryMultiplier)
		server.zombieKillReward = tonumber(row.zombieKillReward)
	end

	-- set up other initial states
	server.ignoreAdmins = true
	server.uptime = os.time()
	server.coppi = false
end


function loadPlayers(steam)
	local word, words, rdate, ryear, rmonth, rday, rhour, rmin, rsec

	-- load players table
	getTableFields(&quot;players&quot;)

	if steam == nil then 
		players = {} 
		cursor,errorString = conn:execute(&quot;select * from players&quot;)
	else
		cursor,errorString = conn:execute(&quot;select * from players where steam = &quot; .. steam)
	end

	row = cursor:fetch({}, &quot;a&quot;)
	while row do		
		players[row.steam] = {}

		players[row.steam].silentBob = dbTrue(row.silentBob)
		players[row.steam].walkies = dbTrue(row.walkies)
		players[row.steam].steam = row.steam
		players[row.steam].name = row.name
		players[row.steam].id = row.id
		players[row.steam].xPos = tonumber(row.xPos)
		players[row.steam].yPos = tonumber(row.yPos)
		players[row.steam].zPos = tonumber(row.zPos)
		players[row.steam].xPosOld = tonumber(row.xPosOld)
		players[row.steam].yPosOld = tonumber(row.yPosOld)
		players[row.steam].zPosOld = tonumber(row.zPosOld)
		players[row.steam].xPosTimeout = tonumber(row.xPosTimeout)
		players[row.steam].yPosTimeout = tonumber(row.yPosTimeout)
		players[row.steam].zPosTimeout = tonumber(row.zPosTimeout)
		players[row.steam].homeX = tonumber(row.homeX)
		players[row.steam].homeY = tonumber(row.homeY)
		players[row.steam].homeZ = tonumber(row.homeZ)
		players[row.steam].home2X = tonumber(row.home2X)
		players[row.steam].home2Y = tonumber(row.home2Y)
		players[row.steam].home2Z = tonumber(row.home2Z)
		players[row.steam].exitX = tonumber(row.exitX)
		players[row.steam].exitY = tonumber(row.exitY)
		players[row.steam].exitZ = tonumber(row.exitZ)
		players[row.steam].exit2X = tonumber(row.exit2X)
		players[row.steam].exit2Y = tonumber(row.exit2Y)
		players[row.steam].exit2Z = tonumber(row.exit2Z)
		players[row.steam].level = tonumber(row.level)
		players[row.steam].cash = tonumber(row.cash)
		players[row.steam].pvpBounty = tonumber(row.pvpBounty)
		players[row.steam].zombies = tonumber(row.zombies)
		players[row.steam].score = tonumber(row.score)
		players[row.steam].playerKills = tonumber(row.playerKills)
		players[row.steam].deaths = tonumber(row.deaths)
		players[row.steam].protectSize = tonumber(row.protectSize)
		players[row.steam].protect2Size = tonumber(row.protect2Size)
		players[row.steam].sessionCount = tonumber(row.sessionCount)
		players[row.steam].timeOnServer = tonumber(row.timeOnServer)
		players[row.steam].firstSeen = tonumber(row.firstSeen)
		players[row.steam].keystones = tonumber(row.keystones)
		players[row.steam].overstackTimeout = dbTrue(row.overstackTimeout)
		players[row.steam].overstack = dbTrue(row.overstack)
		players[row.steam].shareWaypoint = dbTrue(row.shareWaypoint)
		players[row.steam].watchCash = dbTrue(row.watchCash)
		players[row.steam].watchPlayer = dbTrue(row.watchPlayer)
		players[row.steam].timeout = dbTrue(row.timeout)
		players[row.steam].denyRights = dbTrue(row.denyRights)
		players[row.steam].botTimeout = dbTrue(row.botTimeout)
		players[row.steam].newPlayer = dbTrue(row.newPlayer)
		players[row.steam].IP = row.IP
		players[row.steam].seen = row.seen
		players[row.steam].baseCooldown = tonumber(row.baseCooldown)
		players[row.steam].ircAlias = row.ircAlias
		players[row.steam].ircPass = row.ircPass
		players[row.steam].bed = row.bed
		players[row.steam].donor = dbTrue(row.donor)
		players[row.steam].playtime = tonumber(row.playtime)
		players[row.steam].protect = dbTrue(row.protect)
		players[row.steam].protect2 = dbTrue(row.protect2)
		players[row.steam].tokens = tonumber(row.tokens)
		players[row.steam].exile = dbTrue(row.exile)
		players[row.steam].translate = dbTrue(row.translate)
		players[row.steam].prisoner = dbTrue(row.prisoner)
		players[row.steam].prisonReason = row.prisonReason
		players[row.steam].prisonxPosOld = tonumber(row.prisonxPosOld)
		players[row.steam].prisonyPosOld = tonumber(row.prisonyPosOld)
		players[row.steam].prisonzPosOld = tonumber(row.prisonzPosOld)
		players[row.steam].permanentBan = dbTrue(row.permanentBan)
		players[row.steam].whitelisted = dbTrue(row.whitelisted)
		players[row.steam].aliases = row.aliases
		players[row.steam].pvpVictim = row.pvpVictim
		players[row.steam].location = row.location
		players[row.steam].canTeleport = dbTrue(row.canTeleport)
		players[row.steam].allowBadInventory = dbTrue(row.allowBadInventory)
		players[row.steam].ircTranslate = dbTrue(row.ircTranslate)
		players[row.steam].noSpam = dbTrue(row.noSpam)
		players[row.steam].waypointX = tonumber(row.waypointX)
		players[row.steam].waypointY = tonumber(row.waypointY)
		players[row.steam].waypointZ = tonumber(row.waypointZ)
		players[row.steam].accessLevel = tonumber(row.accessLevel)
		players[row.steam].country = row.country
		players[row.steam].ping = tonumber(row.ping)
		players[row.steam].donorLevel = tonumber(row.donorLevel)
		players[row.steam].autoFriend = row.autoFriend
		players[row.steam].bedX = tonumber(row.bedX)
		players[row.steam].bedY = tonumber(row.bedY)
		players[row.steam].bedZ = tonumber(row.bedZ)
		players[row.steam].showLocationMessages = dbTrue(row.showLocationMessages)
		players[row.steam].mute = dbTrue(row.mute)

		-- convert donorExpiry to a timestamp
		words = {}
		for word in row.donorExpiry:gmatch(&quot;%w+&quot;) do table.insert(words, word) end

		ryear = words[1]
		rmonth = words[2]
		rday = words[3]
		rhour = words[4]
		rmin = words[5]
		rsec = words[6]

		rdate = {year=ryear, month=rmonth, day=rday, hour=rhour, min=rmin, sec=rsec}
		players[row.steam].donorExpiry = os.time(rdate)

		if tonumber(row.accessLevel) &lt; 3 then
			-- add the steamid to the admins table
			if tonumber(row.accessLevel) == 0 then
				owners[players[row.steam].steam] = {}
			end

			if tonumber(row.accessLevel) == 1 then
				admins[players[row.steam].steam] = {}
			end

			if tonumber(row.accessLevel) == 2 then
				mods[players[row.steam].steam] = {}
			end
		end

		row = cursor:fetch(row, &quot;a&quot;)	
	end
end


function loadShopCategories()
	-- load shop categories
   shopCategories = {}
	getTableFields(&quot;shopCategories&quot;)

	cursor,errorString = conn:execute(&quot;select * from shopCategories&quot;)

	-- add the misc category so it always exists
	if cursor:numrows() &gt; 0 then
		shopCategories[&quot;misc&quot;] = {}
		shopCategories[&quot;misc&quot;].idx = 1
		shopCategories[&quot;misc&quot;].code = &quot;misc&quot;
	end

	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		shopCategories[row.category] = {}
		shopCategories[row.category].idx = row.idx
		shopCategories[row.category].code = row.code
		row = cursor:fetch(row, &quot;a&quot;)	
	end
end


function loadResetZones()
	-- load reset zones
   resetRegions = {}
	getTableFields(&quot;resetZones&quot;)

	cursor,errorString = conn:execute(&quot;select * from resetZones&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		resetRegions[row.region] = {}
		row = cursor:fetch(row, &quot;a&quot;)	
	end
end


function loadTeleports(tp)
	-- load teleports
	getTableFields(&quot;teleports&quot;)

	if tp == nil then teleports = {} end

	cursor,errorString = conn:execute(&quot;select * from teleports&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		if tp == row.name or tp == nil then
			teleports[row.name] = {}
			teleports[row.name].id = row.id
			teleports[row.name].active = dbTrue(row.active)
			teleports[row.name].oneway = dbTrue(row.oneway)
			teleports[row.name].public = dbTrue(row.public)
			teleports[row.name].friends = dbTrue(row.friends)
			teleports[row.name].x = tonumber(row.x)
			teleports[row.name].y = tonumber(row.y)
			teleports[row.name].z = tonumber(row.z)
			teleports[row.name].dx = tonumber(row.dx)
			teleports[row.name].dy = tonumber(row.dy)
			teleports[row.name].dz = tonumber(row.dz)
			teleports[row.name].name = row.name
			teleports[row.name].owner = row.owner
			row = cursor:fetch(row, &quot;a&quot;)	
		end
	end
end


function loadLocations(loc)
	-- load locations
	getTableFields(&quot;locations&quot;)

	if loc == nil then locations = {} end

	cursor,errorString = conn:execute(&quot;select * from locations&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		if loc == row.name or loc == nil then
			locations[row.name] = {}
			locations[row.name].name = row.name
			locations[row.name].active = dbTrue(row.active)
			locations[row.name].protect = dbTrue(row.protected)
			locations[row.name].public = dbTrue(row.public)
			locations[row.name].resetZone = dbTrue(row.resetZone)
			locations[row.name].village = dbTrue(row.village)
			locations[row.name].allowbase = dbTrue(row.allowbase)
			locations[row.name].pvp = dbTrue(row.pvp)
			locations[row.name].x = tonumber(row.x)
			locations[row.name].y = tonumber(row.y)
			locations[row.name].z = tonumber(row.z)
			locations[row.name].exitX = tonumber(row.exitX)
			locations[row.name].exitY = tonumber(row.exitY)
			locations[row.name].exitZ = tonumber(row.exitZ)
			locations[row.name].owner = row.owner
			locations[row.name].protectSize = tonumber(row.protectSize)
			locations[row.name].cost = tonumber(row.cost)
			locations[row.name].currency = row.currency
			locations[row.name].accessLevel = tonumber(row.accessLevel)
			locations[row.name].size = tonumber(row.size)
			locations[row.name].miniGame = row.miniGame
			locations[row.name].mayor = row.mayor
			locations[row.name].other = row.other -- used with miniGame
			locations[row.name].killZombies = dbTrue(row.killZombies)
		end

		row = cursor:fetch(row, &quot;a&quot;)	
	end
end


function loadBadItems()
	-- load badItems
	getTableFields(&quot;badItems&quot;)

   badItems = {}
	cursor,errorString = conn:execute(&quot;select * from badItems&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		badItems[row.item] = {}
		badItems[row.item].item = row.item
		badItems[row.item].action = row.action
		row = cursor:fetch(row, &quot;a&quot;)	
	end
end


function loadRestrictedItems()
	-- load restrictedItems
	getTableFields(&quot;restrictedItems&quot;)

   restrictedItems = {}
	cursor,errorString = conn:execute(&quot;select * from restrictedItems&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		restrictedItems[row.item] = {}
		restrictedItems[row.item].qty = tonumber(row.qty)
		restrictedItems[row.item].accessLevel = tonumber(row.accessLevel)
		restrictedItems[row.item].action = row.action
		row = cursor:fetch(row, &quot;a&quot;)	
	end
end


function loadFriends()
	-- load friends
	getTableFields(&quot;friends&quot;)

   friends = {}
	cursor,errorString = conn:execute(&quot;select * from friends&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		if friends[row.steam] == nil then
			friends[row.steam] = {}
			friends[row.steam].friends = &quot;&quot;
		end

		if friends[row.steam].friends == &quot;&quot; then
			friends[row.steam].friends = row.friend
		else
			friends[row.steam].friends = friends[row.steam].friends .. &quot;,&quot; .. row.friend .. &quot;,&quot;
		end

		row = cursor:fetch(row, &quot;a&quot;)	
	end
end


function loadHotspots()
	local idx, nextidx

	-- load hotspots
	getTableFields(&quot;hotspots&quot;)

	nextidx = -1
   hotspots = {}
	cursor,errorString = conn:execute(&quot;select * from hotspots&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		idx = tonumber(row.idx)

		if idx == 0 then
			if nextidx == -1 then
				idx = 1
				nextidx = 2
			else
				idx = nextidx
				nextidx = nextidx + 1
			end

			conn:execute(&quot;update hotspots set idx = &quot; .. idx .. &quot; where id = &quot; .. row.id)
		end

		hotspots[idx] = {}
		hotspots[idx].hotspot = row.hotspot
		hotspots[idx].x = row.x
		hotspots[idx].y = row.y
		hotspots[idx].z = row.z
		hotspots[idx].size = row.size
		hotspots[idx].owner = row.owner
		row = cursor:fetch(row, &quot;a&quot;)	
	end
end


function loadVillagers()
	-- load villagers
	getTableFields(&quot;villagers&quot;)

   villagers = {}
	cursor,errorString = conn:execute(&quot;select * from villagers&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		villagers[row.steam .. row.village] = {}
		villagers[row.steam .. row.village].steam = row.steam
		villagers[row.steam .. row.village].village = row.village
		row = cursor:fetch(row, &quot;a&quot;)	
	end
end


function loadCustomMessages()
	-- load customMessages
	getTableFields(&quot;customMessages&quot;)

   customMessages = {}
	cursor,errorString = conn:execute(&quot;select * from customMessages&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		customMessages[row.command] = {}
		customMessages[row.command].message = row.message
		customMessages[row.command].accessLevel = row.accessLevel
		row = cursor:fetch(row, &quot;a&quot;)	
	end
end


function loadProxies()
	local proxy

	-- load proxies
	getTableFields(&quot;proxies&quot;)

   proxies = {}
	cursor,errorString = conn:execute(&quot;select * from proxies&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		proxy = string.trim(row.scanString)
		proxies[proxy] = {}
		proxies[proxy].scanString = proxy
		proxies[proxy].action = row.action
		proxies[proxy].hits = row.hits
		row = cursor:fetch(row, &quot;a&quot;)	
	end

	if db2Connected then
		-- check for new proxies in the bots db
		cursor,errorString = connBots:execute(&quot;select * from proxies&quot;)
		row = cursor:fetch({}, &quot;a&quot;)
		while row do
			proxy = string.trim(row.scanString)

			if not proxies[proxy] then
				proxies[proxy] = {}
				proxies[proxy].scanString = proxy
				proxies[proxy].action = row.action
				proxies[proxy].hits = 0

				conn:execute(&quot;INSERT INTO proxies (scanString, action, hits) VALUES ('&quot; .. escape(proxy) .. &quot;','&quot; .. escape(row.action) .. &quot;',0)&quot;)
			end

			row = cursor:fetch(row, &quot;a&quot;)	
		end
	end
end


function loadTables()
	dbug(&quot;loading players&quot;)
	loadPlayers()
	dbug(&quot;loaded players&quot;)

	loadResetZones()
	dbug(&quot;loaded reset zones&quot;)

	loadTeleports()
	dbug(&quot;loaded teleports&quot;)

	loadLocations()
	dbug(&quot;loaded locations&quot;)

	loadBadItems()
	dbug(&quot;loaded bad items&quot;)

	loadRestrictedItems()
	dbug(&quot;loaded restricted items&quot;)

	loadFriends()
	dbug(&quot;loaded friends&quot;)

	loadHotspots()
	dbug(&quot;loaded hotspots&quot;)

	loadVillagers()
	dbug(&quot;loaded villagers&quot;)

	loadShopCategories()
	dbug(&quot;loaded shop categories&quot;)

	loadCustomMessages()
	dbug(&quot;loaded custom messages&quot;)

	loadProxies()
	dbug(&quot;loaded proxies&quot;)
end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>Save DB Tables</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function updatePlayer(steam)
	fixMissingPlayer(steam)

	-- update the db
	fields = {}
	values = {}
--dbug(&quot;update player &quot; .. steam)
	table.insert(fields, &quot;steamOwner&quot;)
	table.insert(values, players[steam].steamOwner)

	table.insert(fields, &quot;xpos&quot;)
	table.insert(values, players[steam].xPos)

	table.insert(fields, &quot;ypos&quot;)
	table.insert(values, players[steam].yPos)

	table.insert(fields, &quot;zpos&quot;)
	table.insert(values, players[steam].zPos)

	table.insert(fields, &quot;homex&quot;)
	table.insert(values, players[steam].homeX)

	table.insert(fields, &quot;homey&quot;)
	table.insert(values, players[steam].homeY)

	table.insert(fields, &quot;homez&quot;)
	table.insert(values, players[steam].homeZ)

	table.insert(fields, &quot;home2x&quot;)
	table.insert(values, players[steam].home2X)

	table.insert(fields, &quot;home2y&quot;)
	table.insert(values, players[steam].home2Y)

	table.insert(fields, &quot;home2z&quot;)
	table.insert(values, players[steam].home2Z)

	table.insert(fields, &quot;exitx&quot;)
	table.insert(values, players[steam].exitX)

	table.insert(fields, &quot;exity&quot;)
	table.insert(values, players[steam].exitY)

	table.insert(fields, &quot;exitz&quot;)
	table.insert(values, players[steam].exitZ)

	table.insert(fields, &quot;exit2x&quot;)
	table.insert(values, players[steam].exit2X)

	table.insert(fields, &quot;exit2y&quot;)
	table.insert(values, players[steam].exit2Y)

	table.insert(fields, &quot;exit2z&quot;)
	table.insert(values, players[steam].exit2Z)

	table.insert(fields, &quot;xposold&quot;)
	table.insert(values, players[steam].xPosOld)

	table.insert(fields, &quot;yposold&quot;)
	table.insert(values, players[steam].yPosOld)

	table.insert(fields, &quot;zposold&quot;)
	table.insert(values, players[steam].zPosOld)

	table.insert(fields, &quot;timeonserver&quot;)
	table.insert(values, players[steam].timeOnServer)

	table.insert(fields, &quot;seen&quot;)
	table.insert(values, players[steam].seen)

	table.insert(fields, &quot;playerkills&quot;)
	table.insert(values, players[steam].playerKills)

	table.insert(fields, &quot;deaths&quot;)
	table.insert(values, players[steam].deaths)

	table.insert(fields, &quot;zombies&quot;)
	table.insert(values, players[steam].zombies)

	table.insert(fields, &quot;level&quot;)
	table.insert(values, players[steam].level)

	if tonumber(players[steam].ping) &gt; 0 then
		table.insert(fields, &quot;ping&quot;)
		table.insert(values, players[steam].ping)
	end

	table.insert(fields, &quot;score&quot;)
	table.insert(values, players[steam].score)

	table.insert(fields, &quot;tokens&quot;)
	table.insert(values, players[steam].tokens)

	table.insert(fields, &quot;basecooldown&quot;)
	table.insert(values, players[steam].baseCooldown)

	table.insert(fields, &quot;cash&quot;)
	table.insert(values, players[steam].cash)

	table.insert(fields, &quot;sessionCount&quot;)
	table.insert(values, players[steam].sessionCount)

	table.insert(fields, &quot;waypointx&quot;)
	table.insert(values, players[steam].waypointX)

	table.insert(fields, &quot;waypointy&quot;)
	table.insert(values, players[steam].waypointY)

	table.insert(fields, &quot;waypointz&quot;)
	table.insert(values, players[steam].waypointZ)

	table.insert(fields, &quot;accesslevel&quot;)
	table.insert(values, accessLevel(steam))

	table.insert(fields, &quot;protectsize&quot;)
	table.insert(values, players[steam].protectSize)

	table.insert(fields, &quot;protect2size&quot;)
	table.insert(values, players[steam].protect2Size)

	table.insert(fields, &quot;keystones&quot;)
	table.insert(values, players[steam].keystones)

	table.insert(fields, &quot;donor&quot;)
	table.insert(values, players[steam].donor)

	table.insert(fields, &quot;walkies&quot;)
	table.insert(values, players[steam].walkies)

	table.insert(fields, &quot;protect&quot;)
	table.insert(values, players[steam].protect)

	table.insert(fields, &quot;protect2&quot;)
	table.insert(values, players[steam].protect2)

	table.insert(fields, &quot;timeout&quot;)
	table.insert(values, players[steam].timeout)

	table.insert(fields, &quot;bottimeout&quot;)
	table.insert(values, players[steam].botTimeout)

	table.insert(fields, &quot;newplayer&quot;)
	table.insert(values, players[steam].newPlayer)

	table.insert(fields, &quot;prisoner&quot;)
	table.insert(values, players[steam].prisoner)

	table.insert(fields, &quot;sharewaypoint&quot;)
	table.insert(values, players[steam].shareWaypoint)

	table.insert(fields, &quot;canteleport&quot;)
	table.insert(values, players[steam].canTeleport)

	table.insert(fields, &quot;country&quot;)
	table.insert(values, players[steam].country)

	table.insert(fields, &quot;donorlevel&quot;)
	table.insert(values, players[steam].donorLevel)

	table.insert(fields, &quot;donorexpiry&quot;)
	table.insert(values, players[steam].donorExpiry)

	table.insert(fields, &quot;autofriend&quot;)
	table.insert(values, players[steam].autoFriend)

	table.insert(fields, &quot;ip&quot;)
	table.insert(values, players[steam].IP)

	table.insert(fields, &quot;bedx&quot;)
	table.insert(values, players[steam].bedX)

	table.insert(fields, &quot;bedy&quot;)
	table.insert(values, players[steam].bedY)

	table.insert(fields, &quot;bedz&quot;)
	table.insert(values, players[steam].bedZ)

	table.insert(fields, &quot;silentbob&quot;)
	table.insert(values, players[steam].silentBob)

--debugdb = true
	savePlayer(steam, fields, values)
debugdb = false
end


function getServerFields()
	local field

	--function inspect the server table and store field names and types
	serverFields = {}

	cursor,errorString = conn:execute(&quot;SHOW FIELDS FROM server&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		field = string.lower(row.Field)

		serverFields[field] = {}
		serverFields[field].type = string.sub(row.Type, 1,3)
		row = cursor:fetch(row, &quot;a&quot;)	
	end
end

--[[
	-- typical use
	fields = {}
	values = {}
	table.insert(fields, &quot;LootRespawnDays&quot;)
	table.insert(values, number)
	saveServer(fields, values)
--]]

function saveServer(fields, values)
	local i, sql

	if debugdb then
		dbug(&quot;saving to server table&quot;)
	end

	if serverFields == nil then
		getServerFields()
	end

	sql = &quot;UPDATE server SET&quot;

	for i=1,table.maxn(fields),1 do
		fields[i] = string.lower(fields[i])

		if serverFields[fields[i]].type == &quot;var&quot; then
			values[i] = &quot;'&quot; .. escape(values[i]) .. &quot;'&quot;
		end

		if serverFields[fields[i]].type == &quot;tin&quot; then
			if values[i] == true then values[i] = 1 end
			if values[i] == false then values[i] = 0 end
		end

		sql = sql .. &quot; &quot; .. fields[i] .. &quot;=&quot; .. values[i] .. &quot;,&quot;
	end

	sql = string.sub(sql, 1, string.len(sql) - 1)

	if debugdb then
		dbug(&quot;save server &quot; .. sql)
	end

	status, errorString = conn:execute(sql)

	if status == 0 then
		if debugdb then
			dbug(&quot;save server failed&quot;)
		end

		return false -- update failed
	else
		if debugdb then
			dbug(&quot;save server success&quot;)
		end

		return true -- update success
	end
end


function getPlayerFields()
	local field

	--function inspect the player table and store field names and types
	playerFields = {}

	cursor,errorString = conn:execute(&quot;SHOW FIELDS FROM players&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		field = string.lower(row.Field)

		playerFields[field] = {}
		playerFields[field].type = string.sub(row.Type, 1,3)
		row = cursor:fetch(row, &quot;a&quot;)	
	end
end


function savePlayer(steam, fields, values, action)
--[[
	-- typical use
	fields = {}
	values = {}
	table.insert(fields, &quot;LootRespawnDays&quot;)
	table.insert(values, number)
	savePlayer(&quot;1234&quot;, fields, values)
--]]

	if debugdb then
		dbug(&quot;saving player &quot; .. steam)
		display(fields)
		display(values)
	end

	local i, sql, sqlValues, status, errorString

	if playerFields == nil then
		getPlayerFields()
	end

	if action == nil then
		sql = &quot;UPDATE players SET&quot;

		for i=1,table.maxn(fields),1 do
			fields[i] = string.lower(fields[i])

			if playerFields[fields[i]].type == &quot;var&quot; then
				values[i] = &quot;'&quot; .. escape(values[i]) .. &quot;'&quot;
			end

			if playerFields[fields[i]].type == &quot;tin&quot; then
				if values[i] == true then values[i] = 1 end
				if values[i] == false then values[i] = 0 end
			end

			if playerFields[fields[i]].type == &quot;tim&quot; then
				values[i] = &quot;'&quot; .. os.date(&quot;%Y-%m-%d %H:%M:%S&quot;, values[i]) .. &quot;'&quot;
			end

			sql = sql .. &quot; &quot; .. fields[i] .. &quot;=&quot; .. values[i] .. &quot;,&quot;
		end

		sql = string.sub(sql, 1, string.len(sql) - 1)
		sql = sql .. &quot; WHERE steam = '&quot; .. steam .. &quot;'&quot;
	else
		sql = &quot;INSERT INTO players (&quot;
		sqlValues = &quot; VALUES (&quot;

		for i=1,table.maxn(fields),1 do
			fields[i] = string.lower(fields[i])

			if playerFields[fields[i]].type == &quot;var&quot; then
				values[i] = &quot;'&quot; .. escape(values[i]) .. &quot;'&quot;
			end

			if playerFields[fields[i]].type == &quot;tin&quot; then
				if values[i] == true then values[i] = 1 end
				if values[i] == false then values[i] = 0 end
			end
			if playerFields[fields[i]].type == &quot;tim&quot; then
				values[i] = &quot;'&quot; .. os.date(&quot;%Y-%m-%d %H:%M:%S&quot;, values[i]) .. &quot;'&quot;
			end

			sql = sql .. &quot; &quot; .. fields[i] .. &quot;,&quot;
			sqlValues = sqlValues .. values[i] .. &quot;,&quot;
		end

		sql = string.sub(sql, 1, string.len(sql) - 1) .. &quot;)&quot;
		sqlValues = string.sub(sqlValues, 1, string.len(sqlValues) - 1) .. &quot;)&quot;
		sql = sql .. sqlValues
	end

	if debugdb then
		dbug(&quot;save player sql &quot; .. sql)
	end

	status, errorString = conn:execute(sql)

	if status == 0 then
		if debugdb then
			dbug(&quot;save player success&quot;)
		end

		return false -- no record changed
	else
		if debugdb then
			dbug(&quot;save player success&quot;)
			dbug(&quot;save player sql &quot; .. sql)
		end

		return true -- record inserted/updated
	end
end


function getTableFields(table)
	--function inspect the table and store field names and types
	if type(tableFields) ~= &quot;table&quot; then
		tableFields = {}
	end

	tableFields[table] = {}
	tableFields[table].fields = {}
	tableFields[table].types = {}

	cursor,errorString = conn:execute(&quot;SHOW FIELDS FROM &quot; .. table)
	row = cursor:fetch({}, &quot;a&quot;)
	while row do
		tableFields[table].fields[#tableFields[table].fields+1] = {string.lower(row.Field)}
		tableFields[table].types[#tableFields[table].types+1] = {string.lower(string.sub(row.Type, 1,3))}
		row = cursor:fetch(row, &quot;a&quot;)	
	end
end


function saveTable(table, fields, values, condition)
-- This function does updates only, no inserts
	local i, sql

--[[
	-- typical use
	fields = {}
	values = {}
	table.insert(fields, &quot;LootRespawnDays&quot;)
	table.insert(values, number)
	saveTable(&quot;server&quot;, fields, values, &quot;test = true&quot;)
--]]

	if debugdb then
		dbug(&quot;saving to table &quot; .. table)
	end

	if tableFields[table] == nil then
		getTableFields(table)
	end

	sql = &quot;UPDATE &quot; .. table .. &quot; SET&quot;

	for i=1,table.maxn(fields),1 do
		fields[i] = string.lower(fields[i])

		if tableFields[table].fields[i].type == &quot;var&quot; then
			values[i] = &quot;'&quot; .. escape(values[i]) .. &quot;'&quot;
		end

		if tableFields[fields[i]].type == &quot;tin&quot; then
			if values[i] == true then values[i] = 1 end
			if values[i] == false then values[i] = 0 end
		end

		if 	sql == &quot;UPDATE &quot; .. table .. &quot; SET&quot; then
			sql = sql .. &quot; &quot; .. fields[i] .. &quot;=&quot; .. values[i]
		else
			sql = sql .. &quot;, &quot; .. fields[i] .. &quot;=&quot; .. values[i]
		end
	end

	if condition ~= nil then
		sql = sql .. &quot; where &quot; .. condition
	end

	if debugdb then
		dbug(&quot;save &quot; .. table .. &quot; &quot; .. sql)
	end

	status, errorString = conn:execute(sql)

	if status == 0 then
		if debugdb then
			dbug(&quot;save &quot; .. table .. &quot; failed&quot;)
		end

		return false -- update failed
	else
		if debugdb then
			dbug(&quot;save &quot; .. table .. &quot; success&quot;)
		end

		return true -- update success
	end
end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>Base Protection</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function baseProtection(steam, posX, posY, posZ)
	calledFunction = &quot;baseProtection&quot;

	if server.disableBaseProtection then
		return
	end

	local k, v, testMode

	testMode = false

	-- check for and record any non-friend who gets within protectSize meters of a players /setbase coord
	for k, v in pairs(players) do

		if (math.abs(tonumber(v.homeX)) &gt; 100 or math.abs(tonumber(v.homeZ)) &gt; 100) then
			dist = distancexz(posX, posZ, v.homeX, v.homeZ)
			size = tonumber(v.protectSize)


			if (v.steam == steam and v.protectPaused) then
				if (dist &gt; 100) then
					v.protectPaused = nil
					message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Your base protection has re-activated.[-]&quot;)
				end
			end

			if igplayers[steam].protectTest ~= nil and v.steam == steam then
				if igplayers[steam].protectTestEnd - os.time() &lt; 0 then
					igplayers[steam].protectTest = nil
				else
					testMode = true
				end
			end

			if (v.steam ~= steam or testMode) and (v.protectSize ~= nil)  then
				if isFriend(v.steam, steam) == false or testMode then
					if (dist &lt; size) then
						if (accessLevel(steam) &gt; 2) or server.ignoreAdmins == false or testMode then

							if (players[steam].watchPlayer == true) then
								alert = false

								if (players[steam].lastBaseRaid == nil) then
									players[steam].lastBaseRaid = os.time()
									alert = true
									-- spam prevention
									igplayers[steam].xPosLastAlert = 0
									igplayers[steam].yPosLastAlert = 0
									igplayers[steam].zPosLastAlert = 0
								end

								if (os.time() - tonumber(players[steam].lastBaseRaid) &gt; 15) and ((posX ~= igplayers[steam].xPosLastAlert) or (posY ~= igplayers[steam].yPosLastAlert) or (posZ ~= igplayers[steam].zPosLastAlert)) then
									alert = true
								end

								if (alert == true) then
									-- spam prevention
									igplayers[steam].xPosLastAlert = posX
									igplayers[steam].yPosLastAlert = posY
									igplayers[steam].zPosLastAlert = posZ

									for n, m in pairs(igplayers) do
										if (accessLevel(n) &lt; 3) then
											message(&quot;pm &quot; .. n .. &quot; [&quot; .. server.chatColour .. &quot;]Watched player &quot; .. players[steam].id .. &quot; &quot; .. players[steam].name .. &quot; is &quot; .. string.format(&quot;%-8.2d&quot;, dist) .. &quot; meters from &quot; .. v.name .. &quot;'s base[-]&quot;)
										end
									end

									irc_QueueMsg(server.ircMain, gameDate .. &quot; Watched player &quot; .. players[steam].id .. &quot; &quot; .. players[steam].name .. &quot; is &quot; .. string.format(&quot;%-8.2d&quot;, dist) .. &quot; meters from &quot; .. v.name .. &quot;'s base&quot;)
									players[steam].lastBaseRaid = os.time()
								end
							end

							igplayers[steam].raiding = true
							igplayers[steam].raidingBase = k

							-- log this intrusion into the base
--							if (raids[steam] == nil) then
--								raids[steam] = {}
--								raids[steam].name = igplayers[steam].name
--								raids[steam].coords = {}
--								table.insert(raids[steam].coords, {timestamp, v.steam, intX, intY, intZ } )	
--							end

							-- do the base protection magic
							if (v.protect and v.protectSize and v.protect == true and not v.protectPaused) and v.homeX ~= 0 and v.homeY ~= 0 and v.homeZ ~= 0 then
								irc_QueueMsg(server.ircAlerts, &quot;base protection triggered for base1 of &quot; .. players[k].name .. &quot; &quot; .. k .. &quot; against &quot; .. players[steam].name .. &quot; &quot; .. steam)

								if (igplayers[k] ~= nil) then
									message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. igplayers[steam].name .. &quot; has been bounced away from your base.[-]&quot;)
								end


								for n,m in pairs(igplayers) do
									if (accessLevel(n) &lt; 3) then
										message(&quot;pm &quot; .. n .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. igplayers[steam].name .. &quot; has been ejected from &quot; .. v.name  ..&quot;'s 1st base.[-]&quot;)
									end
								end


								if distancexz(igplayers[steam].xPosLastOK, igplayers[steam].zPosLastOK, v.homeX, v.homeZ) &gt; v.protectSize then
									message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You are too close to a protected player base. The base owner needs to add you to their friends list by typing /friend &quot; .. igplayers[steam].name .. &quot;[-]&quot;)
									cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. igplayers[steam].xPosLastOK .. &quot; &quot; .. igplayers[steam].yPosLastOK + 1 .. &quot; &quot; .. igplayers[steam].zPosLastOK

									if players[steam].watchPlayer then
										irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. steam .. &quot; &quot; .. igplayers[steam].name .. &quot; bounced off &quot; .. v.name .. &quot;'s base protection&quot;)
									end

									prepareTeleport(steam, cmd)
									teleport(cmd, true)
								else
									cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. v.exitX .. &quot; &quot; .. v.exitY + 1 .. &quot; &quot; .. v.exitZ

									if players[steam].watchPlayer then
										irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. steam .. &quot; &quot; .. igplayers[steam].name .. &quot; bounced off &quot; .. v.name .. &quot;'s base protection&quot;)
									end

									prepareTeleport(steam, cmd)
									teleport(cmd, true)
									message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You are too close to a protected player base.  The base owner needs to add you to their friends list by typing /friend &quot; .. igplayers[steam].name .. &quot;[-]&quot;)
								end
								
								return true
							end
						end
					end
				end
			end
		end


		-- 2nd base for donors and admins
		if (math.abs(tonumber(v.home2X)) &gt; 100 or math.abs(tonumber(v.home2Z)) &gt; 100) then
			dist = distancexz(igplayers[steam].xPos, igplayers[steam].zPos, v.home2X, v.home2Z)
			size = tonumber(v.protect2Size)

			if (v.steam == steam and v.protect2Paused) then
				if (dist &gt; 100) then
					v.protect2Paused = nil
					message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Protection on your 2nd base has re-activated.[-]&quot;)
				end
			end

			if (v.steam ~= steam or testMode) and (v.protect2Size ~= nil)  then
				if isFriend(v.steam, steam) == false or testMode then
					if (dist &lt; size) then
						if (accessLevel(steam) &gt; 2) or server.ignoreAdmins == false or testMode then

							if (players[steam].watchPlayer == true) then
								alert = false

								if (players[steam].lastBaseRaid == nil) then
									players[steam].lastBaseRaid = os.time()
									alert = true
									-- spam prevention
									igplayers[steam].xPosLastAlert = 0
									igplayers[steam].yPosLastAlert = 0
									igplayers[steam].zPosLastAlert = 0
								end

								if (os.time() - tonumber(players[steam].lastBaseRaid) &gt; 15) and ((posX ~= igplayers[steam].xPosLastAlert) or (posY ~= igplayers[steam].yPosLastAlert) or (posZ ~= igplayers[steam].zPosLastAlert)) then
									alert = true
								end

								if (alert == true) then
									-- spam prevention
									igplayers[steam].xPosLastAlert = posX
									igplayers[steam].yPosLastAlert = posY
									igplayers[steam].zPosLastAlert = posZ

									for n, m in pairs(igplayers) do
										if (accessLevel(n) &lt; 3) then
											message(&quot;pm &quot; .. n .. &quot; [&quot; .. server.chatColour .. &quot;]Watched player &quot; .. players[steam].id .. &quot; &quot; .. players[steam].name .. &quot; is &quot; .. string.format(&quot;%-8.2d&quot;, dist) .. &quot; meters from &quot; .. v.name .. &quot;'s 2nd base teleport[-]&quot;)
										end
									end

									irc_QueueMsg(server.ircMain, gameDate .. &quot; Watched player &quot; .. players[steam].id .. &quot; &quot; .. players[steam].name .. &quot; is &quot; .. string.format(&quot;%-8.2d&quot;, dist) .. &quot; meters from &quot; .. v.name .. &quot;'s 2nd base teleport&quot;)
									players[steam].lastBaseRaid = os.time()
								end
							end

							igplayers[steam].raiding = true
							igplayers[steam].raidingBase = k

							-- log this intrusion into the base
--							if (raids[steam] == nil) then
--								raids[steam] = {}
--								raids[steam].name = igplayers[steam].name
--								raids[steam].coords = {}
--								table.insert(raids[steam].coords, {timestamp, v.steam, intX, intY, intZ } )	
--							end

							-- do the base protection magic

							-- if base owner's donor status expired a week or more ago, disable protection
							if (v.protect2 and v.protect2 == true) and v.home2X ~= 0 and v.home2Y ~= 0 and v.home2Z ~= 0 then
								if os.time() - tonumber(players[k].donorExpiry) &gt; (60 * 60 * 24 * 7) then
									players[k].protect2 = false
									conn:execute(&quot;UPDATE players SET protect2 = 0 WHERE steam = &quot; .. k)
								end
							end

							if (v.protect2 and v.protect2Size and v.protect2 == true and not v.protect2Paused) and v.home2X ~= 0 and v.home2Y ~= 0 and v.home2Z ~= 0 then
								irc_QueueMsg(server.ircAlerts, &quot;base protection triggered for base2 of &quot; .. players[k].name .. &quot; &quot; .. k .. &quot; against &quot; .. players[steam].name .. &quot; &quot; .. steam)

								if (igplayers[k] ~= nil) then
									message(&quot;pm &quot; .. k .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. igplayers[steam].name .. &quot; has been ejected from your 2nd base.[-]&quot;)
								end


								for n,m in pairs(igplayers) do
									if (accessLevel(n) &lt; 3) then
										message(&quot;pm &quot; .. n .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. igplayers[steam].name .. &quot; has been ejected from &quot; .. v.name  ..&quot;'s 2nd base.[-]&quot;)
									end
								end

								if distancexz(igplayers[steam].xPosLastOK, igplayers[steam].zPosLastOK, v.home2X, v.home2Z) &gt; v.protect2Size then
									message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You are too close to a protected player base.  The base owner needs to add you to their friends list by typing /friend &quot; .. igplayers[steam].name .. &quot;[-]&quot;)
									cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. igplayers[steam].xPosLastOK .. &quot; &quot; .. igplayers[steam].yPosLastOK + 1 .. &quot; &quot; .. igplayers[steam].zPosLastOK

									if players[steam].watchPlayer then
										irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. steam .. &quot; &quot; .. igplayers[steam].name .. &quot; bounced off &quot; .. v.name .. &quot;'s base protection&quot;)
									end

									prepareTeleport(steam, cmd)
									teleport(cmd, true)
								else
									cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. v.exit2X .. &quot; &quot; .. v.exit2Y + 1 .. &quot; &quot; .. v.exit2Z
									prepareTeleport(steam, cmd)

									if players[steam].watchPlayer then
										irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. steam .. &quot; &quot; .. igplayers[steam].name .. &quot; bounced off &quot; .. v.name .. &quot;'s base protection&quot;)
									end

									teleport(cmd, true)
									message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You are too close to a protected player base.  The base owner needs to add you to their friends list by typing /friend &quot; .. igplayers[steam].name .. &quot;[-]&quot;)
								end
								
								return true
							end
						end
					end
				end
			end
		end

	end


	-- location/village protection
	if (accessLevel(steam) &gt; 2) or server.ignoreAdmins == false then --  or testMode
		for k, v in pairs(locations) do
			if (v.protect == true and v.x ~= 0 and v.y ~= 0 and v.z ~= 0) then
				if (not LookupVillager(steam, k) ) and steam ~= v.owner then
					dist = distancexz(igplayers[steam].xPos, igplayers[steam].zPos, v.x, v.z)

					if v.size == nil then
						size = 50
					else
						size = tonumber(v.size) 	
					end
				
					if (dist &lt; size) then
						igplayers[steam].raiding = true

						-- do the base protection magic
						if distancexz(igplayers[steam].xPos, igplayers[steam].zPos, v.x, v.z) &gt; tonumber(v.size) then
							message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You are too close to &quot; .. k .. &quot;.[-]&quot;)
							cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. igplayers[steam].xPosLastOK .. &quot; &quot; .. igplayers[steam].yPosLastOK .. &quot; &quot; .. igplayers[steam].zPosLastOK
							igplayers[steam].lastTP = cmd

							if players[steam].watchPlayer then
								irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. steam .. &quot; &quot; .. igplayers[steam].name .. &quot; bounced off location &quot; .. v.name .. &quot;'s protection&quot;)
							end

							teleport(cmd, true)
						else
							cmd = &quot;tele &quot; .. steam .. &quot; &quot; .. v.exitX .. &quot; &quot; .. v.exitY + 1 .. &quot; &quot; .. v.exitZ
							igplayers[steam].lastTP = cmd

							if players[steam].watchPlayer then
								irc_QueueMsg(server.ircTracker, gameDate .. &quot; &quot; .. steam .. &quot; &quot; .. igplayers[steam].name .. &quot; bounced off location &quot; .. v.name .. &quot;'s protection&quot;)
							end

							teleport(cmd, true)
							message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You are too close to &quot; .. k .. &quot;.[-]&quot;)
						end
						
						return true
					end
				end
			end
		end	
	end

end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>Trial Code</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
some lua globals from Mudlet we might use
collectgarbage
showToolBar
sendTelnetChannel102
getStopWatchTime
sendSocket
resetStopWatch
channel102
getTime
startStopWatch
SavedVariables
stopStopWatch
resetProfile
phpTable
startLogging
createStopWatch
--]]


-- os.spawn or mudlet's spawn command might give us a way to run an irc client or other program. not sure if that will help us communicate with it.

--[[
--command ideas
--add a new player flag noSpam which defaults to false
change some server messages to pm always and honour the flag 

--]]


function playerBanned(steam)
-- TODO: FINISH THIS.

	cursor,errorString = conn:execute(&quot;SELECT * FROM bans WHERE steam = &quot; .. steam .. &quot; AND NOT expired&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>Reset Bot Code</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function ResetBot()
	dbug(&quot;Archiving data&quot;)
	saveLuaTables(os.date(&quot;%Y%m%d_%H%M%S&quot;))

	-- save some additional tables in from mysql
	dumpTable(&quot;events&quot;)
	dumpTable(&quot;announcements&quot;)
	dumpTable(&quot;locationSpawns&quot;)
	dumpTable(&quot;alerts&quot;)

	dbug(&quot;Running ResetBot&quot;)

	for k,v in pairs(players) do
		v.xPos = 0
		v.yPos = 0
		v.zPos = 0
		v.xPosOld = 0
		v.yPosOld = 0
		v.zPosOld = 0
		v.exitX = 0
		v.exitY = 0
		v.exitZ = 0
		v.exit2X = 0
		v.exit2Y = 0
		v.exit2Z = 0
		v.baseCooldown = 0		
		v.protect = false
		v.protectSize = 32
		v.protect2 = false
		v.protect2Size = 32
		v.homeX = 0
		v.homeY = 0
		v.homeZ = 0
		v.home2X = 0
		v.home2Y = 0
		v.home2Z = 0		
		v.timeout = false
		v.alertPrison = true
		v.alertReset = true
		v.alertMapLimit = false
		v.sessionCount = 1
		v.watchPlayer = false
		v.lastBaseRaid = 0
		v.zombies = 0
		v.cash = 0
		v.overstack = false
		v.overstackScore = 0
		v.overstackItems = &quot;&quot;
		v.overstackTimeout = false
		v.gimmeCount = 0
		v.raiding = false
		v.playerKills = 0
		v.score = 0
		v.deaths = 0
		v.alertRemovedClaims = false
		v.removedClaims = 0
		v.pvpBounty = 0
		v.tokens = 0
		v.keystones = 0
		
		-- remove some fields
		v.santa = nil
		v.protection = nil
		v.protectionSize = nil
		v.lobby = nil
		v.waypointY = nil
		v.waypointX = nil
		v.waypointZ = nil
		v.shareWaypoint = nil
		v.baseprotection = nil	

		updatePlayer(k)	
	end	
	
	-- clean up other tables
	teleports = {}
	invTemp = {}
	hotspots = {}
	resetRegions = {}
	lastHotspots = {}
	villagers = {}
	locations = {}

	server.lottery = 0
	server.mapSize = 20000
	server.prisonSize = 300
	server.warnBotReset = false

	dbug(&quot;Emptying tables&quot;)

	conn:execute(&quot;TRUNCATE TABLE alerts&quot;)
	conn:execute(&quot;TRUNCATE TABLE bookmarks&quot;)
	conn:execute(&quot;TRUNCATE TABLE commandQueue&quot;)
	conn:execute(&quot;TRUNCATE TABLE events&quot;)
	conn:execute(&quot;TRUNCATE TABLE gimmeQueue&quot;)
	conn:execute(&quot;TRUNCATE TABLE hotspots&quot;)
	conn:execute(&quot;TRUNCATE TABLE ircQueue&quot;)
	conn:execute(&quot;TRUNCATE TABLE keystones&quot;)
	conn:execute(&quot;TRUNCATE TABLE locations&quot;)
	conn:execute(&quot;TRUNCATE TABLE locationSpawns&quot;)
	conn:execute(&quot;TRUNCATE TABLE lottery&quot;)
	conn:execute(&quot;TRUNCATE TABLE mail&quot;)
	conn:execute(&quot;TRUNCATE TABLE memLottery&quot;)
	conn:execute(&quot;TRUNCATE TABLE memTracker&quot;)
	conn:execute(&quot;TRUNCATE TABLE messageQueue&quot;)
	conn:execute(&quot;TRUNCATE TABLE performance&quot;)
	conn:execute(&quot;TRUNCATE TABLE playerQueue&quot;)
	conn:execute(&quot;TRUNCATE TABLE resetZones&quot;)
	conn:execute(&quot;TRUNCATE TABLE teleports&quot;)
	conn:execute(&quot;TRUNCATE TABLE tracker&quot;)
	conn:execute(&quot;TRUNCATE TABLE searchResults&quot;)
	conn:execute(&quot;TRUNCATE TABLE villagers&quot;)
	conn:execute(&quot;TRUNCATE TABLE visits&quot;)
	conn:execute(&quot;TRUNCATE TABLE inventoryChanges&quot;)
	conn:execute(&quot;TRUNCATE TABLE inventoryTracker&quot;)

	dbug(&quot;Reading server, players, bans and admin data&quot;)

	send(&quot;lkp&quot;)
	tempTimer( 10, [[send(&quot;pm IPCHECK&quot;)]] )
	tempTimer( 12, [[send(&quot;admin list&quot;)]] )
	tempTimer( 14, [[send(&quot;gg&quot;)]] )
	tempTimer( 16, [[send(&quot;ban list&quot;)]] )

	dbug(&quot;Finished resetting bot&quot;)
	return true
end


function ResetServer()
	-- This will wipe everything from the bot about the server and its players and it will ask the server for players and other info.
	-- For anything else, default values will be set until you change them.

	serverTime = &quot;&quot;
	feralWarning = false
	scheduledReboot = false
	homedir = getMudletHomeDir()

	lfs.mkdir(homedir .. &quot;/daily&quot;)
	lfs.mkdir(homedir .. &quot;/dns&quot;)
	lfs.mkdir(homedir .. &quot;/temp&quot;)

	players = {}
	igplayers = {}
	teleports = {}
	admins = {}
	friends = {}
	locations = {}
	server = {}
	invTemp = {}
	hotspots = {}
	resetRegions = {}
	gimmeQueuedCommands = {}
	lastHotspots = {}
	villagers = {}
	owners = {}
	mods = {}
	shop = {}
	shopCategories = {}
	stackLimits = {}

	openUserWindow(server.windowGMSG) 
	openUserWindow(server.windowDebug) 
	openUserWindow(server.windowLists) 
	openUserWindow(server.windowPlayers) 
	openUserWindow(server.windowAlerts) 

	dbug(&quot;Resetting Bot (full wipe)&quot;)

	yourname = &quot;12345678901234567&quot;

	if (ExceptionCount == nil) then
		ExceptionCount = 0
	end

	AnnounceBot = true
	botStarted = os.time()
	faultyGimme = false
	faultyChat = false
	gimmeHell = 0
	server.scheduledRestartPaused  = false
	server.scheduledRestart = false
	ExceptionRebooted = false

	if server.lottery == nil then
		server.lottery = 0
	end

	conn:execute(&quot;TRUNCATE TABLE players&quot;)
	conn:execute(&quot;TRUNCATE TABLE whitelist&quot;)

	ResetBot()
	initServer()

	botStarted = nil
	login()
end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>irc help</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function irc_commands()
	calledFunction = &quot;irc_commands&quot;

	local id
	id = LookupOfflinePlayer(irc_params[1], &quot;all&quot;)

	irc_QueueMsg(irc_params[1], &quot;Commands that output to IRC:&quot;)
	irc_QueueMsg(irc_params[1], &quot;============================&quot;)

	if (accessLevel(id) &gt; 2) then
		irc_QueueMsg(irc_params[1], &quot;help (display this list)&quot;)
		irc_QueueMsg(irc_params[1], &quot;admins (list admins)&quot;)
		irc_QueueMsg(irc_params[1], &quot;day or date or time (show the game date and time)&quot;)		
		irc_QueueMsg(irc_params[1], &quot;type say &lt;something&gt; to talk to players ingame&quot;)
		irc_QueueMsg(irc_params[1], &quot;date, time, day (display the current game date and time)&quot;)
		irc_QueueMsg(irc_params[1], &quot;locations&quot;)
		irc_QueueMsg(irc_params[1], &quot;mods (list mods)&quot;)
		irc_QueueMsg(irc_params[1], &quot;new players (list new players in the last 2 days)&quot;)		
		irc_QueueMsg(irc_params[1], &quot;nuke irc (clear all queued irc bot spam directed to you)&quot;)		
		irc_QueueMsg(irc_params[1], &quot;owners (list owners)&quot;)		
		irc_QueueMsg(irc_params[1], &quot;resetzones&quot;)
		irc_QueueMsg(irc_params[1], &quot;uptime (server and bot running times)&quot;)
		irc_QueueMsg(irc_params[1], &quot;who (list in-game players)&quot;)
		irc_QueueMsg(irc_params[1], &quot;server status (some daily stats)&quot;)		
		irc_QueueMsg(irc_params[1], &quot;shop categories  (list categories)&quot;)
		irc_QueueMsg(irc_params[1], &quot;shop &lt;category&gt;  (list items in a category)&quot;)
		irc_QueueMsg(irc_params[1], &quot;shop &lt;item&gt;  (list all items that partially match what you type)&quot;)
		irc_QueueMsg(irc_params[1], &quot;villages (list)&quot;)
		irc_QueueMsg(irc_params[1], &quot;villagers (list villages and villagers)&quot;)
		irc_QueueMsg(name, &quot;&quot;)
		return
	end

	irc_QueueMsg(irc_params[1], &quot;If your login is not working properly try typing rescue me, hit return then login again.&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
	irc_QueueMsg(irc_params[1], &quot;help (display this list)&quot;)
	irc_QueueMsg(irc_params[1], &quot;help topics (display help topics only)&quot;)
	irc_QueueMsg(irc_params[1], &quot;help commands (for ingame commands that you can also do in irc)&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
	irc_QueueMsg(irc_params[1], &quot;add player &lt;playername&gt; login &lt;password&gt; (create a password for an irc player to authenticate on irc).&quot;)
	irc_QueueMsg(irc_params[1], &quot;bases (list all bases and their regions)&quot;)
	irc_QueueMsg(irc_params[1], &quot;check dns player &lt;player&gt; ip &lt;ip&gt; (tell bot to do a dns check on a player)&quot;)
	irc_QueueMsg(irc_params[1], &quot;claims (list all players more than 1 placed claim and their total)&quot;)
	irc_QueueMsg(irc_params[1], &quot;claims &lt;player&gt; (list each placed claim for a player with coords)&quot;)
	irc_QueueMsg(irc_params[1], &quot;date, time, day (display the current game date and time)&quot;)
	irc_QueueMsg(irc_params[1], &quot;donors (list donors known to the bot)&quot;)
	irc_QueueMsg(irc_params[1], &quot;friends &lt;player name&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;info &lt;player name&gt; (lots of quick info about a player)&quot;)
	irc_QueueMsg(irc_params[1], &quot;inv &lt;player name&gt; (current inventory of player)&quot;)
	irc_QueueMsg(irc_params[1], &quot;view alerts (lists the last 20) add a number for more&quot;)
	irc_QueueMsg(irc_params[1], &quot;list bad items&quot;)
	irc_QueueMsg(irc_params[1], &quot;locations (list)&quot;)
	irc_QueueMsg(irc_params[1], &quot;new players&quot;)
	irc_QueueMsg(irc_params[1], &quot;pay &lt;amount&gt; to &lt;player&gt; (gift zennies to a player or admin)&quot;)	
	irc_QueueMsg(irc_params[1], &quot;permaban &lt;playername&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;player &lt;player name&gt; friend &lt;player to be friended&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;player &lt;player name&gt; unfriend &lt;player to be unfriended&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;player &lt;player name&gt; (info on a specific player)&quot;)
	irc_QueueMsg(irc_params[1], &quot;players (master list of all players)&quot;)
	irc_QueueMsg(irc_params[1], &quot;prisoners (list)&quot;)
	irc_QueueMsg(irc_params[1], &quot;remove permaban &lt;playername&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;resetzones (list)&quot;)
	irc_QueueMsg(irc_params[1], &quot;server stats&quot;)
	irc_QueueMsg(irc_params[1], &quot;status &lt;player name&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;stealth translate &lt;player&gt; (ingame chat from the player will not be translated to irc only)&quot;)			
	irc_QueueMsg(irc_params[1], &quot;stop translating &lt;player&gt; (ingame chat from the player will not be translated)&quot;)
	irc_QueueMsg(irc_params[1], &quot;teleports (list)&quot;)
	irc_QueueMsg(irc_params[1], &quot;translate &lt;player&gt; (ingame chat from the player will be translated ingame)&quot;)	
	irc_QueueMsg(irc_params[1], &quot;visits&quot;)
	irc_QueueMsg(irc_params[1], &quot;watch player &lt;player&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;stop watching &lt;player&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;who (list in-game players)&quot;)
	irc_QueueMsg(irc_params[1], &quot;uptime&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
	irc_QueueMsg(irc_params[1], &quot;type say &lt;something&gt; to talk to players ingame&quot;)
	irc_QueueMsg(irc_params[1], &quot;type pm &lt;playername or id&gt; PM a player ingame&quot;)
	irc_QueueMsg(irc_params[1], &quot;type con &lt;server command&gt; (send a command to the server in console&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
	return
end


function irc_HelpTopics()
	local id
	id = LookupOfflinePlayer(irc_params[1], &quot;all&quot;)
	if (accessLevel(id) &gt; 2) then return end

	irc_QueueMsg(irc_params[1], &quot;Commands by topic:&quot;)
	irc_QueueMsg(irc_params[1], &quot;==================&quot;)
	irc_QueueMsg(irc_params[1], &quot;help announcements&quot;)
	irc_QueueMsg(irc_params[1], &quot;help bad items&quot;)
	irc_QueueMsg(irc_params[1], &quot;help commands&quot;)
	irc_QueueMsg(irc_params[1], &quot;help custom commands&quot;)
	irc_QueueMsg(irc_params[1], &quot;help CSI&quot;)
	irc_QueueMsg(irc_params[1], &quot;help donors&quot;)
	irc_QueueMsg(irc_params[1], &quot;help motd&quot;)
	irc_QueueMsg(irc_params[1], &quot;help server&quot;)	
	irc_QueueMsg(irc_params[1], &quot;help shop&quot;)
	irc_QueueMsg(irc_params[1], &quot;help watchlist&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_HelpServer()
	local id
	id = LookupOfflinePlayer(irc_params[1], &quot;all&quot;)
	if (accessLevel(id) &gt; 2) then return end

	irc_QueueMsg(irc_params[1], &quot;Customising the bot and server&quot;)
	irc_QueueMsg(irc_params[1], &quot;==============================&quot;)
	irc_QueueMsg(irc_params[1], &quot;reset bot (Do after a wipe. BE CAREFUL. This will make the bot forgot things like bases.)&quot;)	
	irc_QueueMsg(irc_params[1], &quot;server ip &lt;internet address of server&gt; (to view just type server)&quot;)
	irc_QueueMsg(irc_params[1], &quot;set rules &lt;new rules&gt; (to view just type rules)&quot;)
	irc_QueueMsg(irc_params[1], &quot;See help motd for setting the message of the day&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_HelpCSI()
	local id
	id = LookupOfflinePlayer(irc_params[1], &quot;all&quot;)
	if (accessLevel(id) &gt; 2) then return end

	irc_QueueMsg(irc_params[1], &quot;Forensic Investigative Tools&quot;)
	irc_QueueMsg(irc_params[1], &quot;============================&quot;)
	irc_QueueMsg(irc_params[1], &quot;claims &lt;player&gt; (list each placed claim for a player with coords)&quot;)	
	irc_QueueMsg(irc_params[1], &quot;info &lt;player name&gt; (lots of quick info about a player)&quot;)
	irc_QueueMsg(irc_params[1], &quot;inv &lt;player name&gt; (current inventory of player)&quot;)	
	irc_QueueMsg(irc_params[1], &quot;near &lt;player&gt; range &lt;number&gt; (list bases and players near a player.  Range is optional and defaults to 200 metres.&quot;)	
	irc_QueueMsg(irc_params[1], &quot;show inventory (See built in help. Just type show inventory)&quot;)
	irc_QueueMsg(irc_params[1], &quot;who visited (See built in help. Just type who visited)&quot;)
	irc_QueueMsg(irc_params[1], &quot;view alerts (lists the last 20) add a number for more&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_HelpAnnouncements()
	local id
	id = LookupOfflinePlayer(irc_params[1], &quot;all&quot;)
	if (accessLevel(id) &gt; 2) then return end

	irc_QueueMsg(irc_params[1], &quot;Announcements Management&quot;)
	irc_QueueMsg(irc_params[1], &quot;========================&quot;)
	irc_QueueMsg(irc_params[1], &quot;announcements (view a numbered list of the server announcements).&quot;)
	irc_QueueMsg(irc_params[1], &quot;add announcement &lt;your message here&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;delete announcement &lt;number&gt; (from the numbered list given with announcements)&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_HelpCustomCommands()
	local id
	id = LookupOfflinePlayer(irc_params[1], &quot;all&quot;)
	if (accessLevel(id) &gt; 2) then return end

	irc_QueueMsg(irc_params[1], &quot;Custom Commands&quot;)
	irc_QueueMsg(irc_params[1], &quot;===============&quot;)
	irc_QueueMsg(irc_params[1], &quot;You can create commands that send a private message.&quot;)
	irc_QueueMsg(irc_params[1], &quot;Type custom commands (list them)[-]&quot;)
	irc_QueueMsg(irc_params[1], &quot;Type add command &lt;command&gt; level &lt;access level&gt; message &lt;message&gt;.[-]&quot;)
	irc_QueueMsg(irc_params[1], &quot;Type remove command &lt;command&gt;.[-]&quot;)
	irc_QueueMsg(irc_params[1], &quot;Access level is optional and defaults to 99.[-]&quot;)
	irc_QueueMsg(irc_params[1], &quot;See help access for the list of access levels.[-]&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_HelpBadItems()
	local id
	id = LookupOfflinePlayer(irc_params[1], &quot;all&quot;)
	if (accessLevel(id) &gt; 2) then return end

	irc_QueueMsg(irc_params[1], &quot;Bad Item (uncraftable) Management&quot;)
	irc_QueueMsg(irc_params[1], &quot;=================================&quot;)
	irc_QueueMsg(irc_params[1], &quot;list bad items&quot;)
	irc_QueueMsg(irc_params[1], &quot;add bad item &lt;name of item as given by server&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;remove bad item &lt;name of item as given by server&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
	irc_QueueMsg(irc_params[1], &quot;Any player caught with an item on this list will be sent to timeout or banned.&quot;)
	irc_QueueMsg(irc_params[1], &quot;You can allow a player to have these items (except bedrock and smokestorm) with..&quot;)
	irc_QueueMsg(irc_params[1], &quot;exclude &lt;player&gt; (They can have bad items in inventory)&quot;)
	irc_QueueMsg(irc_params[1], &quot;include &lt;player&gt; (They may not have bad items on them)&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_HelpCommands()
	local id
	id = LookupOfflinePlayer(irc_params[1], &quot;all&quot;)
	if (accessLevel(id) &gt; 2) then return end

	irc_QueueMsg(irc_params[1], &quot;Remote server commands:&quot;)
	irc_QueueMsg(irc_params[1], &quot;=======================&quot;)
	irc_QueueMsg(irc_params[1], &quot;Most ingame commands can be done from IRC by putting cmd infront.  These commands do require a slash.&quot;)
	irc_QueueMsg(irc_params[1], &quot;If an ingame command does not support running from IRC you will get 'Unknown command'. For the full list refer to ingame command help.&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /arrest &lt;playername&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /deactivatetp &lt;teleport&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /activatetp &lt;teleport&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /gimme gimme&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /gimme off&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /gimme on&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /gimme peace&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /gimme reset&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /ignoreadmins&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /includeadmins&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /killtp &lt;teleport&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /owntp &lt;teleport&gt; &lt;playername&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /privatetp &lt;teleport&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /protect &lt;playername&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /publictp &lt;teleport&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /release &lt;playername&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /reset gimmehell&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /resettimers &lt;playername&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /return &lt;playername&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /sendhome &lt;playername&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /set base size &lt;size&gt; &lt;playername&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /timeout &lt;playername&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;cmd /unprotect &lt;playername&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_HelpMOTD()
	local id
	id = LookupOfflinePlayer(irc_params[1], &quot;all&quot;)
	if (accessLevel(id) &gt; 2) then return end

	irc_QueueMsg(irc_params[1], &quot;Message Of The Day Management&quot;)
	irc_QueueMsg(irc_params[1], &quot;=============================&quot;)
	irc_QueueMsg(irc_params[1], &quot;motd (view the current message of the day if set).&quot;)
	irc_QueueMsg(irc_params[1], &quot;motd clear (or motd delete).&quot;)
	irc_QueueMsg(irc_params[1], &quot;set motd followed by anything else sets the message of the day.&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_HelpWatchlist()
	local id
	id = LookupOfflinePlayer(irc_params[1], &quot;all&quot;)
	if (accessLevel(id) &gt; 2) then return end

	irc_QueueMsg(irc_params[1], &quot;Watchlist Management&quot;)
	irc_QueueMsg(irc_params[1], &quot;====================&quot;)
	irc_QueueMsg(irc_params[1], &quot;Changes to player inventories can be sent to a channel called #watch&quot;)
	irc_QueueMsg(irc_params[1], &quot;New players and watched players are automatically included.&quot;)
	irc_QueueMsg(irc_params[1], &quot;To add a player type watch &lt;player&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;To remove them type stop watching &lt;player&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;The bot will automatically add players that are detected with certain items in unusual quantities.&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_HelpDonors()
	local id
	id = LookupOfflinePlayer(irc_params[1], &quot;all&quot;)
	if (accessLevel(id) &gt; 2) then return end

	irc_QueueMsg(irc_params[1], &quot;Donor Management&quot;)
	irc_QueueMsg(irc_params[1], &quot;================&quot;)
	irc_QueueMsg(irc_params[1], &quot;donors (list donors known to the bot)&quot;)
	irc_QueueMsg(irc_params[1], &quot;add donor &lt;player&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;remove donor &lt;player&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
end


function irc_HelpShop()
	local id
	id = LookupOfflinePlayer(irc_params[1], &quot;all&quot;)
	if (accessLevel(id) &gt; 2) then return end

	irc_QueueMsg(irc_params[1], &quot;Shop Management&quot;)
	irc_QueueMsg(irc_params[1], &quot;===============&quot;)
	irc_QueueMsg(irc_params[1], &quot;shop categories (list categories)&quot;)
	irc_QueueMsg(irc_params[1], &quot;shop &lt;category&gt; (list items in a category)&quot;)
	irc_QueueMsg(irc_params[1], &quot;shop &lt;item&gt; (list all items that partially match what you type)&quot;)
	irc_QueueMsg(irc_params[1], &quot;shop add category &lt;food&gt; code=&lt;code&gt; (1 or more letters only)&quot;)
	irc_QueueMsg(irc_params[1], &quot;shop remove category &lt;food&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;shop change category &lt;old category&gt; &lt;new category&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;shop add item &lt;item&gt; category=food price=100 stock=50&quot;)
	irc_QueueMsg(irc_params[1], &quot;shop remove item &lt;item&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;shop price &lt;item&gt; &lt;number&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;shop restock &lt;item&gt; +-&lt;number&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;shop special &lt;item&gt; &lt;number&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;shop variation &lt;item&gt; &lt;number&gt;&quot;)
	irc_QueueMsg(irc_params[1], &quot;open shop&quot;)
	irc_QueueMsg(irc_params[1], &quot;close shop (staff can still access)&quot;)
	irc_QueueMsg(irc_params[1], &quot;&quot;)
end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>30MinuteTimer</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function ThirtyMinuteTimer()
	cecho (server.windowDebug, &quot;half hour timer\n&quot;)

	-- save the world (and the kitties)
	send(&quot;sa&quot;)

	-- reload the list of proxies from the bots db
	loadProxies()
end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>StartupBot</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	          This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function checkData()
	if server.botName == nil then
		loadServer()
		botStarted = nil
		login()
	end

	if tablelength(shopCategories) == 0 then
		loadShopCategories()		
	end

	if tablelength(owners) == 0 then
		send(&quot;admin list&quot;)
	end

	if tonumber(server.ServerPort) == 0 then
		send(&quot;gg&quot;)
	end

	if (playersOnline &gt; 0) then
		if 	tablelength(igplayers) == 0 then
			igplayers = {}
			send(&quot;lp&quot;)
		end
	end
end


function getServerData()
	if not server.allowPhysics then
		send(&quot;py&quot;)
	end

	tempTimer( 2, [[send(&quot;ban list&quot;)]] )
	dbug(&quot;ban list&quot;)

	tempTimer( 5, [[send(&quot;lkp&quot;)]] )
	dbug(&quot;lkp&quot;)

	tempTimer( 8, [[send(&quot;llp&quot;)]] )
	dbug(&quot;llp&quot;)

	tempTimer( 8, [[send(&quot;admin list&quot;)]] )
	dbug(&quot;admin list&quot;)

	tempTimer( 10, [[send(&quot;pm IPCHECK&quot;)]] )
	dbug(&quot;ipcheck&quot;)

	tempTimer( 11, [[send(&quot;teleh&quot;)]] )
	dbug(&quot;coppi test&quot;)

	tempTimer( 12, [[send(&quot;gg&quot;)]] )
	dbug(&quot;gg&quot;)

	tempTimer( 14, [[registerBot()]] )
	dbug(&quot;registerBot&quot;)
end


function login()
	local debug
	debug = false
	debugdb = false

	tempTimer( 30, [[checkData()]] )

	stackLimits = {}

	if type(server) ~= &quot;table&quot; then
	  server = {}
	end

	if (botStarted == nil) then
		botStarted = os.time()

		openDB()
		initDB()
		openBotsDB()

		dbConnected = isDBConnected()
		db2Connected = isDBBotsConnected()

		initError = true
		serverTime = &quot;&quot;
		feralWarning = false
		scheduledReboot = false
		homedir = getMudletHomeDir()
		userHome = string.sub(homedir, 1, string.find(homedir, &quot;.config&quot;) - 2)

		lfs.mkdir(homedir .. &quot;/daily&quot;)
		lfs.mkdir(homedir .. &quot;/dns&quot;)
		lfs.mkdir(homedir .. &quot;/proxies&quot;)
		lfs.mkdir(homedir .. &quot;/temp&quot;)
		lfs.mkdir(homedir .. &quot;/scripts&quot;)

		fixMissingStuff()

		loadServer()

		openUserWindow(server.windowGMSG) 
		openUserWindow(server.windowDebug) 
		openUserWindow(server.windowLists) 
		openUserWindow(server.windowPlayers) 
		openUserWindow(server.windowAlerts) 

		if not botDisabled and botTick == nil then
			botTick = readBotTick()
			tempTimer( 58, [[checkBotTick()]] )
		end

		if debug then dbug(&quot;debug login 1\n&quot;) end

		if type(igplayers) ~= &quot;table&quot; then
		  igplayers = {}
		end

		if type(owners) ~= &quot;table&quot; then
		  owners = {}
		end

		if type(admins) ~= &quot;table&quot; then
		  admins = {}
		end

		if type(mods) ~= &quot;table&quot; then
		  mods = {}
		end

		if type(friends) ~= &quot;table&quot; then
		  friends = {}
		end

		if type(invTemp) ~= &quot;table&quot; then
		  invTemp = {}
		end

		if type(hotspots) ~= &quot;table&quot; then
		  hotspots = {}
		end

		if type(badItems) ~= &quot;table&quot; then
		  badItems = {}
		end

		if type(restrictedItems) ~= &quot;table&quot; then
		  restrictedItems = {}
		end

		if type(lastHotspots) ~= &quot;table&quot; then
			lastHotspots = {}
		end

		if type(villagers) ~= &quot;table&quot; then
		  villagers = {}
		end

		if type(shopCategories) ~= &quot;table&quot; then
			shopCategories = {}
		end

		if type(stackLimits) ~= &quot;table&quot; then
			stackLimits = {}
		end

		if type(customMessages) ~= &quot;table&quot; then
		  customMessages = {}
		end

		if type(reservedSlots) ~= &quot;table&quot; then
			reservedSlots = {}
		end

		if type(proxies) ~= &quot;table&quot; then
			proxies = {}
		end

		if debug then dbug(&quot;debug login 2\n&quot;) end

		-- add your steam id here so you can debug using your name
		yourname = &quot;12345678901234567&quot;

		if (ExceptionCount == nil) then
			ExceptionCount = 0
		end

		AnnounceBot = true
		faultyGimme = false
		faultyGimmeNumber = 0
		faultyChat = false
		gimmeHell = 0
		server.scheduledRestartPaused  = false
		server.scheduledRestart = false
		ExceptionRebooted = false
		scanZombies = false

		-- load tables
		loadTables()

		-- set all players to offline in cloud db
		cleanupBotsData()

		if debug then dbug(&quot;debug login 5\n&quot;) end

		nextRebootTest = nil
		initError = false

		if db2Connected then
			getWhitelistedServers()
		end
	end

	if debug then dbug(&quot;debug login end\n&quot;) end
end

login()</script>
            <eventHandlerList>
                <string>sysConnectionEvent</string>
            </eventHandlerList>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>Teleport functions</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function forgetLastTP(steam)
	if igplayers[steam] then
		igplayers[steam].lastCatchTimestamp = os.time() + 10
		igplayers[steam].lastTP = nil
	end
end


function prepareTeleport(steam, cmd)
	if igplayers[steam] then
		igplayers[steam].lastCatchTimestamp = os.time() + 10
		igplayers[steam].lastTP = cmd
	end
end


function teleport(cmd, forced)
	local id, coords, temp, dist
	id = string.sub(cmd, 6, 22)
	dist = nil

	-- disable some stuff because we are teleporting
	igplayers[id].location = nil

	coords = string.sub(cmd, 24)
	coords = string.split(coords, &quot; &quot;)

	-- don't teleport the player if the coords are 0 0 0
	if tonumber(coords[1]) == 0 and tonumber(coords[2]) == 0 and tonumber(coords[3]) == 0 then
		return
	end

	-- if an admin is following a player (using the /near command) and they teleport away, stop following the player
	if igplayers[id].following ~= nil then igplayers[id].following = nil end

	players[id].tp = 1
	players[id].hackerScore = 0

	send(cmd)

	players[id].tp = 1
	players[id].hackerScore = 0

	return true
end


function fallCatcher(steam, x, y, z)
	local coords, temp, dist

	if players[steam].timeout == true or players[steam].botTimeout == true or igplayers[steam].following ~= nil then
		return
	end

	-- world fall catcher
	if igplayers[steam].lastCatchTimestamp - os.time() &lt; 0 then
		if (tonumber(y) &lt; 0 and players[steam].timeout == false and players[steam].botTimeout == false and igplayers[steam].sessionPlaytime &gt; 5)  then
			igplayers[steam].lastCatchTimestamp = os.time() + 10
		
			if igplayers[steam].lastTP ~= nil then
				players[steam].tp = 1
				players[steam].hackerScore = 0
				send(igplayers[steam].lastTP)
				return
			end

			sql = &quot;SELECT count(*) as num, x,y,z FROM tracker WHERE steam = &quot; .. steam .. &quot; and y &gt; 0 and y &lt; 255 and ((abs(x - &quot; .. x .. &quot;) &gt; 2 and abs(x - &quot; .. x .. &quot;) &lt; 30) and (abs(z - &quot; .. z .. &quot;) &gt; 2 and abs(z - &quot; .. z .. &quot;) &lt; 30)) GROUP BY y ORDER BY num DESC limit 0,1&quot;

			cursor,errorString = conn:execute(sql)
			if cursor:numrows() &gt; 0 then
				row = cursor:fetch({}, &quot;a&quot;)
				cmd = &quot;&quot;
				
				while row do
					cmd = (&quot;tele &quot; .. steam .. &quot; &quot; .. row.x .. &quot; &quot; .. row.y + 1 .. &quot; &quot; .. row.z)
					
					if cmd ~= &quot;&quot; then
						players[steam].tp = 1
						players[steam].hackerScore = 0
						send(cmd)
						players[id].tp = 1
						players[id].hackerScore = 0
						return
					else
						message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]You have fallen through the ground. Relog to rescue yourself.[-]&quot;)
					end

					row = cursor:fetch(row, &quot;a&quot;)	
				end
			end

			return
		end
	end
end


function randomPVPTP(playerid, location, forced)
	local r, rows, row, rowCount

	cursor,errorString = conn:execute(&quot;select * from locationSpawns where location='&quot; .. location .. &quot;'&quot;)
	rows = tonumber(cursor:numrows())

	if rows == 0 then
		cmd = &quot;tele &quot; .. playerid .. &quot; &quot; .. locations[location].x .. &quot; &quot; .. locations[location].y .. &quot; &quot; .. locations[location].z
		prepareTeleport(playerid, cmd)
		teleport(cmd, true)
		return
	end

	rowCount = 1
	r = rand(rows)

	cursor,errorString = conn:execute(&quot;select * from locationSpawns where location='&quot; .. location .. &quot;' limit &quot; .. r - 1 .. &quot;,1&quot;)
	row = cursor:fetch({}, &quot;a&quot;)
	cmd = &quot;tele &quot; .. playerid .. &quot; &quot; .. row.x .. &quot; &quot; .. row.y .. &quot; &quot; .. row.z
	prepareTeleport(playerid, cmd)

	if location == &quot;lobby&quot; then
		teleport(cmd, true)
	else
		if forced ~= nil then
			teleport(cmd, true)
		else
			teleport(cmd)
		end
	end
end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>Lua Tables</name>
            <packageName></packageName>
            <script>function saveLuaTables(date)
	if date ~= nil then
		date = date .. &quot;_&quot;
	else
		date = &quot;&quot;
	end

	dbug(&quot;saving Lua tables&quot;)
	table.save(homedir .. &quot;/&quot; .. date .. &quot;players.lua&quot;, players)
	table.save(homedir .. &quot;/&quot; .. date .. &quot;teleports.lua&quot;, teleports)
	table.save(homedir .. &quot;/&quot; .. date .. &quot;friends.lua&quot;, friends)
	table.save(homedir .. &quot;/&quot; .. date .. &quot;locations.lua&quot;, locations)
	table.save(homedir .. &quot;/&quot; .. date .. &quot;server.lua&quot;, server)
	table.save(homedir .. &quot;/&quot; .. date .. &quot;badItems.lua&quot;, badItems)
	table.save(homedir .. &quot;/&quot; .. date .. &quot;hotspots.lua&quot;, hotspots)
	table.save(homedir .. &quot;/&quot; .. date .. &quot;resetRegions.lua&quot;, resetRegions)
	table.save(homedir .. &quot;/&quot; .. date .. &quot;shopCategories.lua&quot;, shopCategories)
	table.save(homedir .. &quot;/&quot; .. date .. &quot;villagers.lua&quot;, villagers)
	table.save(homedir .. &quot;/&quot; .. date .. &quot;restrictedItems.lua&quot;, restrictedItems)
	table.save(homedir .. &quot;/&quot; .. date .. &quot;customMessages.lua&quot;, customMessages)
	dbug(&quot;finished saving Lua tables&quot;)
end


function importServer()
	dbug(&quot;Importing Server&quot;)
	message(&quot;say [&quot; .. server.chatColour .. &quot;]Importing server[-]&quot;)
	conn:execute(&quot;DELETE FROM server)&quot;)
	conn:execute(&quot;INSERT INTO server (ircMain, ircAlerts, ircWatch, rules, shopCountdown, gimmePeace, allowGimme, mapSize, baseCooldown, MOTD, allowShop, chatColour, botName, lottery, allowWaypoints, prisonSize, baseSize) VALUES ('&quot; .. escape(server.ircMain) .. &quot;','&quot; .. escape(server.ircAlerts) .. &quot;','&quot; .. escape(server.ircWatch) .. &quot;','&quot; .. escape(server.rules) .. &quot;',0,&quot; .. dbBool(server.gimmePeace) .. &quot;,&quot; .. dbBool(server.allowGimme) .. &quot;,&quot; .. server.mapSize .. &quot;,&quot; .. server.baseCooldown .. &quot;,'&quot; .. escape(server.MOTD) .. &quot;',&quot; .. dbBool(server.allowShop) .. &quot;,'&quot; .. server.chatColour .. &quot;','&quot; .. escape(server.botName) .. &quot;',&quot; .. server.lottery .. &quot;,&quot; .. dbBool(server.allowWaypoints) .. &quot;,&quot; .. server.prisonSize .. &quot;,&quot; .. server.baseSize .. &quot;)&quot;)

	-- reload from db to grab defaults for any missing data
	loadServer()

	openUserWindow(server.windowGMSG) 
	openUserWindow(server.windowDebug) 
	openUserWindow(server.windowLists) 
	openUserWindow(server.windowPlayers) 
	openUserWindow(server.windowAlerts) 
end


function importShopCategories()
	dbug(&quot;Importing Shop Categories&quot;)
	message(&quot;say [&quot; .. server.chatColour .. &quot;]Importing shop categories[-]&quot;)

	for k,v in pairs(shopCategories) do
		conn:execute(&quot;INSERT INTO shopCategories (category, idx, code) VALUES ('&quot; .. escape(k) .. &quot;',&quot; .. v.idx .. &quot;,'&quot; .. v.code .. &quot;')&quot;)
	end

	dbug(&quot;Shop Categories Imported&quot;)
end


function importPlayers()
	dbug(&quot;Importing Players&quot;)
	message(&quot;say [&quot; .. server.chatColour .. &quot;]Importing players[-]&quot;)

	for k,v in pairs(players) do
		conn:execute(&quot;INSERT INTO players (steam, id, name) VALUES (&quot; .. k .. &quot;,&quot; .. v.id .. &quot;,'&quot; .. escape(v.name) .. &quot;')&quot;)		
		fixMissingPlayer(k)
		updatePlayer(k)
	end

	dbug(&quot;Players Imported&quot;)
end


function importTeleports()
	dbug(&quot;Importing Teleports&quot;)
	message(&quot;say [&quot; .. server.chatColour .. &quot;]Importing teleports[-]&quot;)

	for k,v in pairs(teleports) do
		conn:execute(&quot;INSERT INTO teleports (name, active, public, oneway, friends, x, y, z, dx, dy, dz, owner) VALUES ('&quot; .. escape(v.name) .. &quot;',&quot; .. dbBool(v.active) .. &quot;,&quot; .. dbBool(v.public) .. &quot;,&quot; .. dbBool(v.oneway) .. &quot;,&quot; .. dbBool(v.friends) .. &quot;,&quot; .. v.x .. &quot;,&quot; .. v.y .. &quot;,&quot; .. v.z .. &quot;,&quot; .. v.dx .. &quot;,&quot; .. v.dy .. &quot;,&quot; .. v.owner .. &quot;)&quot;)
	end
end


function importLocations()
	local sql, fields, values

	dbug(&quot;Importing Locations&quot;)
	message(&quot;say [&quot; .. server.chatColour .. &quot;]Importing locations[-]&quot;)

	for k,v in pairs(locations) do
		fields = &quot;name, x, y, z, public, active&quot;
		values = &quot;'&quot; .. escape(v.name) .. &quot;',&quot; .. v.x .. &quot;,&quot; .. v.y .. &quot;,&quot; .. v.z .. &quot;,&quot; .. dbBool(v.public) .. &quot;,&quot; .. dbBool(v.active)

		if v.protect ~= nil then
			fields = fields .. &quot;, protected&quot;
			values = values .. &quot;,&quot; .. dbBool(v.protect)
		end	

		if v.village ~= nil then
			fields = fields .. &quot;, village&quot;
			values = values .. &quot;,&quot; .. dbBool(v.village)
		end	

		if v.pvp ~= nil then
			fields = fields .. &quot;, pvp&quot;
			values = values .. &quot;,&quot; .. dbBool(v.pvp)
		end	

		if v.allowBase ~= nil then
			fields = fields .. &quot;, allowBase&quot;
			values = values .. &quot;,&quot; .. dbBool(v.allowBase)
		end	

		if v.accessLevel ~= nil then
			fields = fields .. &quot;, accessLevel&quot;
			values = values .. &quot;,&quot; .. dbBool(v.accessLevel)
		end	

		if v.owner ~= nil then
			fields = fields .. &quot;, owner&quot;
			values = values .. &quot;,&quot; .. v.owner
		end	

		if v.mayor ~= nil then
			fields = fields .. &quot;, mayor&quot;
			values = values .. &quot;,&quot; .. v.mayor
		end	

		if v.protectSize ~= nil then
			fields = fields .. &quot;, protectSize&quot;
			values = values .. &quot;,&quot; .. v.protectSize
		end	

		if v.killZombies ~= nil then
			fields = fields .. &quot;, killZombies&quot;
			values = values .. &quot;,&quot; .. dbBool(v.killZombies)
		end	
	
		sql = &quot;INSERT INTO locations (&quot; .. fields .. &quot;) VALUES (&quot; .. values .. &quot;)&quot;

		conn:execute(sql)
	end

	dbug(&quot;Locations Imported&quot;)
end


function importFriends()
	local friendlist, i

	dbug(&quot;Importing Friends&quot;)
	message(&quot;say [&quot; .. server.chatColour .. &quot;]Importing friends[-]&quot;)

	for k,v in pairs(friends) do
		friendlist = string.split(v.friends, &quot;,&quot;)

		for i=1,table.maxn(friendlist),1 do
			if friendlist[i] ~= &quot;&quot; then
				conn:execute(&quot;INSERT INTO friends (steam, friend) VALUES (&quot; .. k .. &quot;,&quot; .. friendlist[i] .. &quot;)&quot;)
			end
		end
	end

	dbug(&quot;Friends Imported&quot;)
end


function importVillagers()
	dbug(&quot;Importing Villagers&quot;)
	message(&quot;say [&quot; .. server.chatColour .. &quot;]Importing villagers[-]&quot;)

	for k,v in pairs(villagers) do
		conn:execute(&quot;INSERT INTO villagers (steam, village) VALUES (&quot; .. k .. &quot;,'&quot; .. escape(v.village) .. &quot;')&quot;)
	end

	dbug(&quot;Villagers Imported&quot;)
end


function importHotspots()
	dbug(&quot;Importing Hotspots&quot;)
	message(&quot;say [&quot; .. server.chatColour .. &quot;]Importing hotspots[-]&quot;)

	for k,v in pairs(hotspots) do
		if v.radius then
			conn:execute(&quot;INSERT INTO hotspots (hotspot, x, y, z, owner, size) VALUES ('&quot; .. escape(v.message) .. &quot;',&quot; .. v.x .. &quot;,&quot; .. v.y .. &quot;,&quot; .. v.z .. &quot;,&quot; .. v.owner .. &quot;,&quot; .. v.radius .. &quot;)&quot;)
		else
			conn:execute(&quot;INSERT INTO hotspots (hotspot, x, y, z, owner) VALUES ('&quot; .. escape(v.message) .. &quot;',&quot; .. v.x .. &quot;,&quot; .. v.y .. &quot;,&quot; .. v.z .. &quot;,&quot; .. v.owner .. &quot;)&quot;)
		end
	end

	dbug(&quot;Hotspots Imported&quot;)
end


function importResets()
	dbug(&quot;Importing Reset Zones&quot;)
	message(&quot;say [&quot; .. server.chatColour .. &quot;]Importing reset zones[-]&quot;)

	for k,v in pairs(resetRegions) do
		conn:execute(&quot;INSERT INTO resetZones (region) VALUES ('&quot; .. escape(k) .. &quot;')&quot;)
	end

	dbug(&quot;Resets Imported&quot;)
end


function importBaditems()
	dbug(&quot;Importing Bad Items&quot;)
	message(&quot;say [&quot; .. server.chatColour .. &quot;]Importing bad items list[-]&quot;)

	for k,v in pairs(badItems) do
		conn:execute(&quot;INSERT INTO badItems (item) VALUES ('&quot; .. escape(k) .. &quot;')&quot;)
	end

	dbug(&quot;Bad Items Imported&quot;)
end


function importLuaData()
	dbug(&quot;Importing Lua Tables&quot;)
	message(&quot;say [&quot; .. server.chatColour .. &quot;]Importing data from Lua tables..[-]&quot;)

--[[
	server = {}
	players = {}
	teleports = {}
	friends = {}
	locations = {}
	hotspots = {}
	villagers = {}
	shopCategories = {}
	languages = {}
	resetRegions = {}
--]]

dbug(&quot;import 1&quot;)
	dbug(&quot;Loading server&quot;)
	table.load(homedir .. &quot;/server.lua&quot;, server)
dbug(&quot;import 2&quot;)
	dbug(&quot;Loading players&quot;)
	table.load(homedir .. &quot;/players.lua&quot;, players)
dbug(&quot;import 3&quot;)
	dbug(&quot;Loading teleports&quot;)
	table.load(homedir .. &quot;/teleports.lua&quot;, teleports)
dbug(&quot;import 4&quot;)
	dbug(&quot;Loading friends&quot;)
	table.load(homedir .. &quot;/friends.lua&quot;, friends)
dbug(&quot;import 5&quot;)
	dbug(&quot;Loading locations&quot;)
	table.load(homedir .. &quot;/locations.lua&quot;, locations)
dbug(&quot;import 6&quot;)
	dbug(&quot;Loading hotspots&quot;)
	table.load(homedir .. &quot;/hotspots.lua&quot;, hotspots)
dbug(&quot;import 7&quot;)
	dbug(&quot;Loading villagers&quot;)
	table.load(homedir .. &quot;/villagers.lua&quot;, villagers)
dbug(&quot;import 9&quot;)
	dbug(&quot;Loading shop categories&quot;)
	table.load(homedir .. &quot;/shopCategories.lua&quot;, shopCategories)
dbug(&quot;import 11&quot;)
	dbug(&quot;Loading reset zones&quot;)
	table.load(homedir .. &quot;/resetRegions.lua&quot;, resetRegions)
dbug(&quot;import 12&quot;)
	dbug(&quot;Loading bad items&quot;)
	table.load(homedir .. &quot;/badItems.lua&quot;, badItems)
dbug(&quot;import 13&quot;)
	conn:execute(&quot;DELETE FROM badItems&quot;)
	conn:execute(&quot;DELETE FROM friends&quot;)
	conn:execute(&quot;DELETE FROM hotspots&quot;)
	conn:execute(&quot;DELETE FROM locations&quot;)
	conn:execute(&quot;DELETE FROM players&quot;)
	conn:execute(&quot;DELETE FROM resetZones&quot;)
	conn:execute(&quot;DELETE FROM shopCategories&quot;)
	conn:execute(&quot;DELETE FROM teleports&quot;)
	conn:execute(&quot;DELETE FROM villagers&quot;)

dbug(&quot;import 4&quot;)
	importPlayers()
dbug(&quot;import 5&quot;)
	importBaditems()
dbug(&quot;import 6&quot;)
	importHotspots()
dbug(&quot;import 8&quot;)
	importLocations()
dbug(&quot;import 9&quot;)
	importResets()
dbug(&quot;import 12&quot;)
	importTeleports()
dbug(&quot;import 13&quot;)
	importVillagers()
dbug(&quot;import 14&quot;)
	importFriends()
dbug(&quot;import 15&quot;)
	importShopCategories()


	dbug(&quot;Import of Lua tables Complete&quot;)
	message(&quot;say [&quot; .. server.chatColour .. &quot;]Import complete.[-]&quot;)
end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_misc</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
bookmark commands
=============
list bookmarks
bookmark
bk
--]]


function gmsg_misc()
	calledFunction = &quot;gmsg_misc&quot;

	local note, pid, debug, result

	debug = false

if debug then display (&quot;debug misc 1\n&quot;) end

	if chatvars.words[1] == &quot;list&quot; and chatvars.words[2] == &quot;bookmarks&quot; then
		pid = string.sub(chatvars.command, string.find(chatvars.command, &quot;bookmarks &quot;) + 10)
		pid = string.trim(pid)
		pid = LookupPlayer(pid)

		if (accessLevel(chatvars.playerid) &gt; 2) then
			pid = chatvars.playerid
		end

		if (pid == nil) then 
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No player found with that name.[-]&quot;)
			else
				irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;No player found with that name.&quot;)
			end	

			faultyChat = false
			return true
		else
			cursor,errorString = conn:execute(&quot;select * from bookmarks where steam = &quot; .. pid)
			row = cursor:fetch({}, &quot;a&quot;)

			while row do
				if (chatvars.playername ~= &quot;Server&quot;) then 
					message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]#&quot; .. row.id .. &quot; &quot; .. row.x .. &quot; &quot; .. row.y .. &quot; &quot; .. row.z .. &quot; &quot; .. row.note .. &quot;[-]&quot;)
				else
					irc_QueueMsg(players[chatvars.ircid].ircAlias, &quot;#&quot; .. row.id .. &quot; &quot; .. row.x .. &quot; &quot; .. row.y .. &quot; &quot; .. row.z .. &quot; &quot; .. row.note)
				end	

				row = cursor:fetch(row, &quot;a&quot;)
			end
		end

		faultyChat = false
		return true
	end

if debug then display (&quot;debug misc 1\n&quot;) end

	if chatvars.words[1] == &quot;get&quot; and chatvars.words[2] == &quot;region&quot; and chatvars.words[3] ~=  nil then
		if ToInt(chatvars.words[3]) == nil or ToInt(chatvars.words[4]) == nil then
			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Integer coordinates expected for x and z eg. /get region 123 456[-]&quot;)		
			else
				irc_QueueMsg(server.ircMain, &quot;Integer coordinates expected for x and z eg. /get region 123 456&quot;)
			end
		else
			result = getRegion(chatvars.words[3], chatvars.words[4])

			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The region at xPos &quot; .. chatvars.words[3] .. &quot; zPos &quot; .. chatvars.words[4] .. &quot; is &quot; .. result .. &quot;[-]&quot;)		
			else
				irc_QueueMsg(server.ircMain, &quot;The region at xPos &quot; .. chatvars.words[3] .. &quot; zPos &quot; .. chatvars.words[4] .. &quot; is &quot; .. result)
			end
		end

		faultyChat = false
		return true
	end

	-- ###################  do not allow remote commands beyond this point ################
	if (chatvars.playerid == nil) then
		faultyChat = false
		return false
	end
	-- ####################################################################################

if debug then display (&quot;debug misc 2\n&quot;) end

	if (chatvars.words[1] == &quot;bookmark&quot; and chatvars.words[2] ~= nil) then

		note = string.sub(chatvars.command, string.find(chatvars.command, &quot;bookmark &quot;) + 9)
		
		if note == nil then note = &quot;&quot; end

		conn:execute(&quot;INSERT INTO bookmarks (steam, x, y, z, note) VALUES (&quot; .. chatvars.playerid .. &quot;,&quot; .. math.floor(igplayers[chatvars.playerid].xPos) .. &quot;,&quot; .. math.ceil(igplayers[chatvars.playerid].yPos) .. &quot;,&quot; .. math.floor(igplayers[chatvars.playerid].zPos) .. &quot;,'&quot; .. escape(note) .. &quot;')&quot;)
		message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Position added to bookmarks.[-]&quot;)	

		faultyChat = false
		return true
	end

if debug then display (&quot;debug misc 3\n&quot;) end

	if chatvars.words[1] == &quot;bk&quot; then
		if (accessLevel(chatvars.playerid) &gt; 2) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted[-]&quot;)
			faultyChat = false
			return true
		end

		if (chatvars.number == nil) then 
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]The bookmark number is required eg. /goto bookmark 5[-]&quot;)
			faultyChat = false
			return true
		else
			cursor,errorString = conn:execute(&quot;select * from bookmarks where id = &quot; .. chatvars.number)
			rows = cursor:numrows()

			if rows &gt; 0 then
				row = cursor:fetch({}, &quot;a&quot;)

				-- first record their current x y z
				savePosition(chatvars.playerid)

				cmd = &quot;tele &quot; .. chatvars.playerid .. &quot; &quot; .. row.x .. &quot; &quot; .. row.y .. &quot; &quot; .. row.z
				prepareTeleport(chatvars.playerid, cmd)
				teleport(cmd, true)
			end
		end

		faultyChat = false
		return true
	end

if debug then display (&quot;debug misc end\n&quot;) end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_pms</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
private message messages
=============
These are stored in the table customMessages.  Currently they are limited to simple private text responses.
add command
remove command
custom commands
--]]

function gmsg_pms()
	calledFunction = &quot;gmsg_pms&quot;

	local access, msg, cmd

	-- don't proceed if there is no leading slash
	if (string.sub(chatvars.command, 1, 1) ~= &quot;/&quot;) then
		faultyChat = false
		return false
	end

	cmd = string.sub(chatvars.command, 2)

	if (chatvars.words[1] == &quot;add&quot; and chatvars.words[2] == &quot;command&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted.[-]&quot;)
				faultyChat = false
				return true
			end
		end

		access = 99
		cmd = nil

		if string.find(chatvars.command, &quot;message&quot;) then
			msg = string.sub(chatvars.command, string.find(chatvars.command, &quot;message&quot;) + 8)

			if string.find(chatvars.command, &quot;level&quot;) then
				cmd = string.sub(chatvars.oldLine, string.find(chatvars.oldLine, &quot;command&quot;) + 8, string.find(chatvars.oldLine, &quot;level&quot;) - 2)
				access = string.sub(chatvars.command, string.find(chatvars.command, &quot;level&quot;) + 6, string.find(chatvars.command, &quot;message&quot;) - 2)
			else
				cmd = string.sub(chatvars.oldLine, string.find(chatvars.oldLine, &quot;command&quot;) + 8, string.find(chatvars.oldLine, &quot;message&quot;) - 2)
			end
		else
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Message required.[-]&quot;)
			else
				irc_QueueMsg(server.ircMain, &quot;Message required.&quot;)
			end

			faultyChat = false
			return true
		end

		if cmd == nil then
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Command required.[-]&quot;)
			else
				irc_QueueMsg(server.ircMain, &quot;Command required.&quot;)
			end

			faultyChat = false
			return true
		end

		-- strip leading /
		if (string.sub(cmd, 1, 1) == &quot;/&quot;) then
			cmd = string.sub(cmd, 2)
		end
	
		conn:execute(&quot;INSERT INTO customMessages (command, message, accessLevel) Values ('&quot; .. escape(cmd) .. &quot;','&quot; .. escape(msg) .. &quot;',&quot; .. access .. &quot;) ON DUPLICATE KEY UPDATE accessLevel = &quot; .. access.. &quot;, message = '&quot; .. escape(msg) .. &quot;'&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then 
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You added the command: /&quot; .. cmd .. &quot;.[-]&quot;)
		else
			irc_QueueMsg(server.ircMain, &quot;You added the command: /&quot; .. cmd)
		end

		-- reload from the database
		loadCustomMessages()

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;remove&quot; and chatvars.words[2] == &quot;command&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted.[-]&quot;)
				faultyChat = false
				return true
			end
		end

		cmd = string.sub(chatvars.command, string.find(chatvars.command, &quot;command&quot;) + 9)

		if cmd ~= nil then
			conn:execute(&quot;DELETE FROM customMessages WHERE command = '&quot; .. escape(cmd) .. &quot;'&quot;)
			customMessages[cmd] = nil

			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]You removed the command /&quot; .. cmd .. &quot;.[-]&quot;)
			else
				irc_QueueMsg(server.ircMain, &quot;You removed the command: /&quot; .. cmd)
			end
		else
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Command required.[-]&quot;)
			else
				irc_QueueMsg(server.ircMain, &quot;Command required.&quot;)
			end
		end

		faultyChat = false
		return true
	end


	if (chatvars.words[1] == &quot;custom&quot; and chatvars.words[2] == &quot;commands&quot;) then
		if (chatvars.playername ~= &quot;Server&quot;) then 
			if (accessLevel(chatvars.playerid) &gt; 2) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]This command is restricted.[-]&quot;)
				faultyChat = false
				return true
			end
		end

		cursor,errorString = conn:execute(&quot;SELECT * FROM customMessages&quot;)
		row = cursor:fetch({}, &quot;a&quot;)

		if not row then
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]There are no custom commands.[-]&quot;)
			else
				irc_QueueMsg(server.ircMain, &quot;There are no custom commands.&quot;)
			end
		else
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Custom commands:[-]&quot;)
			else
				irc_QueueMsg(server.ircMain, &quot;Custom commands:&quot;)
			end
		end

		while row do
			if (chatvars.playername ~= &quot;Server&quot;) then 
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]/&quot; .. row.command .. &quot;[-]&quot;)
			else
				irc_QueueMsg(server.ircMain, &quot;/&quot; .. row.command)
			end

			row = cursor:fetch(row, &quot;a&quot;)	
		end

		faultyChat = false
		return true
	end

	-- ###################  do not allow remote commands beyond this point ################
	if (chatvars.playerid == nil) then
		faultyChat = false
		return false
	end
	-- ####################################################################################

	if customMessages[cmd] then
		cursor,errorString = conn:execute(&quot;select * from customMessages where command = '&quot; .. escape(cmd) .. &quot;'&quot;)
		row = cursor:fetch({}, &quot;a&quot;)

		if row then
			if (accessLevel(chatvars.playerid) &lt;= tonumber(row.accessLevel)) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. row.message .. &quot;[-]&quot;)
				faultyChat = false
				return true
			end

			faultyChat = false
			return true
		end
	end

end
</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>gmsg_custom</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
custom commands in an external script
=============
This is called ahead of most other gmsg code modules.  You can use this module to override commands in other modules so long as both commands
are trying to match the same strings.

--]]


dofile(homedir .. &quot;/scripts/gmsg_custom.lua&quot;)</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>NewServer</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


function gatherServerData()
	-- read a bunch of info from the server.  The bot will capture it elsewhere.

	send(&quot;lkp&quot;)
	tempTimer( 4, [[send(&quot;pm IPCHECK&quot;)]] )
	tempTimer( 5, [[send(&quot;admin list&quot;)]] )
	tempTimer( 7, [[send(&quot;ban list&quot;)]] )
	tempTimer( 9, [[send(&quot;gg&quot;)]] )
	tempTimer( 11, [[send(&quot;llp&quot;)]] )
end


function initServer()
	server.windowGMSG = &quot;Chat&quot;
	server.windowDebug = &quot;Debug&quot;
	server.windowAlerts = &quot;Alerts&quot;
	server.windowLists = &quot;Lists&quot;
	server.windowPlayers = &quot;Players&quot;
	server.botName = &quot;Bot&quot;
	server.prisonSize = 30
	server.mapSize = 30000
	server.chatColour = &quot;D4FFD4&quot;
	server.baseSize = 32
	server.ServerPort = &quot;0&quot;
	server.MOTD = &quot;We have a new server bot!&quot;
	server.IP = &quot;0.0.0.0&quot;
	server.ircAlerts = &quot;#bot_alerts&quot;
	server.ircMain = &quot;#bot&quot;
	server.ircWatch = &quot;#bot_watch&quot;
	server.allowGimme = false
	server.lottery = 0
	server.allowShop = false
	server.allowWaypoints = false
	server.maxPlayers = 24
	server.maxServerUptime = 6
	server.baseSize = 32
	server.baseCooldown = 2400
	server.protectionMaxDays = 31
	server.ircBotName = &quot;Bot&quot;
	server.ServerName = &quot;New Server&quot;
	server.rules = &quot;No rules yet!&quot;
	server.shopCountdown = 3
	server.gimmePeace = false

	conn:execute(&quot;DELETE FROM server&quot;)
	cursor,errorString = conn:execute(&quot;INSERT INTO server (botName, windowGMSG, windowAlerts, windowDebug, windowLists, windowPlayers) values ('Bot', 'Chat', 'Alerts', 'Debug', 'Lists', 'Players')&quot;)
end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>Modded Allocs</name>
            <packageName></packageName>
            <script>--[[
    Botman - A collection of scripts for managing 7 Days to Die servers
    Copyright (C) 2015  Matthew Dwyer
	           This copyright applies to the Lua source code in this Mudlet profile.
    Email     mdwyer@snap.net.nz
    URL       http://botman.nz
    Source    https://bitbucket.org/mhdwyer/botman
--]]


--[[
Commands for Coppi's modded Alloc's mod
=============

--]]

function mutePlayer(steam)
	send(&quot;mpc &quot; .. steam .. &quot; true&quot;)
	players[steam].mute = true
	irc_QueueMsg(server.ircMain, players[steam].name .. &quot;'s chat has been muted :D&quot;)
	message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Your chat has been muted.[-]&quot;)
	conn:execute(&quot;UPDATE players SET mute = 1 WHERE steam = &quot; .. steam)
end


function unmutePlayer(steam)
	send(&quot;mpc &quot; .. steam .. &quot; false&quot;)
	players[steam].mute = false
	irc_QueueMsg(server.ircMain, players[steam].name .. &quot;'s chat is no longer muted D:&quot;)
	message(&quot;pm &quot; .. steam .. &quot; [&quot; .. server.chatColour .. &quot;]Your chat is no longer muted.[-]&quot;)
	conn:execute(&quot;UPDATE players SET mute = 0 WHERE steam = &quot; .. steam)
end


function gmsg_coppi()
	calledFunction = &quot;gmsg_coppi&quot;

	local debug

	debug = false

if debug then dbug(&quot;debug coppi start&quot;) end

	-- ###################  Staff only beyond this point ################
	-- Don't proceed if this is a player.  Server and staff only here.
	if (chatvars.playername ~= &quot;Server&quot;) then 
		if (accessLevel(chatvars.playerid) &gt; 2) then
			faultyChat = false
			return false
		end
	end
	-- ##################################################################

if debug then dbug(&quot;debug coppi 1&quot;) end

	if chatvars.words[1] == &quot;mute&quot; and chatvars.words[2] ~= nil then
		pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;mute &quot;) + 6)
		pname = string.trim(pname)
		pid = LookupPlayer(pname)

		if pid == nil then
			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No player found called &quot; .. pname .. &quot;[-]&quot;)
			else
				irc_QueueMsg(server.ircMain, &quot;No player found called &quot; .. pname)
			end

			faultyChat = false
			return true
		end

		mutePlayer(pid)

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Chat from player &quot; .. players[pid].name .. &quot; is blocked :D[-]&quot;)
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug coppi 2&quot;) end

	if chatvars.words[1] == &quot;unmute&quot; and chatvars.words[2] ~= nil then
		pname = string.sub(chatvars.command, string.find(chatvars.command, &quot;mute &quot;) + 6)
		pname = string.trim(pname)
		pid = LookupPlayer(pname)

		if pid == nil then
			if (chatvars.playername ~= &quot;Server&quot;) then
				message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]No player found called &quot; .. pname .. &quot;[-]&quot;)
			else
				irc_QueueMsg(server.ircMain, &quot;No player found called &quot; .. pname)
			end

			faultyChat = false
			return true
		end

		unmutePlayer(pid)

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]&quot; .. players[pid].name .. &quot; can chat again D:[-]&quot;)
		end


		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug coppi 3&quot;) end

	if chatvars.words[1] == &quot;spawn&quot; and (chatvars.words[2] == &quot;horde&quot;) then
		if chatvars.words[3] ~= nil then
			pid = LookupPlayer(chatvars.words[3])
			if pid ~= nil then
				if igplayers[pid] then
					send(&quot;sh &quot; .. math.floor(igplayers[pid].xPos) .. &quot; &quot; .. math.floor(igplayers[pid].yPos) .. &quot; &quot; .. math.floor(igplayers[pid].zPos))
					irc_QueueMsg(server.ircMain, &quot;Horde spawned by bot at &quot; .. igplayers[pid].name .. &quot;'s position at &quot; .. math.floor(igplayers[pid].xPos) .. &quot; &quot; .. math.floor(igplayers[pid].yPos) .. &quot; &quot; .. math.floor(igplayers[pid].zPos))
				end
			else
				loc = LookupLocation(chatvars.words[3])
				if loc ~= nil then
					send(&quot;sh &quot; .. locations[loc].x .. &quot; &quot; .. locations[loc].y .. &quot; &quot; .. locations[loc].z)	
					irc_QueueMsg(server.ircMain, &quot;Horde spawned by bot at &quot; .. locations[loc].x .. &quot; &quot; .. locations[loc].y .. &quot; &quot; .. locations[loc].z)
				end
			end
		else
			if (chatvars.playername ~= &quot;Server&quot;) then
				if igplayers[chatvars.playerid].horde ~= nil then
					send(&quot;sh &quot; .. igplayers[chatvars.playerid].horde)
				else
					send(&quot;sh &quot; .. chatvars.intX .. &quot; &quot; .. chatvars.intY .. &quot; &quot; .. chatvars.intZ)
				end
			end
		end

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug coppi 4&quot;) end

	if (chatvars.words[1] == &quot;hide&quot; and chatvars.words[2] == &quot;commands&quot; and chatvars.words[3] == nil) then
		server.hideCommands = true
		send(&quot;tcch /&quot;)
		conn:execute(&quot;UPDATE server SET hideCommands = 1&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Bot commands are now hidden from global chat.[-]&quot;)	
		else
			irc_QueueMsg(server.ircMain, &quot;Bot commands are now hidden from global chat.&quot;)
		end
		
		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug coppi 5&quot;) end

	if (chatvars.words[1] == &quot;show&quot; and chatvars.words[2] == &quot;commands&quot; and chatvars.words[3] == nil) then
		server.hideCommands = true
		send(&quot;tcch&quot;)
		conn:execute(&quot;UPDATE server SET hideCommands = 0&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Bot commands are now visible in global chat.[-]&quot;)	
		else
			irc_QueueMsg(server.ircMain, &quot;Bot commands are now visible in global chat.&quot;)
		end
		
		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug coppi 6&quot;) end

	if (chatvars.words[1] == &quot;physics&quot; and chatvars.words[2] == &quot;off&quot;) then
		server.allowPhysics = false
		send(&quot;py&quot;)
		conn:execute(&quot;UPDATE server SET allowPhysics = 0&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Physics is disabled.[-]&quot;)	
		else
			irc_QueueMsg(server.ircMain, &quot;Physics is disabled.&quot;)
		end
		
		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug coppi 7&quot;) end

	if (chatvars.words[1] == &quot;physics&quot; and chatvars.words[2] == &quot;on&quot;) then
		server.allowPhysics = true
		send(&quot;py&quot;)
		conn:execute(&quot;UPDATE server SET allowPhysics = 1&quot;)

		if (chatvars.playername ~= &quot;Server&quot;) then
			message(&quot;pm &quot; .. chatvars.playerid .. &quot; [&quot; .. server.chatColour .. &quot;]Physics is enabled.[-]&quot;)	
		else
			irc_QueueMsg(server.ircMain, &quot;Physics is enabled.&quot;)
		end
		
		faultyChat = false
		return true
	end

	-- ###################  do not allow remote commands beyond this point ################
	if (chatvars.playerid == nil) then
		faultyChat = false
		return false
	end
	-- ####################################################################################

if debug then dbug(&quot;debug coppi 8&quot;) end

	if chatvars.words[1] == &quot;set&quot; and (chatvars.words[2] == &quot;horde&quot;) then
		-- mark the player's current position for spawning a horde with /spawn horde
		igplayers[chatvars.playerid].horde = chatvars.intX .. &quot; &quot; .. chatvars.intY .. &quot; &quot; .. chatvars.intZ

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug coppi 9&quot;) end

	if chatvars.words[1] == &quot;clear&quot; and (chatvars.words[2] == &quot;horde&quot;) then
		-- forget the pre-recorded coords of the horde spawn point
		igplayers[chatvars.playerid].horde = nil

		faultyChat = false
		return true
	end

if debug then dbug(&quot;debug coppi end&quot;) end

end</script>
            <eventHandlerList/>
        </Script>
        <Script isActive="yes" isFolder="no">
            <name>FirstRun</name>
            <packageName></packageName>
            <script>-- This script is run first when the bot starts up
serverDataLoaded = false
botDisabled = false
dbConnected = false
botOffline = 0

require &quot;lfs&quot;</script>
            <eventHandlerList>
                <string>sysLoadEvent</string>
            </eventHandlerList>
        </Script>
    </ScriptPackage>
    <KeyPackage/>
</MudletPackage>
